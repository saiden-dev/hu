<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>:root {
  --color: black;
  --bg: white;
  --head-bg: white;
  --link: #338;

  --blue: #ccf;
  --red: #fcc;
  --yellow: #ffc;
  --green: #cfc;
}

[data-theme='dark'] {
  --color: white;
  --bg: black;
  --head-bg: #333;
  --link: #aaf;

  --blue: #225;
  --red: #522;
  --yellow: #552;
  --green: #252;
}

html,
body {
  margin: 0;
  padding: 0;
  color: var(--color);
  background: var(--bg);
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: var(--head-bg);
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: var(--blue);
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: var(--red);
}
.files-list__file_medium {
  background: var(--yellow);
}
.files-list__file_high {
  background: var(--green);
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: var(--bg);
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: var(--link);
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
  content: counter(line);
  margin-right: 72px;
}
.code-line {
  margin: 0;
  height: 1em;
  counter-increment: line;

  position: absolute;
  padding: 0 0.3em 0.3em 0.3em;
  display: inherit;
  width: 100%;
}
.code-line_covered {
  background: var(--green);
}
.code-line_uncovered {
  background: var(--red);
}

.code-text-container {
  position: relative;
  height: 1em;
  padding: 0.3em 0;
}

.cover-indicator {
  display: flex;
  width: 100%;
  position: absolute;
  justify-content: end;
  height: 1em;
  align-items: center;
  padding: 0 0.3em 0.3em 0.3em;
}

.cover-indicator.check-cover::after {
  content: "\2713";
  font-weight: bold;
  background-color: var(--green);
  height: 1em;
}

.cover-indicator.no-cover::after {
  content: "\2716";
  font-weight: bold;
  background-color: var(--red);
  height: 1em;
}

.stat-line-hit {
  max-width: 48px;
  overflow: hidden;
  font-weight: bold;
  margin-right: 4px;
  background-color: var(--green);
  position: relative;
  top: 0.1em;
}

#theme-toggle-label {
  margin-left: 1ch;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","Users","chi","Projects","hu","src","cli.rs"],"content":"use clap::{Parser, Subcommand};\n\nuse crate::context::ContextCommand;\nuse crate::data::DataCommand;\nuse crate::docs::DocsCommand;\nuse crate::eks::EksCommand;\nuse crate::gh::GhCommand;\nuse crate::install::InstallCommand;\nuse crate::jira::JiraCommand;\nuse crate::newrelic::NewRelicCommand;\nuse crate::pagerduty::PagerDutyCommand;\nuse crate::pipeline::PipelineCommand;\nuse crate::read::ReadArgs;\nuse crate::sentry::SentryCommand;\nuse crate::slack::SlackCommands;\nuse crate::utils::UtilsCommand;\n\n#[derive(Parser)]\n#[command(name = \"hu\")]\n#[command(about = \"Dev workflow CLI\", long_about = None)]\n#[command(version)]\npub struct Cli {\n    #[command(subcommand)]\n    pub command: Option\u003cCommand\u003e,\n}\n\n#[derive(Subcommand)]\npub enum Command {\n    /// Jira operations (tickets, sprint, search)\n    Jira {\n        #[command(subcommand)]\n        cmd: Option\u003cJiraCommand\u003e,\n    },\n\n    /// GitHub operations (prs, runs, failures)\n    Gh {\n        #[command(subcommand)]\n        cmd: Option\u003cGhCommand\u003e,\n    },\n\n    /// Slack operations (messages, channels)\n    Slack {\n        #[command(subcommand)]\n        cmd: Option\u003cSlackCommands\u003e,\n    },\n\n    /// PagerDuty (oncall, alerts)\n    #[command(name = \"pagerduty\", alias = \"pd\")]\n    PagerDuty {\n        #[command(subcommand)]\n        cmd: Option\u003cPagerDutyCommand\u003e,\n    },\n\n    /// Sentry (issues, errors)\n    Sentry {\n        #[command(subcommand)]\n        cmd: Option\u003cSentryCommand\u003e,\n    },\n\n    /// NewRelic (incidents, queries)\n    #[command(name = \"newrelic\", alias = \"nr\")]\n    NewRelic {\n        #[command(subcommand)]\n        cmd: Option\u003cNewRelicCommand\u003e,\n    },\n\n    /// EKS pod access (list, exec, logs)\n    Eks {\n        #[command(subcommand)]\n        cmd: Option\u003cEksCommand\u003e,\n    },\n\n    /// CodePipeline status (read-only)\n    Pipeline {\n        #[command(subcommand)]\n        cmd: Option\u003cPipelineCommand\u003e,\n    },\n\n    /// Utility commands (fetch-html, grep)\n    Utils {\n        #[command(subcommand)]\n        cmd: Option\u003cUtilsCommand\u003e,\n    },\n\n    /// Session context tracking (prevent duplicate file reads)\n    Context {\n        #[command(subcommand)]\n        cmd: Option\u003cContextCommand\u003e,\n    },\n\n    /// Smart file reading (outline, interface, around, diff)\n    Read(ReadArgs),\n\n    /// Claude Code session data (sync, stats, search)\n    Data {\n        #[command(subcommand)]\n        cmd: Option\u003cDataCommand\u003e,\n    },\n\n    /// Install hu hooks and commands to Claude Code\n    Install {\n        #[command(subcommand)]\n        cmd: Option\u003cInstallCommand\u003e,\n    },\n\n    /// Documentation management (add, get, list, remove, sync)\n    Docs {\n        #[command(subcommand)]\n        cmd: Option\u003cDocsCommand\u003e,\n    },\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","context","cli.rs"],"content":"use clap::{Args, Subcommand};\n\n#[derive(Debug, Subcommand)]\npub enum ContextCommand {\n    /// Track a file as loaded in context\n    Track(TrackArgs),\n    /// Check if a file is in context\n    Check(CheckArgs),\n    /// Show summary of all tracked files\n    Summary,\n    /// Clear all tracked files\n    Clear,\n}\n\n#[derive(Debug, Args)]\npub struct TrackArgs {\n    /// File path(s) to track\n    #[arg(required = true)]\n    pub paths: Vec\u003cString\u003e,\n}\n\n#[derive(Debug, Args)]\npub struct CheckArgs {\n    /// File path(s) to check\n    #[arg(required = true)]\n    pub paths: Vec\u003cString\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use clap::Parser;\n\n    #[derive(Parser)]\n    struct TestCli {\n        #[command(subcommand)]\n        cmd: ContextCommand,\n    }\n\n    #[test]\n    fn parse_track_single() {\n        let cli = TestCli::try_parse_from([\"test\", \"track\", \"file.rs\"]).unwrap();\n        if let ContextCommand::Track(args) = cli.cmd {\n            assert_eq!(args.paths, vec![\"file.rs\"]);\n        } else {\n            panic!(\"Expected Track\");\n        }\n    }\n\n    #[test]\n    fn parse_track_multiple() {\n        let cli = TestCli::try_parse_from([\"test\", \"track\", \"a.rs\", \"b.rs\", \"c.rs\"]).unwrap();\n        if let ContextCommand::Track(args) = cli.cmd {\n            assert_eq!(args.paths, vec![\"a.rs\", \"b.rs\", \"c.rs\"]);\n        } else {\n            panic!(\"Expected Track\");\n        }\n    }\n\n    #[test]\n    fn parse_check_single() {\n        let cli = TestCli::try_parse_from([\"test\", \"check\", \"file.rs\"]).unwrap();\n        if let ContextCommand::Check(args) = cli.cmd {\n            assert_eq!(args.paths, vec![\"file.rs\"]);\n        } else {\n            panic!(\"Expected Check\");\n        }\n    }\n\n    #[test]\n    fn parse_check_multiple() {\n        let cli = TestCli::try_parse_from([\"test\", \"check\", \"a.rs\", \"b.rs\"]).unwrap();\n        if let ContextCommand::Check(args) = cli.cmd {\n            assert_eq!(args.paths, vec![\"a.rs\", \"b.rs\"]);\n        } else {\n            panic!(\"Expected Check\");\n        }\n    }\n\n    #[test]\n    fn parse_summary() {\n        let cli = TestCli::try_parse_from([\"test\", \"summary\"]).unwrap();\n        assert!(matches!(cli.cmd, ContextCommand::Summary));\n    }\n\n    #[test]\n    fn parse_clear() {\n        let cli = TestCli::try_parse_from([\"test\", \"clear\"]).unwrap();\n        assert!(matches!(cli.cmd, ContextCommand::Clear));\n    }\n\n    #[test]\n    fn track_requires_path() {\n        let result = TestCli::try_parse_from([\"test\", \"track\"]);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn check_requires_path() {\n        let result = TestCli::try_parse_from([\"test\", \"check\"]);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn track_args_debug() {\n        let args = TrackArgs {\n            paths: vec![\"a.rs\".to_string()],\n        };\n        let debug = format!(\"{:?}\", args);\n        assert!(debug.contains(\"TrackArgs\"));\n    }\n\n    #[test]\n    fn check_args_debug() {\n        let args = CheckArgs {\n            paths: vec![\"a.rs\".to_string()],\n        };\n        let debug = format!(\"{:?}\", args);\n        assert!(debug.contains(\"CheckArgs\"));\n    }\n\n    #[test]\n    fn context_command_debug() {\n        let cmd = ContextCommand::Summary;\n        let debug = format!(\"{:?}\", cmd);\n        assert!(debug.contains(\"Summary\"));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","context","mod.rs"],"content":"mod cli;\nmod service;\nmod store;\nmod types;\n\npub use cli::ContextCommand;\n\nuse anyhow::Result;\n\n/// Run a context subcommand\npub async fn run_command(cmd: ContextCommand) -\u003e Result\u003c()\u003e {\n    match cmd {\n        ContextCommand::Track(args) =\u003e service::track(\u0026args.paths).await,\n        ContextCommand::Check(args) =\u003e service::check(\u0026args.paths).await,\n        ContextCommand::Summary =\u003e service::summary().await,\n        ContextCommand::Clear =\u003e service::clear().await,\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["/","Users","chi","Projects","hu","src","context","service","mod.rs"],"content":"use anyhow::{Context, Result};\nuse std::fs;\nuse std::io::BufRead;\nuse std::path::PathBuf;\nuse std::time::SystemTime;\n\nuse super::store::{default_store, ContextStore};\nuse super::types::{ContextEntry, ContextState, FileStatus};\n\n#[cfg(test)]\nmod tests;\n\n/// Track file(s) as loaded in context\npub async fn track(paths: \u0026[String]) -\u003e Result\u003c()\u003e {\n    let store = default_store()?;\n    track_with_store(\u0026store, paths)\n}\n\n/// Track files using a specific store (for testing)\npub fn track_with_store(store: \u0026impl ContextStore, paths: \u0026[String]) -\u003e Result\u003c()\u003e {\n    let mut state = store.load()?;\n\n    for path_str in paths {\n        let path = resolve_path(path_str)?;\n        let (size, line_count) = get_file_info(\u0026path)?;\n        let entry = ContextEntry::new(path.clone(), size, line_count);\n        state.track(entry);\n        println!(\n            \"Tracked: {} ({} lines, {} bytes)\",\n            path.display(),\n            line_count,\n            size\n        );\n    }\n\n    store.save(\u0026state)?;\n    Ok(())\n}\n\n/// Check if file(s) are in context\npub async fn check(paths: \u0026[String]) -\u003e Result\u003c()\u003e {\n    let store = default_store()?;\n    check_with_store(\u0026store, paths)\n}\n\n/// Check files using a specific store (for testing)\npub fn check_with_store(store: \u0026impl ContextStore, paths: \u0026[String]) -\u003e Result\u003c()\u003e {\n    let state = store.load()?;\n    let now = current_timestamp();\n\n    for path_str in paths {\n        let path = resolve_path(path_str)?;\n        let status = get_file_status(\u0026state, \u0026path, now)?;\n        print_file_status(\u0026status);\n    }\n\n    Ok(())\n}\n\n/// Show summary of all tracked files\npub async fn summary() -\u003e Result\u003c()\u003e {\n    let store = default_store()?;\n    summary_with_store(\u0026store)\n}\n\n/// Show summary using a specific store (for testing)\npub fn summary_with_store(store: \u0026impl ContextStore) -\u003e Result\u003c()\u003e {\n    let state = store.load()?;\n    let now = current_timestamp();\n\n    if state.file_count() == 0 {\n        println!(\"No files tracked in context\");\n        return Ok(());\n    }\n\n    println!(\"Session: {}\", state.session_id);\n    println!();\n\n    let mut entries: Vec\u003c_\u003e = state.all_entries().into_iter().collect();\n    entries.sort_by(|a, b| b.tracked_at.cmp(\u0026a.tracked_at));\n\n    for entry in \u0026entries {\n        let age = format_age(now.saturating_sub(entry.tracked_at));\n        println!(\n            \"  {} ({} lines, {}) - {}\",\n            entry.path.display(),\n            entry.line_count,\n            format_bytes(entry.size),\n            age\n        );\n    }\n\n    println!();\n    println!(\n        \"Total: {} files, {} lines, {}\",\n        state.file_count(),\n        state.total_lines(),\n        format_bytes(state.total_bytes())\n    );\n\n    Ok(())\n}\n\n/// Clear all tracked files\npub async fn clear() -\u003e Result\u003c()\u003e {\n    let store = default_store()?;\n    clear_with_store(\u0026store)\n}\n\n/// Clear using a specific store (for testing)\npub fn clear_with_store(store: \u0026impl ContextStore) -\u003e Result\u003c()\u003e {\n    store.delete()?;\n    println!(\"Context cleared\");\n    Ok(())\n}\n\n/// Get file status relative to current context\npub fn get_file_status(state: \u0026ContextState, path: \u0026PathBuf, now: u64) -\u003e Result\u003cFileStatus\u003e {\n    if let Some(entry) = state.get(path) {\n        let age_secs = now.saturating_sub(entry.tracked_at);\n        Ok(FileStatus::Loaded {\n            entry: entry.clone(),\n            age_secs,\n        })\n    } else {\n        let (size, line_count) = get_file_info(path)?;\n        Ok(FileStatus::NotLoaded {\n            path: path.clone(),\n            size,\n            line_count,\n        })\n    }\n}\n\n/// Resolve a path string to an absolute path\nfn resolve_path(path_str: \u0026str) -\u003e Result\u003cPathBuf\u003e {\n    let path = PathBuf::from(path_str);\n    let resolved = if path.is_absolute() {\n        path\n    } else {\n        std::env::current_dir()\n            .context(\"Failed to get current directory\")?\n            .join(path)\n    };\n\n    resolved\n        .canonicalize()\n        .with_context(|| format!(\"Path not found: {}\", path_str))\n}\n\n/// Get file size and line count\nfn get_file_info(path: \u0026PathBuf) -\u003e Result\u003c(u64, usize)\u003e {\n    let metadata = fs::metadata(path)\n        .with_context(|| format!(\"Failed to read metadata for {}\", path.display()))?;\n    let size = metadata.len();\n\n    let file =\n        fs::File::open(path).with_context(|| format!(\"Failed to open {}\", path.display()))?;\n    let reader = std::io::BufReader::new(file);\n    let line_count = reader.lines().count();\n\n    Ok((size, line_count))\n}\n\n/// Get current Unix timestamp\nfn current_timestamp() -\u003e u64 {\n    SystemTime::now()\n        .duration_since(SystemTime::UNIX_EPOCH)\n        .map(|d| d.as_secs())\n        .unwrap_or(0)\n}\n\n/// Print file status to stdout\nfn print_file_status(status: \u0026FileStatus) {\n    match status {\n        FileStatus::Loaded { entry, age_secs } =\u003e {\n            let age = format_age(*age_secs);\n            println!(\n                \"{}: loaded {} ({} lines)\",\n                entry.path.display(),\n                age,\n                entry.line_count\n            );\n        }\n        FileStatus::NotLoaded {\n            path,\n            size: _,\n            line_count,\n        } =\u003e {\n            println!(\"{}: not loaded ({} lines)\", path.display(), line_count);\n        }\n    }\n}\n\n/// Format seconds as human-readable age\nfn format_age(secs: u64) -\u003e String {\n    if secs \u003c 60 {\n        format!(\"{}s ago\", secs)\n    } else if secs \u003c 3600 {\n        format!(\"{}m ago\", secs / 60)\n    } else if secs \u003c 86400 {\n        format!(\"{}h ago\", secs / 3600)\n    } else {\n        format!(\"{}d ago\", secs / 86400)\n    }\n}\n\n/// Format bytes as human-readable size\nfn format_bytes(bytes: u64) -\u003e String {\n    if bytes \u003c 1024 {\n        format!(\"{} B\", bytes)\n    } else if bytes \u003c 1024 * 1024 {\n        format!(\"{:.1} KB\", bytes as f64 / 1024.0)\n    } else {\n        format!(\"{:.1} MB\", bytes as f64 / (1024.0 * 1024.0))\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":1}},{"line":21,"address":[],"length":0,"stats":{"Line":3}},{"line":23,"address":[],"length":0,"stats":{"Line":3}},{"line":24,"address":[],"length":0,"stats":{"Line":3}},{"line":25,"address":[],"length":0,"stats":{"Line":4}},{"line":26,"address":[],"length":0,"stats":{"Line":6}},{"line":27,"address":[],"length":0,"stats":{"Line":3}},{"line":28,"address":[],"length":0,"stats":{"Line":1}},{"line":29,"address":[],"length":0,"stats":{"Line":1}},{"line":30,"address":[],"length":0,"stats":{"Line":1}},{"line":36,"address":[],"length":0,"stats":{"Line":3}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":1}},{"line":48,"address":[],"length":0,"stats":{"Line":3}},{"line":49,"address":[],"length":0,"stats":{"Line":2}},{"line":51,"address":[],"length":0,"stats":{"Line":3}},{"line":52,"address":[],"length":0,"stats":{"Line":3}},{"line":53,"address":[],"length":0,"stats":{"Line":5}},{"line":54,"address":[],"length":0,"stats":{"Line":2}},{"line":57,"address":[],"length":0,"stats":{"Line":1}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":2}},{"line":68,"address":[],"length":0,"stats":{"Line":6}},{"line":69,"address":[],"length":0,"stats":{"Line":4}},{"line":71,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":2}},{"line":77,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":6}},{"line":80,"address":[],"length":0,"stats":{"Line":5}},{"line":82,"address":[],"length":0,"stats":{"Line":7}},{"line":83,"address":[],"length":0,"stats":{"Line":12}},{"line":84,"address":[],"length":0,"stats":{"Line":4}},{"line":85,"address":[],"length":0,"stats":{"Line":4}},{"line":86,"address":[],"length":0,"stats":{"Line":4}},{"line":87,"address":[],"length":0,"stats":{"Line":2}},{"line":88,"address":[],"length":0,"stats":{"Line":2}},{"line":89,"address":[],"length":0,"stats":{"Line":2}},{"line":93,"address":[],"length":0,"stats":{"Line":1}},{"line":94,"address":[],"length":0,"stats":{"Line":1}},{"line":95,"address":[],"length":0,"stats":{"Line":1}},{"line":96,"address":[],"length":0,"stats":{"Line":2}},{"line":97,"address":[],"length":0,"stats":{"Line":2}},{"line":98,"address":[],"length":0,"stats":{"Line":3}},{"line":101,"address":[],"length":0,"stats":{"Line":1}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":1}},{"line":112,"address":[],"length":0,"stats":{"Line":2}},{"line":113,"address":[],"length":0,"stats":{"Line":2}},{"line":114,"address":[],"length":0,"stats":{"Line":1}},{"line":118,"address":[],"length":0,"stats":{"Line":3}},{"line":119,"address":[],"length":0,"stats":{"Line":8}},{"line":120,"address":[],"length":0,"stats":{"Line":8}},{"line":121,"address":[],"length":0,"stats":{"Line":2}},{"line":122,"address":[],"length":0,"stats":{"Line":4}},{"line":123,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":4}},{"line":127,"address":[],"length":0,"stats":{"Line":1}},{"line":128,"address":[],"length":0,"stats":{"Line":3}},{"line":129,"address":[],"length":0,"stats":{"Line":1}},{"line":130,"address":[],"length":0,"stats":{"Line":1}},{"line":136,"address":[],"length":0,"stats":{"Line":5}},{"line":137,"address":[],"length":0,"stats":{"Line":15}},{"line":138,"address":[],"length":0,"stats":{"Line":10}},{"line":139,"address":[],"length":0,"stats":{"Line":4}},{"line":141,"address":[],"length":0,"stats":{"Line":1}},{"line":143,"address":[],"length":0,"stats":{"Line":2}},{"line":146,"address":[],"length":0,"stats":{"Line":5}},{"line":148,"address":[],"length":0,"stats":{"Line":7}},{"line":152,"address":[],"length":0,"stats":{"Line":4}},{"line":153,"address":[],"length":0,"stats":{"Line":11}},{"line":154,"address":[],"length":0,"stats":{"Line":8}},{"line":155,"address":[],"length":0,"stats":{"Line":9}},{"line":157,"address":[],"length":0,"stats":{"Line":3}},{"line":158,"address":[],"length":0,"stats":{"Line":9}},{"line":159,"address":[],"length":0,"stats":{"Line":9}},{"line":160,"address":[],"length":0,"stats":{"Line":12}},{"line":162,"address":[],"length":0,"stats":{"Line":3}},{"line":166,"address":[],"length":0,"stats":{"Line":5}},{"line":167,"address":[],"length":0,"stats":{"Line":5}},{"line":168,"address":[],"length":0,"stats":{"Line":5}},{"line":169,"address":[],"length":0,"stats":{"Line":15}},{"line":174,"address":[],"length":0,"stats":{"Line":3}},{"line":175,"address":[],"length":0,"stats":{"Line":3}},{"line":176,"address":[],"length":0,"stats":{"Line":6}},{"line":177,"address":[],"length":0,"stats":{"Line":8}},{"line":178,"address":[],"length":0,"stats":{"Line":4}},{"line":179,"address":[],"length":0,"stats":{"Line":4}},{"line":180,"address":[],"length":0,"stats":{"Line":2}},{"line":181,"address":[],"length":0,"stats":{"Line":2}},{"line":182,"address":[],"length":0,"stats":{"Line":2}},{"line":186,"address":[],"length":0,"stats":{"Line":1}},{"line":188,"address":[],"length":0,"stats":{"Line":1}},{"line":189,"address":[],"length":0,"stats":{"Line":1}},{"line":190,"address":[],"length":0,"stats":{"Line":3}},{"line":196,"address":[],"length":0,"stats":{"Line":15}},{"line":197,"address":[],"length":0,"stats":{"Line":15}},{"line":198,"address":[],"length":0,"stats":{"Line":6}},{"line":199,"address":[],"length":0,"stats":{"Line":12}},{"line":200,"address":[],"length":0,"stats":{"Line":15}},{"line":201,"address":[],"length":0,"stats":{"Line":7}},{"line":202,"address":[],"length":0,"stats":{"Line":9}},{"line":204,"address":[],"length":0,"stats":{"Line":12}},{"line":209,"address":[],"length":0,"stats":{"Line":11}},{"line":210,"address":[],"length":0,"stats":{"Line":11}},{"line":211,"address":[],"length":0,"stats":{"Line":12}},{"line":212,"address":[],"length":0,"stats":{"Line":5}},{"line":213,"address":[],"length":0,"stats":{"Line":9}},{"line":215,"address":[],"length":0,"stats":{"Line":6}}],"covered":108,"coverable":120},{"path":["/","Users","chi","Projects","hu","src","context","service","tests.rs"],"content":"use super::*;\nuse std::cell::RefCell;\n\n/// Mock store for testing\nstruct MockStore {\n    state: RefCell\u003cContextState\u003e,\n    session_id: String,\n    deleted: RefCell\u003cbool\u003e,\n}\n\nimpl MockStore {\n    fn new() -\u003e Self {\n        Self {\n            state: RefCell::new(ContextState::new(\"mock-session\".to_string())),\n            session_id: \"mock-session\".to_string(),\n            deleted: RefCell::new(false),\n        }\n    }\n\n    fn with_state(state: ContextState) -\u003e Self {\n        let session_id = state.session_id.clone();\n        Self {\n            state: RefCell::new(state),\n            session_id,\n            deleted: RefCell::new(false),\n        }\n    }\n}\n\nimpl ContextStore for MockStore {\n    fn load(\u0026self) -\u003e Result\u003cContextState\u003e {\n        Ok(self.state.borrow().clone())\n    }\n\n    fn save(\u0026self, state: \u0026ContextState) -\u003e Result\u003c()\u003e {\n        *self.state.borrow_mut() = state.clone();\n        Ok(())\n    }\n\n    fn delete(\u0026self) -\u003e Result\u003c()\u003e {\n        *self.deleted.borrow_mut() = true;\n        Ok(())\n    }\n}\n\n#[test]\nfn format_age_seconds() {\n    assert_eq!(format_age(0), \"0s ago\");\n    assert_eq!(format_age(30), \"30s ago\");\n    assert_eq!(format_age(59), \"59s ago\");\n}\n\n#[test]\nfn format_age_minutes() {\n    assert_eq!(format_age(60), \"1m ago\");\n    assert_eq!(format_age(120), \"2m ago\");\n    assert_eq!(format_age(3599), \"59m ago\");\n}\n\n#[test]\nfn format_age_hours() {\n    assert_eq!(format_age(3600), \"1h ago\");\n    assert_eq!(format_age(7200), \"2h ago\");\n    assert_eq!(format_age(86399), \"23h ago\");\n}\n\n#[test]\nfn format_age_days() {\n    assert_eq!(format_age(86400), \"1d ago\");\n    assert_eq!(format_age(172800), \"2d ago\");\n}\n\n#[test]\nfn format_bytes_b() {\n    assert_eq!(format_bytes(0), \"0 B\");\n    assert_eq!(format_bytes(512), \"512 B\");\n    assert_eq!(format_bytes(1023), \"1023 B\");\n}\n\n#[test]\nfn format_bytes_kb() {\n    assert_eq!(format_bytes(1024), \"1.0 KB\");\n    assert_eq!(format_bytes(2048), \"2.0 KB\");\n    assert_eq!(format_bytes(1536), \"1.5 KB\");\n}\n\n#[test]\nfn format_bytes_mb() {\n    assert_eq!(format_bytes(1024 * 1024), \"1.0 MB\");\n    assert_eq!(format_bytes(2 * 1024 * 1024), \"2.0 MB\");\n}\n\n#[test]\nfn get_file_status_loaded() {\n    let mut state = ContextState::new(\"s\".to_string());\n    state.track(ContextEntry::with_timestamp(\n        PathBuf::from(\"/test.rs\"),\n        100,\n        10,\n        1000,\n    ));\n\n    let status = get_file_status(\u0026state, \u0026PathBuf::from(\"/test.rs\"), 1060).unwrap();\n    if let FileStatus::Loaded { entry, age_secs } = status {\n        assert_eq!(entry.size, 100);\n        assert_eq!(entry.line_count, 10);\n        assert_eq!(age_secs, 60);\n    } else {\n        panic!(\"Expected Loaded\");\n    }\n}\n\n#[test]\nfn get_file_status_not_loaded() {\n    let state = ContextState::new(\"s\".to_string());\n    // Use Cargo.toml which we know exists\n    let path = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\")).join(\"Cargo.toml\");\n    let status = get_file_status(\u0026state, \u0026path, 1000).unwrap();\n    assert!(matches!(status, FileStatus::NotLoaded { .. }));\n}\n\n#[test]\nfn clear_with_store_deletes() {\n    let store = MockStore::new();\n    clear_with_store(\u0026store).unwrap();\n    assert!(*store.deleted.borrow());\n}\n\n#[test]\nfn summary_with_store_empty() {\n    let store = MockStore::new();\n    // Just verify it doesn't panic\n    summary_with_store(\u0026store).unwrap();\n}\n\n#[test]\nfn summary_with_store_with_entries() {\n    let mut state = ContextState::new(\"test\".to_string());\n    state.track(ContextEntry::with_timestamp(\n        PathBuf::from(\"/a.rs\"),\n        100,\n        10,\n        1000,\n    ));\n    state.track(ContextEntry::with_timestamp(\n        PathBuf::from(\"/b.rs\"),\n        200,\n        20,\n        2000,\n    ));\n    let store = MockStore::with_state(state);\n    summary_with_store(\u0026store).unwrap();\n}\n\n#[test]\nfn track_with_store_real_file() {\n    let store = MockStore::new();\n    let cargo_toml = env!(\"CARGO_MANIFEST_DIR\").to_string() + \"/Cargo.toml\";\n    track_with_store(\u0026store, \u0026[cargo_toml]).unwrap();\n\n    let state = store.load().unwrap();\n    assert_eq!(state.file_count(), 1);\n}\n\n#[test]\nfn check_with_store_real_file() {\n    let mut state = ContextState::new(\"test\".to_string());\n    let cargo_path = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\")).join(\"Cargo.toml\");\n    state.track(ContextEntry::with_timestamp(\n        cargo_path.clone(),\n        100,\n        10,\n        current_timestamp() - 60,\n    ));\n    let store = MockStore::with_state(state);\n\n    check_with_store(\u0026store, \u0026[cargo_path.to_string_lossy().to_string()]).unwrap();\n}\n\n#[test]\nfn resolve_path_absolute() {\n    let result = resolve_path(\"/tmp\").unwrap();\n    assert!(result.is_absolute());\n}\n\n#[test]\nfn resolve_path_relative() {\n    // Cargo.toml should exist in project root\n    let result = resolve_path(\"Cargo.toml\").unwrap();\n    assert!(result.is_absolute());\n    assert!(result.to_string_lossy().ends_with(\"Cargo.toml\"));\n}\n\n#[test]\nfn resolve_path_not_found() {\n    let result = resolve_path(\"/nonexistent/path/to/file.xyz\");\n    assert!(result.is_err());\n}\n\n#[test]\nfn get_file_info_real_file() {\n    let path = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\")).join(\"Cargo.toml\");\n    let (size, line_count) = get_file_info(\u0026path).unwrap();\n    assert!(size \u003e 0);\n    assert!(line_count \u003e 0);\n}\n\n#[test]\nfn get_file_info_missing_file() {\n    let path = PathBuf::from(\"/nonexistent/file.txt\");\n    let result = get_file_info(\u0026path);\n    assert!(result.is_err());\n}\n\n#[test]\nfn current_timestamp_returns_value() {\n    let ts = current_timestamp();\n    // Should be a reasonable Unix timestamp (after 2020)\n    assert!(ts \u003e 1577836800);\n}\n\n#[test]\nfn mock_store_load_save() {\n    let store = MockStore::new();\n    let mut state = store.load().unwrap();\n    state.track(ContextEntry::new(PathBuf::from(\"/test.rs\"), 100, 10));\n    store.save(\u0026state).unwrap();\n\n    let loaded = store.load().unwrap();\n    assert_eq!(loaded.file_count(), 1);\n}\n\n#[test]\nfn mock_store_session_id() {\n    let store = MockStore::new();\n    assert_eq!(store.session_id, \"mock-session\");\n}\n\n#[test]\nfn print_file_status_loaded() {\n    let entry = ContextEntry::with_timestamp(PathBuf::from(\"/test.rs\"), 100, 10, 1000);\n    let status = FileStatus::Loaded {\n        entry,\n        age_secs: 60,\n    };\n    // Just verify it doesn't panic - output goes to stdout\n    print_file_status(\u0026status);\n}\n\n#[test]\nfn print_file_status_not_loaded() {\n    let status = FileStatus::NotLoaded {\n        path: PathBuf::from(\"/test.rs\"),\n        size: 100,\n        line_count: 10,\n    };\n    // Just verify it doesn't panic - output goes to stdout\n    print_file_status(\u0026status);\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":5}},{"line":14,"address":[],"length":0,"stats":{"Line":25}},{"line":15,"address":[],"length":0,"stats":{"Line":10}},{"line":16,"address":[],"length":0,"stats":{"Line":5}},{"line":20,"address":[],"length":0,"stats":{"Line":2}},{"line":21,"address":[],"length":0,"stats":{"Line":6}},{"line":23,"address":[],"length":0,"stats":{"Line":6}},{"line":25,"address":[],"length":0,"stats":{"Line":2}},{"line":31,"address":[],"length":0,"stats":{"Line":7}},{"line":32,"address":[],"length":0,"stats":{"Line":7}},{"line":35,"address":[],"length":0,"stats":{"Line":2}},{"line":36,"address":[],"length":0,"stats":{"Line":6}},{"line":37,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":1}},{"line":41,"address":[],"length":0,"stats":{"Line":1}},{"line":42,"address":[],"length":0,"stats":{"Line":1}}],"covered":16,"coverable":16},{"path":["/","Users","chi","Projects","hu","src","context","store.rs"],"content":"use anyhow::{Context, Result};\nuse std::env;\nuse std::fs;\nuse std::path::PathBuf;\n\nuse super::types::ContextState;\n\n/// Trait for context storage (enables mocking in tests)\npub trait ContextStore {\n    fn load(\u0026self) -\u003e Result\u003cContextState\u003e;\n    fn save(\u0026self, state: \u0026ContextState) -\u003e Result\u003c()\u003e;\n    fn delete(\u0026self) -\u003e Result\u003c()\u003e;\n}\n\n/// File-based context store\npub struct FileContextStore {\n    path: PathBuf,\n    session_id: String,\n}\n\nimpl FileContextStore {\n    /// Create a new file context store\n    pub fn new() -\u003e Result\u003cSelf\u003e {\n        let session_id = get_session_id();\n        let path = context_file_path(\u0026session_id);\n        Ok(Self { path, session_id })\n    }\n\n    /// Create with explicit path (for testing)\n    #[cfg(test)]\n    pub fn with_path(path: PathBuf, session_id: String) -\u003e Self {\n        Self { path, session_id }\n    }\n}\n\nimpl ContextStore for FileContextStore {\n    fn load(\u0026self) -\u003e Result\u003cContextState\u003e {\n        if !self.path.exists() {\n            return Ok(ContextState::new(self.session_id.clone()));\n        }\n\n        let contents = fs::read_to_string(\u0026self.path)\n            .with_context(|| format!(\"Failed to read {}\", self.path.display()))?;\n\n        serde_json::from_str(\u0026contents)\n            .with_context(|| format!(\"Failed to parse {}\", self.path.display()))\n    }\n\n    fn save(\u0026self, state: \u0026ContextState) -\u003e Result\u003c()\u003e {\n        if let Some(dir) = self.path.parent() {\n            fs::create_dir_all(dir)\n                .with_context(|| format!(\"Failed to create directory {}\", dir.display()))?;\n        }\n\n        let contents =\n            serde_json::to_string_pretty(state).context(\"Failed to serialize context state\")?;\n\n        fs::write(\u0026self.path, contents)\n            .with_context(|| format!(\"Failed to write {}\", self.path.display()))?;\n\n        Ok(())\n    }\n\n    fn delete(\u0026self) -\u003e Result\u003c()\u003e {\n        if self.path.exists() {\n            fs::remove_file(\u0026self.path)\n                .with_context(|| format!(\"Failed to delete {}\", self.path.display()))?;\n        }\n        Ok(())\n    }\n}\n\n/// Get session ID from environment or generate one\nfn get_session_id() -\u003e String {\n    env::var(\"CLAUDE_SESSION_ID\").unwrap_or_else(|_| {\n        // Use a stable ID based on process ID and start time\n        // This gives same ID within a session but different across sessions\n        format!(\"hu-{}\", std::process::id())\n    })\n}\n\n/// Get path to context file for a session\nfn context_file_path(session_id: \u0026str) -\u003e PathBuf {\n    let tmp = env::temp_dir();\n    tmp.join(format!(\"hu-context-{}.json\", session_id))\n}\n\n/// Get the default store instance\npub fn default_store() -\u003e Result\u003cFileContextStore\u003e {\n    FileContextStore::new()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::context::types::ContextEntry;\n\n    fn temp_store() -\u003e (FileContextStore, PathBuf) {\n        let tmp_dir = std::env::temp_dir().join(format!(\"hu_store_test_{}\", rand_suffix()));\n        let _ = std::fs::create_dir_all(\u0026tmp_dir);\n        let path = tmp_dir.join(\"context.json\");\n        let store = FileContextStore::with_path(path.clone(), \"test-session\".to_string());\n        (store, tmp_dir)\n    }\n\n    fn rand_suffix() -\u003e u64 {\n        use std::time::{SystemTime, UNIX_EPOCH};\n        SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .unwrap()\n            .as_nanos() as u64\n    }\n\n    #[test]\n    fn file_context_store_new() {\n        let store = FileContextStore::new().unwrap();\n        assert!(!store.session_id.is_empty());\n    }\n\n    #[test]\n    fn file_context_store_with_path() {\n        let store = FileContextStore::with_path(PathBuf::from(\"/test/path\"), \"sid\".to_string());\n        assert_eq!(store.path, PathBuf::from(\"/test/path\"));\n        assert_eq!(store.session_id, \"sid\");\n    }\n\n    #[test]\n    fn store_session_id() {\n        let store = FileContextStore::with_path(PathBuf::from(\"/tmp/x\"), \"my-session\".to_string());\n        assert_eq!(store.session_id, \"my-session\");\n    }\n\n    #[test]\n    fn store_load_missing_file() {\n        let (store, tmp_dir) = temp_store();\n        let state = store.load().unwrap();\n        assert_eq!(state.session_id, \"test-session\");\n        assert!(state.entries.is_empty());\n        let _ = std::fs::remove_dir_all(\u0026tmp_dir);\n    }\n\n    #[test]\n    fn store_save_and_load() {\n        let (store, tmp_dir) = temp_store();\n\n        let mut state = ContextState::new(\"test-session\".to_string());\n        state.track(ContextEntry::with_timestamp(\n            PathBuf::from(\"/test.rs\"),\n            100,\n            10,\n            123,\n        ));\n\n        store.save(\u0026state).unwrap();\n        assert!(store.path.exists());\n\n        let loaded = store.load().unwrap();\n        assert_eq!(loaded.session_id, \"test-session\");\n        assert_eq!(loaded.file_count(), 1);\n\n        let _ = std::fs::remove_dir_all(\u0026tmp_dir);\n    }\n\n    #[test]\n    fn store_delete() {\n        let (store, tmp_dir) = temp_store();\n\n        let state = ContextState::new(\"test-session\".to_string());\n        store.save(\u0026state).unwrap();\n        assert!(store.path.exists());\n\n        store.delete().unwrap();\n        assert!(!store.path.exists());\n\n        let _ = std::fs::remove_dir_all(\u0026tmp_dir);\n    }\n\n    #[test]\n    fn store_delete_missing_file() {\n        let (store, tmp_dir) = temp_store();\n        // Delete should succeed even if file doesn't exist\n        store.delete().unwrap();\n        let _ = std::fs::remove_dir_all(\u0026tmp_dir);\n    }\n\n    #[test]\n    fn store_save_creates_parent_dirs() {\n        let tmp_dir = std::env::temp_dir().join(format!(\"hu_nested_{}/a/b\", rand_suffix()));\n        let path = tmp_dir.join(\"context.json\");\n        let store = FileContextStore::with_path(path.clone(), \"s\".to_string());\n\n        let state = ContextState::new(\"s\".to_string());\n        store.save(\u0026state).unwrap();\n        assert!(path.exists());\n\n        let _ = std::fs::remove_dir_all(\n            std::env::temp_dir().join(format!(\"hu_nested_{}\", rand_suffix())),\n        );\n    }\n\n    #[test]\n    fn store_overwrites_existing() {\n        let (store, tmp_dir) = temp_store();\n\n        let mut state1 = ContextState::new(\"test-session\".to_string());\n        state1.track(ContextEntry::with_timestamp(\n            PathBuf::from(\"/old.rs\"),\n            1,\n            1,\n            1,\n        ));\n        store.save(\u0026state1).unwrap();\n\n        let mut state2 = ContextState::new(\"test-session\".to_string());\n        state2.track(ContextEntry::with_timestamp(\n            PathBuf::from(\"/new.rs\"),\n            2,\n            2,\n            2,\n        ));\n        store.save(\u0026state2).unwrap();\n\n        let loaded = store.load().unwrap();\n        assert_eq!(loaded.file_count(), 1);\n        assert!(loaded.is_tracked(\u0026PathBuf::from(\"/new.rs\")));\n        assert!(!loaded.is_tracked(\u0026PathBuf::from(\"/old.rs\")));\n\n        let _ = std::fs::remove_dir_all(\u0026tmp_dir);\n    }\n\n    #[test]\n    fn get_session_id_from_env() {\n        // This test just verifies the function runs\n        let id = get_session_id();\n        assert!(!id.is_empty());\n    }\n\n    #[test]\n    fn context_file_path_format() {\n        let path = context_file_path(\"my-session-123\");\n        let path_str = path.to_string_lossy();\n        assert!(path_str.contains(\"hu-context-my-session-123.json\"));\n    }\n\n    #[test]\n    fn default_store_creates() {\n        let store = default_store().unwrap();\n        assert!(!store.session_id.is_empty());\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":2}},{"line":24,"address":[],"length":0,"stats":{"Line":4}},{"line":25,"address":[],"length":0,"stats":{"Line":6}},{"line":26,"address":[],"length":0,"stats":{"Line":2}},{"line":31,"address":[],"length":0,"stats":{"Line":8}},{"line":37,"address":[],"length":0,"stats":{"Line":3}},{"line":38,"address":[],"length":0,"stats":{"Line":3}},{"line":39,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":6}},{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":4}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":5}},{"line":50,"address":[],"length":0,"stats":{"Line":10}},{"line":51,"address":[],"length":0,"stats":{"Line":10}},{"line":52,"address":[],"length":0,"stats":{"Line":5}},{"line":55,"address":[],"length":0,"stats":{"Line":5}},{"line":56,"address":[],"length":0,"stats":{"Line":15}},{"line":58,"address":[],"length":0,"stats":{"Line":15}},{"line":59,"address":[],"length":0,"stats":{"Line":5}},{"line":61,"address":[],"length":0,"stats":{"Line":5}},{"line":64,"address":[],"length":0,"stats":{"Line":2}},{"line":65,"address":[],"length":0,"stats":{"Line":2}},{"line":66,"address":[],"length":0,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":1}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":74,"address":[],"length":0,"stats":{"Line":3}},{"line":75,"address":[],"length":0,"stats":{"Line":9}},{"line":78,"address":[],"length":0,"stats":{"Line":9}},{"line":83,"address":[],"length":0,"stats":{"Line":3}},{"line":84,"address":[],"length":0,"stats":{"Line":6}},{"line":85,"address":[],"length":0,"stats":{"Line":9}},{"line":89,"address":[],"length":0,"stats":{"Line":1}},{"line":90,"address":[],"length":0,"stats":{"Line":1}}],"covered":34,"coverable":34},{"path":["/","Users","chi","Projects","hu","src","context","types.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::path::{Path, PathBuf};\nuse std::time::SystemTime;\n\n/// Entry for a tracked file in the context\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct ContextEntry {\n    /// Absolute path to the file\n    pub path: PathBuf,\n    /// File size in bytes\n    pub size: u64,\n    /// Number of lines in the file\n    pub line_count: usize,\n    /// When the file was tracked (Unix timestamp)\n    pub tracked_at: u64,\n}\n\nimpl ContextEntry {\n    /// Create a new context entry from file metadata\n    pub fn new(path: PathBuf, size: u64, line_count: usize) -\u003e Self {\n        let tracked_at = SystemTime::now()\n            .duration_since(SystemTime::UNIX_EPOCH)\n            .map(|d| d.as_secs())\n            .unwrap_or(0);\n\n        Self {\n            path,\n            size,\n            line_count,\n            tracked_at,\n        }\n    }\n\n    /// Create entry with explicit timestamp (for testing)\n    #[cfg(test)]\n    pub fn with_timestamp(path: PathBuf, size: u64, line_count: usize, tracked_at: u64) -\u003e Self {\n        Self {\n            path,\n            size,\n            line_count,\n            tracked_at,\n        }\n    }\n}\n\n/// Complete context state for a session\n#[derive(Debug, Clone, Serialize, Deserialize, Default, PartialEq)]\npub struct ContextState {\n    /// Session ID this context belongs to\n    pub session_id: String,\n    /// Map of canonical path string to entry\n    pub entries: HashMap\u003cString, ContextEntry\u003e,\n}\n\nimpl ContextState {\n    /// Create a new empty context state\n    pub fn new(session_id: String) -\u003e Self {\n        Self {\n            session_id,\n            entries: HashMap::new(),\n        }\n    }\n\n    /// Add or update an entry\n    pub fn track(\u0026mut self, entry: ContextEntry) {\n        let key = entry.path.to_string_lossy().to_string();\n        self.entries.insert(key, entry);\n    }\n\n    /// Get an entry by path\n    pub fn get(\u0026self, path: \u0026Path) -\u003e Option\u003c\u0026ContextEntry\u003e {\n        let key = path.to_string_lossy().to_string();\n        self.entries.get(\u0026key)\n    }\n\n    /// Check if a path is tracked\n    #[cfg(test)]\n    pub fn is_tracked(\u0026self, path: \u0026Path) -\u003e bool {\n        let key = path.to_string_lossy().to_string();\n        self.entries.contains_key(\u0026key)\n    }\n\n    /// Get all entries\n    pub fn all_entries(\u0026self) -\u003e Vec\u003c\u0026ContextEntry\u003e {\n        self.entries.values().collect()\n    }\n\n    /// Clear all entries\n    #[cfg(test)]\n    pub fn clear(\u0026mut self) {\n        self.entries.clear();\n    }\n\n    /// Total tracked files\n    pub fn file_count(\u0026self) -\u003e usize {\n        self.entries.len()\n    }\n\n    /// Total bytes tracked\n    pub fn total_bytes(\u0026self) -\u003e u64 {\n        self.entries.values().map(|e| e.size).sum()\n    }\n\n    /// Total lines tracked\n    pub fn total_lines(\u0026self) -\u003e usize {\n        self.entries.values().map(|e| e.line_count).sum()\n    }\n}\n\n/// Result of checking a file's status\n#[derive(Debug, Clone, PartialEq)]\npub enum FileStatus {\n    /// File is already in context\n    Loaded { entry: ContextEntry, age_secs: u64 },\n    /// File is not in context\n    NotLoaded {\n        path: PathBuf,\n        size: u64,\n        line_count: usize,\n    },\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn context_entry_new() {\n        let entry = ContextEntry::new(PathBuf::from(\"/test/file.rs\"), 1024, 50);\n        assert_eq!(entry.path, PathBuf::from(\"/test/file.rs\"));\n        assert_eq!(entry.size, 1024);\n        assert_eq!(entry.line_count, 50);\n        assert!(entry.tracked_at \u003e 0);\n    }\n\n    #[test]\n    fn context_entry_with_timestamp() {\n        let entry = ContextEntry::with_timestamp(PathBuf::from(\"/test.rs\"), 512, 25, 1000);\n        assert_eq!(entry.tracked_at, 1000);\n    }\n\n    #[test]\n    fn context_entry_clone() {\n        let entry = ContextEntry::new(PathBuf::from(\"/test.rs\"), 100, 10);\n        let cloned = entry.clone();\n        assert_eq!(entry, cloned);\n    }\n\n    #[test]\n    fn context_entry_debug() {\n        let entry = ContextEntry::new(PathBuf::from(\"/test.rs\"), 100, 10);\n        let debug = format!(\"{:?}\", entry);\n        assert!(debug.contains(\"ContextEntry\"));\n    }\n\n    #[test]\n    fn context_entry_serialize_deserialize() {\n        let entry = ContextEntry::with_timestamp(PathBuf::from(\"/test.rs\"), 100, 10, 12345);\n        let json = serde_json::to_string(\u0026entry).unwrap();\n        let parsed: ContextEntry = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(entry, parsed);\n    }\n\n    #[test]\n    fn context_state_new() {\n        let state = ContextState::new(\"session123\".to_string());\n        assert_eq!(state.session_id, \"session123\");\n        assert!(state.entries.is_empty());\n    }\n\n    #[test]\n    fn context_state_default() {\n        let state = ContextState::default();\n        assert_eq!(state.session_id, \"\");\n        assert!(state.entries.is_empty());\n    }\n\n    #[test]\n    fn context_state_track() {\n        let mut state = ContextState::new(\"s1\".to_string());\n        let entry = ContextEntry::new(PathBuf::from(\"/a.rs\"), 100, 10);\n        state.track(entry.clone());\n\n        assert_eq!(state.file_count(), 1);\n        assert!(state.is_tracked(\u0026PathBuf::from(\"/a.rs\")));\n    }\n\n    #[test]\n    fn context_state_get() {\n        let mut state = ContextState::new(\"s1\".to_string());\n        let entry = ContextEntry::with_timestamp(PathBuf::from(\"/a.rs\"), 100, 10, 500);\n        state.track(entry);\n\n        let got = state.get(\u0026PathBuf::from(\"/a.rs\")).unwrap();\n        assert_eq!(got.size, 100);\n        assert_eq!(got.line_count, 10);\n    }\n\n    #[test]\n    fn context_state_get_missing() {\n        let state = ContextState::new(\"s1\".to_string());\n        assert!(state.get(\u0026PathBuf::from(\"/missing.rs\")).is_none());\n    }\n\n    #[test]\n    fn context_state_is_tracked() {\n        let mut state = ContextState::new(\"s1\".to_string());\n        state.track(ContextEntry::new(PathBuf::from(\"/yes.rs\"), 1, 1));\n\n        assert!(state.is_tracked(\u0026PathBuf::from(\"/yes.rs\")));\n        assert!(!state.is_tracked(\u0026PathBuf::from(\"/no.rs\")));\n    }\n\n    #[test]\n    fn context_state_all_entries() {\n        let mut state = ContextState::new(\"s1\".to_string());\n        state.track(ContextEntry::new(PathBuf::from(\"/a.rs\"), 100, 10));\n        state.track(ContextEntry::new(PathBuf::from(\"/b.rs\"), 200, 20));\n\n        let entries = state.all_entries();\n        assert_eq!(entries.len(), 2);\n    }\n\n    #[test]\n    fn context_state_clear() {\n        let mut state = ContextState::new(\"s1\".to_string());\n        state.track(ContextEntry::new(PathBuf::from(\"/a.rs\"), 100, 10));\n        assert_eq!(state.file_count(), 1);\n\n        state.clear();\n        assert_eq!(state.file_count(), 0);\n    }\n\n    #[test]\n    fn context_state_totals() {\n        let mut state = ContextState::new(\"s1\".to_string());\n        state.track(ContextEntry::new(PathBuf::from(\"/a.rs\"), 100, 10));\n        state.track(ContextEntry::new(PathBuf::from(\"/b.rs\"), 200, 20));\n\n        assert_eq!(state.total_bytes(), 300);\n        assert_eq!(state.total_lines(), 30);\n    }\n\n    #[test]\n    fn context_state_update_existing() {\n        let mut state = ContextState::new(\"s1\".to_string());\n        state.track(ContextEntry::with_timestamp(\n            PathBuf::from(\"/a.rs\"),\n            100,\n            10,\n            1,\n        ));\n        state.track(ContextEntry::with_timestamp(\n            PathBuf::from(\"/a.rs\"),\n            200,\n            20,\n            2,\n        ));\n\n        assert_eq!(state.file_count(), 1);\n        let entry = state.get(\u0026PathBuf::from(\"/a.rs\")).unwrap();\n        assert_eq!(entry.size, 200);\n        assert_eq!(entry.tracked_at, 2);\n    }\n\n    #[test]\n    fn context_state_serialize_deserialize() {\n        let mut state = ContextState::new(\"session\".to_string());\n        state.track(ContextEntry::with_timestamp(\n            PathBuf::from(\"/test.rs\"),\n            100,\n            10,\n            123,\n        ));\n\n        let json = serde_json::to_string(\u0026state).unwrap();\n        let parsed: ContextState = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(state, parsed);\n    }\n\n    #[test]\n    fn context_state_clone() {\n        let mut state = ContextState::new(\"s1\".to_string());\n        state.track(ContextEntry::new(PathBuf::from(\"/a.rs\"), 100, 10));\n\n        let cloned = state.clone();\n        assert_eq!(state, cloned);\n    }\n\n    #[test]\n    fn context_state_debug() {\n        let state = ContextState::new(\"s1\".to_string());\n        let debug = format!(\"{:?}\", state);\n        assert!(debug.contains(\"ContextState\"));\n    }\n\n    #[test]\n    fn file_status_loaded() {\n        let entry = ContextEntry::with_timestamp(PathBuf::from(\"/a.rs\"), 100, 10, 1);\n        let status = FileStatus::Loaded {\n            entry: entry.clone(),\n            age_secs: 60,\n        };\n        if let FileStatus::Loaded { entry: e, age_secs } = status {\n            assert_eq!(e.path, PathBuf::from(\"/a.rs\"));\n            assert_eq!(age_secs, 60);\n        } else {\n            panic!(\"Expected Loaded\");\n        }\n    }\n\n    #[test]\n    fn file_status_not_loaded() {\n        let status = FileStatus::NotLoaded {\n            path: PathBuf::from(\"/b.rs\"),\n            size: 500,\n            line_count: 50,\n        };\n        if let FileStatus::NotLoaded {\n            path,\n            size,\n            line_count,\n        } = status\n        {\n            assert_eq!(path, PathBuf::from(\"/b.rs\"));\n            assert_eq!(size, 500);\n            assert_eq!(line_count, 50);\n        } else {\n            panic!(\"Expected NotLoaded\");\n        }\n    }\n\n    #[test]\n    fn file_status_clone() {\n        let status = FileStatus::NotLoaded {\n            path: PathBuf::from(\"/a.rs\"),\n            size: 100,\n            line_count: 10,\n        };\n        let cloned = status.clone();\n        assert_eq!(status, cloned);\n    }\n\n    #[test]\n    fn file_status_debug() {\n        let status = FileStatus::NotLoaded {\n            path: PathBuf::from(\"/a.rs\"),\n            size: 100,\n            line_count: 10,\n        };\n        let debug = format!(\"{:?}\", status);\n        assert!(debug.contains(\"NotLoaded\"));\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":13}},{"line":22,"address":[],"length":0,"stats":{"Line":26}},{"line":23,"address":[],"length":0,"stats":{"Line":13}},{"line":24,"address":[],"length":0,"stats":{"Line":39}},{"line":37,"address":[],"length":0,"stats":{"Line":15}},{"line":58,"address":[],"length":0,"stats":{"Line":27}},{"line":61,"address":[],"length":0,"stats":{"Line":27}},{"line":66,"address":[],"length":0,"stats":{"Line":21}},{"line":67,"address":[],"length":0,"stats":{"Line":63}},{"line":68,"address":[],"length":0,"stats":{"Line":84}},{"line":72,"address":[],"length":0,"stats":{"Line":6}},{"line":73,"address":[],"length":0,"stats":{"Line":18}},{"line":74,"address":[],"length":0,"stats":{"Line":18}},{"line":79,"address":[],"length":0,"stats":{"Line":5}},{"line":80,"address":[],"length":0,"stats":{"Line":15}},{"line":81,"address":[],"length":0,"stats":{"Line":15}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":6}},{"line":91,"address":[],"length":0,"stats":{"Line":1}},{"line":92,"address":[],"length":0,"stats":{"Line":2}},{"line":96,"address":[],"length":0,"stats":{"Line":11}},{"line":97,"address":[],"length":0,"stats":{"Line":22}},{"line":101,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":8}},{"line":106,"address":[],"length":0,"stats":{"Line":2}},{"line":107,"address":[],"length":0,"stats":{"Line":8}}],"covered":26,"coverable":26},{"path":["/","Users","chi","Projects","hu","src","data","cli.rs"],"content":"use clap::Subcommand;\n\n#[derive(Subcommand, Debug)]\npub enum DataCommand {\n    /// Sync Claude Code data to local database\n    Sync {\n        /// Force full resync\n        #[arg(short, long)]\n        force: bool,\n\n        /// Quiet output\n        #[arg(short, long)]\n        quiet: bool,\n    },\n\n    /// Show data configuration\n    Config {\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n    },\n\n    /// Session operations\n    Session {\n        #[command(subcommand)]\n        cmd: SessionCommand,\n    },\n\n    /// Usage statistics\n    Stats {\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n\n        /// Today only\n        #[arg(short, long)]\n        today: bool,\n    },\n\n    /// Todo operations\n    Todos {\n        #[command(subcommand)]\n        cmd: TodosCommand,\n    },\n\n    /// Search messages\n    Search {\n        /// Search query\n        query: String,\n\n        /// Max results\n        #[arg(short = 'n', long, default_value = \"20\")]\n        limit: i64,\n\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n    },\n\n    /// Tool usage statistics\n    Tools {\n        /// Show detail for specific tool\n        #[arg(short, long)]\n        tool: Option\u003cString\u003e,\n\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n    },\n\n    /// Extract errors from debug logs\n    Errors {\n        /// Days to look back\n        #[arg(short, long, default_value = \"7\")]\n        recent: u32,\n\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n    },\n\n    /// Pricing analysis\n    Pricing {\n        /// Subscription tier\n        #[arg(short, long, default_value = \"max20x\")]\n        subscription: String,\n\n        /// Billing day of month\n        #[arg(short, long, default_value = \"6\")]\n        billing_day: u32,\n\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n    },\n\n    /// Branch activity statistics\n    Branches {\n        /// Filter by branch name\n        #[arg(short, long)]\n        branch: Option\u003cString\u003e,\n\n        /// Max results\n        #[arg(short, long, default_value = \"20\")]\n        limit: i64,\n\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n    },\n}\n\n#[derive(Subcommand, Debug)]\npub enum SessionCommand {\n    /// List sessions\n    List {\n        /// Filter by project\n        #[arg(short, long)]\n        project: Option\u003cString\u003e,\n\n        /// Max results\n        #[arg(short = 'n', long, default_value = \"20\")]\n        limit: i64,\n\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n    },\n\n    /// Read session messages\n    Read {\n        /// Session ID (or prefix)\n        id: String,\n\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n    },\n\n    /// Show current session\n    Current {\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n    },\n}\n\n#[derive(Subcommand, Debug)]\npub enum TodosCommand {\n    /// List all todos\n    List {\n        /// Filter by status\n        #[arg(short, long)]\n        status: Option\u003cString\u003e,\n\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n    },\n\n    /// Show pending todos\n    Pending {\n        /// Filter by project\n        #[arg(short, long)]\n        project: Option\u003cString\u003e,\n\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n    },\n}\n\n#[cfg(test)]\nmod tests {\n    use clap::Parser;\n\n    #[derive(Parser)]\n    struct TestCli {\n        #[command(subcommand)]\n        cmd: super::DataCommand,\n    }\n\n    #[test]\n    fn parse_sync() {\n        let cli = TestCli::try_parse_from([\"test\", \"sync\"]).unwrap();\n        assert!(matches!(\n            cli.cmd,\n            super::DataCommand::Sync {\n                force: false,\n                quiet: false\n            }\n        ));\n    }\n\n    #[test]\n    fn parse_sync_force() {\n        let cli = TestCli::try_parse_from([\"test\", \"sync\", \"-f\"]).unwrap();\n        assert!(matches!(\n            cli.cmd,\n            super::DataCommand::Sync { force: true, .. }\n        ));\n    }\n\n    #[test]\n    fn parse_config() {\n        let cli = TestCli::try_parse_from([\"test\", \"config\"]).unwrap();\n        assert!(matches!(\n            cli.cmd,\n            super::DataCommand::Config { json: false }\n        ));\n    }\n\n    #[test]\n    fn parse_config_json() {\n        let cli = TestCli::try_parse_from([\"test\", \"config\", \"-j\"]).unwrap();\n        assert!(matches!(cli.cmd, super::DataCommand::Config { json: true }));\n    }\n\n    #[test]\n    fn parse_session_list() {\n        let cli = TestCli::try_parse_from([\"test\", \"session\", \"list\"]).unwrap();\n        assert!(matches!(\n            cli.cmd,\n            super::DataCommand::Session {\n                cmd: super::SessionCommand::List { .. }\n            }\n        ));\n    }\n\n    #[test]\n    fn parse_session_list_with_project() {\n        let cli = TestCli::try_parse_from([\"test\", \"session\", \"list\", \"-p\", \"myproj\"]).unwrap();\n        if let super::DataCommand::Session {\n            cmd: super::SessionCommand::List { project, .. },\n        } = cli.cmd\n        {\n            assert_eq!(project, Some(\"myproj\".to_string()));\n        } else {\n            panic!(\"wrong variant\");\n        }\n    }\n\n    #[test]\n    fn parse_session_read() {\n        let cli = TestCli::try_parse_from([\"test\", \"session\", \"read\", \"abc-123\"]).unwrap();\n        if let super::DataCommand::Session {\n            cmd: super::SessionCommand::Read { id, .. },\n        } = cli.cmd\n        {\n            assert_eq!(id, \"abc-123\");\n        } else {\n            panic!(\"wrong variant\");\n        }\n    }\n\n    #[test]\n    fn parse_session_current() {\n        let cli = TestCli::try_parse_from([\"test\", \"session\", \"current\"]).unwrap();\n        assert!(matches!(\n            cli.cmd,\n            super::DataCommand::Session {\n                cmd: super::SessionCommand::Current { .. }\n            }\n        ));\n    }\n\n    #[test]\n    fn parse_stats() {\n        let cli = TestCli::try_parse_from([\"test\", \"stats\"]).unwrap();\n        assert!(matches!(cli.cmd, super::DataCommand::Stats { .. }));\n    }\n\n    #[test]\n    fn parse_stats_today() {\n        let cli = TestCli::try_parse_from([\"test\", \"stats\", \"-t\"]).unwrap();\n        if let super::DataCommand::Stats { today, .. } = cli.cmd {\n            assert!(today);\n        } else {\n            panic!(\"wrong variant\");\n        }\n    }\n\n    #[test]\n    fn parse_todos_list() {\n        let cli = TestCli::try_parse_from([\"test\", \"todos\", \"list\"]).unwrap();\n        assert!(matches!(\n            cli.cmd,\n            super::DataCommand::Todos {\n                cmd: super::TodosCommand::List { .. }\n            }\n        ));\n    }\n\n    #[test]\n    fn parse_todos_pending() {\n        let cli = TestCli::try_parse_from([\"test\", \"todos\", \"pending\"]).unwrap();\n        assert!(matches!(\n            cli.cmd,\n            super::DataCommand::Todos {\n                cmd: super::TodosCommand::Pending { .. }\n            }\n        ));\n    }\n\n    #[test]\n    fn parse_search() {\n        let cli = TestCli::try_parse_from([\"test\", \"search\", \"hello\"]).unwrap();\n        if let super::DataCommand::Search { query, limit, .. } = cli.cmd {\n            assert_eq!(query, \"hello\");\n            assert_eq!(limit, 20);\n        } else {\n            panic!(\"wrong variant\");\n        }\n    }\n\n    #[test]\n    fn parse_search_with_limit() {\n        let cli = TestCli::try_parse_from([\"test\", \"search\", \"hello\", \"-n\", \"5\"]).unwrap();\n        if let super::DataCommand::Search { limit, .. } = cli.cmd {\n            assert_eq!(limit, 5);\n        } else {\n            panic!(\"wrong variant\");\n        }\n    }\n\n    #[test]\n    fn parse_tools() {\n        let cli = TestCli::try_parse_from([\"test\", \"tools\"]).unwrap();\n        assert!(matches!(\n            cli.cmd,\n            super::DataCommand::Tools { tool: None, .. }\n        ));\n    }\n\n    #[test]\n    fn parse_tools_specific() {\n        let cli = TestCli::try_parse_from([\"test\", \"tools\", \"-t\", \"Read\"]).unwrap();\n        if let super::DataCommand::Tools { tool, .. } = cli.cmd {\n            assert_eq!(tool, Some(\"Read\".to_string()));\n        } else {\n            panic!(\"wrong variant\");\n        }\n    }\n\n    #[test]\n    fn parse_errors() {\n        let cli = TestCli::try_parse_from([\"test\", \"errors\"]).unwrap();\n        if let super::DataCommand::Errors { recent, .. } = cli.cmd {\n            assert_eq!(recent, 7);\n        } else {\n            panic!(\"wrong variant\");\n        }\n    }\n\n    #[test]\n    fn parse_pricing() {\n        let cli = TestCli::try_parse_from([\"test\", \"pricing\"]).unwrap();\n        if let super::DataCommand::Pricing {\n            subscription,\n            billing_day,\n            ..\n        } = cli.cmd\n        {\n            assert_eq!(subscription, \"max20x\");\n            assert_eq!(billing_day, 6);\n        } else {\n            panic!(\"wrong variant\");\n        }\n    }\n\n    #[test]\n    fn parse_branches() {\n        let cli = TestCli::try_parse_from([\"test\", \"branches\"]).unwrap();\n        assert!(matches!(cli.cmd, super::DataCommand::Branches { .. }));\n    }\n\n    #[test]\n    fn parse_branches_with_filter() {\n        let cli = TestCli::try_parse_from([\"test\", \"branches\", \"-b\", \"feature\"]).unwrap();\n        if let super::DataCommand::Branches { branch, .. } = cli.cmd {\n            assert_eq!(branch, Some(\"feature\".to_string()));\n        } else {\n            panic!(\"wrong variant\");\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","data","config.rs"],"content":"use anyhow::Result;\nuse std::path::PathBuf;\n\n#[derive(Debug, Clone)]\npub struct DataConfig {\n    pub claude_dir: PathBuf,\n    pub database: PathBuf,\n    pub auto_sync_interval: u64,\n    pub sync_on_start: bool,\n}\n\nimpl Default for DataConfig {\n    fn default() -\u003e Self {\n        Self {\n            claude_dir: expand_path(\"~/.claude\"),\n            database: resolve_db_path(\"hu.db\"),\n            auto_sync_interval: 300,\n            sync_on_start: true,\n        }\n    }\n}\n\npub fn expand_path(path: \u0026str) -\u003e PathBuf {\n    if let Some(rest) = path.strip_prefix(\"~/\") {\n        if let Some(home) = dirs::home_dir() {\n            return home.join(rest);\n        }\n    }\n    if path == \"~\" {\n        if let Some(home) = dirs::home_dir() {\n            return home;\n        }\n    }\n    PathBuf::from(path)\n}\n\npub fn resolve_db_path(db: \u0026str) -\u003e PathBuf {\n    let path = PathBuf::from(db);\n    if path.is_absolute() {\n        return path;\n    }\n    if db.starts_with(\"~/\") {\n        return expand_path(db);\n    }\n    config_dir().join(db)\n}\n\nfn config_dir() -\u003e PathBuf {\n    config_dir_with_home(dirs::home_dir())\n}\n\nfn config_dir_with_home(home: Option\u003cPathBuf\u003e) -\u003e PathBuf {\n    match home {\n        Some(h) =\u003e h.join(\".config\").join(\"hu\"),\n        None =\u003e PathBuf::from(\".config/hu\"),\n    }\n}\n\n#[cfg(not(tarpaulin_include))]\npub fn load_data_config() -\u003e Result\u003cDataConfig\u003e {\n    let config_path = config_dir().join(\"settings.toml\");\n    if !config_path.exists() {\n        return Ok(DataConfig::default());\n    }\n\n    let content = std::fs::read_to_string(\u0026config_path)?;\n    load_from_toml(\u0026content)\n}\n\npub fn load_from_toml(content: \u0026str) -\u003e Result\u003cDataConfig\u003e {\n    let table: toml::Value = content.parse()?;\n    let mut config = DataConfig::default();\n\n    if let Some(general) = table.get(\"general\") {\n        if let Some(claude_dir) = general.get(\"claude_dir\").and_then(|v| v.as_str()) {\n            config.claude_dir = expand_path(claude_dir);\n        }\n        if let Some(database) = general.get(\"database\").and_then(|v| v.as_str()) {\n            config.database = resolve_db_path(database);\n        }\n    }\n\n    if let Some(sync) = table.get(\"sync\") {\n        if let Some(interval) = sync.get(\"auto_sync_interval\").and_then(|v| v.as_integer()) {\n            config.auto_sync_interval = interval as u64;\n        }\n        if let Some(on_start) = sync.get(\"sync_on_start\").and_then(|v| v.as_bool()) {\n            config.sync_on_start = on_start;\n        }\n    }\n\n    Ok(config)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn expand_tilde() {\n        let home = dirs::home_dir().unwrap();\n        assert_eq!(expand_path(\"~/foo\"), home.join(\"foo\"));\n        assert_eq!(expand_path(\"~\"), home);\n    }\n\n    #[test]\n    fn expand_absolute() {\n        assert_eq!(expand_path(\"/usr/bin\"), PathBuf::from(\"/usr/bin\"));\n    }\n\n    #[test]\n    fn expand_relative() {\n        assert_eq!(expand_path(\"foo/bar\"), PathBuf::from(\"foo/bar\"));\n    }\n\n    #[test]\n    fn resolve_db_absolute() {\n        assert_eq!(\n            resolve_db_path(\"/tmp/test.db\"),\n            PathBuf::from(\"/tmp/test.db\")\n        );\n    }\n\n    #[test]\n    fn resolve_db_tilde() {\n        let home = dirs::home_dir().unwrap();\n        assert_eq!(resolve_db_path(\"~/data.db\"), home.join(\"data.db\"));\n    }\n\n    #[test]\n    fn resolve_db_relative() {\n        let expected = config_dir().join(\"hu.db\");\n        assert_eq!(resolve_db_path(\"hu.db\"), expected);\n    }\n\n    #[test]\n    fn default_config() {\n        let config = DataConfig::default();\n        assert!(config.claude_dir.ends_with(\".claude\"));\n        assert!(config.database.ends_with(\"hu.db\"));\n        assert_eq!(config.auto_sync_interval, 300);\n        assert!(config.sync_on_start);\n    }\n\n    #[test]\n    fn load_from_empty_toml() {\n        let config = load_from_toml(\"\").unwrap();\n        assert_eq!(config.auto_sync_interval, 300);\n        assert!(config.sync_on_start);\n    }\n\n    #[test]\n    fn load_from_full_toml() {\n        let toml = r#\"\n[general]\nclaude_dir = \"/custom/.claude\"\ndatabase = \"/custom/data.db\"\n\n[sync]\nauto_sync_interval = 600\nsync_on_start = false\n\"#;\n        let config = load_from_toml(toml).unwrap();\n        assert_eq!(config.claude_dir, PathBuf::from(\"/custom/.claude\"));\n        assert_eq!(config.database, PathBuf::from(\"/custom/data.db\"));\n        assert_eq!(config.auto_sync_interval, 600);\n        assert!(!config.sync_on_start);\n    }\n\n    #[test]\n    fn load_partial_toml() {\n        let toml = r#\"\n[sync]\nauto_sync_interval = 0\n\"#;\n        let config = load_from_toml(toml).unwrap();\n        assert_eq!(config.auto_sync_interval, 0);\n        assert!(config.sync_on_start); // default preserved\n    }\n\n    #[test]\n    fn config_dir_with_home_some() {\n        let home = PathBuf::from(\"/home/user\");\n        let result = config_dir_with_home(Some(home));\n        assert_eq!(result, PathBuf::from(\"/home/user/.config/hu\"));\n    }\n\n    #[test]\n    fn config_dir_with_home_none() {\n        let result = config_dir_with_home(None);\n        assert_eq!(result, PathBuf::from(\".config/hu\"));\n    }\n\n    #[test]\n    fn load_invalid_toml() {\n        let result = load_from_toml(\"not valid toml {{{\");\n        assert!(result.is_err());\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":6}},{"line":15,"address":[],"length":0,"stats":{"Line":18}},{"line":16,"address":[],"length":0,"stats":{"Line":6}},{"line":23,"address":[],"length":0,"stats":{"Line":12}},{"line":24,"address":[],"length":0,"stats":{"Line":20}},{"line":25,"address":[],"length":0,"stats":{"Line":16}},{"line":26,"address":[],"length":0,"stats":{"Line":16}},{"line":29,"address":[],"length":0,"stats":{"Line":4}},{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":31,"address":[],"length":0,"stats":{"Line":1}},{"line":34,"address":[],"length":0,"stats":{"Line":6}},{"line":37,"address":[],"length":0,"stats":{"Line":10}},{"line":38,"address":[],"length":0,"stats":{"Line":30}},{"line":39,"address":[],"length":0,"stats":{"Line":10}},{"line":40,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":16}},{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":14}},{"line":48,"address":[],"length":0,"stats":{"Line":8}},{"line":49,"address":[],"length":0,"stats":{"Line":16}},{"line":52,"address":[],"length":0,"stats":{"Line":10}},{"line":53,"address":[],"length":0,"stats":{"Line":10}},{"line":54,"address":[],"length":0,"stats":{"Line":18}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":70,"address":[],"length":0,"stats":{"Line":4}},{"line":71,"address":[],"length":0,"stats":{"Line":15}},{"line":72,"address":[],"length":0,"stats":{"Line":6}},{"line":74,"address":[],"length":0,"stats":{"Line":4}},{"line":75,"address":[],"length":0,"stats":{"Line":7}},{"line":76,"address":[],"length":0,"stats":{"Line":2}},{"line":78,"address":[],"length":0,"stats":{"Line":7}},{"line":79,"address":[],"length":0,"stats":{"Line":2}},{"line":83,"address":[],"length":0,"stats":{"Line":5}},{"line":84,"address":[],"length":0,"stats":{"Line":14}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":87,"address":[],"length":0,"stats":{"Line":10}},{"line":88,"address":[],"length":0,"stats":{"Line":1}},{"line":92,"address":[],"length":0,"stats":{"Line":3}}],"covered":38,"coverable":38},{"path":["/","Users","chi","Projects","hu","src","data","db.rs"],"content":"use anyhow::Result;\nuse rusqlite::Connection;\nuse std::path::Path;\n\nuse super::schema::initialize_schema;\n\npub struct SqliteStore {\n    pub conn: Connection,\n}\n\nimpl SqliteStore {\n    pub fn open(path: \u0026Path) -\u003e Result\u003cSelf\u003e {\n        if let Some(parent) = path.parent() {\n            std::fs::create_dir_all(parent)?;\n        }\n        let conn = Connection::open(path)?;\n        Self::configure(\u0026conn)?;\n        Ok(Self { conn })\n    }\n\n    #[allow(dead_code)]\n    pub fn open_memory() -\u003e Result\u003cSelf\u003e {\n        let conn = Connection::open_in_memory()?;\n        Self::configure(\u0026conn)?;\n        Ok(Self { conn })\n    }\n\n    pub fn open_initialized(path: \u0026Path) -\u003e Result\u003cSelf\u003e {\n        let store = Self::open(path)?;\n        initialize_schema(\u0026store.conn)?;\n        Ok(store)\n    }\n\n    fn configure(conn: \u0026Connection) -\u003e Result\u003c()\u003e {\n        conn.execute_batch(\"PRAGMA journal_mode=WAL; PRAGMA foreign_keys=ON;\")?;\n        Ok(())\n    }\n}\n\n#[cfg(test)]\npub fn open_test_db() -\u003e SqliteStore {\n    let store = SqliteStore::open_memory().unwrap();\n    initialize_schema(\u0026store.conn).unwrap();\n    store\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn open_memory_works() {\n        let store = SqliteStore::open_memory().unwrap();\n        let result: i64 = store\n            .conn\n            .query_row(\"SELECT 1\", [], |row| row.get(0))\n            .unwrap();\n        assert_eq!(result, 1);\n    }\n\n    #[test]\n    fn open_test_db_has_schema() {\n        let store = open_test_db();\n        let version: i64 = store\n            .conn\n            .query_row(\n                \"SELECT COALESCE(MAX(version), 0) FROM schema_version\",\n                [],\n                |row| row.get(0),\n            )\n            .unwrap();\n        assert_eq!(version, 2);\n    }\n\n    #[test]\n    fn open_initialized_creates_file() {\n        let tmp = std::env::temp_dir().join(\"hu-test-db-init\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n        let db_path = tmp.join(\"test.db\");\n\n        let store = SqliteStore::open_initialized(\u0026db_path).unwrap();\n        let version: i64 = store\n            .conn\n            .query_row(\n                \"SELECT COALESCE(MAX(version), 0) FROM schema_version\",\n                [],\n                |row| row.get(0),\n            )\n            .unwrap();\n        assert_eq!(version, 2);\n        assert!(db_path.exists());\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn wal_mode_enabled() {\n        let store = open_test_db();\n        let mode: String = store\n            .conn\n            .query_row(\"PRAGMA journal_mode\", [], |row| row.get(0))\n            .unwrap();\n        // In-memory databases use \"memory\" mode, not WAL\n        assert!(mode == \"wal\" || mode == \"memory\");\n    }\n\n    #[test]\n    fn foreign_keys_enabled() {\n        let store = open_test_db();\n        let fk: i64 = store\n            .conn\n            .query_row(\"PRAGMA foreign_keys\", [], |row| row.get(0))\n            .unwrap();\n        assert_eq!(fk, 1);\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":1}},{"line":13,"address":[],"length":0,"stats":{"Line":2}},{"line":14,"address":[],"length":0,"stats":{"Line":2}},{"line":16,"address":[],"length":0,"stats":{"Line":3}},{"line":17,"address":[],"length":0,"stats":{"Line":2}},{"line":18,"address":[],"length":0,"stats":{"Line":1}},{"line":22,"address":[],"length":0,"stats":{"Line":62}},{"line":23,"address":[],"length":0,"stats":{"Line":124}},{"line":24,"address":[],"length":0,"stats":{"Line":124}},{"line":25,"address":[],"length":0,"stats":{"Line":62}},{"line":28,"address":[],"length":0,"stats":{"Line":1}},{"line":29,"address":[],"length":0,"stats":{"Line":3}},{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":31,"address":[],"length":0,"stats":{"Line":1}},{"line":34,"address":[],"length":0,"stats":{"Line":63}},{"line":35,"address":[],"length":0,"stats":{"Line":189}},{"line":36,"address":[],"length":0,"stats":{"Line":63}},{"line":41,"address":[],"length":0,"stats":{"Line":61}},{"line":42,"address":[],"length":0,"stats":{"Line":183}},{"line":43,"address":[],"length":0,"stats":{"Line":183}},{"line":44,"address":[],"length":0,"stats":{"Line":61}}],"covered":21,"coverable":21},{"path":["/","Users","chi","Projects","hu","src","data","display","mod.rs"],"content":"use anyhow::Result;\nuse comfy_table::presets::UTF8_FULL_CONDENSED;\nuse comfy_table::{Cell, Color, Table};\n\nuse super::pricing::{self, BillingCycle, ValueComparison};\nuse super::queries::{ModelTokenUsage, PeriodUsage};\nuse super::types::*;\n\n#[cfg(test)]\nmod tests;\n\n// --- Helper formatting ---\n\npub fn time_ago_ms(ms: i64) -\u003e String {\n    let now = chrono::Utc::now().timestamp_millis();\n    let diff = now - ms;\n    let secs = diff / 1000;\n\n    if secs \u003c 60 {\n        \"just now\".to_string()\n    } else if secs \u003c 3600 {\n        format!(\"{}m ago\", secs / 60)\n    } else if secs \u003c 86400 {\n        format!(\"{}h ago\", secs / 3600)\n    } else {\n        format!(\"{}d ago\", secs / 86400)\n    }\n}\n\npub fn truncate(s: \u0026str, max: usize) -\u003e String {\n    if s.len() \u003c= max {\n        s.to_string()\n    } else if max \u003c= 3 {\n        s[..max].to_string()\n    } else {\n        format!(\"{}...\", \u0026s[..max - 3])\n    }\n}\n\npub fn role_color(role: \u0026str) -\u003e Color {\n    match role {\n        \"user\" =\u003e Color::Cyan,\n        \"assistant\" =\u003e Color::Green,\n        _ =\u003e Color::White,\n    }\n}\n\npub fn status_color(status: \u0026str) -\u003e Color {\n    match status {\n        \"pending\" =\u003e Color::Yellow,\n        \"in_progress\" =\u003e Color::Cyan,\n        \"completed\" =\u003e Color::Green,\n        _ =\u003e Color::White,\n    }\n}\n\nfn format_tokens(tokens: i64) -\u003e String {\n    if tokens \u003e= 1_000_000 {\n        format!(\"{:.1}M\", tokens as f64 / 1_000_000.0)\n    } else if tokens \u003e= 1_000 {\n        format!(\"{:.1}K\", tokens as f64 / 1_000.0)\n    } else {\n        tokens.to_string()\n    }\n}\n\n// --- Output functions ---\n\npub fn output_sync(result: \u0026SyncResult, format: \u0026OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Json =\u003e {\n            println!(\"{}\", serde_json::to_string_pretty(result)?);\n        }\n        OutputFormat::Table =\u003e {\n            println!(\" Sync complete:\");\n            println!(\"  Sessions: {} new\", result.history);\n            println!(\"  Messages: {} new\", result.messages);\n            println!(\"  Todos: {} synced\", result.todos);\n        }\n    }\n    Ok(())\n}\n\npub fn output_config(config: \u0026super::config::DataConfig, format: \u0026OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Json =\u003e {\n            let json = serde_json::json!({\n                \"claude_dir\": config.claude_dir.display().to_string(),\n                \"database\": config.database.display().to_string(),\n                \"auto_sync_interval\": config.auto_sync_interval,\n                \"sync_on_start\": config.sync_on_start,\n            });\n            println!(\"{}\", serde_json::to_string_pretty(\u0026json)?);\n        }\n        OutputFormat::Table =\u003e {\n            println!(\"Claude dir: {}\", config.claude_dir.display());\n            println!(\"Database:   {}\", config.database.display());\n            println!(\"Sync interval: {}s\", config.auto_sync_interval);\n            println!(\"Sync on start: {}\", config.sync_on_start);\n        }\n    }\n    Ok(())\n}\n\npub fn output_sessions(sessions: \u0026[Session], format: \u0026OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Json =\u003e {\n            println!(\"{}\", serde_json::to_string_pretty(sessions)?);\n        }\n        OutputFormat::Table =\u003e {\n            if sessions.is_empty() {\n                println!(\"No sessions found.\");\n                return Ok(());\n            }\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_header(vec![\"ID\", \"Project\", \"Display\", \"Started\", \"Msgs\", \"Cost\"]);\n\n            for s in sessions {\n                table.add_row(vec![\n                    Cell::new(truncate(\u0026s.id, 12)),\n                    Cell::new(truncate(\u0026s.project, 30)),\n                    Cell::new(truncate(s.display.as_deref().unwrap_or(\"-\"), 25)),\n                    Cell::new(time_ago_ms(s.started_at)),\n                    Cell::new(s.message_count.to_string()),\n                    Cell::new(pricing::format_cost(s.total_cost_usd)),\n                ]);\n            }\n            println!(\"{table}\");\n        }\n    }\n    Ok(())\n}\n\npub fn output_session_messages(messages: \u0026[Message], format: \u0026OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Json =\u003e {\n            println!(\"{}\", serde_json::to_string_pretty(messages)?);\n        }\n        OutputFormat::Table =\u003e {\n            if messages.is_empty() {\n                println!(\"No messages found.\");\n                return Ok(());\n            }\n            for msg in messages {\n                let role = msg.role.as_str();\n                let content = msg.content.as_deref().unwrap_or(\"\");\n                let preview = truncate(content, 120);\n                let model_str = msg.model.as_deref().unwrap_or(\"\");\n                let tokens = match (msg.input_tokens, msg.output_tokens) {\n                    (Some(i), Some(o)) =\u003e format!(\" [{}+{}]\", format_tokens(i), format_tokens(o)),\n                    _ =\u003e String::new(),\n                };\n                let model_suffix = if model_str.is_empty() {\n                    String::new()\n                } else {\n                    format!(\" ({model_str})\")\n                };\n                println!(\"{role}{model_suffix} {preview}{tokens}\");\n            }\n        }\n    }\n    Ok(())\n}\n\npub fn output_search_results(results: \u0026[SearchResult], format: \u0026OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Json =\u003e {\n            println!(\"{}\", serde_json::to_string_pretty(results)?);\n        }\n        OutputFormat::Table =\u003e {\n            if results.is_empty() {\n                println!(\"No results found.\");\n                return Ok(());\n            }\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_header(vec![\"Role\", \"Content\", \"Project\", \"When\"]);\n\n            for r in results {\n                let content = r.content.as_deref().unwrap_or(\"\");\n                table.add_row(vec![\n                    Cell::new(\u0026r.role).fg(role_color(\u0026r.role)),\n                    Cell::new(truncate(content, 60)),\n                    Cell::new(truncate(\u0026r.project, 25)),\n                    Cell::new(time_ago_ms(r.created_at)),\n                ]);\n            }\n            println!(\"{table}\");\n        }\n    }\n    Ok(())\n}\n\npub fn output_stats(\n    stats: \u0026UsageStats,\n    model_usage: \u0026[ModelUsage],\n    format: \u0026OutputFormat,\n) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Json =\u003e {\n            let json = serde_json::json!({\n                \"stats\": stats,\n                \"model_usage\": model_usage,\n            });\n            println!(\"{}\", serde_json::to_string_pretty(\u0026json)?);\n        }\n        OutputFormat::Table =\u003e {\n            println!(\"Usage Statistics:\");\n            println!(\"  Sessions: {}\", stats.total_sessions);\n            println!(\"  Messages: {}\", stats.total_messages);\n            println!(\"  Total cost: {}\", pricing::format_cost(stats.total_cost));\n            println!(\n                \"  Input tokens: {}\",\n                format_tokens(stats.total_input_tokens)\n            );\n            println!(\n                \"  Output tokens: {}\",\n                format_tokens(stats.total_output_tokens)\n            );\n\n            if !model_usage.is_empty() {\n                println!(\"\\nBy Model:\");\n                let mut table = Table::new();\n                table.load_preset(UTF8_FULL_CONDENSED);\n                table.set_header(vec![\"Model\", \"Count\", \"Cost\", \"Input\", \"Output\"]);\n                for m in model_usage {\n                    table.add_row(vec![\n                        Cell::new(\u0026m.model),\n                        Cell::new(m.count.to_string()),\n                        Cell::new(pricing::format_cost(m.cost)),\n                        Cell::new(format_tokens(m.input_tokens)),\n                        Cell::new(format_tokens(m.output_tokens)),\n                    ]);\n                }\n                println!(\"{table}\");\n            }\n        }\n    }\n    Ok(())\n}\n\npub fn output_todos(todos: \u0026[Todo], format: \u0026OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Json =\u003e {\n            println!(\"{}\", serde_json::to_string_pretty(todos)?);\n        }\n        OutputFormat::Table =\u003e {\n            if todos.is_empty() {\n                println!(\"No todos found.\");\n                return Ok(());\n            }\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_header(vec![\"ID\", \"Status\", \"Content\", \"Session\"]);\n\n            for t in todos {\n                let icon = match t.status.as_str() {\n                    \"completed\" =\u003e \"\",\n                    \"in_progress\" =\u003e \"\",\n                    \"pending\" =\u003e \"\",\n                    _ =\u003e \"?\",\n                };\n                table.add_row(vec![\n                    Cell::new(t.id.to_string()),\n                    Cell::new(format!(\"{icon} {}\", t.status)).fg(status_color(\u0026t.status)),\n                    Cell::new(truncate(\u0026t.content, 50)),\n                    Cell::new(truncate(\u0026t.session_id, 12)),\n                ]);\n            }\n            println!(\"{table}\");\n        }\n    }\n    Ok(())\n}\n\npub fn output_pending_todos(todos: \u0026[TodoWithProject], format: \u0026OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Json =\u003e {\n            println!(\"{}\", serde_json::to_string_pretty(todos)?);\n        }\n        OutputFormat::Table =\u003e {\n            if todos.is_empty() {\n                println!(\"No pending todos found.\");\n                return Ok(());\n            }\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_header(vec![\"Status\", \"Content\", \"Project\"]);\n\n            for t in todos {\n                let icon = match t.status.as_str() {\n                    \"in_progress\" =\u003e \"\",\n                    \"pending\" =\u003e \"\",\n                    _ =\u003e \"?\",\n                };\n                table.add_row(vec![\n                    Cell::new(format!(\"{icon} {}\", t.status)).fg(status_color(\u0026t.status)),\n                    Cell::new(truncate(\u0026t.content, 50)),\n                    Cell::new(truncate(\u0026t.project, 30)),\n                ]);\n            }\n            println!(\"{table}\");\n        }\n    }\n    Ok(())\n}\n\npub fn output_tool_stats(stats: \u0026[ToolUsageStats], format: \u0026OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Json =\u003e {\n            println!(\"{}\", serde_json::to_string_pretty(stats)?);\n        }\n        OutputFormat::Table =\u003e {\n            if stats.is_empty() {\n                println!(\"No tool usage data.\");\n                return Ok(());\n            }\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_header(vec![\"Tool\", \"Count\", \"Last Used\"]);\n\n            for s in stats {\n                table.add_row(vec![\n                    Cell::new(\u0026s.tool_name),\n                    Cell::new(s.count.to_string()),\n                    Cell::new(time_ago_ms(s.last_used)),\n                ]);\n            }\n            println!(\"{table}\");\n        }\n    }\n    Ok(())\n}\n\npub fn output_tool_detail(detail: \u0026[ToolUsageDetail], format: \u0026OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Json =\u003e {\n            println!(\"{}\", serde_json::to_string_pretty(detail)?);\n        }\n        OutputFormat::Table =\u003e {\n            if detail.is_empty() {\n                println!(\"No usage found for this tool.\");\n                return Ok(());\n            }\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_header(vec![\"Tool\", \"Session\", \"Project\", \"When\"]);\n\n            for d in detail {\n                table.add_row(vec![\n                    Cell::new(\u0026d.tool_name),\n                    Cell::new(truncate(\u0026d.session_id, 12)),\n                    Cell::new(truncate(\u0026d.project, 30)),\n                    Cell::new(time_ago_ms(d.created_at)),\n                ]);\n            }\n            println!(\"{table}\");\n        }\n    }\n    Ok(())\n}\n\npub fn output_errors(errors: \u0026[DebugError], format: \u0026OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Json =\u003e {\n            println!(\"{}\", serde_json::to_string_pretty(errors)?);\n        }\n        OutputFormat::Table =\u003e {\n            if errors.is_empty() {\n                println!(\"No errors found.\");\n                return Ok(());\n            }\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_header(vec![\"File\", \"Line\", \"Content\"]);\n\n            for e in errors {\n                table.add_row(vec![\n                    Cell::new(truncate(\u0026e.file, 25)),\n                    Cell::new(e.line.to_string()),\n                    Cell::new(truncate(\u0026e.content, 60)).fg(Color::Red),\n                ]);\n            }\n            println!(\"{table}\");\n        }\n    }\n    Ok(())\n}\n\n// Helper types for pricing display\n\n#[derive(Debug, Clone, serde::Serialize)]\npub struct ModelUsageWithCost {\n    pub model: String,\n    pub input_tokens: i64,\n    pub output_tokens: i64,\n    pub cost: f64,\n}\n\n#[derive(Debug, Clone, serde::Serialize)]\npub struct PricingData {\n    pub subscription: String,\n    pub subscription_price: f64,\n    pub billing_cycle: BillingCycle,\n    pub period_usage: PeriodUsage,\n    pub model_costs: Vec\u003cModelUsageWithCost\u003e,\n    pub total_api_cost: f64,\n    pub projected_cost: f64,\n    pub break_even: pricing::BreakEvenAnalysis,\n    pub value_comparisons: Vec\u003cValueComparison\u003e,\n}\n\npub fn output_pricing(data: \u0026PricingData, format: \u0026OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Json =\u003e {\n            println!(\"{}\", serde_json::to_string_pretty(data)?);\n        }\n        OutputFormat::Table =\u003e {\n            println!(\n                \"Pricing Analysis ({} plan, ${}/mo):\",\n                data.subscription, data.subscription_price\n            );\n            println!(\n                \"  Billing cycle: {} days elapsed, {} remaining (of {})\",\n                data.billing_cycle.days_elapsed,\n                data.billing_cycle.days_remaining,\n                data.billing_cycle.total_days\n            );\n            println!();\n\n            println!(\"Current Period Usage:\");\n            println!(\"  Messages: {}\", data.period_usage.messages);\n            println!(\n                \"  Input tokens: {}\",\n                format_tokens(data.period_usage.input_tokens)\n            );\n            println!(\n                \"  Output tokens: {}\",\n                format_tokens(data.period_usage.output_tokens)\n            );\n            println!();\n\n            if !data.model_costs.is_empty() {\n                println!(\"API Cost by Model:\");\n                let mut table = Table::new();\n                table.load_preset(UTF8_FULL_CONDENSED);\n                table.set_header(vec![\"Model\", \"Input\", \"Output\", \"Cost\"]);\n                for m in \u0026data.model_costs {\n                    table.add_row(vec![\n                        Cell::new(\u0026m.model),\n                        Cell::new(format_tokens(m.input_tokens)),\n                        Cell::new(format_tokens(m.output_tokens)),\n                        Cell::new(pricing::format_cost(m.cost)),\n                    ]);\n                }\n                println!(\"{table}\");\n            }\n\n            println!(\n                \"Total API-equivalent cost: {}\",\n                pricing::format_cost(data.total_api_cost)\n            );\n            println!(\n                \"Projected cycle cost: {}\",\n                pricing::format_cost(data.projected_cost)\n            );\n            println!();\n\n            println!(\"Break-even Analysis (Opus 4.5 rates):\");\n            println!(\n                \"  Output tokens to break even: {}\",\n                format_tokens(data.break_even.break_even_output_tokens)\n            );\n            println!(\n                \"  Input tokens to break even: {}\",\n                format_tokens(data.break_even.break_even_input_tokens)\n            );\n\n            if !data.value_comparisons.is_empty() {\n                println!(\n                    \"\\nValue Comparison (vs API cost {}):\",\n                    pricing::format_cost(data.total_api_cost)\n                );\n                let mut table = Table::new();\n                table.load_preset(UTF8_FULL_CONDENSED);\n                table.set_header(vec![\"Service\", \"Plan\", \"Price\", \"Savings\"]);\n                for v in \u0026data.value_comparisons {\n                    let savings_str = if v.savings \u003e 0.0 {\n                        format!(\n                            \"{} ({:.0}%)\",\n                            pricing::format_cost(v.savings),\n                            v.savings_percent\n                        )\n                    } else {\n                        format!(\"-{}\", pricing::format_cost(-v.savings))\n                    };\n                    table.add_row(vec![\n                        Cell::new(\u0026v.service),\n                        Cell::new(\u0026v.plan),\n                        Cell::new(format!(\"${:.0}/mo\", v.price)),\n                        Cell::new(savings_str),\n                    ]);\n                }\n                println!(\"{table}\");\n            }\n        }\n    }\n    Ok(())\n}\n\n#[derive(Debug, Clone, serde::Serialize)]\npub struct BranchWithPr {\n    pub branch: BranchStats,\n    pub pr: Option\u003cPrInfo\u003e,\n}\n\n#[derive(Debug, Clone, serde::Serialize)]\npub struct PrInfo {\n    pub number: i64,\n    pub title: String,\n    pub state: String,\n    pub url: String,\n}\n\npub fn output_branches(branches: \u0026[BranchWithPr], format: \u0026OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Json =\u003e {\n            println!(\"{}\", serde_json::to_string_pretty(branches)?);\n        }\n        OutputFormat::Table =\u003e {\n            if branches.is_empty() {\n                println!(\"No branches found.\");\n                return Ok(());\n            }\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_header(vec![\n                \"Branch\",\n                \"Sessions\",\n                \"Msgs\",\n                \"Cost\",\n                \"Last Active\",\n                \"PR\",\n            ]);\n\n            for b in branches {\n                let pr_str = match \u0026b.pr {\n                    Some(pr) =\u003e format!(\"#{} ({})\", pr.number, pr.state),\n                    None =\u003e \"-\".to_string(),\n                };\n                table.add_row(vec![\n                    Cell::new(truncate(\u0026b.branch.git_branch, 30)),\n                    Cell::new(b.branch.session_count.to_string()),\n                    Cell::new(b.branch.total_messages.to_string()),\n                    Cell::new(pricing::format_cost(b.branch.total_cost)),\n                    Cell::new(time_ago_ms(b.branch.last_activity)),\n                    Cell::new(pr_str),\n                ]);\n            }\n            println!(\"{table}\");\n        }\n    }\n    Ok(())\n}\n\npub fn build_model_costs(model_usage: \u0026[ModelTokenUsage]) -\u003e Vec\u003cModelUsageWithCost\u003e {\n    model_usage\n        .iter()\n        .map(|m| {\n            let cost = pricing::calculate_cost(Some(\u0026m.model), m.input_tokens, m.output_tokens);\n            ModelUsageWithCost {\n                model: m.model.clone(),\n                input_tokens: m.input_tokens,\n                output_tokens: m.output_tokens,\n                cost,\n            }\n        })\n        .collect()\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":10}},{"line":15,"address":[],"length":0,"stats":{"Line":30}},{"line":16,"address":[],"length":0,"stats":{"Line":20}},{"line":17,"address":[],"length":0,"stats":{"Line":20}},{"line":19,"address":[],"length":0,"stats":{"Line":10}},{"line":20,"address":[],"length":0,"stats":{"Line":14}},{"line":21,"address":[],"length":0,"stats":{"Line":3}},{"line":22,"address":[],"length":0,"stats":{"Line":3}},{"line":23,"address":[],"length":0,"stats":{"Line":2}},{"line":24,"address":[],"length":0,"stats":{"Line":3}},{"line":26,"address":[],"length":0,"stats":{"Line":3}},{"line":30,"address":[],"length":0,"stats":{"Line":32}},{"line":31,"address":[],"length":0,"stats":{"Line":64}},{"line":32,"address":[],"length":0,"stats":{"Line":60}},{"line":33,"address":[],"length":0,"stats":{"Line":2}},{"line":34,"address":[],"length":0,"stats":{"Line":2}},{"line":36,"address":[],"length":0,"stats":{"Line":3}},{"line":40,"address":[],"length":0,"stats":{"Line":4}},{"line":41,"address":[],"length":0,"stats":{"Line":4}},{"line":42,"address":[],"length":0,"stats":{"Line":6}},{"line":43,"address":[],"length":0,"stats":{"Line":3}},{"line":44,"address":[],"length":0,"stats":{"Line":1}},{"line":48,"address":[],"length":0,"stats":{"Line":11}},{"line":49,"address":[],"length":0,"stats":{"Line":11}},{"line":50,"address":[],"length":0,"stats":{"Line":14}},{"line":51,"address":[],"length":0,"stats":{"Line":11}},{"line":52,"address":[],"length":0,"stats":{"Line":7}},{"line":53,"address":[],"length":0,"stats":{"Line":3}},{"line":57,"address":[],"length":0,"stats":{"Line":35}},{"line":58,"address":[],"length":0,"stats":{"Line":35}},{"line":59,"address":[],"length":0,"stats":{"Line":30}},{"line":60,"address":[],"length":0,"stats":{"Line":25}},{"line":61,"address":[],"length":0,"stats":{"Line":54}},{"line":63,"address":[],"length":0,"stats":{"Line":14}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":4}},{"line":74,"address":[],"length":0,"stats":{"Line":1}},{"line":75,"address":[],"length":0,"stats":{"Line":3}},{"line":76,"address":[],"length":0,"stats":{"Line":3}},{"line":77,"address":[],"length":0,"stats":{"Line":3}},{"line":78,"address":[],"length":0,"stats":{"Line":1}},{"line":81,"address":[],"length":0,"stats":{"Line":2}},{"line":84,"address":[],"length":0,"stats":{"Line":2}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":87,"address":[],"length":0,"stats":{"Line":2}},{"line":88,"address":[],"length":0,"stats":{"Line":3}},{"line":89,"address":[],"length":0,"stats":{"Line":3}},{"line":90,"address":[],"length":0,"stats":{"Line":1}},{"line":91,"address":[],"length":0,"stats":{"Line":1}},{"line":93,"address":[],"length":0,"stats":{"Line":4}},{"line":95,"address":[],"length":0,"stats":{"Line":1}},{"line":96,"address":[],"length":0,"stats":{"Line":4}},{"line":97,"address":[],"length":0,"stats":{"Line":4}},{"line":98,"address":[],"length":0,"stats":{"Line":3}},{"line":99,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":2}},{"line":105,"address":[],"length":0,"stats":{"Line":3}},{"line":106,"address":[],"length":0,"stats":{"Line":3}},{"line":108,"address":[],"length":0,"stats":{"Line":4}},{"line":111,"address":[],"length":0,"stats":{"Line":4}},{"line":112,"address":[],"length":0,"stats":{"Line":2}},{"line":113,"address":[],"length":0,"stats":{"Line":1}},{"line":115,"address":[],"length":0,"stats":{"Line":2}},{"line":116,"address":[],"length":0,"stats":{"Line":3}},{"line":117,"address":[],"length":0,"stats":{"Line":8}},{"line":119,"address":[],"length":0,"stats":{"Line":4}},{"line":120,"address":[],"length":0,"stats":{"Line":4}},{"line":121,"address":[],"length":0,"stats":{"Line":4}},{"line":122,"address":[],"length":0,"stats":{"Line":4}},{"line":123,"address":[],"length":0,"stats":{"Line":6}},{"line":124,"address":[],"length":0,"stats":{"Line":4}},{"line":125,"address":[],"length":0,"stats":{"Line":4}},{"line":126,"address":[],"length":0,"stats":{"Line":2}},{"line":129,"address":[],"length":0,"stats":{"Line":2}},{"line":132,"address":[],"length":0,"stats":{"Line":2}},{"line":135,"address":[],"length":0,"stats":{"Line":4}},{"line":136,"address":[],"length":0,"stats":{"Line":4}},{"line":138,"address":[],"length":0,"stats":{"Line":4}},{"line":141,"address":[],"length":0,"stats":{"Line":6}},{"line":142,"address":[],"length":0,"stats":{"Line":2}},{"line":143,"address":[],"length":0,"stats":{"Line":1}},{"line":145,"address":[],"length":0,"stats":{"Line":8}},{"line":146,"address":[],"length":0,"stats":{"Line":9}},{"line":147,"address":[],"length":0,"stats":{"Line":15}},{"line":148,"address":[],"length":0,"stats":{"Line":9}},{"line":149,"address":[],"length":0,"stats":{"Line":15}},{"line":150,"address":[],"length":0,"stats":{"Line":9}},{"line":151,"address":[],"length":0,"stats":{"Line":16}},{"line":152,"address":[],"length":0,"stats":{"Line":1}},{"line":154,"address":[],"length":0,"stats":{"Line":9}},{"line":155,"address":[],"length":0,"stats":{"Line":2}},{"line":157,"address":[],"length":0,"stats":{"Line":2}},{"line":159,"address":[],"length":0,"stats":{"Line":6}},{"line":163,"address":[],"length":0,"stats":{"Line":3}},{"line":166,"address":[],"length":0,"stats":{"Line":3}},{"line":167,"address":[],"length":0,"stats":{"Line":3}},{"line":169,"address":[],"length":0,"stats":{"Line":4}},{"line":172,"address":[],"length":0,"stats":{"Line":4}},{"line":173,"address":[],"length":0,"stats":{"Line":2}},{"line":174,"address":[],"length":0,"stats":{"Line":1}},{"line":176,"address":[],"length":0,"stats":{"Line":2}},{"line":177,"address":[],"length":0,"stats":{"Line":3}},{"line":178,"address":[],"length":0,"stats":{"Line":6}},{"line":180,"address":[],"length":0,"stats":{"Line":4}},{"line":181,"address":[],"length":0,"stats":{"Line":6}},{"line":182,"address":[],"length":0,"stats":{"Line":4}},{"line":183,"address":[],"length":0,"stats":{"Line":6}},{"line":184,"address":[],"length":0,"stats":{"Line":4}},{"line":185,"address":[],"length":0,"stats":{"Line":4}},{"line":186,"address":[],"length":0,"stats":{"Line":2}},{"line":189,"address":[],"length":0,"stats":{"Line":2}},{"line":192,"address":[],"length":0,"stats":{"Line":2}},{"line":195,"address":[],"length":0,"stats":{"Line":3}},{"line":200,"address":[],"length":0,"stats":{"Line":3}},{"line":202,"address":[],"length":0,"stats":{"Line":2}},{"line":203,"address":[],"length":0,"stats":{"Line":1}},{"line":204,"address":[],"length":0,"stats":{"Line":1}},{"line":206,"address":[],"length":0,"stats":{"Line":4}},{"line":209,"address":[],"length":0,"stats":{"Line":4}},{"line":210,"address":[],"length":0,"stats":{"Line":4}},{"line":211,"address":[],"length":0,"stats":{"Line":4}},{"line":212,"address":[],"length":0,"stats":{"Line":8}},{"line":213,"address":[],"length":0,"stats":{"Line":2}},{"line":214,"address":[],"length":0,"stats":{"Line":2}},{"line":215,"address":[],"length":0,"stats":{"Line":4}},{"line":217,"address":[],"length":0,"stats":{"Line":2}},{"line":218,"address":[],"length":0,"stats":{"Line":2}},{"line":219,"address":[],"length":0,"stats":{"Line":4}},{"line":222,"address":[],"length":0,"stats":{"Line":2}},{"line":223,"address":[],"length":0,"stats":{"Line":2}},{"line":224,"address":[],"length":0,"stats":{"Line":2}},{"line":225,"address":[],"length":0,"stats":{"Line":3}},{"line":226,"address":[],"length":0,"stats":{"Line":7}},{"line":227,"address":[],"length":0,"stats":{"Line":4}},{"line":228,"address":[],"length":0,"stats":{"Line":4}},{"line":229,"address":[],"length":0,"stats":{"Line":3}},{"line":230,"address":[],"length":0,"stats":{"Line":4}},{"line":231,"address":[],"length":0,"stats":{"Line":4}},{"line":232,"address":[],"length":0,"stats":{"Line":4}},{"line":233,"address":[],"length":0,"stats":{"Line":2}},{"line":236,"address":[],"length":0,"stats":{"Line":2}},{"line":240,"address":[],"length":0,"stats":{"Line":3}},{"line":243,"address":[],"length":0,"stats":{"Line":4}},{"line":244,"address":[],"length":0,"stats":{"Line":4}},{"line":246,"address":[],"length":0,"stats":{"Line":4}},{"line":249,"address":[],"length":0,"stats":{"Line":6}},{"line":250,"address":[],"length":0,"stats":{"Line":2}},{"line":251,"address":[],"length":0,"stats":{"Line":1}},{"line":253,"address":[],"length":0,"stats":{"Line":4}},{"line":254,"address":[],"length":0,"stats":{"Line":6}},{"line":255,"address":[],"length":0,"stats":{"Line":12}},{"line":257,"address":[],"length":0,"stats":{"Line":10}},{"line":258,"address":[],"length":0,"stats":{"Line":8}},{"line":259,"address":[],"length":0,"stats":{"Line":5}},{"line":260,"address":[],"length":0,"stats":{"Line":4}},{"line":261,"address":[],"length":0,"stats":{"Line":3}},{"line":262,"address":[],"length":0,"stats":{"Line":1}},{"line":264,"address":[],"length":0,"stats":{"Line":12}},{"line":265,"address":[],"length":0,"stats":{"Line":12}},{"line":266,"address":[],"length":0,"stats":{"Line":24}},{"line":267,"address":[],"length":0,"stats":{"Line":12}},{"line":268,"address":[],"length":0,"stats":{"Line":12}},{"line":271,"address":[],"length":0,"stats":{"Line":4}},{"line":274,"address":[],"length":0,"stats":{"Line":3}},{"line":277,"address":[],"length":0,"stats":{"Line":5}},{"line":278,"address":[],"length":0,"stats":{"Line":5}},{"line":280,"address":[],"length":0,"stats":{"Line":4}},{"line":283,"address":[],"length":0,"stats":{"Line":8}},{"line":284,"address":[],"length":0,"stats":{"Line":2}},{"line":285,"address":[],"length":0,"stats":{"Line":1}},{"line":287,"address":[],"length":0,"stats":{"Line":6}},{"line":288,"address":[],"length":0,"stats":{"Line":9}},{"line":289,"address":[],"length":0,"stats":{"Line":15}},{"line":291,"address":[],"length":0,"stats":{"Line":9}},{"line":292,"address":[],"length":0,"stats":{"Line":6}},{"line":293,"address":[],"length":0,"stats":{"Line":4}},{"line":294,"address":[],"length":0,"stats":{"Line":3}},{"line":295,"address":[],"length":0,"stats":{"Line":1}},{"line":297,"address":[],"length":0,"stats":{"Line":9}},{"line":298,"address":[],"length":0,"stats":{"Line":18}},{"line":299,"address":[],"length":0,"stats":{"Line":9}},{"line":300,"address":[],"length":0,"stats":{"Line":9}},{"line":303,"address":[],"length":0,"stats":{"Line":6}},{"line":306,"address":[],"length":0,"stats":{"Line":4}},{"line":309,"address":[],"length":0,"stats":{"Line":3}},{"line":310,"address":[],"length":0,"stats":{"Line":3}},{"line":312,"address":[],"length":0,"stats":{"Line":4}},{"line":315,"address":[],"length":0,"stats":{"Line":4}},{"line":316,"address":[],"length":0,"stats":{"Line":2}},{"line":317,"address":[],"length":0,"stats":{"Line":1}},{"line":319,"address":[],"length":0,"stats":{"Line":2}},{"line":320,"address":[],"length":0,"stats":{"Line":3}},{"line":321,"address":[],"length":0,"stats":{"Line":5}},{"line":323,"address":[],"length":0,"stats":{"Line":4}},{"line":324,"address":[],"length":0,"stats":{"Line":4}},{"line":325,"address":[],"length":0,"stats":{"Line":3}},{"line":326,"address":[],"length":0,"stats":{"Line":4}},{"line":327,"address":[],"length":0,"stats":{"Line":2}},{"line":330,"address":[],"length":0,"stats":{"Line":2}},{"line":333,"address":[],"length":0,"stats":{"Line":2}},{"line":336,"address":[],"length":0,"stats":{"Line":3}},{"line":337,"address":[],"length":0,"stats":{"Line":3}},{"line":339,"address":[],"length":0,"stats":{"Line":4}},{"line":342,"address":[],"length":0,"stats":{"Line":4}},{"line":343,"address":[],"length":0,"stats":{"Line":2}},{"line":344,"address":[],"length":0,"stats":{"Line":1}},{"line":346,"address":[],"length":0,"stats":{"Line":2}},{"line":347,"address":[],"length":0,"stats":{"Line":3}},{"line":348,"address":[],"length":0,"stats":{"Line":6}},{"line":350,"address":[],"length":0,"stats":{"Line":4}},{"line":351,"address":[],"length":0,"stats":{"Line":4}},{"line":352,"address":[],"length":0,"stats":{"Line":3}},{"line":353,"address":[],"length":0,"stats":{"Line":4}},{"line":354,"address":[],"length":0,"stats":{"Line":4}},{"line":355,"address":[],"length":0,"stats":{"Line":2}},{"line":358,"address":[],"length":0,"stats":{"Line":2}},{"line":361,"address":[],"length":0,"stats":{"Line":2}},{"line":364,"address":[],"length":0,"stats":{"Line":3}},{"line":365,"address":[],"length":0,"stats":{"Line":3}},{"line":367,"address":[],"length":0,"stats":{"Line":4}},{"line":370,"address":[],"length":0,"stats":{"Line":4}},{"line":371,"address":[],"length":0,"stats":{"Line":2}},{"line":372,"address":[],"length":0,"stats":{"Line":1}},{"line":374,"address":[],"length":0,"stats":{"Line":2}},{"line":375,"address":[],"length":0,"stats":{"Line":3}},{"line":376,"address":[],"length":0,"stats":{"Line":5}},{"line":378,"address":[],"length":0,"stats":{"Line":4}},{"line":379,"address":[],"length":0,"stats":{"Line":4}},{"line":380,"address":[],"length":0,"stats":{"Line":4}},{"line":381,"address":[],"length":0,"stats":{"Line":4}},{"line":382,"address":[],"length":0,"stats":{"Line":4}},{"line":385,"address":[],"length":0,"stats":{"Line":2}},{"line":388,"address":[],"length":0,"stats":{"Line":2}},{"line":414,"address":[],"length":0,"stats":{"Line":5}},{"line":415,"address":[],"length":0,"stats":{"Line":5}},{"line":417,"address":[],"length":0,"stats":{"Line":4}},{"line":420,"address":[],"length":0,"stats":{"Line":4}},{"line":421,"address":[],"length":0,"stats":{"Line":4}},{"line":424,"address":[],"length":0,"stats":{"Line":4}},{"line":425,"address":[],"length":0,"stats":{"Line":4}},{"line":430,"address":[],"length":0,"stats":{"Line":4}},{"line":432,"address":[],"length":0,"stats":{"Line":8}},{"line":433,"address":[],"length":0,"stats":{"Line":8}},{"line":434,"address":[],"length":0,"stats":{"Line":4}},{"line":435,"address":[],"length":0,"stats":{"Line":4}},{"line":436,"address":[],"length":0,"stats":{"Line":8}},{"line":438,"address":[],"length":0,"stats":{"Line":4}},{"line":439,"address":[],"length":0,"stats":{"Line":4}},{"line":440,"address":[],"length":0,"stats":{"Line":8}},{"line":442,"address":[],"length":0,"stats":{"Line":4}},{"line":444,"address":[],"length":0,"stats":{"Line":4}},{"line":445,"address":[],"length":0,"stats":{"Line":6}},{"line":446,"address":[],"length":0,"stats":{"Line":6}},{"line":447,"address":[],"length":0,"stats":{"Line":9}},{"line":448,"address":[],"length":0,"stats":{"Line":18}},{"line":449,"address":[],"length":0,"stats":{"Line":12}},{"line":450,"address":[],"length":0,"stats":{"Line":12}},{"line":451,"address":[],"length":0,"stats":{"Line":9}},{"line":452,"address":[],"length":0,"stats":{"Line":12}},{"line":453,"address":[],"length":0,"stats":{"Line":12}},{"line":454,"address":[],"length":0,"stats":{"Line":6}},{"line":457,"address":[],"length":0,"stats":{"Line":6}},{"line":460,"address":[],"length":0,"stats":{"Line":4}},{"line":461,"address":[],"length":0,"stats":{"Line":4}},{"line":462,"address":[],"length":0,"stats":{"Line":8}},{"line":464,"address":[],"length":0,"stats":{"Line":4}},{"line":465,"address":[],"length":0,"stats":{"Line":4}},{"line":466,"address":[],"length":0,"stats":{"Line":8}},{"line":468,"address":[],"length":0,"stats":{"Line":4}},{"line":470,"address":[],"length":0,"stats":{"Line":8}},{"line":471,"address":[],"length":0,"stats":{"Line":4}},{"line":472,"address":[],"length":0,"stats":{"Line":4}},{"line":473,"address":[],"length":0,"stats":{"Line":8}},{"line":475,"address":[],"length":0,"stats":{"Line":4}},{"line":476,"address":[],"length":0,"stats":{"Line":4}},{"line":477,"address":[],"length":0,"stats":{"Line":8}},{"line":480,"address":[],"length":0,"stats":{"Line":4}},{"line":481,"address":[],"length":0,"stats":{"Line":3}},{"line":482,"address":[],"length":0,"stats":{"Line":3}},{"line":483,"address":[],"length":0,"stats":{"Line":6}},{"line":485,"address":[],"length":0,"stats":{"Line":6}},{"line":486,"address":[],"length":0,"stats":{"Line":9}},{"line":487,"address":[],"length":0,"stats":{"Line":18}},{"line":488,"address":[],"length":0,"stats":{"Line":27}},{"line":489,"address":[],"length":0,"stats":{"Line":24}},{"line":490,"address":[],"length":0,"stats":{"Line":1}},{"line":492,"address":[],"length":0,"stats":{"Line":2}},{"line":496,"address":[],"length":0,"stats":{"Line":44}},{"line":498,"address":[],"length":0,"stats":{"Line":36}},{"line":499,"address":[],"length":0,"stats":{"Line":24}},{"line":500,"address":[],"length":0,"stats":{"Line":24}},{"line":501,"address":[],"length":0,"stats":{"Line":36}},{"line":502,"address":[],"length":0,"stats":{"Line":24}},{"line":505,"address":[],"length":0,"stats":{"Line":6}},{"line":509,"address":[],"length":0,"stats":{"Line":5}},{"line":526,"address":[],"length":0,"stats":{"Line":3}},{"line":527,"address":[],"length":0,"stats":{"Line":3}},{"line":529,"address":[],"length":0,"stats":{"Line":4}},{"line":532,"address":[],"length":0,"stats":{"Line":4}},{"line":533,"address":[],"length":0,"stats":{"Line":2}},{"line":534,"address":[],"length":0,"stats":{"Line":1}},{"line":536,"address":[],"length":0,"stats":{"Line":2}},{"line":537,"address":[],"length":0,"stats":{"Line":3}},{"line":538,"address":[],"length":0,"stats":{"Line":3}},{"line":540,"address":[],"length":0,"stats":{"Line":1}},{"line":541,"address":[],"length":0,"stats":{"Line":1}},{"line":542,"address":[],"length":0,"stats":{"Line":1}},{"line":543,"address":[],"length":0,"stats":{"Line":1}},{"line":544,"address":[],"length":0,"stats":{"Line":1}},{"line":547,"address":[],"length":0,"stats":{"Line":5}},{"line":548,"address":[],"length":0,"stats":{"Line":4}},{"line":549,"address":[],"length":0,"stats":{"Line":3}},{"line":550,"address":[],"length":0,"stats":{"Line":2}},{"line":552,"address":[],"length":0,"stats":{"Line":6}},{"line":553,"address":[],"length":0,"stats":{"Line":6}},{"line":554,"address":[],"length":0,"stats":{"Line":6}},{"line":555,"address":[],"length":0,"stats":{"Line":6}},{"line":556,"address":[],"length":0,"stats":{"Line":6}},{"line":557,"address":[],"length":0,"stats":{"Line":6}},{"line":558,"address":[],"length":0,"stats":{"Line":4}},{"line":561,"address":[],"length":0,"stats":{"Line":2}},{"line":564,"address":[],"length":0,"stats":{"Line":2}},{"line":567,"address":[],"length":0,"stats":{"Line":2}},{"line":568,"address":[],"length":0,"stats":{"Line":2}},{"line":570,"address":[],"length":0,"stats":{"Line":3}},{"line":571,"address":[],"length":0,"stats":{"Line":5}},{"line":572,"address":[],"length":0,"stats":{"Line":1}},{"line":573,"address":[],"length":0,"stats":{"Line":3}},{"line":574,"address":[],"length":0,"stats":{"Line":2}},{"line":575,"address":[],"length":0,"stats":{"Line":1}},{"line":576,"address":[],"length":0,"stats":{"Line":1}}],"covered":332,"coverable":332},{"path":["/","Users","chi","Projects","hu","src","data","display","tests.rs"],"content":"use super::*;\n\n#[test]\nfn time_ago_ms_just_now() {\n    let now = chrono::Utc::now().timestamp_millis();\n    assert_eq!(time_ago_ms(now), \"just now\");\n}\n\n#[test]\nfn time_ago_ms_minutes() {\n    let now = chrono::Utc::now().timestamp_millis();\n    let five_min_ago = now - 5 * 60 * 1000;\n    assert_eq!(time_ago_ms(five_min_ago), \"5m ago\");\n}\n\n#[test]\nfn time_ago_ms_hours() {\n    let now = chrono::Utc::now().timestamp_millis();\n    let two_hours_ago = now - 2 * 60 * 60 * 1000;\n    assert_eq!(time_ago_ms(two_hours_ago), \"2h ago\");\n}\n\n#[test]\nfn time_ago_ms_days() {\n    let now = chrono::Utc::now().timestamp_millis();\n    let three_days_ago = now - 3 * 24 * 60 * 60 * 1000;\n    assert_eq!(time_ago_ms(three_days_ago), \"3d ago\");\n}\n\n#[test]\nfn truncate_short() {\n    assert_eq!(truncate(\"hello\", 10), \"hello\");\n}\n\n#[test]\nfn truncate_exact() {\n    assert_eq!(truncate(\"hello\", 5), \"hello\");\n}\n\n#[test]\nfn truncate_long() {\n    assert_eq!(truncate(\"hello world\", 8), \"hello...\");\n}\n\n#[test]\nfn truncate_tiny_max() {\n    assert_eq!(truncate(\"hello\", 2), \"he\");\n}\n\n#[test]\nfn role_color_values() {\n    assert_eq!(role_color(\"user\"), Color::Cyan);\n    assert_eq!(role_color(\"assistant\"), Color::Green);\n    assert_eq!(role_color(\"system\"), Color::White);\n}\n\n#[test]\nfn status_color_values() {\n    assert_eq!(status_color(\"pending\"), Color::Yellow);\n    assert_eq!(status_color(\"in_progress\"), Color::Cyan);\n    assert_eq!(status_color(\"completed\"), Color::Green);\n    assert_eq!(status_color(\"other\"), Color::White);\n}\n\n#[test]\nfn format_tokens_small() {\n    assert_eq!(format_tokens(500), \"500\");\n}\n\n#[test]\nfn format_tokens_thousands() {\n    assert_eq!(format_tokens(1500), \"1.5K\");\n}\n\n#[test]\nfn format_tokens_millions() {\n    assert_eq!(format_tokens(2_500_000), \"2.5M\");\n}\n\n#[test]\nfn output_sync_table() {\n    let result = SyncResult {\n        history: 5,\n        messages: 100,\n        todos: 3,\n    };\n    assert!(output_sync(\u0026result, \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_sync_json() {\n    let result = SyncResult {\n        history: 0,\n        messages: 0,\n        todos: 0,\n    };\n    assert!(output_sync(\u0026result, \u0026OutputFormat::Json).is_ok());\n}\n\n#[test]\nfn output_config_table() {\n    let config = super::super::config::DataConfig::default();\n    assert!(output_config(\u0026config, \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_config_json() {\n    let config = super::super::config::DataConfig::default();\n    assert!(output_config(\u0026config, \u0026OutputFormat::Json).is_ok());\n}\n\nfn make_session() -\u003e Session {\n    Session {\n        id: \"abc-123-def\".to_string(),\n        project: \"/home/user/project\".to_string(),\n        display: Some(\"Test session\".to_string()),\n        started_at: chrono::Utc::now().timestamp_millis(),\n        message_count: 10,\n        total_cost_usd: 0.05,\n        git_branch: Some(\"main\".to_string()),\n    }\n}\n\n#[test]\nfn output_sessions_empty() {\n    assert!(output_sessions(\u0026[], \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_sessions_table() {\n    let sessions = vec![make_session()];\n    assert!(output_sessions(\u0026sessions, \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_sessions_json() {\n    let sessions = vec![make_session()];\n    assert!(output_sessions(\u0026sessions, \u0026OutputFormat::Json).is_ok());\n}\n\nfn make_message(role: \u0026str) -\u003e Message {\n    Message {\n        id: \"msg-1\".to_string(),\n        session_id: \"sess-1\".to_string(),\n        parent_id: None,\n        role: role.to_string(),\n        content: Some(\"Hello world\".to_string()),\n        model: if role == \"assistant\" {\n            Some(\"claude-sonnet-4-5-20251101\".to_string())\n        } else {\n            None\n        },\n        input_tokens: Some(100),\n        output_tokens: Some(200),\n        cost_usd: Some(0.001),\n        duration_ms: Some(500),\n        created_at: chrono::Utc::now().timestamp_millis(),\n    }\n}\n\n#[test]\nfn output_session_messages_empty() {\n    assert!(output_session_messages(\u0026[], \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_session_messages_table() {\n    let msgs = vec![make_message(\"user\"), make_message(\"assistant\")];\n    assert!(output_session_messages(\u0026msgs, \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_session_messages_json() {\n    let msgs = vec![make_message(\"user\")];\n    assert!(output_session_messages(\u0026msgs, \u0026OutputFormat::Json).is_ok());\n}\n\n#[test]\nfn output_session_messages_no_tokens() {\n    let msg = Message {\n        input_tokens: None,\n        output_tokens: None,\n        model: None,\n        ..make_message(\"user\")\n    };\n    assert!(output_session_messages(\u0026[msg], \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_search_results_empty() {\n    assert!(output_search_results(\u0026[], \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_search_results_table() {\n    let results = vec![SearchResult {\n        id: \"m1\".to_string(),\n        session_id: \"s1\".to_string(),\n        role: \"user\".to_string(),\n        content: Some(\"test query result\".to_string()),\n        model: None,\n        created_at: chrono::Utc::now().timestamp_millis(),\n        project: \"/home/user/proj\".to_string(),\n    }];\n    assert!(output_search_results(\u0026results, \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_search_results_json() {\n    assert!(output_search_results(\u0026[], \u0026OutputFormat::Json).is_ok());\n}\n\n#[test]\nfn output_stats_table() {\n    let stats = UsageStats {\n        total_sessions: 10,\n        total_messages: 100,\n        total_cost: 5.0,\n        total_input_tokens: 1_000_000,\n        total_output_tokens: 500_000,\n    };\n    let model_usage = vec![ModelUsage {\n        model: \"claude-sonnet-4-5-20251101\".to_string(),\n        count: 50,\n        cost: 3.0,\n        input_tokens: 800_000,\n        output_tokens: 400_000,\n    }];\n    assert!(output_stats(\u0026stats, \u0026model_usage, \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_stats_json() {\n    let stats = UsageStats::default();\n    assert!(output_stats(\u0026stats, \u0026[], \u0026OutputFormat::Json).is_ok());\n}\n\n#[test]\nfn output_stats_empty_models() {\n    let stats = UsageStats::default();\n    assert!(output_stats(\u0026stats, \u0026[], \u0026OutputFormat::Table).is_ok());\n}\n\nfn make_todo(status: \u0026str) -\u003e Todo {\n    Todo {\n        id: 1,\n        session_id: \"sess-1\".to_string(),\n        content: \"Fix the bug\".to_string(),\n        status: status.to_string(),\n        active_form: Some(\"Fixing bug\".to_string()),\n    }\n}\n\n#[test]\nfn output_todos_empty() {\n    assert!(output_todos(\u0026[], \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_todos_table() {\n    let todos = vec![\n        make_todo(\"pending\"),\n        make_todo(\"in_progress\"),\n        make_todo(\"completed\"),\n    ];\n    assert!(output_todos(\u0026todos, \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_todos_json() {\n    assert!(output_todos(\u0026[make_todo(\"pending\")], \u0026OutputFormat::Json).is_ok());\n}\n\n#[test]\nfn output_pending_todos_empty() {\n    assert!(output_pending_todos(\u0026[], \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_pending_todos_table() {\n    let todos = vec![TodoWithProject {\n        id: 1,\n        session_id: \"s1\".to_string(),\n        content: \"Review PR\".to_string(),\n        status: \"pending\".to_string(),\n        active_form: None,\n        project: \"/home/user/proj\".to_string(),\n    }];\n    assert!(output_pending_todos(\u0026todos, \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_pending_todos_json() {\n    assert!(output_pending_todos(\u0026[], \u0026OutputFormat::Json).is_ok());\n}\n\n#[test]\nfn output_tool_stats_empty() {\n    assert!(output_tool_stats(\u0026[], \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_tool_stats_table() {\n    let stats = vec![ToolUsageStats {\n        tool_name: \"Read\".to_string(),\n        count: 42,\n        last_used: chrono::Utc::now().timestamp_millis(),\n    }];\n    assert!(output_tool_stats(\u0026stats, \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_tool_stats_json() {\n    assert!(output_tool_stats(\u0026[], \u0026OutputFormat::Json).is_ok());\n}\n\n#[test]\nfn output_tool_detail_empty() {\n    assert!(output_tool_detail(\u0026[], \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_tool_detail_table() {\n    let detail = vec![ToolUsageDetail {\n        tool_name: \"Edit\".to_string(),\n        session_id: \"sess-1\".to_string(),\n        project: \"/home/user/proj\".to_string(),\n        created_at: chrono::Utc::now().timestamp_millis(),\n    }];\n    assert!(output_tool_detail(\u0026detail, \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_tool_detail_json() {\n    assert!(output_tool_detail(\u0026[], \u0026OutputFormat::Json).is_ok());\n}\n\n#[test]\nfn output_errors_empty() {\n    assert!(output_errors(\u0026[], \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_errors_table() {\n    let errors = vec![DebugError {\n        file: \"debug.log\".to_string(),\n        line: 10,\n        content: \"Error: something failed\".to_string(),\n        timestamp: chrono::Utc::now().timestamp(),\n    }];\n    assert!(output_errors(\u0026errors, \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_errors_json() {\n    assert!(output_errors(\u0026[], \u0026OutputFormat::Json).is_ok());\n}\n\nfn make_pricing_data() -\u003e PricingData {\n    PricingData {\n        subscription: \"max20x\".to_string(),\n        subscription_price: 200.0,\n        billing_cycle: pricing::calculate_billing_cycle(6, chrono::Utc::now().timestamp_millis()),\n        period_usage: PeriodUsage {\n            messages: 100,\n            input_tokens: 500_000,\n            output_tokens: 200_000,\n        },\n        model_costs: vec![ModelUsageWithCost {\n            model: \"claude-sonnet-4-5-20251101\".to_string(),\n            input_tokens: 500_000,\n            output_tokens: 200_000,\n            cost: 4.5,\n        }],\n        total_api_cost: 4.5,\n        projected_cost: 9.0,\n        break_even: pricing::calculate_break_even(200.0),\n        value_comparisons: pricing::get_value_comparison(4.5),\n    }\n}\n\n#[test]\nfn output_pricing_table() {\n    assert!(output_pricing(\u0026make_pricing_data(), \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_pricing_json() {\n    assert!(output_pricing(\u0026make_pricing_data(), \u0026OutputFormat::Json).is_ok());\n}\n\n#[test]\nfn output_pricing_empty_models() {\n    let mut data = make_pricing_data();\n    data.model_costs = vec![];\n    data.value_comparisons = vec![];\n    assert!(output_pricing(\u0026data, \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_branches_empty() {\n    assert!(output_branches(\u0026[], \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_branches_table() {\n    let branches = vec![\n        BranchWithPr {\n            branch: BranchStats {\n                git_branch: \"main\".to_string(),\n                session_count: 5,\n                session_ids: \"s1,s2,s3\".to_string(),\n                last_activity: chrono::Utc::now().timestamp_millis(),\n                total_messages: 50,\n                total_cost: 1.5,\n                project: \"/home/user/proj\".to_string(),\n            },\n            pr: Some(PrInfo {\n                number: 42,\n                title: \"Add feature\".to_string(),\n                state: \"OPEN\".to_string(),\n                url: \"https://github.com/org/repo/pull/42\".to_string(),\n            }),\n        },\n        BranchWithPr {\n            branch: BranchStats {\n                git_branch: \"feature/x\".to_string(),\n                session_count: 1,\n                session_ids: \"s4\".to_string(),\n                last_activity: chrono::Utc::now().timestamp_millis(),\n                total_messages: 10,\n                total_cost: 0.3,\n                project: \"/home/user/proj\".to_string(),\n            },\n            pr: None,\n        },\n    ];\n    assert!(output_branches(\u0026branches, \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_branches_json() {\n    assert!(output_branches(\u0026[], \u0026OutputFormat::Json).is_ok());\n}\n\n#[test]\nfn build_model_costs_empty() {\n    let costs = build_model_costs(\u0026[]);\n    assert!(costs.is_empty());\n}\n\n#[test]\nfn build_model_costs_calculates() {\n    let usage = vec![ModelTokenUsage {\n        model: \"claude-sonnet-4-5-20251101\".to_string(),\n        input_tokens: 1_000_000,\n        output_tokens: 1_000_000,\n    }];\n    let costs = build_model_costs(\u0026usage);\n    assert_eq!(costs.len(), 1);\n    assert!((costs[0].cost - 18.0).abs() \u003c 0.01);\n}\n\n#[test]\nfn output_pricing_negative_savings() {\n    let mut data = make_pricing_data();\n    data.total_api_cost = 5.0;\n    data.value_comparisons = vec![ValueComparison {\n        service: \"Test\".to_string(),\n        plan: \"Premium\".to_string(),\n        price: 200.0,\n        savings: -195.0,\n        savings_percent: -3900.0,\n    }];\n    assert!(output_pricing(\u0026data, \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_todos_unknown_status() {\n    let todo = Todo {\n        id: 1,\n        session_id: \"s1\".to_string(),\n        content: \"test\".to_string(),\n        status: \"unknown_status\".to_string(),\n        active_form: None,\n    };\n    assert!(output_todos(\u0026[todo], \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_pending_todos_unknown_status() {\n    let todo = TodoWithProject {\n        id: 1,\n        session_id: \"s1\".to_string(),\n        content: \"task\".to_string(),\n        status: \"weird_status\".to_string(),\n        active_form: None,\n        project: \"/proj\".to_string(),\n    };\n    assert!(output_pending_todos(\u0026[todo], \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_pricing_positive_savings() {\n    let mut data = make_pricing_data();\n    data.total_api_cost = 500.0;\n    data.value_comparisons = vec![ValueComparison {\n        service: \"Test\".to_string(),\n        plan: \"Basic\".to_string(),\n        price: 20.0,\n        savings: 480.0,\n        savings_percent: 96.0,\n    }];\n    assert!(output_pricing(\u0026data, \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_pending_in_progress() {\n    let todo = TodoWithProject {\n        id: 1,\n        session_id: \"s1\".to_string(),\n        content: \"task\".to_string(),\n        status: \"in_progress\".to_string(),\n        active_form: None,\n        project: \"/proj\".to_string(),\n    };\n    assert!(output_pending_todos(\u0026[todo], \u0026OutputFormat::Table).is_ok());\n}\n","traces":[{"line":112,"address":[],"length":0,"stats":{"Line":2}},{"line":114,"address":[],"length":0,"stats":{"Line":6}},{"line":115,"address":[],"length":0,"stats":{"Line":6}},{"line":116,"address":[],"length":0,"stats":{"Line":4}},{"line":117,"address":[],"length":0,"stats":{"Line":6}},{"line":120,"address":[],"length":0,"stats":{"Line":2}},{"line":141,"address":[],"length":0,"stats":{"Line":4}},{"line":143,"address":[],"length":0,"stats":{"Line":8}},{"line":144,"address":[],"length":0,"stats":{"Line":8}},{"line":146,"address":[],"length":0,"stats":{"Line":8}},{"line":147,"address":[],"length":0,"stats":{"Line":4}},{"line":148,"address":[],"length":0,"stats":{"Line":4}},{"line":153,"address":[],"length":0,"stats":{"Line":4}},{"line":154,"address":[],"length":0,"stats":{"Line":4}},{"line":155,"address":[],"length":0,"stats":{"Line":4}},{"line":156,"address":[],"length":0,"stats":{"Line":4}},{"line":157,"address":[],"length":0,"stats":{"Line":8}},{"line":244,"address":[],"length":0,"stats":{"Line":4}},{"line":247,"address":[],"length":0,"stats":{"Line":12}},{"line":248,"address":[],"length":0,"stats":{"Line":12}},{"line":249,"address":[],"length":0,"stats":{"Line":12}},{"line":250,"address":[],"length":0,"stats":{"Line":4}},{"line":359,"address":[],"length":0,"stats":{"Line":5}},{"line":361,"address":[],"length":0,"stats":{"Line":15}},{"line":363,"address":[],"length":0,"stats":{"Line":20}},{"line":364,"address":[],"length":0,"stats":{"Line":10}},{"line":369,"address":[],"length":0,"stats":{"Line":15}},{"line":377,"address":[],"length":0,"stats":{"Line":5}},{"line":378,"address":[],"length":0,"stats":{"Line":5}}],"covered":29,"coverable":29},{"path":["/","Users","chi","Projects","hu","src","data","mod.rs"],"content":"mod cli;\nmod config;\nmod db;\nmod display;\nmod paths;\nmod pricing;\nmod queries;\nmod schema;\nmod sync;\nmod types;\n\npub use cli::DataCommand;\n\nuse anyhow::{bail, Result};\nuse types::OutputFormat;\n\n#[cfg(not(tarpaulin_include))]\npub async fn run_command(cmd: DataCommand) -\u003e Result\u003c()\u003e {\n    match cmd {\n        DataCommand::Sync { force, quiet } =\u003e cmd_sync(force, quiet),\n        DataCommand::Config { json } =\u003e cmd_config(json),\n        DataCommand::Session { cmd } =\u003e cmd_session(cmd),\n        DataCommand::Stats { json, today } =\u003e cmd_stats(json, today),\n        DataCommand::Todos { cmd } =\u003e cmd_todos(cmd),\n        DataCommand::Search { query, limit, json } =\u003e cmd_search(\u0026query, limit, json),\n        DataCommand::Tools { tool, json } =\u003e cmd_tools(tool.as_deref(), json),\n        DataCommand::Errors { recent, json } =\u003e cmd_errors(recent, json),\n        DataCommand::Pricing {\n            subscription,\n            billing_day,\n            json,\n        } =\u003e cmd_pricing(\u0026subscription, billing_day, json),\n        DataCommand::Branches {\n            branch,\n            limit,\n            json,\n        } =\u003e cmd_branches(branch.as_deref(), limit, json).await,\n    }\n}\n\nfn get_format(json: bool) -\u003e OutputFormat {\n    if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    }\n}\n\n#[cfg(not(tarpaulin_include))]\nfn open_db() -\u003e Result\u003cdb::SqliteStore\u003e {\n    let cfg = config::load_data_config()?;\n    let store = db::SqliteStore::open_initialized(\u0026cfg.database)?;\n    Ok(store)\n}\n\n#[cfg(not(tarpaulin_include))]\nfn ensure_synced(store: \u0026db::SqliteStore) -\u003e Result\u003c()\u003e {\n    let cfg = config::load_data_config()?;\n    sync::sync_if_needed(\u0026store.conn, \u0026cfg.claude_dir, cfg.auto_sync_interval)?;\n    Ok(())\n}\n\n#[cfg(not(tarpaulin_include))]\nfn cmd_sync(force: bool, quiet: bool) -\u003e Result\u003c()\u003e {\n    let cfg = config::load_data_config()?;\n    let store = db::SqliteStore::open_initialized(\u0026cfg.database)?;\n\n    let result = if force {\n        sync::sync_all(\u0026store.conn, \u0026cfg.claude_dir)?\n    } else {\n        let synced = sync::sync_if_needed(\u0026store.conn, \u0026cfg.claude_dir, cfg.auto_sync_interval)?;\n        if !synced {\n            if !quiet {\n                println!(\"Already up to date. Use -f to force.\");\n            }\n            return Ok(());\n        }\n        sync::sync_all(\u0026store.conn, \u0026cfg.claude_dir)?\n    };\n\n    if !quiet {\n        display::output_sync(\u0026result, \u0026OutputFormat::Table)?;\n    }\n    Ok(())\n}\n\n#[cfg(not(tarpaulin_include))]\nfn cmd_config(json: bool) -\u003e Result\u003c()\u003e {\n    let cfg = config::load_data_config()?;\n    display::output_config(\u0026cfg, \u0026get_format(json))\n}\n\n#[cfg(not(tarpaulin_include))]\nfn cmd_session(cmd: cli::SessionCommand) -\u003e Result\u003c()\u003e {\n    let store = open_db()?;\n    ensure_synced(\u0026store)?;\n\n    match cmd {\n        cli::SessionCommand::List {\n            project,\n            limit,\n            json,\n        } =\u003e {\n            let sessions = queries::get_sessions(\u0026store.conn, project.as_deref(), limit)?;\n            display::output_sessions(\u0026sessions, \u0026get_format(json))\n        }\n        cli::SessionCommand::Read { id, json } =\u003e {\n            let session = queries::get_session_by_prefix(\u0026store.conn, \u0026id)?\n                .or_else(|| queries::get_session_by_id(\u0026store.conn, \u0026id).ok().flatten());\n\n            match session {\n                Some(s) =\u003e {\n                    let messages = queries::get_messages_by_session(\u0026store.conn, \u0026s.id)?;\n                    display::output_session_messages(\u0026messages, \u0026get_format(json))\n                }\n                None =\u003e bail!(\"Session not found: {id}\"),\n            }\n        }\n        cli::SessionCommand::Current { json } =\u003e {\n            let session_id = std::env::var(\"SESSION_ID\").unwrap_or_default();\n            if session_id.is_empty() {\n                bail!(\"SESSION_ID environment variable not set\");\n            }\n            let session = queries::get_session_by_id(\u0026store.conn, \u0026session_id)?;\n            match session {\n                Some(s) =\u003e {\n                    let messages = queries::get_messages_by_session(\u0026store.conn, \u0026s.id)?;\n                    display::output_session_messages(\u0026messages, \u0026get_format(json))\n                }\n                None =\u003e bail!(\"Current session not found: {session_id}\"),\n            }\n        }\n    }\n}\n\n#[cfg(not(tarpaulin_include))]\nfn cmd_stats(json: bool, today: bool) -\u003e Result\u003c()\u003e {\n    let store = open_db()?;\n    ensure_synced(\u0026store)?;\n\n    let since = if today {\n        Some(start_of_today_ms())\n    } else {\n        None\n    };\n\n    let stats = queries::get_usage_stats(\u0026store.conn, since)?;\n    let model_usage = queries::get_model_usage(\u0026store.conn, since)?;\n    display::output_stats(\u0026stats, \u0026model_usage, \u0026get_format(json))\n}\n\n#[cfg(not(tarpaulin_include))]\nfn cmd_todos(cmd: cli::TodosCommand) -\u003e Result\u003c()\u003e {\n    let store = open_db()?;\n    ensure_synced(\u0026store)?;\n\n    match cmd {\n        cli::TodosCommand::List { status, json } =\u003e {\n            let todos = queries::get_todos(\u0026store.conn, status.as_deref())?;\n            display::output_todos(\u0026todos, \u0026get_format(json))\n        }\n        cli::TodosCommand::Pending { project, json } =\u003e {\n            let todos = queries::get_pending_todos(\u0026store.conn, project.as_deref())?;\n            display::output_pending_todos(\u0026todos, \u0026get_format(json))\n        }\n    }\n}\n\n#[cfg(not(tarpaulin_include))]\nfn cmd_search(query: \u0026str, limit: i64, json: bool) -\u003e Result\u003c()\u003e {\n    let store = open_db()?;\n    ensure_synced(\u0026store)?;\n\n    let results = queries::search_messages(\u0026store.conn, query, limit)?;\n    display::output_search_results(\u0026results, \u0026get_format(json))\n}\n\n#[cfg(not(tarpaulin_include))]\nfn cmd_tools(tool: Option\u003c\u0026str\u003e, json: bool) -\u003e Result\u003c()\u003e {\n    let store = open_db()?;\n    ensure_synced(\u0026store)?;\n    let format = get_format(json);\n\n    match tool {\n        Some(name) =\u003e {\n            let detail = queries::get_tool_detail(\u0026store.conn, name)?;\n            display::output_tool_detail(\u0026detail, \u0026format)\n        }\n        None =\u003e {\n            let stats = queries::get_tool_stats(\u0026store.conn)?;\n            display::output_tool_stats(\u0026stats, \u0026format)\n        }\n    }\n}\n\n#[cfg(not(tarpaulin_include))]\nfn cmd_errors(recent_days: u32, json: bool) -\u003e Result\u003c()\u003e {\n    let cfg = config::load_data_config()?;\n    let errors = scan_debug_errors(\u0026cfg.claude_dir, recent_days)?;\n    display::output_errors(\u0026errors, \u0026get_format(json))\n}\n\nfn scan_debug_errors(\n    claude_dir: \u0026std::path::Path,\n    recent_days: u32,\n) -\u003e Result\u003cVec\u003ctypes::DebugError\u003e\u003e {\n    let dir = paths::debug_dir(claude_dir);\n    if !dir.exists() {\n        return Ok(vec![]);\n    }\n\n    let cutoff = chrono::Utc::now().timestamp() - (recent_days as i64 * 86400);\n    let error_patterns =\n        regex::Regex::new(r\"(?i)(error|failed|exception|warning|ENOENT|EACCES|EPERM)\")?;\n\n    let mut errors = Vec::new();\n    let mut seen = std::collections::HashSet::new();\n\n    for entry in std::fs::read_dir(\u0026dir)? {\n        let entry = entry?;\n        let path = entry.path();\n        if path.extension().and_then(|e| e.to_str()) != Some(\"txt\") {\n            continue;\n        }\n\n        let metadata = entry.metadata()?;\n        let modified = metadata\n            .modified()?\n            .duration_since(std::time::UNIX_EPOCH)?\n            .as_secs() as i64;\n\n        if modified \u003c cutoff {\n            continue;\n        }\n\n        let content = std::fs::read_to_string(\u0026path)?;\n        let filename = path\n            .file_name()\n            .unwrap_or_default()\n            .to_string_lossy()\n            .to_string();\n\n        for (i, line) in content.lines().enumerate() {\n            if error_patterns.is_match(line) \u0026\u0026 seen.insert(line.to_string()) {\n                errors.push(types::DebugError {\n                    file: filename.clone(),\n                    line: i + 1,\n                    content: line.to_string(),\n                    timestamp: modified,\n                });\n            }\n        }\n    }\n\n    errors.truncate(50);\n    Ok(errors)\n}\n\n#[cfg(not(tarpaulin_include))]\nfn cmd_pricing(subscription: \u0026str, billing_day: u32, json: bool) -\u003e Result\u003c()\u003e {\n    let store = open_db()?;\n    ensure_synced(\u0026store)?;\n\n    let now = chrono::Utc::now().timestamp_millis();\n    let cycle = pricing::calculate_billing_cycle(billing_day, now);\n    let sub_price = pricing::get_subscription_price(subscription);\n\n    let period_usage = queries::get_period_usage(\u0026store.conn, cycle.start_ms)?;\n    let model_usage = queries::get_period_model_usage(\u0026store.conn, cycle.start_ms)?;\n    let model_costs = display::build_model_costs(\u0026model_usage);\n    let total_api_cost: f64 = model_costs.iter().map(|m| m.cost).sum();\n    let projected =\n        pricing::project_cycle_cost(total_api_cost, cycle.days_elapsed, cycle.total_days);\n    let break_even = pricing::calculate_break_even(sub_price);\n    let comparisons = pricing::get_value_comparison(total_api_cost);\n\n    let data = display::PricingData {\n        subscription: subscription.to_string(),\n        subscription_price: sub_price,\n        billing_cycle: cycle,\n        period_usage,\n        model_costs,\n        total_api_cost,\n        projected_cost: projected,\n        break_even,\n        value_comparisons: comparisons,\n    };\n\n    display::output_pricing(\u0026data, \u0026get_format(json))\n}\n\n#[cfg(not(tarpaulin_include))]\nasync fn cmd_branches(branch: Option\u003c\u0026str\u003e, limit: i64, json: bool) -\u003e Result\u003c()\u003e {\n    let store = open_db()?;\n    ensure_synced(\u0026store)?;\n\n    let stats = queries::get_branch_stats(\u0026store.conn, branch, limit)?;\n    let mut branches = Vec::new();\n\n    for b in stats {\n        let pr = fetch_pr_info(\u0026b.git_branch).await;\n        branches.push(display::BranchWithPr { branch: b, pr });\n    }\n\n    display::output_branches(\u0026branches, \u0026get_format(json))\n}\n\n#[cfg(not(tarpaulin_include))]\nasync fn fetch_pr_info(branch: \u0026str) -\u003e Option\u003cdisplay::PrInfo\u003e {\n    let output: std::process::Output = tokio::process::Command::new(\"gh\")\n        .args([\n            \"pr\",\n            \"list\",\n            \"--head\",\n            branch,\n            \"--json\",\n            \"number,title,state,url\",\n            \"--limit\",\n            \"1\",\n        ])\n        .output()\n        .await\n        .ok()?;\n\n    if !output.status.success() {\n        return None;\n    }\n\n    let prs: Vec\u003cserde_json::Value\u003e = serde_json::from_slice(\u0026output.stdout).ok()?;\n    let pr = prs.first()?;\n\n    Some(display::PrInfo {\n        number: pr.get(\"number\")?.as_i64()?,\n        title: pr.get(\"title\")?.as_str()?.to_string(),\n        state: pr.get(\"state\")?.as_str()?.to_string(),\n        url: pr.get(\"url\")?.as_str()?.to_string(),\n    })\n}\n\nfn start_of_today_ms() -\u003e i64 {\n    let now = chrono::Utc::now();\n    now.date_naive()\n        .and_hms_opt(0, 0, 0)\n        .unwrap()\n        .and_utc()\n        .timestamp_millis()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn get_format_json() {\n        assert!(matches!(get_format(true), OutputFormat::Json));\n    }\n\n    #[test]\n    fn get_format_table() {\n        assert!(matches!(get_format(false), OutputFormat::Table));\n    }\n\n    #[test]\n    fn start_of_today_is_past() {\n        let ms = start_of_today_ms();\n        let now = chrono::Utc::now().timestamp_millis();\n        assert!(ms \u003c= now);\n        assert!(ms \u003e now - 86_400_000); // Within last 24h\n    }\n\n    #[test]\n    fn scan_debug_errors_missing_dir() {\n        let errors = scan_debug_errors(std::path::Path::new(\"/nonexistent\"), 7).unwrap();\n        assert!(errors.is_empty());\n    }\n\n    #[test]\n    fn scan_debug_errors_with_fixture() {\n        let tmp = std::env::temp_dir().join(\"hu-test-debug-errors\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n        let debug = tmp.join(\"debug\");\n        std::fs::create_dir_all(\u0026debug).unwrap();\n\n        std::fs::write(\n            debug.join(\"test.txt\"),\n            \"normal line\\nError: something broke\\nFailed to connect\\nanother normal line\\n\",\n        )\n        .unwrap();\n\n        let errors = scan_debug_errors(\u0026tmp, 7).unwrap();\n        assert_eq!(errors.len(), 2);\n        assert!(errors[0].content.contains(\"Error\"));\n        assert!(errors[1].content.contains(\"Failed\"));\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn scan_debug_errors_deduplication() {\n        let tmp = std::env::temp_dir().join(\"hu-test-debug-dedup\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n        let debug = tmp.join(\"debug\");\n        std::fs::create_dir_all(\u0026debug).unwrap();\n\n        std::fs::write(debug.join(\"a.txt\"), \"Error: same message\\n\").unwrap();\n        std::fs::write(debug.join(\"b.txt\"), \"Error: same message\\n\").unwrap();\n\n        let errors = scan_debug_errors(\u0026tmp, 7).unwrap();\n        assert_eq!(errors.len(), 1); // Deduplicated\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn scan_debug_errors_skips_non_txt() {\n        let tmp = std::env::temp_dir().join(\"hu-test-debug-skip\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n        let debug = tmp.join(\"debug\");\n        std::fs::create_dir_all(\u0026debug).unwrap();\n\n        std::fs::write(debug.join(\"test.log\"), \"Error: in log file\\n\").unwrap();\n\n        let errors = scan_debug_errors(\u0026tmp, 7).unwrap();\n        assert!(errors.is_empty()); // .log not .txt\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn scan_debug_errors_skips_old_files() {\n        let tmp = std::env::temp_dir().join(\"hu-test-debug-old\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n        let debug = tmp.join(\"debug\");\n        std::fs::create_dir_all(\u0026debug).unwrap();\n\n        let file_path = debug.join(\"old.txt\");\n        std::fs::write(\u0026file_path, \"Error: old error\\n\").unwrap();\n\n        // Set file modification time to 30 days ago\n        let old_time = std::time::SystemTime::now() - std::time::Duration::from_secs(30 * 86400);\n        let file = std::fs::File::options()\n            .write(true)\n            .open(\u0026file_path)\n            .unwrap();\n        file.set_times(std::fs::FileTimes::new().set_modified(old_time))\n            .unwrap();\n\n        // Only look at last 7 days - old file should be skipped\n        let errors = scan_debug_errors(\u0026tmp, 7).unwrap();\n        assert!(errors.is_empty());\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn scan_debug_errors_max_50() {\n        let tmp = std::env::temp_dir().join(\"hu-test-debug-max\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n        let debug = tmp.join(\"debug\");\n        std::fs::create_dir_all(\u0026debug).unwrap();\n\n        let mut content = String::new();\n        for i in 0..60 {\n            content.push_str(\u0026format!(\"Error: unique error {i}\\n\"));\n        }\n        std::fs::write(debug.join(\"many.txt\"), \u0026content).unwrap();\n\n        let errors = scan_debug_errors(\u0026tmp, 7).unwrap();\n        assert_eq!(errors.len(), 50); // Capped at 50\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n}\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":1}},{"line":45,"address":[],"length":0,"stats":{"Line":1}},{"line":203,"address":[],"length":0,"stats":{"Line":6}},{"line":207,"address":[],"length":0,"stats":{"Line":18}},{"line":208,"address":[],"length":0,"stats":{"Line":6}},{"line":209,"address":[],"length":0,"stats":{"Line":1}},{"line":212,"address":[],"length":0,"stats":{"Line":15}},{"line":213,"address":[],"length":0,"stats":{"Line":5}},{"line":214,"address":[],"length":0,"stats":{"Line":10}},{"line":216,"address":[],"length":0,"stats":{"Line":10}},{"line":217,"address":[],"length":0,"stats":{"Line":10}},{"line":219,"address":[],"length":0,"stats":{"Line":16}},{"line":220,"address":[],"length":0,"stats":{"Line":12}},{"line":221,"address":[],"length":0,"stats":{"Line":18}},{"line":222,"address":[],"length":0,"stats":{"Line":30}},{"line":223,"address":[],"length":0,"stats":{"Line":1}},{"line":226,"address":[],"length":0,"stats":{"Line":15}},{"line":227,"address":[],"length":0,"stats":{"Line":10}},{"line":228,"address":[],"length":0,"stats":{"Line":5}},{"line":229,"address":[],"length":0,"stats":{"Line":5}},{"line":230,"address":[],"length":0,"stats":{"Line":5}},{"line":232,"address":[],"length":0,"stats":{"Line":5}},{"line":233,"address":[],"length":0,"stats":{"Line":1}},{"line":236,"address":[],"length":0,"stats":{"Line":12}},{"line":237,"address":[],"length":0,"stats":{"Line":8}},{"line":243,"address":[],"length":0,"stats":{"Line":140}},{"line":244,"address":[],"length":0,"stats":{"Line":517}},{"line":245,"address":[],"length":0,"stats":{"Line":189}},{"line":246,"address":[],"length":0,"stats":{"Line":189}},{"line":247,"address":[],"length":0,"stats":{"Line":126}},{"line":248,"address":[],"length":0,"stats":{"Line":126}},{"line":249,"address":[],"length":0,"stats":{"Line":63}},{"line":255,"address":[],"length":0,"stats":{"Line":10}},{"line":256,"address":[],"length":0,"stats":{"Line":5}},{"line":340,"address":[],"length":0,"stats":{"Line":1}},{"line":341,"address":[],"length":0,"stats":{"Line":2}},{"line":342,"address":[],"length":0,"stats":{"Line":2}}],"covered":39,"coverable":39},{"path":["/","Users","chi","Projects","hu","src","data","paths.rs"],"content":"use anyhow::Result;\nuse serde::de::DeserializeOwned;\nuse std::path::{Path, PathBuf};\n\n#[allow(dead_code)]\npub fn encode_project_path(path: \u0026str) -\u003e String {\n    // Order matters: replace \"/.\" first (double dash), then \"/\" (single dash)\n    path.replace(\"/.\", \"--\").replace('/', \"-\")\n}\n\npub fn decode_project_path(encoded: \u0026str) -\u003e String {\n    // Order matters: replace \"--\" first (was \"/.\"), then \"-\" (was \"/\")\n    encoded.replace(\"--\", \"/.\").replace('-', \"/\")\n}\n\npub fn history_path(claude_dir: \u0026Path) -\u003e PathBuf {\n    claude_dir.join(\"history.jsonl\")\n}\n\npub fn projects_dir(claude_dir: \u0026Path) -\u003e PathBuf {\n    claude_dir.join(\"projects\")\n}\n\npub fn todos_dir(claude_dir: \u0026Path) -\u003e PathBuf {\n    claude_dir.join(\"todos\")\n}\n\npub fn debug_dir(claude_dir: \u0026Path) -\u003e PathBuf {\n    claude_dir.join(\"debug\")\n}\n\npub fn parse_jsonl\u003cT: DeserializeOwned\u003e(content: \u0026str) -\u003e Vec\u003cT\u003e {\n    content\n        .lines()\n        .filter(|line| !line.trim().is_empty())\n        .filter_map(|line| serde_json::from_str(line).ok())\n        .collect()\n}\n\npub fn list_project_dirs(claude_dir: \u0026Path) -\u003e Result\u003cVec\u003cProjectDir\u003e\u003e {\n    let dir = projects_dir(claude_dir);\n    if !dir.exists() {\n        return Ok(vec![]);\n    }\n    let mut projects = Vec::new();\n    for entry in std::fs::read_dir(\u0026dir)? {\n        let entry = entry?;\n        if entry.file_type()?.is_dir() {\n            let name = entry.file_name().to_string_lossy().to_string();\n            projects.push(ProjectDir {\n                path: decode_project_path(\u0026name),\n                encoded: name,\n                dir: entry.path(),\n            });\n        }\n    }\n    projects.sort_by(|a, b| a.encoded.cmp(\u0026b.encoded));\n    Ok(projects)\n}\n\n#[derive(Debug, Clone)]\npub struct ProjectDir {\n    pub encoded: String,\n    pub path: String,\n    pub dir: PathBuf,\n}\n\npub fn list_session_files(project_dir: \u0026Path) -\u003e Result\u003cVec\u003cSessionFile\u003e\u003e {\n    if !project_dir.exists() {\n        return Ok(vec![]);\n    }\n    let mut sessions = Vec::new();\n    for entry in std::fs::read_dir(project_dir)? {\n        let entry = entry?;\n        let name = entry.file_name().to_string_lossy().to_string();\n        if name.ends_with(\".jsonl\") {\n            let session_id = name.trim_end_matches(\".jsonl\").to_string();\n            sessions.push(SessionFile {\n                session_id,\n                path: entry.path(),\n            });\n        }\n    }\n    sessions.sort_by(|a, b| a.session_id.cmp(\u0026b.session_id));\n    Ok(sessions)\n}\n\n#[derive(Debug, Clone)]\npub struct SessionFile {\n    pub session_id: String,\n    pub path: PathBuf,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn encode_basic_path() {\n        assert_eq!(\n            encode_project_path(\"/Users/chi/project\"),\n            \"-Users-chi-project\"\n        );\n    }\n\n    #[test]\n    fn encode_dotfile_path() {\n        assert_eq!(\n            encode_project_path(\"/Users/chi/.claude\"),\n            \"-Users-chi--claude\"\n        );\n    }\n\n    #[test]\n    fn decode_basic_path() {\n        assert_eq!(\n            decode_project_path(\"-Users-chi-project\"),\n            \"/Users/chi/project\"\n        );\n    }\n\n    #[test]\n    fn decode_dotfile_path() {\n        assert_eq!(\n            decode_project_path(\"-Users-chi--claude\"),\n            \"/Users/chi/.claude\"\n        );\n    }\n\n    #[test]\n    fn encode_decode_roundtrip() {\n        let paths = vec![\n            \"/Users/chi/Projects/hu\",\n            \"/Users/chi/.claude\",\n            \"/home/user/.config/test\",\n            \"/tmp/a\",\n        ];\n        for path in paths {\n            let encoded = encode_project_path(path);\n            let decoded = decode_project_path(\u0026encoded);\n            assert_eq!(decoded, path, \"roundtrip failed for {path}\");\n        }\n    }\n\n    #[test]\n    fn encode_root() {\n        assert_eq!(encode_project_path(\"/\"), \"-\");\n    }\n\n    #[test]\n    fn decode_single_dash() {\n        assert_eq!(decode_project_path(\"-\"), \"/\");\n    }\n\n    #[test]\n    fn history_path_construction() {\n        let p = history_path(Path::new(\"/home/user/.claude\"));\n        assert_eq!(p, PathBuf::from(\"/home/user/.claude/history.jsonl\"));\n    }\n\n    #[test]\n    fn projects_dir_construction() {\n        let p = projects_dir(Path::new(\"/home/user/.claude\"));\n        assert_eq!(p, PathBuf::from(\"/home/user/.claude/projects\"));\n    }\n\n    #[test]\n    fn todos_dir_construction() {\n        let p = todos_dir(Path::new(\"/home/user/.claude\"));\n        assert_eq!(p, PathBuf::from(\"/home/user/.claude/todos\"));\n    }\n\n    #[test]\n    fn debug_dir_construction() {\n        let p = debug_dir(Path::new(\"/home/user/.claude\"));\n        assert_eq!(p, PathBuf::from(\"/home/user/.claude/debug\"));\n    }\n\n    #[test]\n    fn parse_jsonl_valid() {\n        let content = r#\"{\"name\":\"a\",\"value\":1}\n{\"name\":\"b\",\"value\":2}\n\"#;\n        #[derive(serde::Deserialize)]\n        struct Item {\n            name: String,\n            value: i32,\n        }\n        let items: Vec\u003cItem\u003e = parse_jsonl(content);\n        assert_eq!(items.len(), 2);\n        assert_eq!(items[0].name, \"a\");\n        assert_eq!(items[1].value, 2);\n    }\n\n    #[test]\n    fn parse_jsonl_skip_malformed() {\n        let content = r#\"{\"valid\":true}\nnot json at all\n{\"also_valid\":true}\n\"#;\n        #[derive(serde::Deserialize)]\n        #[allow(dead_code)]\n        struct Item {\n            valid: Option\u003cbool\u003e,\n            also_valid: Option\u003cbool\u003e,\n        }\n        let items: Vec\u003cItem\u003e = parse_jsonl(content);\n        assert_eq!(items.len(), 2);\n    }\n\n    #[test]\n    fn parse_jsonl_empty() {\n        let items: Vec\u003cserde_json::Value\u003e = parse_jsonl(\"\");\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn parse_jsonl_blank_lines() {\n        let content = \"\\n\\n{\\\"x\\\":1}\\n\\n{\\\"x\\\":2}\\n\\n\";\n        #[derive(serde::Deserialize)]\n        #[allow(dead_code)]\n        struct Item {\n            x: i32,\n        }\n        let items: Vec\u003cItem\u003e = parse_jsonl(content);\n        assert_eq!(items.len(), 2);\n    }\n\n    #[test]\n    fn list_project_dirs_missing() {\n        let dirs = list_project_dirs(Path::new(\"/nonexistent/path\")).unwrap();\n        assert!(dirs.is_empty());\n    }\n\n    #[test]\n    fn list_session_files_missing() {\n        let files = list_session_files(Path::new(\"/nonexistent/path\")).unwrap();\n        assert!(files.is_empty());\n    }\n\n    #[test]\n    fn list_project_dirs_real() {\n        let tmp = std::env::temp_dir().join(\"hu-test-projects\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n        std::fs::create_dir_all(tmp.join(\"projects\").join(\"-Users-chi-proj\")).unwrap();\n        std::fs::create_dir_all(tmp.join(\"projects\").join(\"-Users-chi--hidden\")).unwrap();\n\n        let dirs = list_project_dirs(\u0026tmp).unwrap();\n        assert_eq!(dirs.len(), 2);\n        // Sorted by encoded name\n        assert_eq!(dirs[0].encoded, \"-Users-chi--hidden\");\n        assert_eq!(dirs[0].path, \"/Users/chi/.hidden\");\n        assert_eq!(dirs[1].encoded, \"-Users-chi-proj\");\n        assert_eq!(dirs[1].path, \"/Users/chi/proj\");\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn list_session_files_real() {\n        let tmp = std::env::temp_dir().join(\"hu-test-sessions\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n        std::fs::create_dir_all(\u0026tmp).unwrap();\n        std::fs::write(tmp.join(\"abc-123.jsonl\"), \"\").unwrap();\n        std::fs::write(tmp.join(\"def-456.jsonl\"), \"\").unwrap();\n        std::fs::write(tmp.join(\"notes.txt\"), \"\").unwrap();\n\n        let files = list_session_files(\u0026tmp).unwrap();\n        assert_eq!(files.len(), 2);\n        assert_eq!(files[0].session_id, \"abc-123\");\n        assert_eq!(files[1].session_id, \"def-456\");\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":7}},{"line":8,"address":[],"length":0,"stats":{"Line":21}},{"line":11,"address":[],"length":0,"stats":{"Line":15}},{"line":13,"address":[],"length":0,"stats":{"Line":45}},{"line":16,"address":[],"length":0,"stats":{"Line":7}},{"line":17,"address":[],"length":0,"stats":{"Line":14}},{"line":20,"address":[],"length":0,"stats":{"Line":12}},{"line":21,"address":[],"length":0,"stats":{"Line":24}},{"line":24,"address":[],"length":0,"stats":{"Line":9}},{"line":25,"address":[],"length":0,"stats":{"Line":18}},{"line":28,"address":[],"length":0,"stats":{"Line":7}},{"line":29,"address":[],"length":0,"stats":{"Line":14}},{"line":32,"address":[],"length":0,"stats":{"Line":13}},{"line":33,"address":[],"length":0,"stats":{"Line":13}},{"line":35,"address":[],"length":0,"stats":{"Line":71}},{"line":36,"address":[],"length":0,"stats":{"Line":88}},{"line":40,"address":[],"length":0,"stats":{"Line":11}},{"line":41,"address":[],"length":0,"stats":{"Line":33}},{"line":42,"address":[],"length":0,"stats":{"Line":11}},{"line":43,"address":[],"length":0,"stats":{"Line":3}},{"line":45,"address":[],"length":0,"stats":{"Line":16}},{"line":46,"address":[],"length":0,"stats":{"Line":24}},{"line":47,"address":[],"length":0,"stats":{"Line":16}},{"line":48,"address":[],"length":0,"stats":{"Line":32}},{"line":49,"address":[],"length":0,"stats":{"Line":32}},{"line":50,"address":[],"length":0,"stats":{"Line":24}},{"line":51,"address":[],"length":0,"stats":{"Line":24}},{"line":52,"address":[],"length":0,"stats":{"Line":16}},{"line":53,"address":[],"length":0,"stats":{"Line":8}},{"line":57,"address":[],"length":0,"stats":{"Line":19}},{"line":58,"address":[],"length":0,"stats":{"Line":8}},{"line":68,"address":[],"length":0,"stats":{"Line":8}},{"line":69,"address":[],"length":0,"stats":{"Line":8}},{"line":70,"address":[],"length":0,"stats":{"Line":1}},{"line":72,"address":[],"length":0,"stats":{"Line":14}},{"line":73,"address":[],"length":0,"stats":{"Line":23}},{"line":74,"address":[],"length":0,"stats":{"Line":18}},{"line":75,"address":[],"length":0,"stats":{"Line":27}},{"line":76,"address":[],"length":0,"stats":{"Line":17}},{"line":77,"address":[],"length":0,"stats":{"Line":32}},{"line":78,"address":[],"length":0,"stats":{"Line":24}},{"line":79,"address":[],"length":0,"stats":{"Line":16}},{"line":80,"address":[],"length":0,"stats":{"Line":8}},{"line":84,"address":[],"length":0,"stats":{"Line":17}},{"line":85,"address":[],"length":0,"stats":{"Line":7}}],"covered":45,"coverable":45},{"path":["/","Users","chi","Projects","hu","src","data","pricing.rs"],"content":"use serde::Serialize;\n\n#[derive(Debug, Clone, Serialize)]\npub struct ModelPricing {\n    pub name: \u0026'static str,\n    pub display_name: \u0026'static str,\n    pub input_per_mtok: f64,\n    pub output_per_mtok: f64,\n    pub cache_write_per_mtok: Option\u003cf64\u003e,\n    pub cache_read_per_mtok: Option\u003cf64\u003e,\n}\n\nconst MODEL_PRICING: \u0026[(\u0026str, ModelPricing)] = \u0026[\n    (\n        \"claude-opus-4-5-20251101\",\n        ModelPricing {\n            name: \"claude-opus-4-5-20251101\",\n            display_name: \"Opus 4.5\",\n            input_per_mtok: 5.0,\n            output_per_mtok: 25.0,\n            cache_write_per_mtok: Some(6.25),\n            cache_read_per_mtok: Some(0.5),\n        },\n    ),\n    (\n        \"claude-sonnet-4-5-20251101\",\n        ModelPricing {\n            name: \"claude-sonnet-4-5-20251101\",\n            display_name: \"Sonnet 4.5\",\n            input_per_mtok: 3.0,\n            output_per_mtok: 15.0,\n            cache_write_per_mtok: Some(3.75),\n            cache_read_per_mtok: Some(0.3),\n        },\n    ),\n    (\n        \"claude-haiku-4-5-20251001\",\n        ModelPricing {\n            name: \"claude-haiku-4-5-20251001\",\n            display_name: \"Haiku 4.5\",\n            input_per_mtok: 1.0,\n            output_per_mtok: 5.0,\n            cache_write_per_mtok: Some(1.25),\n            cache_read_per_mtok: Some(0.1),\n        },\n    ),\n    (\n        \"claude-opus-4-20250514\",\n        ModelPricing {\n            name: \"claude-opus-4-20250514\",\n            display_name: \"Opus 4\",\n            input_per_mtok: 15.0,\n            output_per_mtok: 75.0,\n            cache_write_per_mtok: None,\n            cache_read_per_mtok: None,\n        },\n    ),\n    (\n        \"claude-sonnet-4-20250514\",\n        ModelPricing {\n            name: \"claude-sonnet-4-20250514\",\n            display_name: \"Sonnet 4\",\n            input_per_mtok: 3.0,\n            output_per_mtok: 15.0,\n            cache_write_per_mtok: None,\n            cache_read_per_mtok: None,\n        },\n    ),\n    (\n        \"claude-3-5-sonnet-20241022\",\n        ModelPricing {\n            name: \"claude-3-5-sonnet-20241022\",\n            display_name: \"Sonnet 3.5\",\n            input_per_mtok: 3.0,\n            output_per_mtok: 15.0,\n            cache_write_per_mtok: None,\n            cache_read_per_mtok: None,\n        },\n    ),\n    (\n        \"claude-3-haiku-20240307\",\n        ModelPricing {\n            name: \"claude-3-haiku-20240307\",\n            display_name: \"Haiku 3\",\n            input_per_mtok: 0.25,\n            output_per_mtok: 1.25,\n            cache_write_per_mtok: None,\n            cache_read_per_mtok: None,\n        },\n    ),\n];\n\nconst DEFAULT_PRICING: ModelPricing = ModelPricing {\n    name: \"unknown\",\n    display_name: \"Unknown Model\",\n    input_per_mtok: 3.0,\n    output_per_mtok: 15.0,\n    cache_write_per_mtok: None,\n    cache_read_per_mtok: None,\n};\n\npub fn get_model_pricing(model_name: Option\u003c\u0026str\u003e) -\u003e ModelPricing {\n    let name = match model_name {\n        Some(n) =\u003e n,\n        None =\u003e return DEFAULT_PRICING,\n    };\n\n    // Exact match\n    for (key, pricing) in MODEL_PRICING {\n        if *key == name {\n            return pricing.clone();\n        }\n    }\n\n    // Partial match: compare first 3 dash-separated segments\n    let name_lower = name.to_lowercase();\n    let name_prefix = first_n_segments(\u0026name_lower, 3);\n    for (key, pricing) in MODEL_PRICING {\n        let key_prefix = first_n_segments(key, 3);\n        if name_prefix == key_prefix {\n            return pricing.clone();\n        }\n    }\n\n    // Family match\n    if name_lower.contains(\"opus-4-5\") || name_lower.contains(\"opus-4.5\") {\n        return MODEL_PRICING[0].1.clone(); // Opus 4.5\n    }\n    if name_lower.contains(\"sonnet-4-5\") || name_lower.contains(\"sonnet-4.5\") {\n        return MODEL_PRICING[1].1.clone(); // Sonnet 4.5\n    }\n    if name_lower.contains(\"haiku-4-5\") || name_lower.contains(\"haiku-4.5\") {\n        return MODEL_PRICING[2].1.clone(); // Haiku 4.5\n    }\n    if name_lower.contains(\"opus\") {\n        return MODEL_PRICING[3].1.clone(); // Opus 4\n    }\n    if name_lower.contains(\"sonnet\") {\n        return MODEL_PRICING[4].1.clone(); // Sonnet 4\n    }\n    if name_lower.contains(\"haiku\") {\n        return MODEL_PRICING[6].1.clone(); // Haiku 3\n    }\n\n    DEFAULT_PRICING\n}\n\nfn first_n_segments(s: \u0026str, n: usize) -\u003e String {\n    s.split('-').take(n).collect::\u003cVec\u003c_\u003e\u003e().join(\"-\")\n}\n\npub fn calculate_cost(model_name: Option\u003c\u0026str\u003e, input_tokens: i64, output_tokens: i64) -\u003e f64 {\n    let pricing = get_model_pricing(model_name);\n    let input_cost = (input_tokens as f64 / 1_000_000.0) * pricing.input_per_mtok;\n    let output_cost = (output_tokens as f64 / 1_000_000.0) * pricing.output_per_mtok;\n    input_cost + output_cost\n}\n\npub fn format_cost(cost: f64) -\u003e String {\n    if cost \u003c 0.01 {\n        format!(\"${:.4}\", cost)\n    } else if cost \u003c 1.0 {\n        format!(\"${:.3}\", cost)\n    } else {\n        format!(\"${:.2}\", cost)\n    }\n}\n\n#[allow(dead_code)]\npub fn get_all_pricing() -\u003e Vec\u003cModelPricing\u003e {\n    MODEL_PRICING.iter().map(|(_, p)| p.clone()).collect()\n}\n\n// --- Subscription \u0026 Billing ---\n\nfn get_subscription_prices() -\u003e \u0026'static [(\u0026'static str, f64)] {\n    \u0026[\n        (\"free\", 0.0),\n        (\"pro\", 20.0),\n        (\"max5x\", 100.0),\n        (\"max20x\", 200.0),\n    ]\n}\n\npub fn get_subscription_price(tier: \u0026str) -\u003e f64 {\n    let normalized = tier.to_lowercase().replace(['-', ' '], \"\");\n    for (key, price) in get_subscription_prices() {\n        if *key == normalized {\n            return *price;\n        }\n    }\n    200.0\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct BillingCycle {\n    pub start_ms: i64,\n    pub end_ms: i64,\n    pub billing_day: u32,\n    pub total_days: i64,\n    pub days_elapsed: i64,\n    pub days_remaining: i64,\n}\n\npub fn calculate_billing_cycle(billing_day: u32, now_ms: i64) -\u003e BillingCycle {\n    use chrono::{Datelike, NaiveDate, TimeZone, Utc};\n\n    let now = Utc.timestamp_millis_opt(now_ms).unwrap();\n    let today = now.date_naive();\n\n    let (start_date, end_date) = if today.day() \u003c billing_day {\n        // Cycle started last month\n        let start = prev_month_date(today, billing_day);\n        let end = NaiveDate::from_ymd_opt(today.year(), today.month(), billing_day)\n            .unwrap_or_else(|| last_day_of_month(today.year(), today.month()));\n        (start, end)\n    } else {\n        // Cycle started this month\n        let start = NaiveDate::from_ymd_opt(today.year(), today.month(), billing_day)\n            .unwrap_or_else(|| last_day_of_month(today.year(), today.month()));\n        let end = next_month_date(today, billing_day);\n        (start, end)\n    };\n\n    let start_ms = start_date\n        .and_hms_opt(0, 0, 0)\n        .unwrap()\n        .and_utc()\n        .timestamp_millis();\n    let end_ms = end_date\n        .and_hms_opt(0, 0, 0)\n        .unwrap()\n        .and_utc()\n        .timestamp_millis();\n\n    let total_days = (end_ms - start_ms) / 86_400_000;\n    let days_elapsed = (now_ms - start_ms) / 86_400_000;\n    let days_remaining = total_days - days_elapsed;\n\n    BillingCycle {\n        start_ms,\n        end_ms,\n        billing_day,\n        total_days,\n        days_elapsed,\n        days_remaining,\n    }\n}\n\nfn prev_month_date(today: chrono::NaiveDate, day: u32) -\u003e chrono::NaiveDate {\n    use chrono::{Datelike, NaiveDate};\n    let (year, month) = if today.month() == 1 {\n        (today.year() - 1, 12)\n    } else {\n        (today.year(), today.month() - 1)\n    };\n    NaiveDate::from_ymd_opt(year, month, day).unwrap_or_else(|| last_day_of_month(year, month))\n}\n\nfn next_month_date(today: chrono::NaiveDate, day: u32) -\u003e chrono::NaiveDate {\n    use chrono::{Datelike, NaiveDate};\n    let (year, month) = if today.month() == 12 {\n        (today.year() + 1, 1)\n    } else {\n        (today.year(), today.month() + 1)\n    };\n    NaiveDate::from_ymd_opt(year, month, day).unwrap_or_else(|| last_day_of_month(year, month))\n}\n\nfn last_day_of_month(year: i32, month: u32) -\u003e chrono::NaiveDate {\n    use chrono::NaiveDate;\n    let (next_year, next_month) = if month == 12 {\n        (year + 1, 1)\n    } else {\n        (year, month + 1)\n    };\n    NaiveDate::from_ymd_opt(next_year, next_month, 1)\n        .unwrap()\n        .pred_opt()\n        .unwrap()\n}\n\n// --- Break-even analysis ---\n\n#[derive(Debug, Clone, Serialize)]\npub struct BreakEvenAnalysis {\n    pub price: f64,\n    pub break_even_output_tokens: i64,\n    pub break_even_input_tokens: i64,\n}\n\npub fn calculate_break_even(subscription_price: f64) -\u003e BreakEvenAnalysis {\n    // Uses Opus 4.5 pricing: $5/MTok input, $25/MTok output\n    let break_even_output_tokens = ((subscription_price / 25.0) * 1_000_000.0).round() as i64;\n    let break_even_input_tokens = ((subscription_price / 5.0) * 1_000_000.0).round() as i64;\n    BreakEvenAnalysis {\n        price: subscription_price,\n        break_even_output_tokens,\n        break_even_input_tokens,\n    }\n}\n\n#[allow(dead_code)]\npub fn get_max_tier_break_even() -\u003e (BreakEvenAnalysis, BreakEvenAnalysis) {\n    (calculate_break_even(100.0), calculate_break_even(200.0))\n}\n\npub fn project_cycle_cost(current_cost: f64, days_elapsed: i64, total_days: i64) -\u003e f64 {\n    if days_elapsed \u003c= 0 {\n        return 0.0;\n    }\n    (current_cost / days_elapsed as f64) * total_days as f64\n}\n\n// --- Competitor pricing ---\n\n#[derive(Debug, Clone, Serialize)]\npub struct CompetitorPricing {\n    pub name: \u0026'static str,\n    pub url: \u0026'static str,\n    pub plans: Vec\u003cCompetitorPlan\u003e,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct CompetitorPlan {\n    pub name: \u0026'static str,\n    pub price: f64,\n    pub plan_type: \u0026'static str,\n    pub limits: Option\u003c\u0026'static str\u003e,\n}\n\npub fn get_competitor_pricing() -\u003e Vec\u003cCompetitorPricing\u003e {\n    vec![\n        CompetitorPricing {\n            name: \"Claude (Anthropic)\",\n            url: \"https://claude.com/pricing\",\n            plans: vec![\n                CompetitorPlan {\n                    name: \"Free\",\n                    price: 0.0,\n                    plan_type: \"individual\",\n                    limits: Some(\"Basic usage\"),\n                },\n                CompetitorPlan {\n                    name: \"Pro\",\n                    price: 20.0,\n                    plan_type: \"individual\",\n                    limits: Some(\"More usage, Claude Code access\"),\n                },\n                CompetitorPlan {\n                    name: \"Max 5x\",\n                    price: 100.0,\n                    plan_type: \"individual\",\n                    limits: Some(\"5x Pro usage\"),\n                },\n                CompetitorPlan {\n                    name: \"Max 20x\",\n                    price: 200.0,\n                    plan_type: \"individual\",\n                    limits: Some(\"20x Pro usage\"),\n                },\n                CompetitorPlan {\n                    name: \"Team Standard\",\n                    price: 30.0,\n                    plan_type: \"team\",\n                    limits: Some(\"Per seat, min 5 members\"),\n                },\n                CompetitorPlan {\n                    name: \"Team Premium\",\n                    price: 150.0,\n                    plan_type: \"team\",\n                    limits: Some(\"Per seat, includes Claude Code\"),\n                },\n            ],\n        },\n        CompetitorPricing {\n            name: \"GitHub Copilot\",\n            url: \"https://github.com/features/copilot\",\n            plans: vec![\n                CompetitorPlan {\n                    name: \"Free\",\n                    price: 0.0,\n                    plan_type: \"individual\",\n                    limits: Some(\"2,000 completions/mo, 50 chat/mo\"),\n                },\n                CompetitorPlan {\n                    name: \"Pro\",\n                    price: 10.0,\n                    plan_type: \"individual\",\n                    limits: Some(\"Unlimited completions, 300 premium req/mo\"),\n                },\n                CompetitorPlan {\n                    name: \"Pro+\",\n                    price: 39.0,\n                    plan_type: \"individual\",\n                    limits: Some(\"1,500 premium req/mo\"),\n                },\n                CompetitorPlan {\n                    name: \"Business\",\n                    price: 19.0,\n                    plan_type: \"team\",\n                    limits: Some(\"300 premium req/mo per user\"),\n                },\n                CompetitorPlan {\n                    name: \"Enterprise\",\n                    price: 39.0,\n                    plan_type: \"enterprise\",\n                    limits: Some(\"1,000 premium req/mo per user\"),\n                },\n            ],\n        },\n        CompetitorPricing {\n            name: \"Cursor\",\n            url: \"https://cursor.com/pricing\",\n            plans: vec![\n                CompetitorPlan {\n                    name: \"Hobby\",\n                    price: 0.0,\n                    plan_type: \"individual\",\n                    limits: Some(\"Limited Agent \u0026 Tab completions\"),\n                },\n                CompetitorPlan {\n                    name: \"Pro\",\n                    price: 20.0,\n                    plan_type: \"individual\",\n                    limits: Some(\"Extended Agent, unlimited Tabs\"),\n                },\n                CompetitorPlan {\n                    name: \"Pro+\",\n                    price: 60.0,\n                    plan_type: \"individual\",\n                    limits: Some(\"3x usage on all models\"),\n                },\n                CompetitorPlan {\n                    name: \"Ultra\",\n                    price: 200.0,\n                    plan_type: \"individual\",\n                    limits: Some(\"20x usage, priority features\"),\n                },\n                CompetitorPlan {\n                    name: \"Teams\",\n                    price: 40.0,\n                    plan_type: \"team\",\n                    limits: Some(\"Shared chats, SSO, RBAC\"),\n                },\n            ],\n        },\n        CompetitorPricing {\n            name: \"Windsurf\",\n            url: \"https://windsurf.com/pricing\",\n            plans: vec![\n                CompetitorPlan {\n                    name: \"Free\",\n                    price: 0.0,\n                    plan_type: \"individual\",\n                    limits: Some(\"25 prompt credits/mo\"),\n                },\n                CompetitorPlan {\n                    name: \"Pro\",\n                    price: 15.0,\n                    plan_type: \"individual\",\n                    limits: Some(\"500 credits/mo\"),\n                },\n                CompetitorPlan {\n                    name: \"Teams\",\n                    price: 30.0,\n                    plan_type: \"team\",\n                    limits: Some(\"500 credits/user/mo\"),\n                },\n            ],\n        },\n        CompetitorPricing {\n            name: \"Tabnine\",\n            url: \"https://tabnine.com/pricing\",\n            plans: vec![CompetitorPlan {\n                name: \"Agentic Platform\",\n                price: 59.0,\n                plan_type: \"individual\",\n                limits: Some(\"Unlimited with own LLM\"),\n            }],\n        },\n        CompetitorPricing {\n            name: \"Amazon Q Developer\",\n            url: \"https://aws.amazon.com/q/developer/pricing/\",\n            plans: vec![\n                CompetitorPlan {\n                    name: \"Free\",\n                    price: 0.0,\n                    plan_type: \"individual\",\n                    limits: Some(\"50 agentic req/mo\"),\n                },\n                CompetitorPlan {\n                    name: \"Pro\",\n                    price: 19.0,\n                    plan_type: \"team\",\n                    limits: Some(\"4,000 lines/mo pooled\"),\n                },\n            ],\n        },\n    ]\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct ValueComparison {\n    pub service: String,\n    pub plan: String,\n    pub price: f64,\n    pub savings: f64,\n    pub savings_percent: f64,\n}\n\npub fn get_value_comparison(api_equivalent_cost: f64) -\u003e Vec\u003cValueComparison\u003e {\n    let mut comparisons = Vec::new();\n\n    for competitor in get_competitor_pricing() {\n        for plan in \u0026competitor.plans {\n            if plan.plan_type != \"individual\" || plan.price \u003c= 0.0 {\n                continue;\n            }\n            let savings = api_equivalent_cost - plan.price;\n            let savings_percent = if api_equivalent_cost \u003e 0.0 {\n                (savings / api_equivalent_cost) * 100.0\n            } else {\n                0.0\n            };\n            comparisons.push(ValueComparison {\n                service: competitor.name.to_string(),\n                plan: plan.name.to_string(),\n                price: plan.price,\n                savings,\n                savings_percent,\n            });\n        }\n    }\n\n    comparisons.sort_by(|a, b| a.price.partial_cmp(\u0026b.price).unwrap());\n    comparisons\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use chrono::Datelike;\n\n    #[test]\n    fn exact_match_opus_45() {\n        let p = get_model_pricing(Some(\"claude-opus-4-5-20251101\"));\n        assert_eq!(p.display_name, \"Opus 4.5\");\n        assert_eq!(p.input_per_mtok, 5.0);\n        assert_eq!(p.output_per_mtok, 25.0);\n    }\n\n    #[test]\n    fn exact_match_sonnet_45() {\n        let p = get_model_pricing(Some(\"claude-sonnet-4-5-20251101\"));\n        assert_eq!(p.display_name, \"Sonnet 4.5\");\n    }\n\n    #[test]\n    fn exact_match_haiku_45() {\n        let p = get_model_pricing(Some(\"claude-haiku-4-5-20251001\"));\n        assert_eq!(p.display_name, \"Haiku 4.5\");\n    }\n\n    #[test]\n    fn exact_match_opus_4() {\n        let p = get_model_pricing(Some(\"claude-opus-4-20250514\"));\n        assert_eq!(p.display_name, \"Opus 4\");\n        assert_eq!(p.input_per_mtok, 15.0);\n    }\n\n    #[test]\n    fn exact_match_sonnet_35() {\n        let p = get_model_pricing(Some(\"claude-3-5-sonnet-20241022\"));\n        assert_eq!(p.display_name, \"Sonnet 3.5\");\n    }\n\n    #[test]\n    fn exact_match_haiku_3() {\n        let p = get_model_pricing(Some(\"claude-3-haiku-20240307\"));\n        assert_eq!(p.display_name, \"Haiku 3\");\n        assert_eq!(p.input_per_mtok, 0.25);\n    }\n\n    #[test]\n    fn family_match_opus() {\n        let p = get_model_pricing(Some(\"some-opus-model\"));\n        assert_eq!(p.display_name, \"Opus 4\");\n    }\n\n    #[test]\n    fn family_match_sonnet() {\n        let p = get_model_pricing(Some(\"some-sonnet-model\"));\n        assert_eq!(p.display_name, \"Sonnet 4\");\n    }\n\n    #[test]\n    fn family_match_haiku() {\n        let p = get_model_pricing(Some(\"some-haiku-model\"));\n        assert_eq!(p.display_name, \"Haiku 3\");\n    }\n\n    #[test]\n    fn family_match_opus_45_variant() {\n        let p = get_model_pricing(Some(\"claude-opus-4-5-extended\"));\n        assert_eq!(p.display_name, \"Opus 4.5\");\n    }\n\n    #[test]\n    fn family_match_sonnet_45_variant() {\n        let p = get_model_pricing(Some(\"claude-sonnet-4.5-new\"));\n        assert_eq!(p.display_name, \"Sonnet 4.5\");\n    }\n\n    #[test]\n    fn none_returns_default() {\n        let p = get_model_pricing(None);\n        assert_eq!(p.display_name, \"Unknown Model\");\n        assert_eq!(p.input_per_mtok, 3.0);\n    }\n\n    #[test]\n    fn unknown_model_returns_default() {\n        let p = get_model_pricing(Some(\"totally-unknown-model\"));\n        assert_eq!(p.display_name, \"Unknown Model\");\n    }\n\n    #[test]\n    fn calculate_cost_sonnet() {\n        let cost = calculate_cost(Some(\"claude-sonnet-4-5-20251101\"), 1_000_000, 1_000_000);\n        // $3/MTok input + $15/MTok output = $18\n        assert!((cost - 18.0).abs() \u003c 0.001);\n    }\n\n    #[test]\n    fn calculate_cost_zero_tokens() {\n        let cost = calculate_cost(Some(\"claude-opus-4-5-20251101\"), 0, 0);\n        assert_eq!(cost, 0.0);\n    }\n\n    #[test]\n    fn calculate_cost_unknown_model() {\n        let cost = calculate_cost(None, 1_000_000, 1_000_000);\n        // Default: $3 + $15 = $18\n        assert!((cost - 18.0).abs() \u003c 0.001);\n    }\n\n    #[test]\n    fn format_cost_small() {\n        assert_eq!(format_cost(0.001), \"$0.0010\");\n        assert_eq!(format_cost(0.0001), \"$0.0001\");\n    }\n\n    #[test]\n    fn format_cost_medium() {\n        assert_eq!(format_cost(0.123), \"$0.123\");\n        assert_eq!(format_cost(0.5), \"$0.500\");\n    }\n\n    #[test]\n    fn format_cost_large() {\n        assert_eq!(format_cost(1.5), \"$1.50\");\n        assert_eq!(format_cost(100.0), \"$100.00\");\n    }\n\n    #[test]\n    fn format_cost_zero() {\n        assert_eq!(format_cost(0.0), \"$0.0000\");\n    }\n\n    #[test]\n    fn get_all_pricing_returns_all() {\n        let all = get_all_pricing();\n        assert_eq!(all.len(), 7);\n    }\n\n    #[test]\n    fn subscription_price_known() {\n        assert_eq!(get_subscription_price(\"free\"), 0.0);\n        assert_eq!(get_subscription_price(\"pro\"), 20.0);\n        assert_eq!(get_subscription_price(\"max5x\"), 100.0);\n        assert_eq!(get_subscription_price(\"max20x\"), 200.0);\n    }\n\n    #[test]\n    fn subscription_price_normalized() {\n        assert_eq!(get_subscription_price(\"Max-5x\"), 100.0);\n        assert_eq!(get_subscription_price(\"MAX 20X\"), 200.0);\n        assert_eq!(get_subscription_price(\"Pro\"), 20.0);\n    }\n\n    #[test]\n    fn subscription_price_unknown() {\n        assert_eq!(get_subscription_price(\"enterprise\"), 200.0);\n    }\n\n    #[test]\n    fn billing_cycle_mid_month() {\n        // Jan 15, billing day 6 -\u003e cycle started Jan 6\n        let jan15 = chrono::NaiveDate::from_ymd_opt(2024, 1, 15)\n            .unwrap()\n            .and_hms_opt(12, 0, 0)\n            .unwrap()\n            .and_utc()\n            .timestamp_millis();\n        let cycle = calculate_billing_cycle(6, jan15);\n        assert_eq!(cycle.billing_day, 6);\n        assert!(cycle.days_elapsed \u003e 0);\n        assert!(cycle.days_remaining \u003e= 0);\n        assert_eq!(cycle.total_days, cycle.days_elapsed + cycle.days_remaining);\n    }\n\n    #[test]\n    fn billing_cycle_before_billing_day() {\n        // Jan 3, billing day 6 -\u003e cycle started Dec 6\n        let jan3 = chrono::NaiveDate::from_ymd_opt(2024, 1, 3)\n            .unwrap()\n            .and_hms_opt(12, 0, 0)\n            .unwrap()\n            .and_utc()\n            .timestamp_millis();\n        let cycle = calculate_billing_cycle(6, jan3);\n        assert!(cycle.total_days \u003e= 28);\n        assert!(cycle.days_elapsed \u003e 0);\n    }\n\n    #[test]\n    fn billing_cycle_on_billing_day() {\n        // Jan 6, billing day 6 -\u003e cycle started Jan 6\n        let jan6 = chrono::NaiveDate::from_ymd_opt(2024, 1, 6)\n            .unwrap()\n            .and_hms_opt(12, 0, 0)\n            .unwrap()\n            .and_utc()\n            .timestamp_millis();\n        let cycle = calculate_billing_cycle(6, jan6);\n        assert_eq!(cycle.days_elapsed, 0);\n    }\n\n    #[test]\n    fn break_even_max5x() {\n        let be = calculate_break_even(100.0);\n        assert_eq!(be.price, 100.0);\n        assert_eq!(be.break_even_output_tokens, 4_000_000);\n        assert_eq!(be.break_even_input_tokens, 20_000_000);\n    }\n\n    #[test]\n    fn break_even_max20x() {\n        let be = calculate_break_even(200.0);\n        assert_eq!(be.break_even_output_tokens, 8_000_000);\n        assert_eq!(be.break_even_input_tokens, 40_000_000);\n    }\n\n    #[test]\n    fn break_even_zero() {\n        let be = calculate_break_even(0.0);\n        assert_eq!(be.break_even_output_tokens, 0);\n        assert_eq!(be.break_even_input_tokens, 0);\n    }\n\n    #[test]\n    fn max_tier_break_even() {\n        let (max5x, max20x) = get_max_tier_break_even();\n        assert_eq!(max5x.price, 100.0);\n        assert_eq!(max20x.price, 200.0);\n    }\n\n    #[test]\n    fn project_cycle_cost_normal() {\n        let projected = project_cycle_cost(10.0, 15, 30);\n        assert!((projected - 20.0).abs() \u003c 0.001);\n    }\n\n    #[test]\n    fn project_cycle_cost_zero_elapsed() {\n        assert_eq!(project_cycle_cost(10.0, 0, 30), 0.0);\n    }\n\n    #[test]\n    fn project_cycle_cost_negative_elapsed() {\n        assert_eq!(project_cycle_cost(10.0, -1, 30), 0.0);\n    }\n\n    #[test]\n    fn competitor_pricing_count() {\n        let competitors = get_competitor_pricing();\n        assert_eq!(competitors.len(), 6);\n    }\n\n    #[test]\n    fn competitor_pricing_claude_first() {\n        let competitors = get_competitor_pricing();\n        assert_eq!(competitors[0].name, \"Claude (Anthropic)\");\n    }\n\n    #[test]\n    fn value_comparison_positive() {\n        let comparisons = get_value_comparison(500.0);\n        assert!(!comparisons.is_empty());\n        // All individual plans with price \u003e 0\n        for c in \u0026comparisons {\n            assert!(c.price \u003e 0.0);\n        }\n        // Sorted by price ascending\n        for w in comparisons.windows(2) {\n            assert!(w[0].price \u003c= w[1].price);\n        }\n    }\n\n    #[test]\n    fn value_comparison_zero_cost() {\n        let comparisons = get_value_comparison(0.0);\n        for c in \u0026comparisons {\n            assert_eq!(c.savings_percent, 0.0);\n        }\n    }\n\n    #[test]\n    fn first_n_segments_works() {\n        assert_eq!(first_n_segments(\"a-b-c-d\", 3), \"a-b-c\");\n        assert_eq!(first_n_segments(\"a-b\", 3), \"a-b\");\n        assert_eq!(first_n_segments(\"abc\", 3), \"abc\");\n    }\n\n    #[test]\n    fn partial_match_different_date() {\n        // Same model prefix, different date suffix\n        let p = get_model_pricing(Some(\"claude-opus-4-5-20260101\"));\n        assert_eq!(p.display_name, \"Opus 4.5\");\n    }\n\n    #[test]\n    fn last_day_of_february() {\n        let d = last_day_of_month(2024, 2); // Leap year\n        assert_eq!(d.day(), 29);\n        let d2 = last_day_of_month(2023, 2); // Non-leap\n        assert_eq!(d2.day(), 28);\n    }\n\n    #[test]\n    fn last_day_of_december() {\n        let d = last_day_of_month(2024, 12);\n        assert_eq!(d.day(), 31);\n    }\n\n    #[test]\n    fn family_match_opus_45_dot_variant() {\n        let p = get_model_pricing(Some(\"some-opus-4.5-model\"));\n        assert_eq!(p.display_name, \"Opus 4.5\");\n    }\n\n    #[test]\n    fn family_match_haiku_45_dot_variant() {\n        let p = get_model_pricing(Some(\"some-haiku-4.5-model\"));\n        assert_eq!(p.display_name, \"Haiku 4.5\");\n    }\n\n    #[test]\n    fn billing_cycle_december_wrap() {\n        // Dec 15, billing day 10 -\u003e cycle started Dec 10, ends Jan 10\n        let dec15 = chrono::NaiveDate::from_ymd_opt(2024, 12, 15)\n            .unwrap()\n            .and_hms_opt(12, 0, 0)\n            .unwrap()\n            .and_utc()\n            .timestamp_millis();\n        let cycle = calculate_billing_cycle(10, dec15);\n        assert_eq!(cycle.billing_day, 10);\n        assert!(cycle.days_elapsed \u003e= 5);\n        assert!(cycle.total_days \u003e= 28);\n    }\n\n    #[test]\n    fn model_pricing_cache_fields() {\n        let p = get_model_pricing(Some(\"claude-opus-4-5-20251101\"));\n        assert_eq!(p.cache_write_per_mtok, Some(6.25));\n        assert_eq!(p.cache_read_per_mtok, Some(0.5));\n\n        let p2 = get_model_pricing(Some(\"claude-opus-4-20250514\"));\n        assert!(p2.cache_write_per_mtok.is_none());\n    }\n}\n","traces":[{"line":102,"address":[],"length":0,"stats":{"Line":22}},{"line":103,"address":[],"length":0,"stats":{"Line":42}},{"line":104,"address":[],"length":0,"stats":{"Line":40}},{"line":105,"address":[],"length":0,"stats":{"Line":2}},{"line":109,"address":[],"length":0,"stats":{"Line":297}},{"line":110,"address":[],"length":0,"stats":{"Line":96}},{"line":111,"address":[],"length":0,"stats":{"Line":22}},{"line":116,"address":[],"length":0,"stats":{"Line":27}},{"line":117,"address":[],"length":0,"stats":{"Line":27}},{"line":118,"address":[],"length":0,"stats":{"Line":160}},{"line":119,"address":[],"length":0,"stats":{"Line":153}},{"line":120,"address":[],"length":0,"stats":{"Line":51}},{"line":121,"address":[],"length":0,"stats":{"Line":4}},{"line":126,"address":[],"length":0,"stats":{"Line":14}},{"line":127,"address":[],"length":0,"stats":{"Line":2}},{"line":129,"address":[],"length":0,"stats":{"Line":12}},{"line":130,"address":[],"length":0,"stats":{"Line":2}},{"line":132,"address":[],"length":0,"stats":{"Line":10}},{"line":133,"address":[],"length":0,"stats":{"Line":2}},{"line":135,"address":[],"length":0,"stats":{"Line":4}},{"line":136,"address":[],"length":0,"stats":{"Line":2}},{"line":138,"address":[],"length":0,"stats":{"Line":3}},{"line":139,"address":[],"length":0,"stats":{"Line":2}},{"line":141,"address":[],"length":0,"stats":{"Line":2}},{"line":142,"address":[],"length":0,"stats":{"Line":2}},{"line":145,"address":[],"length":0,"stats":{"Line":1}},{"line":148,"address":[],"length":0,"stats":{"Line":63}},{"line":149,"address":[],"length":0,"stats":{"Line":315}},{"line":152,"address":[],"length":0,"stats":{"Line":4}},{"line":153,"address":[],"length":0,"stats":{"Line":12}},{"line":154,"address":[],"length":0,"stats":{"Line":8}},{"line":155,"address":[],"length":0,"stats":{"Line":8}},{"line":156,"address":[],"length":0,"stats":{"Line":4}},{"line":159,"address":[],"length":0,"stats":{"Line":39}},{"line":160,"address":[],"length":0,"stats":{"Line":39}},{"line":161,"address":[],"length":0,"stats":{"Line":8}},{"line":162,"address":[],"length":0,"stats":{"Line":35}},{"line":163,"address":[],"length":0,"stats":{"Line":8}},{"line":165,"address":[],"length":0,"stats":{"Line":62}},{"line":170,"address":[],"length":0,"stats":{"Line":1}},{"line":171,"address":[],"length":0,"stats":{"Line":18}},{"line":176,"address":[],"length":0,"stats":{"Line":8}},{"line":177,"address":[],"length":0,"stats":{"Line":8}},{"line":178,"address":[],"length":0,"stats":{"Line":8}},{"line":179,"address":[],"length":0,"stats":{"Line":8}},{"line":180,"address":[],"length":0,"stats":{"Line":8}},{"line":181,"address":[],"length":0,"stats":{"Line":8}},{"line":185,"address":[],"length":0,"stats":{"Line":8}},{"line":186,"address":[],"length":0,"stats":{"Line":32}},{"line":187,"address":[],"length":0,"stats":{"Line":54}},{"line":188,"address":[],"length":0,"stats":{"Line":23}},{"line":189,"address":[],"length":0,"stats":{"Line":7}},{"line":192,"address":[],"length":0,"stats":{"Line":1}},{"line":205,"address":[],"length":0,"stats":{"Line":9}},{"line":208,"address":[],"length":0,"stats":{"Line":45}},{"line":209,"address":[],"length":0,"stats":{"Line":27}},{"line":211,"address":[],"length":0,"stats":{"Line":36}},{"line":213,"address":[],"length":0,"stats":{"Line":4}},{"line":214,"address":[],"length":0,"stats":{"Line":7}},{"line":215,"address":[],"length":0,"stats":{"Line":1}},{"line":216,"address":[],"length":0,"stats":{"Line":1}},{"line":219,"address":[],"length":0,"stats":{"Line":56}},{"line":220,"address":[],"length":0,"stats":{"Line":8}},{"line":221,"address":[],"length":0,"stats":{"Line":32}},{"line":222,"address":[],"length":0,"stats":{"Line":8}},{"line":225,"address":[],"length":0,"stats":{"Line":27}},{"line":230,"address":[],"length":0,"stats":{"Line":27}},{"line":236,"address":[],"length":0,"stats":{"Line":18}},{"line":237,"address":[],"length":0,"stats":{"Line":18}},{"line":238,"address":[],"length":0,"stats":{"Line":18}},{"line":250,"address":[],"length":0,"stats":{"Line":1}},{"line":252,"address":[],"length":0,"stats":{"Line":3}},{"line":253,"address":[],"length":0,"stats":{"Line":1}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":5}},{"line":260,"address":[],"length":0,"stats":{"Line":8}},{"line":262,"address":[],"length":0,"stats":{"Line":24}},{"line":263,"address":[],"length":0,"stats":{"Line":1}},{"line":265,"address":[],"length":0,"stats":{"Line":21}},{"line":267,"address":[],"length":0,"stats":{"Line":40}},{"line":270,"address":[],"length":0,"stats":{"Line":3}},{"line":272,"address":[],"length":0,"stats":{"Line":9}},{"line":273,"address":[],"length":0,"stats":{"Line":1}},{"line":275,"address":[],"length":0,"stats":{"Line":2}},{"line":277,"address":[],"length":0,"stats":{"Line":9}},{"line":292,"address":[],"length":0,"stats":{"Line":10}},{"line":294,"address":[],"length":0,"stats":{"Line":20}},{"line":295,"address":[],"length":0,"stats":{"Line":20}},{"line":304,"address":[],"length":0,"stats":{"Line":1}},{"line":305,"address":[],"length":0,"stats":{"Line":1}},{"line":308,"address":[],"length":0,"stats":{"Line":3}},{"line":309,"address":[],"length":0,"stats":{"Line":3}},{"line":310,"address":[],"length":0,"stats":{"Line":2}},{"line":312,"address":[],"length":0,"stats":{"Line":1}},{"line":332,"address":[],"length":0,"stats":{"Line":9}},{"line":333,"address":[],"length":0,"stats":{"Line":9}},{"line":334,"address":[],"length":0,"stats":{"Line":9}},{"line":335,"address":[],"length":0,"stats":{"Line":9}},{"line":336,"address":[],"length":0,"stats":{"Line":9}},{"line":337,"address":[],"length":0,"stats":{"Line":18}},{"line":338,"address":[],"length":0,"stats":{"Line":18}},{"line":339,"address":[],"length":0,"stats":{"Line":18}},{"line":340,"address":[],"length":0,"stats":{"Line":18}},{"line":341,"address":[],"length":0,"stats":{"Line":18}},{"line":342,"address":[],"length":0,"stats":{"Line":18}},{"line":344,"address":[],"length":0,"stats":{"Line":18}},{"line":345,"address":[],"length":0,"stats":{"Line":18}},{"line":346,"address":[],"length":0,"stats":{"Line":18}},{"line":347,"address":[],"length":0,"stats":{"Line":18}},{"line":348,"address":[],"length":0,"stats":{"Line":18}},{"line":350,"address":[],"length":0,"stats":{"Line":18}},{"line":351,"address":[],"length":0,"stats":{"Line":18}},{"line":352,"address":[],"length":0,"stats":{"Line":18}},{"line":353,"address":[],"length":0,"stats":{"Line":18}},{"line":354,"address":[],"length":0,"stats":{"Line":18}},{"line":356,"address":[],"length":0,"stats":{"Line":18}},{"line":357,"address":[],"length":0,"stats":{"Line":18}},{"line":358,"address":[],"length":0,"stats":{"Line":18}},{"line":359,"address":[],"length":0,"stats":{"Line":18}},{"line":360,"address":[],"length":0,"stats":{"Line":18}},{"line":362,"address":[],"length":0,"stats":{"Line":9}},{"line":363,"address":[],"length":0,"stats":{"Line":9}},{"line":364,"address":[],"length":0,"stats":{"Line":9}},{"line":365,"address":[],"length":0,"stats":{"Line":9}},{"line":366,"address":[],"length":0,"stats":{"Line":9}},{"line":368,"address":[],"length":0,"stats":{"Line":9}},{"line":369,"address":[],"length":0,"stats":{"Line":9}},{"line":370,"address":[],"length":0,"stats":{"Line":9}},{"line":371,"address":[],"length":0,"stats":{"Line":9}},{"line":372,"address":[],"length":0,"stats":{"Line":9}},{"line":376,"address":[],"length":0,"stats":{"Line":9}},{"line":377,"address":[],"length":0,"stats":{"Line":9}},{"line":378,"address":[],"length":0,"stats":{"Line":9}},{"line":379,"address":[],"length":0,"stats":{"Line":18}},{"line":380,"address":[],"length":0,"stats":{"Line":18}},{"line":381,"address":[],"length":0,"stats":{"Line":18}},{"line":382,"address":[],"length":0,"stats":{"Line":18}},{"line":383,"address":[],"length":0,"stats":{"Line":18}},{"line":384,"address":[],"length":0,"stats":{"Line":18}},{"line":386,"address":[],"length":0,"stats":{"Line":18}},{"line":387,"address":[],"length":0,"stats":{"Line":18}},{"line":388,"address":[],"length":0,"stats":{"Line":18}},{"line":389,"address":[],"length":0,"stats":{"Line":18}},{"line":390,"address":[],"length":0,"stats":{"Line":18}},{"line":392,"address":[],"length":0,"stats":{"Line":18}},{"line":393,"address":[],"length":0,"stats":{"Line":18}},{"line":394,"address":[],"length":0,"stats":{"Line":18}},{"line":395,"address":[],"length":0,"stats":{"Line":18}},{"line":396,"address":[],"length":0,"stats":{"Line":18}},{"line":398,"address":[],"length":0,"stats":{"Line":9}},{"line":399,"address":[],"length":0,"stats":{"Line":9}},{"line":400,"address":[],"length":0,"stats":{"Line":9}},{"line":401,"address":[],"length":0,"stats":{"Line":9}},{"line":402,"address":[],"length":0,"stats":{"Line":9}},{"line":404,"address":[],"length":0,"stats":{"Line":9}},{"line":405,"address":[],"length":0,"stats":{"Line":9}},{"line":406,"address":[],"length":0,"stats":{"Line":9}},{"line":407,"address":[],"length":0,"stats":{"Line":9}},{"line":408,"address":[],"length":0,"stats":{"Line":9}},{"line":412,"address":[],"length":0,"stats":{"Line":9}},{"line":413,"address":[],"length":0,"stats":{"Line":9}},{"line":414,"address":[],"length":0,"stats":{"Line":9}},{"line":415,"address":[],"length":0,"stats":{"Line":18}},{"line":416,"address":[],"length":0,"stats":{"Line":18}},{"line":417,"address":[],"length":0,"stats":{"Line":18}},{"line":418,"address":[],"length":0,"stats":{"Line":18}},{"line":419,"address":[],"length":0,"stats":{"Line":18}},{"line":420,"address":[],"length":0,"stats":{"Line":18}},{"line":422,"address":[],"length":0,"stats":{"Line":18}},{"line":423,"address":[],"length":0,"stats":{"Line":18}},{"line":424,"address":[],"length":0,"stats":{"Line":18}},{"line":425,"address":[],"length":0,"stats":{"Line":18}},{"line":426,"address":[],"length":0,"stats":{"Line":18}},{"line":428,"address":[],"length":0,"stats":{"Line":18}},{"line":429,"address":[],"length":0,"stats":{"Line":18}},{"line":430,"address":[],"length":0,"stats":{"Line":18}},{"line":431,"address":[],"length":0,"stats":{"Line":18}},{"line":432,"address":[],"length":0,"stats":{"Line":18}},{"line":434,"address":[],"length":0,"stats":{"Line":9}},{"line":435,"address":[],"length":0,"stats":{"Line":9}},{"line":436,"address":[],"length":0,"stats":{"Line":9}},{"line":437,"address":[],"length":0,"stats":{"Line":9}},{"line":438,"address":[],"length":0,"stats":{"Line":9}},{"line":440,"address":[],"length":0,"stats":{"Line":9}},{"line":441,"address":[],"length":0,"stats":{"Line":9}},{"line":442,"address":[],"length":0,"stats":{"Line":9}},{"line":443,"address":[],"length":0,"stats":{"Line":9}},{"line":444,"address":[],"length":0,"stats":{"Line":9}},{"line":448,"address":[],"length":0,"stats":{"Line":9}},{"line":449,"address":[],"length":0,"stats":{"Line":9}},{"line":450,"address":[],"length":0,"stats":{"Line":9}},{"line":451,"address":[],"length":0,"stats":{"Line":18}},{"line":452,"address":[],"length":0,"stats":{"Line":18}},{"line":453,"address":[],"length":0,"stats":{"Line":18}},{"line":454,"address":[],"length":0,"stats":{"Line":18}},{"line":455,"address":[],"length":0,"stats":{"Line":18}},{"line":456,"address":[],"length":0,"stats":{"Line":18}},{"line":458,"address":[],"length":0,"stats":{"Line":9}},{"line":459,"address":[],"length":0,"stats":{"Line":9}},{"line":460,"address":[],"length":0,"stats":{"Line":9}},{"line":461,"address":[],"length":0,"stats":{"Line":9}},{"line":462,"address":[],"length":0,"stats":{"Line":9}},{"line":464,"address":[],"length":0,"stats":{"Line":9}},{"line":465,"address":[],"length":0,"stats":{"Line":9}},{"line":466,"address":[],"length":0,"stats":{"Line":9}},{"line":467,"address":[],"length":0,"stats":{"Line":9}},{"line":468,"address":[],"length":0,"stats":{"Line":9}},{"line":472,"address":[],"length":0,"stats":{"Line":9}},{"line":473,"address":[],"length":0,"stats":{"Line":9}},{"line":474,"address":[],"length":0,"stats":{"Line":9}},{"line":475,"address":[],"length":0,"stats":{"Line":9}},{"line":476,"address":[],"length":0,"stats":{"Line":9}},{"line":477,"address":[],"length":0,"stats":{"Line":9}},{"line":478,"address":[],"length":0,"stats":{"Line":9}},{"line":479,"address":[],"length":0,"stats":{"Line":9}},{"line":482,"address":[],"length":0,"stats":{"Line":9}},{"line":483,"address":[],"length":0,"stats":{"Line":9}},{"line":484,"address":[],"length":0,"stats":{"Line":9}},{"line":485,"address":[],"length":0,"stats":{"Line":18}},{"line":486,"address":[],"length":0,"stats":{"Line":9}},{"line":487,"address":[],"length":0,"stats":{"Line":9}},{"line":488,"address":[],"length":0,"stats":{"Line":9}},{"line":489,"address":[],"length":0,"stats":{"Line":9}},{"line":490,"address":[],"length":0,"stats":{"Line":9}},{"line":492,"address":[],"length":0,"stats":{"Line":9}},{"line":493,"address":[],"length":0,"stats":{"Line":9}},{"line":494,"address":[],"length":0,"stats":{"Line":9}},{"line":495,"address":[],"length":0,"stats":{"Line":9}},{"line":496,"address":[],"length":0,"stats":{"Line":9}},{"line":512,"address":[],"length":0,"stats":{"Line":7}},{"line":513,"address":[],"length":0,"stats":{"Line":14}},{"line":515,"address":[],"length":0,"stats":{"Line":49}},{"line":516,"address":[],"length":0,"stats":{"Line":350}},{"line":517,"address":[],"length":0,"stats":{"Line":259}},{"line":518,"address":[],"length":0,"stats":{"Line":84}},{"line":520,"address":[],"length":0,"stats":{"Line":140}},{"line":521,"address":[],"length":0,"stats":{"Line":140}},{"line":522,"address":[],"length":0,"stats":{"Line":60}},{"line":524,"address":[],"length":0,"stats":{"Line":10}},{"line":526,"address":[],"length":0,"stats":{"Line":210}},{"line":527,"address":[],"length":0,"stats":{"Line":210}},{"line":528,"address":[],"length":0,"stats":{"Line":210}},{"line":529,"address":[],"length":0,"stats":{"Line":140}},{"line":530,"address":[],"length":0,"stats":{"Line":70}},{"line":531,"address":[],"length":0,"stats":{"Line":70}},{"line":536,"address":[],"length":0,"stats":{"Line":826}},{"line":537,"address":[],"length":0,"stats":{"Line":7}}],"covered":246,"coverable":247},{"path":["/","Users","chi","Projects","hu","src","data","queries.rs"],"content":"use anyhow::Result;\nuse rusqlite::Connection;\nuse rusqlite::OptionalExtension;\n\nuse super::types::*;\n\npub fn get_sessions(conn: \u0026Connection, project: Option\u003c\u0026str\u003e, limit: i64) -\u003e Result\u003cVec\u003cSession\u003e\u003e {\n    let (sql, params) = match project {\n        Some(p) =\u003e {\n            let pattern = format!(\"%{p}%\");\n            (\n                \"SELECT id, project, display, started_at, message_count, total_cost_usd, git_branch FROM sessions WHERE project LIKE ?1 ORDER BY started_at DESC LIMIT ?2\".to_string(),\n                vec![rusqlite::types::Value::Text(pattern), rusqlite::types::Value::Integer(limit)],\n            )\n        }\n        None =\u003e (\n            \"SELECT id, project, display, started_at, message_count, total_cost_usd, git_branch FROM sessions ORDER BY started_at DESC LIMIT ?1\".to_string(),\n            vec![rusqlite::types::Value::Integer(limit)],\n        ),\n    };\n\n    let mut stmt = conn.prepare(\u0026sql)?;\n    let rows = stmt.query_map(rusqlite::params_from_iter(params), |row| {\n        Ok(Session {\n            id: row.get(0)?,\n            project: row.get(1)?,\n            display: row.get(2)?,\n            started_at: row.get(3)?,\n            message_count: row.get(4)?,\n            total_cost_usd: row.get(5)?,\n            git_branch: row.get(6)?,\n        })\n    })?;\n\n    Ok(rows.filter_map(|r| r.ok()).collect())\n}\n\npub fn get_session_by_prefix(conn: \u0026Connection, prefix: \u0026str) -\u003e Result\u003cOption\u003cSession\u003e\u003e {\n    let pattern = format!(\"{prefix}%\");\n    Ok(conn.query_row(\n        \"SELECT id, project, display, started_at, message_count, total_cost_usd, git_branch FROM sessions WHERE id LIKE ?1 ORDER BY started_at DESC LIMIT 1\",\n        rusqlite::params![pattern],\n        |row| {\n            Ok(Session {\n                id: row.get(0)?,\n                project: row.get(1)?,\n                display: row.get(2)?,\n                started_at: row.get(3)?,\n                message_count: row.get(4)?,\n                total_cost_usd: row.get(5)?,\n                git_branch: row.get(6)?,\n            })\n        },\n    ).optional()?)\n}\n\npub fn get_session_by_id(conn: \u0026Connection, id: \u0026str) -\u003e Result\u003cOption\u003cSession\u003e\u003e {\n    Ok(conn.query_row(\n        \"SELECT id, project, display, started_at, message_count, total_cost_usd, git_branch FROM sessions WHERE id = ?1\",\n        rusqlite::params![id],\n        |row| {\n            Ok(Session {\n                id: row.get(0)?,\n                project: row.get(1)?,\n                display: row.get(2)?,\n                started_at: row.get(3)?,\n                message_count: row.get(4)?,\n                total_cost_usd: row.get(5)?,\n                git_branch: row.get(6)?,\n            })\n        },\n    ).optional()?)\n}\n\npub fn get_messages_by_session(conn: \u0026Connection, session_id: \u0026str) -\u003e Result\u003cVec\u003cMessage\u003e\u003e {\n    let mut stmt = conn.prepare(\n        \"SELECT id, session_id, parent_id, role, content, model, input_tokens, output_tokens, cost_usd, duration_ms, created_at FROM messages WHERE session_id = ?1 ORDER BY created_at ASC\",\n    )?;\n    let rows = stmt.query_map(rusqlite::params![session_id], |row| {\n        Ok(Message {\n            id: row.get(0)?,\n            session_id: row.get(1)?,\n            parent_id: row.get(2)?,\n            role: row.get(3)?,\n            content: row.get(4)?,\n            model: row.get(5)?,\n            input_tokens: row.get(6)?,\n            output_tokens: row.get(7)?,\n            cost_usd: row.get(8)?,\n            duration_ms: row.get(9)?,\n            created_at: row.get(10)?,\n        })\n    })?;\n    Ok(rows.filter_map(|r| r.ok()).collect())\n}\n\npub fn search_messages(conn: \u0026Connection, query: \u0026str, limit: i64) -\u003e Result\u003cVec\u003cSearchResult\u003e\u003e {\n    let pattern = format!(\"%{query}%\");\n    let mut stmt = conn.prepare(\n        \"SELECT m.id, m.session_id, m.role, m.content, m.model, m.created_at, s.project FROM messages m JOIN sessions s ON m.session_id = s.id WHERE m.content LIKE ?1 ORDER BY m.created_at DESC LIMIT ?2\",\n    )?;\n    let rows = stmt.query_map(rusqlite::params![pattern, limit], |row| {\n        Ok(SearchResult {\n            id: row.get(0)?,\n            session_id: row.get(1)?,\n            role: row.get(2)?,\n            content: row.get(3)?,\n            model: row.get(4)?,\n            created_at: row.get(5)?,\n            project: row.get(6)?,\n        })\n    })?;\n    Ok(rows.filter_map(|r| r.ok()).collect())\n}\n\npub fn get_todos(conn: \u0026Connection, status: Option\u003c\u0026str\u003e) -\u003e Result\u003cVec\u003cTodo\u003e\u003e {\n    let (sql, params) = match status {\n        Some(s) =\u003e (\n            \"SELECT id, session_id, content, status, active_form FROM todos WHERE status = ?1 ORDER BY id DESC\".to_string(),\n            vec![rusqlite::types::Value::Text(s.to_string())],\n        ),\n        None =\u003e (\n            \"SELECT id, session_id, content, status, active_form FROM todos ORDER BY id DESC\"\n                .to_string(),\n            vec![],\n        ),\n    };\n\n    let mut stmt = conn.prepare(\u0026sql)?;\n    let rows = stmt.query_map(rusqlite::params_from_iter(params), |row| {\n        Ok(Todo {\n            id: row.get(0)?,\n            session_id: row.get(1)?,\n            content: row.get(2)?,\n            status: row.get(3)?,\n            active_form: row.get(4)?,\n        })\n    })?;\n    Ok(rows.filter_map(|r| r.ok()).collect())\n}\n\npub fn get_pending_todos(conn: \u0026Connection, project: Option\u003c\u0026str\u003e) -\u003e Result\u003cVec\u003cTodoWithProject\u003e\u003e {\n    let (sql, params) = match project {\n        Some(p) =\u003e {\n            let pattern = format!(\"%{p}%\");\n            (\n                \"SELECT t.id, t.session_id, t.content, t.status, t.active_form, s.project FROM todos t JOIN sessions s ON t.session_id = s.id WHERE t.status != 'completed' AND s.project LIKE ?1 ORDER BY t.id DESC\".to_string(),\n                vec![rusqlite::types::Value::Text(pattern)],\n            )\n        }\n        None =\u003e (\n            \"SELECT t.id, t.session_id, t.content, t.status, t.active_form, s.project FROM todos t JOIN sessions s ON t.session_id = s.id WHERE t.status != 'completed' ORDER BY t.id DESC\".to_string(),\n            vec![],\n        ),\n    };\n\n    let mut stmt = conn.prepare(\u0026sql)?;\n    let rows = stmt.query_map(rusqlite::params_from_iter(params), |row| {\n        Ok(TodoWithProject {\n            id: row.get(0)?,\n            session_id: row.get(1)?,\n            content: row.get(2)?,\n            status: row.get(3)?,\n            active_form: row.get(4)?,\n            project: row.get(5)?,\n        })\n    })?;\n    Ok(rows.filter_map(|r| r.ok()).collect())\n}\n\npub fn get_usage_stats(conn: \u0026Connection, since: Option\u003ci64\u003e) -\u003e Result\u003cUsageStats\u003e {\n    let total_sessions: i64 = conn.query_row(\"SELECT COUNT(*) FROM sessions\", [], |r| r.get(0))?;\n\n    let (total_messages, total_cost, total_input_tokens, total_output_tokens) = match since {\n        Some(ts) =\u003e {\n            let msgs: i64 = conn.query_row(\n                \"SELECT COUNT(*) FROM messages WHERE created_at \u003e= ?1\",\n                rusqlite::params![ts],\n                |r| r.get(0),\n            )?;\n            let cost: f64 = conn.query_row(\n                \"SELECT COALESCE(SUM(cost_usd), 0) FROM messages WHERE created_at \u003e= ?1\",\n                rusqlite::params![ts],\n                |r| r.get(0),\n            )?;\n            let input: i64 = conn.query_row(\n                \"SELECT COALESCE(SUM(input_tokens), 0) FROM messages WHERE created_at \u003e= ?1\",\n                rusqlite::params![ts],\n                |r| r.get(0),\n            )?;\n            let output: i64 = conn.query_row(\n                \"SELECT COALESCE(SUM(output_tokens), 0) FROM messages WHERE created_at \u003e= ?1\",\n                rusqlite::params![ts],\n                |r| r.get(0),\n            )?;\n            (msgs, cost, input, output)\n        }\n        None =\u003e {\n            let msgs: i64 = conn.query_row(\"SELECT COUNT(*) FROM messages\", [], |r| r.get(0))?;\n            let cost: f64 =\n                conn.query_row(\"SELECT COALESCE(SUM(cost_usd), 0) FROM messages\", [], |r| {\n                    r.get(0)\n                })?;\n            let input: i64 = conn.query_row(\n                \"SELECT COALESCE(SUM(input_tokens), 0) FROM messages\",\n                [],\n                |r| r.get(0),\n            )?;\n            let output: i64 = conn.query_row(\n                \"SELECT COALESCE(SUM(output_tokens), 0) FROM messages\",\n                [],\n                |r| r.get(0),\n            )?;\n            (msgs, cost, input, output)\n        }\n    };\n\n    Ok(UsageStats {\n        total_sessions,\n        total_messages,\n        total_cost,\n        total_input_tokens,\n        total_output_tokens,\n    })\n}\n\npub fn get_model_usage(conn: \u0026Connection, since: Option\u003ci64\u003e) -\u003e Result\u003cVec\u003cModelUsage\u003e\u003e {\n    let (sql, params): (String, Vec\u003crusqlite::types::Value\u003e) = match since {\n        Some(ts) =\u003e (\n            \"SELECT model, COUNT(*) as count, COALESCE(SUM(cost_usd), 0) as cost, COALESCE(SUM(input_tokens), 0) as input_tokens, COALESCE(SUM(output_tokens), 0) as output_tokens FROM messages WHERE model IS NOT NULL AND created_at \u003e= ?1 GROUP BY model ORDER BY count DESC\".to_string(),\n            vec![rusqlite::types::Value::Integer(ts)],\n        ),\n        None =\u003e (\n            \"SELECT model, COUNT(*) as count, COALESCE(SUM(cost_usd), 0) as cost, COALESCE(SUM(input_tokens), 0) as input_tokens, COALESCE(SUM(output_tokens), 0) as output_tokens FROM messages WHERE model IS NOT NULL GROUP BY model ORDER BY count DESC\".to_string(),\n            vec![],\n        ),\n    };\n\n    let mut stmt = conn.prepare(\u0026sql)?;\n    let rows = stmt.query_map(rusqlite::params_from_iter(params), |row| {\n        Ok(ModelUsage {\n            model: row.get(0)?,\n            count: row.get(1)?,\n            cost: row.get(2)?,\n            input_tokens: row.get(3)?,\n            output_tokens: row.get(4)?,\n        })\n    })?;\n    Ok(rows.filter_map(|r| r.ok()).collect())\n}\n\npub fn get_tool_stats(conn: \u0026Connection) -\u003e Result\u003cVec\u003cToolUsageStats\u003e\u003e {\n    let mut stmt = conn.prepare(\n        \"SELECT tool_name, COUNT(*) as count, MAX(created_at) as last_used FROM tool_usage GROUP BY tool_name ORDER BY count DESC\",\n    )?;\n    let rows = stmt.query_map([], |row| {\n        Ok(ToolUsageStats {\n            tool_name: row.get(0)?,\n            count: row.get(1)?,\n            last_used: row.get(2)?,\n        })\n    })?;\n    Ok(rows.filter_map(|r| r.ok()).collect())\n}\n\npub fn get_tool_detail(conn: \u0026Connection, tool_name: \u0026str) -\u003e Result\u003cVec\u003cToolUsageDetail\u003e\u003e {\n    let mut stmt = conn.prepare(\n        \"SELECT tu.tool_name, tu.session_id, s.project, tu.created_at FROM tool_usage tu JOIN sessions s ON tu.session_id = s.id WHERE tu.tool_name = ?1 ORDER BY tu.created_at DESC LIMIT 20\",\n    )?;\n    let rows = stmt.query_map(rusqlite::params![tool_name], |row| {\n        Ok(ToolUsageDetail {\n            tool_name: row.get(0)?,\n            session_id: row.get(1)?,\n            project: row.get(2)?,\n            created_at: row.get(3)?,\n        })\n    })?;\n    Ok(rows.filter_map(|r| r.ok()).collect())\n}\n\npub fn get_branch_stats(\n    conn: \u0026Connection,\n    branch_filter: Option\u003c\u0026str\u003e,\n    limit: i64,\n) -\u003e Result\u003cVec\u003cBranchStats\u003e\u003e {\n    let (sql, params): (String, Vec\u003crusqlite::types::Value\u003e) = match branch_filter {\n        Some(b) =\u003e {\n            let pattern = format!(\"%{b}%\");\n            (\n                \"SELECT git_branch, COUNT(*) as session_count, GROUP_CONCAT(id) as session_ids, MAX(started_at) as last_activity, SUM(message_count) as total_messages, SUM(total_cost_usd) as total_cost, project FROM sessions WHERE git_branch IS NOT NULL AND git_branch LIKE ?1 GROUP BY git_branch, project ORDER BY last_activity DESC LIMIT ?2\".to_string(),\n                vec![rusqlite::types::Value::Text(pattern), rusqlite::types::Value::Integer(limit)],\n            )\n        }\n        None =\u003e (\n            \"SELECT git_branch, COUNT(*) as session_count, GROUP_CONCAT(id) as session_ids, MAX(started_at) as last_activity, SUM(message_count) as total_messages, SUM(total_cost_usd) as total_cost, project FROM sessions WHERE git_branch IS NOT NULL GROUP BY git_branch, project ORDER BY last_activity DESC LIMIT ?1\".to_string(),\n            vec![rusqlite::types::Value::Integer(limit)],\n        ),\n    };\n\n    let mut stmt = conn.prepare(\u0026sql)?;\n    let rows = stmt.query_map(rusqlite::params_from_iter(params), |row| {\n        Ok(BranchStats {\n            git_branch: row.get(0)?,\n            session_count: row.get(1)?,\n            session_ids: row.get::\u003c_, Option\u003cString\u003e\u003e(2)?.unwrap_or_default(),\n            last_activity: row.get(3)?,\n            total_messages: row.get(4)?,\n            total_cost: row.get(5)?,\n            project: row.get(6)?,\n        })\n    })?;\n    Ok(rows.filter_map(|r| r.ok()).collect())\n}\n\npub fn get_period_usage(conn: \u0026Connection, since: i64) -\u003e Result\u003cPeriodUsage\u003e {\n    let row = conn.query_row(\n        \"SELECT COUNT(*) as messages, COALESCE(SUM(input_tokens), 0) as input_tokens, COALESCE(SUM(output_tokens), 0) as output_tokens FROM messages WHERE created_at \u003e= ?1\",\n        rusqlite::params![since],\n        |row| {\n            Ok(PeriodUsage {\n                messages: row.get(0)?,\n                input_tokens: row.get(1)?,\n                output_tokens: row.get(2)?,\n            })\n        },\n    )?;\n    Ok(row)\n}\n\npub fn get_period_model_usage(conn: \u0026Connection, since: i64) -\u003e Result\u003cVec\u003cModelTokenUsage\u003e\u003e {\n    let mut stmt = conn.prepare(\n        \"SELECT model, COALESCE(SUM(input_tokens), 0) as input_tokens, COALESCE(SUM(output_tokens), 0) as output_tokens FROM messages WHERE model IS NOT NULL AND created_at \u003e= ?1 GROUP BY model\",\n    )?;\n    let rows = stmt.query_map(rusqlite::params![since], |row| {\n        Ok(ModelTokenUsage {\n            model: row.get(0)?,\n            input_tokens: row.get(1)?,\n            output_tokens: row.get(2)?,\n        })\n    })?;\n    Ok(rows.filter_map(|r| r.ok()).collect())\n}\n\n// Extra types used only by queries\n\n#[derive(Debug, Clone, Default, serde::Serialize)]\npub struct PeriodUsage {\n    pub messages: i64,\n    pub input_tokens: i64,\n    pub output_tokens: i64,\n}\n\n#[derive(Debug, Clone, Default, serde::Serialize)]\npub struct ModelTokenUsage {\n    pub model: String,\n    pub input_tokens: i64,\n    pub output_tokens: i64,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::data::db::open_test_db;\n\n    fn seed_data(conn: \u0026Connection) {\n        conn.execute_batch(\n            \"\n            INSERT INTO sessions (id, project, display, started_at, message_count, total_cost_usd, git_branch) VALUES\n                ('s1', '/home/user/proj', 'First session', 1700000000000, 3, 0.05, 'main'),\n                ('s2', '/home/user/proj2', 'Second session', 1700001000000, 1, 0.01, 'feature/x');\n\n            INSERT INTO messages (id, session_id, role, content, model, input_tokens, output_tokens, cost_usd, created_at) VALUES\n                ('m1', 's1', 'user', 'hello world', NULL, 10, 0, NULL, 1700000000000),\n                ('m2', 's1', 'assistant', 'hi there', 'claude-sonnet-4-5-20251101', 10, 50, 0.003, 1700000001000),\n                ('m3', 's1', 'user', 'search test query', NULL, 15, 0, NULL, 1700000002000),\n                ('m4', 's2', 'user', 'other message', NULL, 5, 0, NULL, 1700001000000);\n\n            INSERT INTO todos (session_id, content, status, active_form) VALUES\n                ('s1', 'Fix bug', 'pending', 'Fixing bug'),\n                ('s1', 'Add tests', 'completed', NULL),\n                ('s2', 'Review PR', 'in_progress', 'Reviewing PR');\n\n            INSERT INTO tool_usage (session_id, message_id, tool_name, created_at) VALUES\n                ('s1', 'm2', 'Read', 1700000001000),\n                ('s1', 'm2', 'Read', 1700000001500),\n                ('s1', 'm2', 'Edit', 1700000002000);\n            \",\n        )\n        .unwrap();\n    }\n\n    #[test]\n    fn get_sessions_all() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let sessions = get_sessions(\u0026store.conn, None, 20).unwrap();\n        assert_eq!(sessions.len(), 2);\n        assert_eq!(sessions[0].id, \"s2\"); // Most recent first\n    }\n\n    #[test]\n    fn get_sessions_filtered() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let sessions = get_sessions(\u0026store.conn, Some(\"proj2\"), 20).unwrap();\n        assert_eq!(sessions.len(), 1);\n        assert_eq!(sessions[0].id, \"s2\");\n    }\n\n    #[test]\n    fn get_sessions_limited() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let sessions = get_sessions(\u0026store.conn, None, 1).unwrap();\n        assert_eq!(sessions.len(), 1);\n    }\n\n    #[test]\n    fn get_sessions_empty() {\n        let store = open_test_db();\n        let sessions = get_sessions(\u0026store.conn, None, 20).unwrap();\n        assert!(sessions.is_empty());\n    }\n\n    #[test]\n    fn get_session_by_prefix_found() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let session = get_session_by_prefix(\u0026store.conn, \"s1\").unwrap();\n        assert!(session.is_some());\n        assert_eq!(session.unwrap().id, \"s1\");\n    }\n\n    #[test]\n    fn get_session_by_prefix_not_found() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let session = get_session_by_prefix(\u0026store.conn, \"zzz\").unwrap();\n        assert!(session.is_none());\n    }\n\n    #[test]\n    fn get_session_by_id_found() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let session = get_session_by_id(\u0026store.conn, \"s1\").unwrap();\n        assert!(session.is_some());\n    }\n\n    #[test]\n    fn get_session_by_id_not_found() {\n        let store = open_test_db();\n        let session = get_session_by_id(\u0026store.conn, \"nonexistent\").unwrap();\n        assert!(session.is_none());\n    }\n\n    #[test]\n    fn get_messages_by_session_found() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let msgs = get_messages_by_session(\u0026store.conn, \"s1\").unwrap();\n        assert_eq!(msgs.len(), 3);\n        assert_eq!(msgs[0].role, \"user\");\n        assert_eq!(msgs[1].role, \"assistant\");\n    }\n\n    #[test]\n    fn get_messages_by_session_empty() {\n        let store = open_test_db();\n        let msgs = get_messages_by_session(\u0026store.conn, \"nonexistent\").unwrap();\n        assert!(msgs.is_empty());\n    }\n\n    #[test]\n    fn search_messages_found() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let results = search_messages(\u0026store.conn, \"search test\", 50).unwrap();\n        assert_eq!(results.len(), 1);\n        assert_eq!(results[0].id, \"m3\");\n    }\n\n    #[test]\n    fn search_messages_not_found() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let results = search_messages(\u0026store.conn, \"nonexistent_xyz\", 50).unwrap();\n        assert!(results.is_empty());\n    }\n\n    #[test]\n    fn search_messages_empty_db() {\n        let store = open_test_db();\n        let results = search_messages(\u0026store.conn, \"test\", 50).unwrap();\n        assert!(results.is_empty());\n    }\n\n    #[test]\n    fn get_todos_all() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let todos = get_todos(\u0026store.conn, None).unwrap();\n        assert_eq!(todos.len(), 3);\n    }\n\n    #[test]\n    fn get_todos_filtered() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let todos = get_todos(\u0026store.conn, Some(\"pending\")).unwrap();\n        assert_eq!(todos.len(), 1);\n        assert_eq!(todos[0].content, \"Fix bug\");\n    }\n\n    #[test]\n    fn get_todos_empty() {\n        let store = open_test_db();\n        let todos = get_todos(\u0026store.conn, None).unwrap();\n        assert!(todos.is_empty());\n    }\n\n    #[test]\n    fn get_pending_todos_all() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let todos = get_pending_todos(\u0026store.conn, None).unwrap();\n        assert_eq!(todos.len(), 2); // pending + in_progress\n    }\n\n    #[test]\n    fn get_pending_todos_filtered() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let todos = get_pending_todos(\u0026store.conn, Some(\"proj2\")).unwrap();\n        assert_eq!(todos.len(), 1);\n        assert_eq!(todos[0].content, \"Review PR\");\n    }\n\n    #[test]\n    fn get_pending_todos_empty() {\n        let store = open_test_db();\n        let todos = get_pending_todos(\u0026store.conn, None).unwrap();\n        assert!(todos.is_empty());\n    }\n\n    #[test]\n    fn get_usage_stats_all() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let stats = get_usage_stats(\u0026store.conn, None).unwrap();\n        assert_eq!(stats.total_sessions, 2);\n        assert_eq!(stats.total_messages, 4);\n        assert!(stats.total_cost \u003e 0.0);\n        assert!(stats.total_input_tokens \u003e 0);\n    }\n\n    #[test]\n    fn get_usage_stats_since() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let stats = get_usage_stats(\u0026store.conn, Some(1700000500000)).unwrap();\n        assert_eq!(stats.total_sessions, 2); // sessions always counted fully\n        assert_eq!(stats.total_messages, 1); // only m4\n    }\n\n    #[test]\n    fn get_usage_stats_empty() {\n        let store = open_test_db();\n        let stats = get_usage_stats(\u0026store.conn, None).unwrap();\n        assert_eq!(stats.total_sessions, 0);\n        assert_eq!(stats.total_messages, 0);\n        assert_eq!(stats.total_cost, 0.0);\n    }\n\n    #[test]\n    fn get_model_usage_all() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let usage = get_model_usage(\u0026store.conn, None).unwrap();\n        assert_eq!(usage.len(), 1); // Only assistant msgs have model\n        assert_eq!(usage[0].model, \"claude-sonnet-4-5-20251101\");\n    }\n\n    #[test]\n    fn get_model_usage_empty() {\n        let store = open_test_db();\n        let usage = get_model_usage(\u0026store.conn, None).unwrap();\n        assert!(usage.is_empty());\n    }\n\n    #[test]\n    fn get_model_usage_since() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        // After all messages\n        let usage = get_model_usage(\u0026store.conn, Some(9999999999999)).unwrap();\n        assert!(usage.is_empty());\n    }\n\n    #[test]\n    fn get_tool_stats_found() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let stats = get_tool_stats(\u0026store.conn).unwrap();\n        assert_eq!(stats.len(), 2); // Read and Edit\n        assert_eq!(stats[0].tool_name, \"Read\"); // Most used\n        assert_eq!(stats[0].count, 2);\n    }\n\n    #[test]\n    fn get_tool_stats_empty() {\n        let store = open_test_db();\n        let stats = get_tool_stats(\u0026store.conn).unwrap();\n        assert!(stats.is_empty());\n    }\n\n    #[test]\n    fn get_tool_detail_found() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let detail = get_tool_detail(\u0026store.conn, \"Read\").unwrap();\n        assert_eq!(detail.len(), 2);\n        assert_eq!(detail[0].project, \"/home/user/proj\");\n    }\n\n    #[test]\n    fn get_tool_detail_not_found() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let detail = get_tool_detail(\u0026store.conn, \"NonexistentTool\").unwrap();\n        assert!(detail.is_empty());\n    }\n\n    #[test]\n    fn get_branch_stats_all() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let stats = get_branch_stats(\u0026store.conn, None, 20).unwrap();\n        assert_eq!(stats.len(), 2);\n    }\n\n    #[test]\n    fn get_branch_stats_filtered() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let stats = get_branch_stats(\u0026store.conn, Some(\"feature\"), 20).unwrap();\n        assert_eq!(stats.len(), 1);\n        assert_eq!(stats[0].git_branch, \"feature/x\");\n    }\n\n    #[test]\n    fn get_branch_stats_limited() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let stats = get_branch_stats(\u0026store.conn, None, 1).unwrap();\n        assert_eq!(stats.len(), 1);\n    }\n\n    #[test]\n    fn get_branch_stats_empty() {\n        let store = open_test_db();\n        let stats = get_branch_stats(\u0026store.conn, None, 20).unwrap();\n        assert!(stats.is_empty());\n    }\n\n    #[test]\n    fn get_period_usage_found() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let usage = get_period_usage(\u0026store.conn, 0).unwrap();\n        assert_eq!(usage.messages, 4);\n        assert!(usage.input_tokens \u003e 0);\n    }\n\n    #[test]\n    fn get_period_usage_empty() {\n        let store = open_test_db();\n        let usage = get_period_usage(\u0026store.conn, 0).unwrap();\n        assert_eq!(usage.messages, 0);\n    }\n\n    #[test]\n    fn get_period_model_usage_found() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let usage = get_period_model_usage(\u0026store.conn, 0).unwrap();\n        assert_eq!(usage.len(), 1);\n    }\n\n    #[test]\n    fn get_period_model_usage_empty() {\n        let store = open_test_db();\n        let usage = get_period_model_usage(\u0026store.conn, 0).unwrap();\n        assert!(usage.is_empty());\n    }\n\n    #[test]\n    fn period_usage_default() {\n        let p = PeriodUsage::default();\n        assert_eq!(p.messages, 0);\n    }\n\n    #[test]\n    fn model_token_usage_default() {\n        let m = ModelTokenUsage::default();\n        assert_eq!(m.model, \"\");\n    }\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":4}},{"line":8,"address":[],"length":0,"stats":{"Line":12}},{"line":9,"address":[],"length":0,"stats":{"Line":1}},{"line":10,"address":[],"length":0,"stats":{"Line":3}},{"line":12,"address":[],"length":0,"stats":{"Line":3}},{"line":13,"address":[],"length":0,"stats":{"Line":2}},{"line":16,"address":[],"length":0,"stats":{"Line":3}},{"line":17,"address":[],"length":0,"stats":{"Line":9}},{"line":18,"address":[],"length":0,"stats":{"Line":3}},{"line":22,"address":[],"length":0,"stats":{"Line":16}},{"line":23,"address":[],"length":0,"stats":{"Line":24}},{"line":25,"address":[],"length":0,"stats":{"Line":8}},{"line":26,"address":[],"length":0,"stats":{"Line":8}},{"line":27,"address":[],"length":0,"stats":{"Line":8}},{"line":28,"address":[],"length":0,"stats":{"Line":8}},{"line":29,"address":[],"length":0,"stats":{"Line":8}},{"line":30,"address":[],"length":0,"stats":{"Line":8}},{"line":31,"address":[],"length":0,"stats":{"Line":8}},{"line":35,"address":[],"length":0,"stats":{"Line":20}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":39,"address":[],"length":0,"stats":{"Line":6}},{"line":40,"address":[],"length":0,"stats":{"Line":4}},{"line":41,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":1}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":47,"address":[],"length":0,"stats":{"Line":2}},{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":2}},{"line":50,"address":[],"length":0,"stats":{"Line":2}},{"line":51,"address":[],"length":0,"stats":{"Line":2}},{"line":54,"address":[],"length":0,"stats":{"Line":2}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":4}},{"line":59,"address":[],"length":0,"stats":{"Line":2}},{"line":60,"address":[],"length":0,"stats":{"Line":2}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":63,"address":[],"length":0,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":2}},{"line":65,"address":[],"length":0,"stats":{"Line":2}},{"line":66,"address":[],"length":0,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":2}},{"line":68,"address":[],"length":0,"stats":{"Line":2}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":75,"address":[],"length":0,"stats":{"Line":2}},{"line":76,"address":[],"length":0,"stats":{"Line":6}},{"line":79,"address":[],"length":0,"stats":{"Line":11}},{"line":81,"address":[],"length":0,"stats":{"Line":6}},{"line":82,"address":[],"length":0,"stats":{"Line":6}},{"line":83,"address":[],"length":0,"stats":{"Line":6}},{"line":84,"address":[],"length":0,"stats":{"Line":6}},{"line":85,"address":[],"length":0,"stats":{"Line":6}},{"line":86,"address":[],"length":0,"stats":{"Line":6}},{"line":87,"address":[],"length":0,"stats":{"Line":6}},{"line":88,"address":[],"length":0,"stats":{"Line":6}},{"line":89,"address":[],"length":0,"stats":{"Line":6}},{"line":90,"address":[],"length":0,"stats":{"Line":6}},{"line":91,"address":[],"length":0,"stats":{"Line":6}},{"line":94,"address":[],"length":0,"stats":{"Line":12}},{"line":97,"address":[],"length":0,"stats":{"Line":3}},{"line":98,"address":[],"length":0,"stats":{"Line":9}},{"line":99,"address":[],"length":0,"stats":{"Line":9}},{"line":102,"address":[],"length":0,"stats":{"Line":13}},{"line":104,"address":[],"length":0,"stats":{"Line":2}},{"line":105,"address":[],"length":0,"stats":{"Line":2}},{"line":106,"address":[],"length":0,"stats":{"Line":2}},{"line":107,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":2}},{"line":109,"address":[],"length":0,"stats":{"Line":2}},{"line":110,"address":[],"length":0,"stats":{"Line":2}},{"line":113,"address":[],"length":0,"stats":{"Line":11}},{"line":116,"address":[],"length":0,"stats":{"Line":3}},{"line":117,"address":[],"length":0,"stats":{"Line":9}},{"line":118,"address":[],"length":0,"stats":{"Line":2}},{"line":119,"address":[],"length":0,"stats":{"Line":3}},{"line":120,"address":[],"length":0,"stats":{"Line":2}},{"line":122,"address":[],"length":0,"stats":{"Line":2}},{"line":123,"address":[],"length":0,"stats":{"Line":4}},{"line":124,"address":[],"length":0,"stats":{"Line":2}},{"line":125,"address":[],"length":0,"stats":{"Line":2}},{"line":129,"address":[],"length":0,"stats":{"Line":12}},{"line":130,"address":[],"length":0,"stats":{"Line":19}},{"line":132,"address":[],"length":0,"stats":{"Line":8}},{"line":133,"address":[],"length":0,"stats":{"Line":8}},{"line":134,"address":[],"length":0,"stats":{"Line":8}},{"line":135,"address":[],"length":0,"stats":{"Line":8}},{"line":136,"address":[],"length":0,"stats":{"Line":8}},{"line":139,"address":[],"length":0,"stats":{"Line":17}},{"line":142,"address":[],"length":0,"stats":{"Line":3}},{"line":143,"address":[],"length":0,"stats":{"Line":9}},{"line":144,"address":[],"length":0,"stats":{"Line":1}},{"line":145,"address":[],"length":0,"stats":{"Line":3}},{"line":147,"address":[],"length":0,"stats":{"Line":3}},{"line":148,"address":[],"length":0,"stats":{"Line":1}},{"line":151,"address":[],"length":0,"stats":{"Line":2}},{"line":152,"address":[],"length":0,"stats":{"Line":4}},{"line":153,"address":[],"length":0,"stats":{"Line":2}},{"line":157,"address":[],"length":0,"stats":{"Line":12}},{"line":158,"address":[],"length":0,"stats":{"Line":18}},{"line":160,"address":[],"length":0,"stats":{"Line":6}},{"line":161,"address":[],"length":0,"stats":{"Line":6}},{"line":162,"address":[],"length":0,"stats":{"Line":6}},{"line":163,"address":[],"length":0,"stats":{"Line":6}},{"line":164,"address":[],"length":0,"stats":{"Line":6}},{"line":165,"address":[],"length":0,"stats":{"Line":6}},{"line":168,"address":[],"length":0,"stats":{"Line":15}},{"line":171,"address":[],"length":0,"stats":{"Line":3}},{"line":172,"address":[],"length":0,"stats":{"Line":24}},{"line":174,"address":[],"length":0,"stats":{"Line":15}},{"line":175,"address":[],"length":0,"stats":{"Line":1}},{"line":176,"address":[],"length":0,"stats":{"Line":4}},{"line":178,"address":[],"length":0,"stats":{"Line":1}},{"line":179,"address":[],"length":0,"stats":{"Line":2}},{"line":181,"address":[],"length":0,"stats":{"Line":4}},{"line":183,"address":[],"length":0,"stats":{"Line":1}},{"line":184,"address":[],"length":0,"stats":{"Line":2}},{"line":186,"address":[],"length":0,"stats":{"Line":4}},{"line":188,"address":[],"length":0,"stats":{"Line":1}},{"line":189,"address":[],"length":0,"stats":{"Line":2}},{"line":191,"address":[],"length":0,"stats":{"Line":4}},{"line":193,"address":[],"length":0,"stats":{"Line":1}},{"line":194,"address":[],"length":0,"stats":{"Line":2}},{"line":196,"address":[],"length":0,"stats":{"Line":3}},{"line":199,"address":[],"length":0,"stats":{"Line":16}},{"line":200,"address":[],"length":0,"stats":{"Line":4}},{"line":201,"address":[],"length":0,"stats":{"Line":10}},{"line":202,"address":[],"length":0,"stats":{"Line":4}},{"line":204,"address":[],"length":0,"stats":{"Line":8}},{"line":207,"address":[],"length":0,"stats":{"Line":4}},{"line":209,"address":[],"length":0,"stats":{"Line":8}},{"line":212,"address":[],"length":0,"stats":{"Line":4}},{"line":214,"address":[],"length":0,"stats":{"Line":6}},{"line":218,"address":[],"length":0,"stats":{"Line":3}},{"line":219,"address":[],"length":0,"stats":{"Line":6}},{"line":220,"address":[],"length":0,"stats":{"Line":6}},{"line":221,"address":[],"length":0,"stats":{"Line":6}},{"line":222,"address":[],"length":0,"stats":{"Line":3}},{"line":223,"address":[],"length":0,"stats":{"Line":3}},{"line":227,"address":[],"length":0,"stats":{"Line":3}},{"line":228,"address":[],"length":0,"stats":{"Line":12}},{"line":229,"address":[],"length":0,"stats":{"Line":2}},{"line":230,"address":[],"length":0,"stats":{"Line":3}},{"line":231,"address":[],"length":0,"stats":{"Line":1}},{"line":233,"address":[],"length":0,"stats":{"Line":2}},{"line":234,"address":[],"length":0,"stats":{"Line":4}},{"line":235,"address":[],"length":0,"stats":{"Line":2}},{"line":239,"address":[],"length":0,"stats":{"Line":12}},{"line":240,"address":[],"length":0,"stats":{"Line":16}},{"line":242,"address":[],"length":0,"stats":{"Line":2}},{"line":243,"address":[],"length":0,"stats":{"Line":2}},{"line":244,"address":[],"length":0,"stats":{"Line":2}},{"line":245,"address":[],"length":0,"stats":{"Line":2}},{"line":246,"address":[],"length":0,"stats":{"Line":2}},{"line":249,"address":[],"length":0,"stats":{"Line":11}},{"line":252,"address":[],"length":0,"stats":{"Line":2}},{"line":253,"address":[],"length":0,"stats":{"Line":6}},{"line":256,"address":[],"length":0,"stats":{"Line":10}},{"line":258,"address":[],"length":0,"stats":{"Line":4}},{"line":259,"address":[],"length":0,"stats":{"Line":4}},{"line":260,"address":[],"length":0,"stats":{"Line":4}},{"line":263,"address":[],"length":0,"stats":{"Line":10}},{"line":266,"address":[],"length":0,"stats":{"Line":2}},{"line":267,"address":[],"length":0,"stats":{"Line":6}},{"line":270,"address":[],"length":0,"stats":{"Line":10}},{"line":272,"address":[],"length":0,"stats":{"Line":4}},{"line":273,"address":[],"length":0,"stats":{"Line":4}},{"line":274,"address":[],"length":0,"stats":{"Line":4}},{"line":275,"address":[],"length":0,"stats":{"Line":4}},{"line":278,"address":[],"length":0,"stats":{"Line":10}},{"line":281,"address":[],"length":0,"stats":{"Line":4}},{"line":286,"address":[],"length":0,"stats":{"Line":16}},{"line":287,"address":[],"length":0,"stats":{"Line":1}},{"line":288,"address":[],"length":0,"stats":{"Line":3}},{"line":290,"address":[],"length":0,"stats":{"Line":3}},{"line":291,"address":[],"length":0,"stats":{"Line":2}},{"line":294,"address":[],"length":0,"stats":{"Line":3}},{"line":295,"address":[],"length":0,"stats":{"Line":9}},{"line":296,"address":[],"length":0,"stats":{"Line":3}},{"line":300,"address":[],"length":0,"stats":{"Line":16}},{"line":301,"address":[],"length":0,"stats":{"Line":24}},{"line":303,"address":[],"length":0,"stats":{"Line":8}},{"line":304,"address":[],"length":0,"stats":{"Line":8}},{"line":305,"address":[],"length":0,"stats":{"Line":12}},{"line":306,"address":[],"length":0,"stats":{"Line":8}},{"line":307,"address":[],"length":0,"stats":{"Line":8}},{"line":308,"address":[],"length":0,"stats":{"Line":8}},{"line":309,"address":[],"length":0,"stats":{"Line":8}},{"line":312,"address":[],"length":0,"stats":{"Line":20}},{"line":315,"address":[],"length":0,"stats":{"Line":2}},{"line":316,"address":[],"length":0,"stats":{"Line":6}},{"line":318,"address":[],"length":0,"stats":{"Line":2}},{"line":319,"address":[],"length":0,"stats":{"Line":2}},{"line":321,"address":[],"length":0,"stats":{"Line":4}},{"line":322,"address":[],"length":0,"stats":{"Line":4}},{"line":323,"address":[],"length":0,"stats":{"Line":4}},{"line":327,"address":[],"length":0,"stats":{"Line":2}},{"line":330,"address":[],"length":0,"stats":{"Line":2}},{"line":331,"address":[],"length":0,"stats":{"Line":6}},{"line":334,"address":[],"length":0,"stats":{"Line":9}},{"line":336,"address":[],"length":0,"stats":{"Line":2}},{"line":337,"address":[],"length":0,"stats":{"Line":2}},{"line":338,"address":[],"length":0,"stats":{"Line":2}},{"line":341,"address":[],"length":0,"stats":{"Line":8}}],"covered":205,"coverable":205},{"path":["/","Users","chi","Projects","hu","src","data","schema.rs"],"content":"use anyhow::Result;\nuse rusqlite::Connection;\n\nconst MIGRATION_V1: \u0026str = r#\"\nCREATE TABLE IF NOT EXISTS schema_version (\n    version INTEGER PRIMARY KEY,\n    applied_at INTEGER NOT NULL\n);\n\nCREATE TABLE IF NOT EXISTS sessions (\n    id TEXT PRIMARY KEY,\n    project TEXT NOT NULL,\n    display TEXT,\n    started_at INTEGER NOT NULL,\n    message_count INTEGER DEFAULT 0,\n    total_cost_usd REAL DEFAULT 0\n);\nCREATE INDEX IF NOT EXISTS idx_sessions_project ON sessions(project);\nCREATE INDEX IF NOT EXISTS idx_sessions_started_at ON sessions(started_at);\n\nCREATE TABLE IF NOT EXISTS messages (\n    id TEXT PRIMARY KEY,\n    session_id TEXT NOT NULL,\n    parent_id TEXT,\n    role TEXT NOT NULL,\n    content TEXT,\n    model TEXT,\n    input_tokens INTEGER,\n    output_tokens INTEGER,\n    cost_usd REAL,\n    duration_ms INTEGER,\n    created_at INTEGER NOT NULL,\n    FOREIGN KEY (session_id) REFERENCES sessions(id)\n);\nCREATE INDEX IF NOT EXISTS idx_messages_session ON messages(session_id);\nCREATE INDEX IF NOT EXISTS idx_messages_created ON messages(created_at);\n\nCREATE VIRTUAL TABLE IF NOT EXISTS messages_fts USING fts5(\n    content,\n    content=messages,\n    content_rowid=rowid\n);\n\nCREATE TRIGGER IF NOT EXISTS messages_ai AFTER INSERT ON messages BEGIN\n    INSERT INTO messages_fts(rowid, content) VALUES (NEW.rowid, NEW.content);\nEND;\n\nCREATE TRIGGER IF NOT EXISTS messages_ad AFTER DELETE ON messages BEGIN\n    INSERT INTO messages_fts(messages_fts, rowid, content)\n        VALUES('delete', OLD.rowid, OLD.content);\nEND;\n\nCREATE TRIGGER IF NOT EXISTS messages_au AFTER UPDATE ON messages BEGIN\n    INSERT INTO messages_fts(messages_fts, rowid, content)\n        VALUES('delete', OLD.rowid, OLD.content);\n    INSERT INTO messages_fts(rowid, content) VALUES (NEW.rowid, NEW.content);\nEND;\n\nCREATE TABLE IF NOT EXISTS todos (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    session_id TEXT NOT NULL,\n    content TEXT NOT NULL,\n    status TEXT NOT NULL DEFAULT 'pending',\n    active_form TEXT,\n    FOREIGN KEY (session_id) REFERENCES sessions(id)\n);\nCREATE INDEX IF NOT EXISTS idx_todos_session ON todos(session_id);\nCREATE INDEX IF NOT EXISTS idx_todos_status ON todos(status);\n\nCREATE TABLE IF NOT EXISTS tool_usage (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    session_id TEXT NOT NULL,\n    message_id TEXT,\n    tool_name TEXT NOT NULL,\n    input_json TEXT,\n    output_json TEXT,\n    duration_ms INTEGER,\n    created_at INTEGER NOT NULL,\n    FOREIGN KEY (session_id) REFERENCES sessions(id)\n);\nCREATE INDEX IF NOT EXISTS idx_tool_usage_session ON tool_usage(session_id);\nCREATE INDEX IF NOT EXISTS idx_tool_usage_tool ON tool_usage(tool_name);\n\nCREATE TABLE IF NOT EXISTS sync_state (\n    source TEXT PRIMARY KEY,\n    last_sync_at INTEGER NOT NULL,\n    last_modified_at INTEGER,\n    checksum TEXT\n);\n\"#;\n\nconst MIGRATION_V2: \u0026str = r#\"\nALTER TABLE sessions ADD COLUMN git_branch TEXT;\nCREATE INDEX IF NOT EXISTS idx_sessions_git_branch ON sessions(git_branch);\n\"#;\n\nstruct Migration {\n    version: i64,\n    sql: \u0026'static str,\n}\n\nconst MIGRATIONS: \u0026[Migration] = \u0026[\n    Migration {\n        version: 1,\n        sql: MIGRATION_V1,\n    },\n    Migration {\n        version: 2,\n        sql: MIGRATION_V2,\n    },\n];\n\npub fn get_schema_version(conn: \u0026Connection) -\u003e Result\u003ci64\u003e {\n    // Check if schema_version table exists\n    let exists: bool = conn.query_row(\n        \"SELECT COUNT(*) \u003e 0 FROM sqlite_master WHERE type='table' AND name='schema_version'\",\n        [],\n        |row| row.get(0),\n    )?;\n\n    if !exists {\n        return Ok(0);\n    }\n\n    let version: i64 = conn.query_row(\n        \"SELECT COALESCE(MAX(version), 0) FROM schema_version\",\n        [],\n        |row| row.get(0),\n    )?;\n    Ok(version)\n}\n\npub fn run_migrations(conn: \u0026Connection) -\u003e Result\u003c()\u003e {\n    let current = get_schema_version(conn)?;\n\n    for migration in MIGRATIONS {\n        if migration.version \u003e current {\n            conn.execute_batch(migration.sql)?;\n\n            let now = chrono::Utc::now().timestamp_millis();\n            conn.execute(\n                \"INSERT INTO schema_version (version, applied_at) VALUES (?1, ?2)\",\n                rusqlite::params![migration.version, now],\n            )?;\n        }\n    }\n\n    Ok(())\n}\n\npub fn initialize_schema(conn: \u0026Connection) -\u003e Result\u003c()\u003e {\n    run_migrations(conn)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn open_memory() -\u003e Connection {\n        let conn = Connection::open_in_memory().unwrap();\n        conn.execute_batch(\"PRAGMA journal_mode=WAL; PRAGMA foreign_keys=ON;\")\n            .unwrap();\n        conn\n    }\n\n    #[test]\n    fn schema_version_no_table() {\n        let conn = open_memory();\n        assert_eq!(get_schema_version(\u0026conn).unwrap(), 0);\n    }\n\n    #[test]\n    fn initialize_creates_tables() {\n        let conn = open_memory();\n        initialize_schema(\u0026conn).unwrap();\n\n        let version = get_schema_version(\u0026conn).unwrap();\n        assert_eq!(version, 2);\n\n        // Verify tables exist\n        let tables: Vec\u003cString\u003e = conn\n            .prepare(\"SELECT name FROM sqlite_master WHERE type='table' ORDER BY name\")\n            .unwrap()\n            .query_map([], |row| row.get(0))\n            .unwrap()\n            .filter_map(|r| r.ok())\n            .collect();\n\n        assert!(tables.contains(\u0026\"sessions\".to_string()));\n        assert!(tables.contains(\u0026\"messages\".to_string()));\n        assert!(tables.contains(\u0026\"todos\".to_string()));\n        assert!(tables.contains(\u0026\"tool_usage\".to_string()));\n        assert!(tables.contains(\u0026\"sync_state\".to_string()));\n        assert!(tables.contains(\u0026\"schema_version\".to_string()));\n    }\n\n    #[test]\n    fn initialize_is_idempotent() {\n        let conn = open_memory();\n        initialize_schema(\u0026conn).unwrap();\n        initialize_schema(\u0026conn).unwrap();\n        assert_eq!(get_schema_version(\u0026conn).unwrap(), 2);\n    }\n\n    #[test]\n    fn migration_v2_adds_git_branch() {\n        let conn = open_memory();\n        initialize_schema(\u0026conn).unwrap();\n\n        // Verify git_branch column exists by inserting with it\n        conn.execute(\n            \"INSERT INTO sessions (id, project, started_at, git_branch) VALUES ('s1', '/p', 100, 'main')\",\n            [],\n        )\n        .unwrap();\n\n        let branch: Option\u003cString\u003e = conn\n            .query_row(\n                \"SELECT git_branch FROM sessions WHERE id = 's1'\",\n                [],\n                |row| row.get(0),\n            )\n            .unwrap();\n        assert_eq!(branch, Some(\"main\".to_string()));\n    }\n\n    #[test]\n    fn fts_trigger_inserts() {\n        let conn = open_memory();\n        initialize_schema(\u0026conn).unwrap();\n\n        conn.execute(\n            \"INSERT INTO sessions (id, project, started_at) VALUES ('s1', '/p', 100)\",\n            [],\n        )\n        .unwrap();\n        conn.execute(\n            \"INSERT INTO messages (id, session_id, role, content, created_at) VALUES ('m1', 's1', 'user', 'hello world', 100)\",\n            [],\n        )\n        .unwrap();\n\n        let fts_count: i64 = conn\n            .query_row(\n                \"SELECT COUNT(*) FROM messages_fts WHERE messages_fts MATCH 'hello'\",\n                [],\n                |row| row.get(0),\n            )\n            .unwrap();\n        assert_eq!(fts_count, 1);\n    }\n\n    #[test]\n    fn fts_trigger_deletes() {\n        let conn = open_memory();\n        initialize_schema(\u0026conn).unwrap();\n\n        conn.execute(\n            \"INSERT INTO sessions (id, project, started_at) VALUES ('s1', '/p', 100)\",\n            [],\n        )\n        .unwrap();\n        conn.execute(\n            \"INSERT INTO messages (id, session_id, role, content, created_at) VALUES ('m1', 's1', 'user', 'unique_test_word', 100)\",\n            [],\n        )\n        .unwrap();\n\n        // Delete should propagate to FTS\n        conn.execute_batch(\"PRAGMA foreign_keys=OFF;\").unwrap();\n        conn.execute(\"DELETE FROM messages WHERE id = 'm1'\", [])\n            .unwrap();\n\n        let fts_count: i64 = conn\n            .query_row(\n                \"SELECT COUNT(*) FROM messages_fts WHERE messages_fts MATCH 'unique_test_word'\",\n                [],\n                |row| row.get(0),\n            )\n            .unwrap();\n        assert_eq!(fts_count, 0);\n    }\n\n    #[test]\n    fn schema_version_tracks_migrations() {\n        let conn = open_memory();\n        initialize_schema(\u0026conn).unwrap();\n\n        let count: i64 = conn\n            .query_row(\"SELECT COUNT(*) FROM schema_version\", [], |row| row.get(0))\n            .unwrap();\n        assert_eq!(count, 2); // v1 + v2\n    }\n}\n","traces":[{"line":113,"address":[],"length":0,"stats":{"Line":72}},{"line":115,"address":[],"length":0,"stats":{"Line":288}},{"line":118,"address":[],"length":0,"stats":{"Line":144}},{"line":121,"address":[],"length":0,"stats":{"Line":72}},{"line":122,"address":[],"length":0,"stats":{"Line":69}},{"line":125,"address":[],"length":0,"stats":{"Line":12}},{"line":128,"address":[],"length":0,"stats":{"Line":6}},{"line":130,"address":[],"length":0,"stats":{"Line":3}},{"line":133,"address":[],"length":0,"stats":{"Line":69}},{"line":134,"address":[],"length":0,"stats":{"Line":207}},{"line":136,"address":[],"length":0,"stats":{"Line":345}},{"line":137,"address":[],"length":0,"stats":{"Line":138}},{"line":138,"address":[],"length":0,"stats":{"Line":408}},{"line":140,"address":[],"length":0,"stats":{"Line":408}},{"line":141,"address":[],"length":0,"stats":{"Line":272}},{"line":143,"address":[],"length":0,"stats":{"Line":136}},{"line":148,"address":[],"length":0,"stats":{"Line":69}},{"line":151,"address":[],"length":0,"stats":{"Line":69}},{"line":152,"address":[],"length":0,"stats":{"Line":138}}],"covered":19,"coverable":19},{"path":["/","Users","chi","Projects","hu","src","data","sync.rs"],"content":"use anyhow::Result;\nuse rusqlite::Connection;\nuse rusqlite::OptionalExtension;\nuse std::path::Path;\n\nuse super::paths;\nuse super::types::{HistoryEntry, MessageEntry, SyncResult, TodoEntry};\n\npub fn get_last_sync_time(conn: \u0026Connection, source: \u0026str) -\u003e Result\u003ci64\u003e {\n    let result: Option\u003ci64\u003e = conn\n        .query_row(\n            \"SELECT last_sync_at FROM sync_state WHERE source = ?1\",\n            rusqlite::params![source],\n            |row| row.get(0),\n        )\n        .optional()?;\n    Ok(result.unwrap_or(0))\n}\n\npub fn update_sync_state(conn: \u0026Connection, source: \u0026str) -\u003e Result\u003c()\u003e {\n    let now = chrono::Utc::now().timestamp_millis();\n    conn.execute(\n        \"INSERT OR REPLACE INTO sync_state (source, last_sync_at, last_modified_at) VALUES (?1, ?2, ?3)\",\n        rusqlite::params![source, now, now],\n    )?;\n    Ok(())\n}\n\npub fn needs_sync(conn: \u0026Connection, source: \u0026str, interval_secs: u64) -\u003e Result\u003cbool\u003e {\n    if interval_secs == 0 {\n        return Ok(false);\n    }\n    let last = get_last_sync_time(conn, source)?;\n    let now = chrono::Utc::now().timestamp_millis();\n    let interval_ms = interval_secs as i64 * 1000;\n    Ok(now - last \u003e interval_ms)\n}\n\npub fn sync_history(conn: \u0026Connection, claude_dir: \u0026Path) -\u003e Result\u003cusize\u003e {\n    let path = paths::history_path(claude_dir);\n    if !path.exists() {\n        update_sync_state(conn, \"history\")?;\n        return Ok(0);\n    }\n\n    let content = std::fs::read_to_string(\u0026path)?;\n    let entries: Vec\u003cHistoryEntry\u003e = paths::parse_jsonl(\u0026content);\n    let mut count = 0;\n\n    for entry in \u0026entries {\n        let (session_id, project, display, timestamp) = match (\n            entry.session_id.as_deref(),\n            entry.project.as_deref(),\n            entry.timestamp,\n        ) {\n            (Some(id), Some(proj), Some(ts)) =\u003e (id, proj, entry.display.as_deref(), ts as i64),\n            _ =\u003e continue,\n        };\n\n        let changed = conn.execute(\n            \"INSERT OR IGNORE INTO sessions (id, project, display, started_at) VALUES (?1, ?2, ?3, ?4)\",\n            rusqlite::params![session_id, project, display, timestamp],\n        )?;\n        if changed \u003e 0 {\n            count += 1;\n        }\n    }\n\n    update_sync_state(conn, \"history\")?;\n    Ok(count)\n}\n\npub fn sync_sessions(conn: \u0026Connection, claude_dir: \u0026Path) -\u003e Result\u003cusize\u003e {\n    let projects = paths::list_project_dirs(claude_dir)?;\n    let mut total = 0;\n\n    for project in \u0026projects {\n        let sessions = paths::list_session_files(\u0026project.dir)?;\n        for session_file in \u0026sessions {\n            total += sync_session_file(conn, \u0026project.path, session_file)?;\n        }\n    }\n\n    update_sync_state(conn, \"sessions\")?;\n    Ok(total)\n}\n\nfn sync_session_file(\n    conn: \u0026Connection,\n    project_path: \u0026str,\n    session_file: \u0026paths::SessionFile,\n) -\u003e Result\u003cusize\u003e {\n    let content = std::fs::read_to_string(\u0026session_file.path)?;\n    let entries: Vec\u003cMessageEntry\u003e = paths::parse_jsonl(\u0026content);\n    let session_id = \u0026session_file.session_id;\n\n    let tx = conn.unchecked_transaction()?;\n\n    // Ensure session exists\n    let now = chrono::Utc::now().timestamp_millis();\n    tx.execute(\n        \"INSERT OR IGNORE INTO sessions (id, project, started_at) VALUES (?1, ?2, ?3)\",\n        rusqlite::params![session_id, project_path, now],\n    )?;\n\n    // Extract git_branch from first entry that has one\n    let git_branch = entries.iter().find_map(|e| e.git_branch.as_ref());\n    if let Some(branch) = git_branch {\n        tx.execute(\n            \"UPDATE sessions SET git_branch = ?1 WHERE id = ?2 AND git_branch IS NULL\",\n            rusqlite::params![branch, session_id],\n        )?;\n    }\n\n    let mut msg_count = 0;\n\n    for entry in \u0026entries {\n        let uuid = match entry.uuid.as_deref() {\n            Some(id) =\u003e id,\n            None =\u003e continue,\n        };\n\n        let msg = match entry.message.as_ref() {\n            Some(m) =\u003e m,\n            None =\u003e continue,\n        };\n\n        let timestamp_str = match entry.timestamp.as_deref() {\n            Some(ts) =\u003e ts,\n            None =\u003e continue,\n        };\n\n        let created_at = parse_timestamp(timestamp_str);\n        let role = msg.role.as_deref().unwrap_or(\"unknown\");\n\n        let content_str = msg.content.as_ref().map(|c| c.as_string());\n        let model = msg.model.as_deref();\n        let input_tokens = msg.usage.as_ref().and_then(|u| u.input_tokens);\n        let output_tokens = msg.usage.as_ref().and_then(|u| u.output_tokens);\n        let cost_usd = entry.cost_usd;\n        let duration_ms = entry.duration_ms;\n        let parent_id = entry.parent_uuid.as_deref();\n\n        let changed = tx.execute(\n            \"INSERT OR IGNORE INTO messages (id, session_id, parent_id, role, content, model, input_tokens, output_tokens, cost_usd, duration_ms, created_at) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11)\",\n            rusqlite::params![uuid, session_id, parent_id, role, content_str, model, input_tokens, output_tokens, cost_usd, duration_ms, created_at],\n        )?;\n        if changed \u003e 0 {\n            msg_count += 1;\n        }\n\n        // Extract tool usage from assistant messages\n        if role == \"assistant\" {\n            if let Some(content) = msg.content.as_ref() {\n                for block in content.tool_use_blocks() {\n                    let tool_name = match block.name.as_deref() {\n                        Some(n) =\u003e n,\n                        None =\u003e continue,\n                    };\n                    let input_json = block.input.as_ref().map(|v| v.to_string());\n                    tx.execute(\n                        \"INSERT OR IGNORE INTO tool_usage (session_id, message_id, tool_name, input_json, created_at) VALUES (?1, ?2, ?3, ?4, ?5)\",\n                        rusqlite::params![session_id, uuid, tool_name, input_json, created_at],\n                    )?;\n                }\n            }\n        }\n    }\n\n    // Update session stats\n    tx.execute(\n        \"UPDATE sessions SET message_count = (SELECT COUNT(*) FROM messages WHERE session_id = ?1), total_cost_usd = (SELECT COALESCE(SUM(cost_usd), 0) FROM messages WHERE session_id = ?1) WHERE id = ?1\",\n        rusqlite::params![session_id],\n    )?;\n\n    tx.commit()?;\n    Ok(msg_count)\n}\n\nfn parse_timestamp(ts: \u0026str) -\u003e i64 {\n    chrono::DateTime::parse_from_rfc3339(ts)\n        .map(|dt| dt.timestamp_millis())\n        .unwrap_or(0)\n}\n\npub fn sync_todos(conn: \u0026Connection, claude_dir: \u0026Path) -\u003e Result\u003cusize\u003e {\n    let dir = paths::todos_dir(claude_dir);\n    if !dir.exists() {\n        update_sync_state(conn, \"todos\")?;\n        return Ok(0);\n    }\n\n    let mut count = 0;\n    for entry in std::fs::read_dir(\u0026dir)? {\n        let entry = entry?;\n        let name = entry.file_name().to_string_lossy().to_string();\n        if !name.ends_with(\".json\") {\n            continue;\n        }\n\n        let session_id = name.trim_end_matches(\".json\");\n        let content = std::fs::read_to_string(entry.path())?;\n        let todos: Vec\u003cTodoEntry\u003e = match serde_json::from_str(\u0026content) {\n            Ok(t) =\u003e t,\n            Err(_) =\u003e continue,\n        };\n\n        // Ensure session exists (may not be in history.jsonl yet)\n        let now = chrono::Utc::now().timestamp_millis();\n        conn.execute(\n            \"INSERT OR IGNORE INTO sessions (id, project, started_at) VALUES (?1, ?2, ?3)\",\n            rusqlite::params![session_id, \"unknown\", now],\n        )?;\n\n        // Delete existing todos for this session, then re-insert\n        conn.execute(\n            \"DELETE FROM todos WHERE session_id = ?1\",\n            rusqlite::params![session_id],\n        )?;\n\n        for todo in \u0026todos {\n            let todo_content = match todo.content.as_deref() {\n                Some(c) =\u003e c,\n                None =\u003e continue,\n            };\n            let status = todo.status.as_deref().unwrap_or(\"pending\");\n            let active_form = todo.active_form.as_deref();\n\n            conn.execute(\n                \"INSERT INTO todos (session_id, content, status, active_form) VALUES (?1, ?2, ?3, ?4)\",\n                rusqlite::params![session_id, todo_content, status, active_form],\n            )?;\n            count += 1;\n        }\n    }\n\n    update_sync_state(conn, \"todos\")?;\n    Ok(count)\n}\n\npub fn sync_all(conn: \u0026Connection, claude_dir: \u0026Path) -\u003e Result\u003cSyncResult\u003e {\n    let history = sync_history(conn, claude_dir)?;\n    let messages = sync_sessions(conn, claude_dir)?;\n    let todos = sync_todos(conn, claude_dir)?;\n    Ok(SyncResult {\n        history,\n        messages,\n        todos,\n    })\n}\n\npub fn sync_if_needed(conn: \u0026Connection, claude_dir: \u0026Path, interval_secs: u64) -\u003e Result\u003cbool\u003e {\n    let any_needed = needs_sync(conn, \"history\", interval_secs)?\n        || needs_sync(conn, \"sessions\", interval_secs)?\n        || needs_sync(conn, \"todos\", interval_secs)?;\n\n    if any_needed {\n        sync_all(conn, claude_dir)?;\n        Ok(true)\n    } else {\n        Ok(false)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::data::db::open_test_db;\n\n    #[test]\n    fn get_last_sync_no_record() {\n        let store = open_test_db();\n        assert_eq!(get_last_sync_time(\u0026store.conn, \"history\").unwrap(), 0);\n    }\n\n    #[test]\n    fn update_and_get_sync_time() {\n        let store = open_test_db();\n        update_sync_state(\u0026store.conn, \"history\").unwrap();\n        let time = get_last_sync_time(\u0026store.conn, \"history\").unwrap();\n        assert!(time \u003e 0);\n    }\n\n    #[test]\n    fn needs_sync_zero_interval() {\n        let store = open_test_db();\n        assert!(!needs_sync(\u0026store.conn, \"test\", 0).unwrap());\n    }\n\n    #[test]\n    fn needs_sync_no_prior() {\n        let store = open_test_db();\n        assert!(needs_sync(\u0026store.conn, \"test\", 300).unwrap());\n    }\n\n    #[test]\n    fn needs_sync_recent() {\n        let store = open_test_db();\n        update_sync_state(\u0026store.conn, \"test\").unwrap();\n        assert!(!needs_sync(\u0026store.conn, \"test\", 300).unwrap());\n    }\n\n    #[test]\n    fn sync_history_missing_file() {\n        let store = open_test_db();\n        let result = sync_history(\u0026store.conn, Path::new(\"/nonexistent\")).unwrap();\n        assert_eq!(result, 0);\n    }\n\n    #[test]\n    fn sync_history_from_fixture() {\n        let store = open_test_db();\n        let tmp = std::env::temp_dir().join(\"hu-test-sync-history\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n        std::fs::create_dir_all(\u0026tmp).unwrap();\n\n        let jsonl = r#\"{\"display\":\"test session\",\"timestamp\":1700000000000,\"project\":\"/home/user/proj\",\"sessionId\":\"sess-001\"}\n{\"display\":\"another\",\"timestamp\":1700001000000,\"project\":\"/home/user/proj2\",\"sessionId\":\"sess-002\"}\n\"#;\n        std::fs::write(tmp.join(\"history.jsonl\"), jsonl).unwrap();\n\n        let count = sync_history(\u0026store.conn, \u0026tmp).unwrap();\n        assert_eq!(count, 2);\n\n        // Verify data\n        let session_count: i64 = store\n            .conn\n            .query_row(\"SELECT COUNT(*) FROM sessions\", [], |r| r.get(0))\n            .unwrap();\n        assert_eq!(session_count, 2);\n\n        // Idempotent\n        let count2 = sync_history(\u0026store.conn, \u0026tmp).unwrap();\n        assert_eq!(count2, 0);\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn sync_history_skips_incomplete() {\n        let store = open_test_db();\n        let tmp = std::env::temp_dir().join(\"hu-test-sync-hist-skip\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n        std::fs::create_dir_all(\u0026tmp).unwrap();\n\n        let jsonl = r#\"{\"display\":\"no session id\",\"timestamp\":1700000000000,\"project\":\"/proj\"}\n{\"display\":\"no timestamp\",\"project\":\"/proj\",\"sessionId\":\"s1\"}\n{\"display\":\"ok\",\"timestamp\":1700000000000,\"project\":\"/proj\",\"sessionId\":\"s2\"}\n\"#;\n        std::fs::write(tmp.join(\"history.jsonl\"), jsonl).unwrap();\n\n        let count = sync_history(\u0026store.conn, \u0026tmp).unwrap();\n        assert_eq!(count, 1);\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn sync_sessions_from_fixture() {\n        let store = open_test_db();\n        let tmp = std::env::temp_dir().join(\"hu-test-sync-sessions\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n\n        let proj_dir = tmp.join(\"projects\").join(\"-home-user-proj\");\n        std::fs::create_dir_all(\u0026proj_dir).unwrap();\n\n        let jsonl = r#\"{\"uuid\":\"m1\",\"type\":\"user\",\"timestamp\":\"2024-01-01T00:00:00Z\",\"gitBranch\":\"main\",\"message\":{\"role\":\"user\",\"content\":\"hello\",\"usage\":{\"input_tokens\":10,\"output_tokens\":0}}}\n{\"uuid\":\"m2\",\"parentUuid\":\"m1\",\"type\":\"assistant\",\"timestamp\":\"2024-01-01T00:00:01Z\",\"message\":{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"hi\"},{\"type\":\"tool_use\",\"name\":\"Read\",\"input\":{\"path\":\"/tmp\"}}],\"model\":\"claude-sonnet-4-5-20251101\",\"usage\":{\"input_tokens\":10,\"output_tokens\":50}},\"costUSD\":0.001,\"durationMs\":500}\n\"#;\n        std::fs::write(proj_dir.join(\"sess-001.jsonl\"), jsonl).unwrap();\n\n        let count = sync_sessions(\u0026store.conn, \u0026tmp).unwrap();\n        assert_eq!(count, 2);\n\n        // Check session was created with git_branch\n        let branch: Option\u003cString\u003e = store\n            .conn\n            .query_row(\n                \"SELECT git_branch FROM sessions WHERE id = 'sess-001'\",\n                [],\n                |r| r.get(0),\n            )\n            .unwrap();\n        assert_eq!(branch, Some(\"main\".to_string()));\n\n        // Check tool usage\n        let tool_count: i64 = store\n            .conn\n            .query_row(\"SELECT COUNT(*) FROM tool_usage\", [], |r| r.get(0))\n            .unwrap();\n        assert_eq!(tool_count, 1);\n\n        // Check message stats updated\n        let msg_count: i64 = store\n            .conn\n            .query_row(\n                \"SELECT message_count FROM sessions WHERE id = 'sess-001'\",\n                [],\n                |r| r.get(0),\n            )\n            .unwrap();\n        assert_eq!(msg_count, 2);\n\n        // Idempotent\n        let count2 = sync_sessions(\u0026store.conn, \u0026tmp).unwrap();\n        assert_eq!(count2, 0);\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn sync_sessions_skips_non_message_entries() {\n        let store = open_test_db();\n        let tmp = std::env::temp_dir().join(\"hu-test-sync-skip-types\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n\n        let proj_dir = tmp.join(\"projects\").join(\"-home-user-proj\");\n        std::fs::create_dir_all(\u0026proj_dir).unwrap();\n\n        let jsonl = r#\"{\"uuid\":\"m1\",\"type\":\"summary\",\"timestamp\":\"2024-01-01T00:00:00Z\"}\n{\"uuid\":\"m2\",\"type\":\"user\",\"timestamp\":\"2024-01-01T00:00:01Z\",\"message\":{\"role\":\"user\",\"content\":\"hello\"}}\n\"#;\n        std::fs::write(proj_dir.join(\"sess-002.jsonl\"), jsonl).unwrap();\n\n        let count = sync_sessions(\u0026store.conn, \u0026tmp).unwrap();\n        assert_eq!(count, 1); // Only the message with message body\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn sync_todos_missing_dir() {\n        let store = open_test_db();\n        let result = sync_todos(\u0026store.conn, Path::new(\"/nonexistent\")).unwrap();\n        assert_eq!(result, 0);\n    }\n\n    #[test]\n    fn sync_todos_from_fixture() {\n        let store = open_test_db();\n        let tmp = std::env::temp_dir().join(\"hu-test-sync-todos\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n\n        // Need a session first\n        store\n            .conn\n            .execute(\n                \"INSERT INTO sessions (id, project, started_at) VALUES ('sess-t1', '/proj', 100)\",\n                [],\n            )\n            .unwrap();\n\n        let todos_dir = tmp.join(\"todos\");\n        std::fs::create_dir_all(\u0026todos_dir).unwrap();\n\n        let json = r#\"[\n            {\"content\":\"Fix bug\",\"status\":\"pending\",\"activeForm\":\"Fixing bug\"},\n            {\"content\":\"Add tests\",\"status\":\"completed\"}\n        ]\"#;\n        std::fs::write(todos_dir.join(\"sess-t1.json\"), json).unwrap();\n\n        let count = sync_todos(\u0026store.conn, \u0026tmp).unwrap();\n        assert_eq!(count, 2);\n\n        let todo_count: i64 = store\n            .conn\n            .query_row(\"SELECT COUNT(*) FROM todos\", [], |r| r.get(0))\n            .unwrap();\n        assert_eq!(todo_count, 2);\n\n        // Re-sync replaces (delete + insert)\n        let count2 = sync_todos(\u0026store.conn, \u0026tmp).unwrap();\n        assert_eq!(count2, 2);\n        let todo_count2: i64 = store\n            .conn\n            .query_row(\"SELECT COUNT(*) FROM todos\", [], |r| r.get(0))\n            .unwrap();\n        assert_eq!(todo_count2, 2);\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn sync_todos_skips_invalid_json() {\n        let store = open_test_db();\n        let tmp = std::env::temp_dir().join(\"hu-test-sync-todos-bad\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n\n        let todos_dir = tmp.join(\"todos\");\n        std::fs::create_dir_all(\u0026todos_dir).unwrap();\n        std::fs::write(todos_dir.join(\"bad-session.json\"), \"not json\").unwrap();\n\n        let count = sync_todos(\u0026store.conn, \u0026tmp).unwrap();\n        assert_eq!(count, 0);\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn sync_all_from_fixture() {\n        let store = open_test_db();\n        let tmp = std::env::temp_dir().join(\"hu-test-sync-all\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n        std::fs::create_dir_all(\u0026tmp).unwrap();\n\n        // Empty claude dir\n        let result = sync_all(\u0026store.conn, \u0026tmp).unwrap();\n        assert_eq!(result.history, 0);\n        assert_eq!(result.messages, 0);\n        assert_eq!(result.todos, 0);\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn sync_if_needed_fresh_db() {\n        let store = open_test_db();\n        let tmp = std::env::temp_dir().join(\"hu-test-sync-needed\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n        std::fs::create_dir_all(\u0026tmp).unwrap();\n\n        let synced = sync_if_needed(\u0026store.conn, \u0026tmp, 300).unwrap();\n        assert!(synced);\n\n        // After sync, should not need again\n        let synced2 = sync_if_needed(\u0026store.conn, \u0026tmp, 300).unwrap();\n        assert!(!synced2);\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn parse_timestamp_valid() {\n        let ts = parse_timestamp(\"2024-01-01T00:00:00Z\");\n        assert!(ts \u003e 0);\n    }\n\n    #[test]\n    fn parse_timestamp_invalid() {\n        let ts = parse_timestamp(\"not a date\");\n        assert_eq!(ts, 0);\n    }\n\n    #[test]\n    fn sync_todos_skips_non_json() {\n        let store = open_test_db();\n        let tmp = std::env::temp_dir().join(\"hu-test-sync-todos-nonjson\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n\n        let todos_dir = tmp.join(\"todos\");\n        std::fs::create_dir_all(\u0026todos_dir).unwrap();\n        std::fs::write(todos_dir.join(\"notes.txt\"), \"not a todo file\").unwrap();\n\n        let count = sync_todos(\u0026store.conn, \u0026tmp).unwrap();\n        assert_eq!(count, 0);\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn sync_sessions_skips_missing_uuid() {\n        let store = open_test_db();\n        let tmp = std::env::temp_dir().join(\"hu-test-sync-no-uuid\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n\n        let proj_dir = tmp.join(\"projects\").join(\"-home-user-proj\");\n        std::fs::create_dir_all(\u0026proj_dir).unwrap();\n\n        // Entry without uuid should be skipped\n        let jsonl = r#\"{\"type\":\"user\",\"timestamp\":\"2024-01-01T00:00:00Z\",\"message\":{\"role\":\"user\",\"content\":\"hello\"}}\n{\"uuid\":\"m1\",\"type\":\"user\",\"timestamp\":\"2024-01-01T00:00:01Z\",\"message\":{\"role\":\"user\",\"content\":\"world\"}}\n\"#;\n        std::fs::write(proj_dir.join(\"sess-nouuid.jsonl\"), jsonl).unwrap();\n\n        let count = sync_sessions(\u0026store.conn, \u0026tmp).unwrap();\n        assert_eq!(count, 1); // Only the entry with uuid\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn sync_sessions_skips_missing_timestamp() {\n        let store = open_test_db();\n        let tmp = std::env::temp_dir().join(\"hu-test-sync-no-ts\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n\n        let proj_dir = tmp.join(\"projects\").join(\"-home-user-proj\");\n        std::fs::create_dir_all(\u0026proj_dir).unwrap();\n\n        // Entry with uuid and message but no timestamp should be skipped\n        let jsonl = r#\"{\"uuid\":\"m1\",\"type\":\"user\",\"message\":{\"role\":\"user\",\"content\":\"hello\"}}\n{\"uuid\":\"m2\",\"type\":\"user\",\"timestamp\":\"2024-01-01T00:00:01Z\",\"message\":{\"role\":\"user\",\"content\":\"world\"}}\n\"#;\n        std::fs::write(proj_dir.join(\"sess-nots.jsonl\"), jsonl).unwrap();\n\n        let count = sync_sessions(\u0026store.conn, \u0026tmp).unwrap();\n        assert_eq!(count, 1); // Only the entry with timestamp\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn sync_sessions_skips_nameless_tool_use() {\n        let store = open_test_db();\n        let tmp = std::env::temp_dir().join(\"hu-test-sync-no-toolname\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n\n        let proj_dir = tmp.join(\"projects\").join(\"-home-user-proj\");\n        std::fs::create_dir_all(\u0026proj_dir).unwrap();\n\n        // Assistant message with tool_use block that has no name should skip that block\n        let jsonl = r#\"{\"uuid\":\"m1\",\"type\":\"assistant\",\"timestamp\":\"2024-01-01T00:00:01Z\",\"message\":{\"role\":\"assistant\",\"content\":[{\"type\":\"tool_use\",\"input\":{\"path\":\"/tmp\"}},{\"type\":\"tool_use\",\"name\":\"Read\",\"input\":{\"path\":\"/tmp\"}}],\"model\":\"claude-sonnet-4-5-20251101\",\"usage\":{\"input_tokens\":10,\"output_tokens\":50}}}\n\"#;\n        std::fs::write(proj_dir.join(\"sess-notool.jsonl\"), jsonl).unwrap();\n\n        let count = sync_sessions(\u0026store.conn, \u0026tmp).unwrap();\n        assert_eq!(count, 1);\n\n        // Only one tool_usage row (the one with name \"Read\"), nameless block skipped\n        let tool_count: i64 = store\n            .conn\n            .query_row(\"SELECT COUNT(*) FROM tool_usage\", [], |r| r.get(0))\n            .unwrap();\n        assert_eq!(tool_count, 1);\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn sync_todos_skips_missing_content() {\n        let store = open_test_db();\n        let tmp = std::env::temp_dir().join(\"hu-test-sync-todos-nocontent\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n\n        store\n            .conn\n            .execute(\n                \"INSERT INTO sessions (id, project, started_at) VALUES ('sess-nc', '/proj', 100)\",\n                [],\n            )\n            .unwrap();\n\n        let todos_dir = tmp.join(\"todos\");\n        std::fs::create_dir_all(\u0026todos_dir).unwrap();\n\n        // Todo with no content should be skipped\n        let json = r#\"[\n            {\"status\":\"pending\"},\n            {\"content\":\"Valid todo\",\"status\":\"pending\"}\n        ]\"#;\n        std::fs::write(todos_dir.join(\"sess-nc.json\"), json).unwrap();\n\n        let count = sync_todos(\u0026store.conn, \u0026tmp).unwrap();\n        assert_eq!(count, 1); // Only the valid todo\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn sync_sessions_empty_projects() {\n        let store = open_test_db();\n        let tmp = std::env::temp_dir().join(\"hu-test-sync-empty-proj\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n        std::fs::create_dir_all(tmp.join(\"projects\")).unwrap();\n\n        let count = sync_sessions(\u0026store.conn, \u0026tmp).unwrap();\n        assert_eq!(count, 0);\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":8}},{"line":10,"address":[],"length":0,"stats":{"Line":24}},{"line":13,"address":[],"length":0,"stats":{"Line":8}},{"line":14,"address":[],"length":0,"stats":{"Line":10}},{"line":17,"address":[],"length":0,"stats":{"Line":8}},{"line":20,"address":[],"length":0,"stats":{"Line":25}},{"line":21,"address":[],"length":0,"stats":{"Line":75}},{"line":22,"address":[],"length":0,"stats":{"Line":50}},{"line":24,"address":[],"length":0,"stats":{"Line":25}},{"line":26,"address":[],"length":0,"stats":{"Line":25}},{"line":29,"address":[],"length":0,"stats":{"Line":7}},{"line":30,"address":[],"length":0,"stats":{"Line":7}},{"line":31,"address":[],"length":0,"stats":{"Line":1}},{"line":33,"address":[],"length":0,"stats":{"Line":24}},{"line":34,"address":[],"length":0,"stats":{"Line":18}},{"line":35,"address":[],"length":0,"stats":{"Line":12}},{"line":36,"address":[],"length":0,"stats":{"Line":6}},{"line":39,"address":[],"length":0,"stats":{"Line":6}},{"line":40,"address":[],"length":0,"stats":{"Line":18}},{"line":41,"address":[],"length":0,"stats":{"Line":6}},{"line":42,"address":[],"length":0,"stats":{"Line":9}},{"line":43,"address":[],"length":0,"stats":{"Line":3}},{"line":46,"address":[],"length":0,"stats":{"Line":9}},{"line":47,"address":[],"length":0,"stats":{"Line":12}},{"line":48,"address":[],"length":0,"stats":{"Line":6}},{"line":50,"address":[],"length":0,"stats":{"Line":17}},{"line":51,"address":[],"length":0,"stats":{"Line":20}},{"line":52,"address":[],"length":0,"stats":{"Line":14}},{"line":53,"address":[],"length":0,"stats":{"Line":14}},{"line":54,"address":[],"length":0,"stats":{"Line":7}},{"line":56,"address":[],"length":0,"stats":{"Line":35}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":60,"address":[],"length":0,"stats":{"Line":15}},{"line":62,"address":[],"length":0,"stats":{"Line":5}},{"line":64,"address":[],"length":0,"stats":{"Line":8}},{"line":65,"address":[],"length":0,"stats":{"Line":3}},{"line":69,"address":[],"length":0,"stats":{"Line":9}},{"line":70,"address":[],"length":0,"stats":{"Line":3}},{"line":73,"address":[],"length":0,"stats":{"Line":9}},{"line":74,"address":[],"length":0,"stats":{"Line":27}},{"line":75,"address":[],"length":0,"stats":{"Line":18}},{"line":77,"address":[],"length":0,"stats":{"Line":21}},{"line":78,"address":[],"length":0,"stats":{"Line":18}},{"line":79,"address":[],"length":0,"stats":{"Line":18}},{"line":80,"address":[],"length":0,"stats":{"Line":24}},{"line":84,"address":[],"length":0,"stats":{"Line":27}},{"line":85,"address":[],"length":0,"stats":{"Line":9}},{"line":88,"address":[],"length":0,"stats":{"Line":6}},{"line":93,"address":[],"length":0,"stats":{"Line":18}},{"line":94,"address":[],"length":0,"stats":{"Line":24}},{"line":95,"address":[],"length":0,"stats":{"Line":12}},{"line":97,"address":[],"length":0,"stats":{"Line":18}},{"line":100,"address":[],"length":0,"stats":{"Line":18}},{"line":101,"address":[],"length":0,"stats":{"Line":18}},{"line":103,"address":[],"length":0,"stats":{"Line":6}},{"line":107,"address":[],"length":0,"stats":{"Line":36}},{"line":108,"address":[],"length":0,"stats":{"Line":8}},{"line":109,"address":[],"length":0,"stats":{"Line":6}},{"line":111,"address":[],"length":0,"stats":{"Line":2}},{"line":115,"address":[],"length":0,"stats":{"Line":12}},{"line":117,"address":[],"length":0,"stats":{"Line":28}},{"line":118,"address":[],"length":0,"stats":{"Line":21}},{"line":119,"address":[],"length":0,"stats":{"Line":20}},{"line":120,"address":[],"length":0,"stats":{"Line":1}},{"line":123,"address":[],"length":0,"stats":{"Line":19}},{"line":124,"address":[],"length":0,"stats":{"Line":18}},{"line":125,"address":[],"length":0,"stats":{"Line":1}},{"line":128,"address":[],"length":0,"stats":{"Line":17}},{"line":129,"address":[],"length":0,"stats":{"Line":16}},{"line":130,"address":[],"length":0,"stats":{"Line":1}},{"line":133,"address":[],"length":0,"stats":{"Line":24}},{"line":134,"address":[],"length":0,"stats":{"Line":40}},{"line":136,"address":[],"length":0,"stats":{"Line":48}},{"line":137,"address":[],"length":0,"stats":{"Line":24}},{"line":138,"address":[],"length":0,"stats":{"Line":32}},{"line":139,"address":[],"length":0,"stats":{"Line":32}},{"line":140,"address":[],"length":0,"stats":{"Line":16}},{"line":141,"address":[],"length":0,"stats":{"Line":16}},{"line":142,"address":[],"length":0,"stats":{"Line":24}},{"line":144,"address":[],"length":0,"stats":{"Line":32}},{"line":146,"address":[],"length":0,"stats":{"Line":8}},{"line":148,"address":[],"length":0,"stats":{"Line":14}},{"line":149,"address":[],"length":0,"stats":{"Line":6}},{"line":153,"address":[],"length":0,"stats":{"Line":8}},{"line":154,"address":[],"length":0,"stats":{"Line":6}},{"line":155,"address":[],"length":0,"stats":{"Line":10}},{"line":156,"address":[],"length":0,"stats":{"Line":7}},{"line":157,"address":[],"length":0,"stats":{"Line":6}},{"line":158,"address":[],"length":0,"stats":{"Line":1}},{"line":160,"address":[],"length":0,"stats":{"Line":18}},{"line":161,"address":[],"length":0,"stats":{"Line":9}},{"line":163,"address":[],"length":0,"stats":{"Line":3}},{"line":171,"address":[],"length":0,"stats":{"Line":18}},{"line":173,"address":[],"length":0,"stats":{"Line":6}},{"line":176,"address":[],"length":0,"stats":{"Line":12}},{"line":177,"address":[],"length":0,"stats":{"Line":6}},{"line":180,"address":[],"length":0,"stats":{"Line":10}},{"line":181,"address":[],"length":0,"stats":{"Line":20}},{"line":182,"address":[],"length":0,"stats":{"Line":28}},{"line":186,"address":[],"length":0,"stats":{"Line":8}},{"line":187,"address":[],"length":0,"stats":{"Line":24}},{"line":188,"address":[],"length":0,"stats":{"Line":8}},{"line":189,"address":[],"length":0,"stats":{"Line":9}},{"line":190,"address":[],"length":0,"stats":{"Line":3}},{"line":193,"address":[],"length":0,"stats":{"Line":10}},{"line":194,"address":[],"length":0,"stats":{"Line":15}},{"line":195,"address":[],"length":0,"stats":{"Line":10}},{"line":196,"address":[],"length":0,"stats":{"Line":15}},{"line":197,"address":[],"length":0,"stats":{"Line":5}},{"line":198,"address":[],"length":0,"stats":{"Line":1}},{"line":201,"address":[],"length":0,"stats":{"Line":8}},{"line":202,"address":[],"length":0,"stats":{"Line":16}},{"line":203,"address":[],"length":0,"stats":{"Line":10}},{"line":204,"address":[],"length":0,"stats":{"Line":6}},{"line":205,"address":[],"length":0,"stats":{"Line":1}},{"line":209,"address":[],"length":0,"stats":{"Line":9}},{"line":210,"address":[],"length":0,"stats":{"Line":6}},{"line":212,"address":[],"length":0,"stats":{"Line":3}},{"line":216,"address":[],"length":0,"stats":{"Line":6}},{"line":218,"address":[],"length":0,"stats":{"Line":3}},{"line":221,"address":[],"length":0,"stats":{"Line":15}},{"line":222,"address":[],"length":0,"stats":{"Line":11}},{"line":223,"address":[],"length":0,"stats":{"Line":10}},{"line":224,"address":[],"length":0,"stats":{"Line":1}},{"line":226,"address":[],"length":0,"stats":{"Line":25}},{"line":227,"address":[],"length":0,"stats":{"Line":15}},{"line":229,"address":[],"length":0,"stats":{"Line":10}},{"line":231,"address":[],"length":0,"stats":{"Line":5}},{"line":233,"address":[],"length":0,"stats":{"Line":5}},{"line":237,"address":[],"length":0,"stats":{"Line":15}},{"line":238,"address":[],"length":0,"stats":{"Line":5}},{"line":241,"address":[],"length":0,"stats":{"Line":2}},{"line":242,"address":[],"length":0,"stats":{"Line":8}},{"line":243,"address":[],"length":0,"stats":{"Line":8}},{"line":244,"address":[],"length":0,"stats":{"Line":8}},{"line":245,"address":[],"length":0,"stats":{"Line":2}},{"line":246,"address":[],"length":0,"stats":{"Line":4}},{"line":247,"address":[],"length":0,"stats":{"Line":2}},{"line":248,"address":[],"length":0,"stats":{"Line":2}},{"line":252,"address":[],"length":0,"stats":{"Line":2}},{"line":253,"address":[],"length":0,"stats":{"Line":10}},{"line":254,"address":[],"length":0,"stats":{"Line":4}},{"line":255,"address":[],"length":0,"stats":{"Line":4}},{"line":257,"address":[],"length":0,"stats":{"Line":2}},{"line":258,"address":[],"length":0,"stats":{"Line":3}},{"line":259,"address":[],"length":0,"stats":{"Line":1}},{"line":261,"address":[],"length":0,"stats":{"Line":1}}],"covered":147,"coverable":147},{"path":["/","Users","chi","Projects","hu","src","data","types.rs"],"content":"use serde::{Deserialize, Serialize};\n\n// --- JSONL source types (read from Claude Code files) ---\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct HistoryEntry {\n    pub display: Option\u003cString\u003e,\n    pub timestamp: Option\u003cf64\u003e,\n    pub project: Option\u003cString\u003e,\n    #[serde(rename = \"sessionId\")]\n    pub session_id: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MessageEntry {\n    pub uuid: Option\u003cString\u003e,\n    #[serde(rename = \"parentUuid\")]\n    pub parent_uuid: Option\u003cString\u003e,\n    #[serde(rename = \"sessionId\")]\n    pub session_id: Option\u003cString\u003e,\n    #[serde(rename = \"type\")]\n    pub entry_type: Option\u003cString\u003e,\n    pub timestamp: Option\u003cString\u003e,\n    #[serde(rename = \"gitBranch\")]\n    pub git_branch: Option\u003cString\u003e,\n    pub cwd: Option\u003cString\u003e,\n    pub message: Option\u003cMessageBody\u003e,\n    #[serde(rename = \"costUSD\")]\n    pub cost_usd: Option\u003cf64\u003e,\n    #[serde(rename = \"durationMs\")]\n    pub duration_ms: Option\u003ci64\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MessageBody {\n    pub role: Option\u003cString\u003e,\n    pub content: Option\u003cMessageContent\u003e,\n    pub model: Option\u003cString\u003e,\n    pub usage: Option\u003cTokenUsage\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum MessageContent {\n    Text(String),\n    Blocks(Vec\u003cContentBlock\u003e),\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ContentBlock {\n    #[serde(rename = \"type\")]\n    pub block_type: Option\u003cString\u003e,\n    pub text: Option\u003cString\u003e,\n    pub name: Option\u003cString\u003e,\n    pub input: Option\u003cserde_json::Value\u003e,\n    pub id: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TokenUsage {\n    pub input_tokens: Option\u003ci64\u003e,\n    pub output_tokens: Option\u003ci64\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TodoEntry {\n    pub content: Option\u003cString\u003e,\n    pub status: Option\u003cString\u003e,\n    #[serde(rename = \"activeForm\")]\n    pub active_form: Option\u003cString\u003e,\n}\n\n// --- DB row types ---\n\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct Session {\n    pub id: String,\n    pub project: String,\n    pub display: Option\u003cString\u003e,\n    pub started_at: i64,\n    pub message_count: i64,\n    pub total_cost_usd: f64,\n    pub git_branch: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct Message {\n    pub id: String,\n    pub session_id: String,\n    pub parent_id: Option\u003cString\u003e,\n    pub role: String,\n    pub content: Option\u003cString\u003e,\n    pub model: Option\u003cString\u003e,\n    pub input_tokens: Option\u003ci64\u003e,\n    pub output_tokens: Option\u003ci64\u003e,\n    pub cost_usd: Option\u003cf64\u003e,\n    pub duration_ms: Option\u003ci64\u003e,\n    pub created_at: i64,\n}\n\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct Todo {\n    pub id: i64,\n    pub session_id: String,\n    pub content: String,\n    pub status: String,\n    pub active_form: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct TodoWithProject {\n    pub id: i64,\n    pub session_id: String,\n    pub content: String,\n    pub status: String,\n    pub active_form: Option\u003cString\u003e,\n    pub project: String,\n}\n\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct UsageStats {\n    pub total_sessions: i64,\n    pub total_messages: i64,\n    pub total_cost: f64,\n    pub total_input_tokens: i64,\n    pub total_output_tokens: i64,\n}\n\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct ModelUsage {\n    pub model: String,\n    pub count: i64,\n    pub cost: f64,\n    pub input_tokens: i64,\n    pub output_tokens: i64,\n}\n\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct ToolUsageStats {\n    pub tool_name: String,\n    pub count: i64,\n    pub last_used: i64,\n}\n\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct ToolUsageDetail {\n    pub tool_name: String,\n    pub session_id: String,\n    pub project: String,\n    pub created_at: i64,\n}\n\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct BranchStats {\n    pub git_branch: String,\n    pub session_count: i64,\n    pub session_ids: String,\n    pub last_activity: i64,\n    pub total_messages: i64,\n    pub total_cost: f64,\n    pub project: String,\n}\n\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct SearchResult {\n    pub id: String,\n    pub session_id: String,\n    pub role: String,\n    pub content: Option\u003cString\u003e,\n    pub model: Option\u003cString\u003e,\n    pub created_at: i64,\n    pub project: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DebugError {\n    pub file: String,\n    pub line: usize,\n    pub content: String,\n    pub timestamp: i64,\n}\n\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct SyncResult {\n    pub history: usize,\n    pub messages: usize,\n    pub todos: usize,\n}\n\n#[derive(Debug, Clone, Default)]\npub enum OutputFormat {\n    #[default]\n    Table,\n    Json,\n}\n\n// --- Helpers ---\n\nimpl MessageContent {\n    pub fn as_string(\u0026self) -\u003e String {\n        match self {\n            MessageContent::Text(s) =\u003e s.clone(),\n            MessageContent::Blocks(blocks) =\u003e serde_json::to_string(blocks).unwrap_or_default(),\n        }\n    }\n\n    pub fn tool_use_blocks(\u0026self) -\u003e Vec\u003c\u0026ContentBlock\u003e {\n        match self {\n            MessageContent::Text(_) =\u003e vec![],\n            MessageContent::Blocks(blocks) =\u003e blocks\n                .iter()\n                .filter(|b| b.block_type.as_deref() == Some(\"tool_use\"))\n                .collect(),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn history_entry_serde_roundtrip() {\n        let json = r#\"{\"display\":\"test\",\"timestamp\":1700000000000,\"project\":\"/home/user\",\"sessionId\":\"abc-123\"}\"#;\n        let entry: HistoryEntry = serde_json::from_str(json).unwrap();\n        assert_eq!(entry.session_id.as_deref(), Some(\"abc-123\"));\n        assert_eq!(entry.display.as_deref(), Some(\"test\"));\n        let serialized = serde_json::to_string(\u0026entry).unwrap();\n        let re: HistoryEntry = serde_json::from_str(\u0026serialized).unwrap();\n        assert_eq!(re.session_id, entry.session_id);\n    }\n\n    #[test]\n    fn history_entry_partial_fields() {\n        let json = r#\"{\"display\":\"test\"}\"#;\n        let entry: HistoryEntry = serde_json::from_str(json).unwrap();\n        assert!(entry.session_id.is_none());\n        assert!(entry.timestamp.is_none());\n        assert!(entry.project.is_none());\n    }\n\n    #[test]\n    fn message_entry_serde_roundtrip() {\n        let json = r#\"{\n            \"uuid\": \"msg-1\",\n            \"parentUuid\": \"msg-0\",\n            \"type\": \"user\",\n            \"timestamp\": \"2024-01-01T00:00:00Z\",\n            \"message\": {\n                \"role\": \"user\",\n                \"content\": \"hello\",\n                \"model\": null,\n                \"usage\": null\n            }\n        }\"#;\n        let entry: MessageEntry = serde_json::from_str(json).unwrap();\n        assert_eq!(entry.uuid.as_deref(), Some(\"msg-1\"));\n        assert_eq!(entry.parent_uuid.as_deref(), Some(\"msg-0\"));\n        let body = entry.message.as_ref().unwrap();\n        assert_eq!(body.role.as_deref(), Some(\"user\"));\n    }\n\n    #[test]\n    fn message_content_text() {\n        let content = MessageContent::Text(\"hello world\".to_string());\n        assert_eq!(content.as_string(), \"hello world\");\n        assert!(content.tool_use_blocks().is_empty());\n    }\n\n    #[test]\n    fn message_content_blocks() {\n        let blocks = vec![\n            ContentBlock {\n                block_type: Some(\"text\".to_string()),\n                text: Some(\"hi\".to_string()),\n                name: None,\n                input: None,\n                id: None,\n            },\n            ContentBlock {\n                block_type: Some(\"tool_use\".to_string()),\n                text: None,\n                name: Some(\"Read\".to_string()),\n                input: Some(serde_json::json!({\"path\": \"/tmp/test\"})),\n                id: Some(\"tu-1\".to_string()),\n            },\n        ];\n        let content = MessageContent::Blocks(blocks);\n        let s = content.as_string();\n        assert!(s.contains(\"text\"));\n        assert!(s.contains(\"tool_use\"));\n        let tool_blocks = content.tool_use_blocks();\n        assert_eq!(tool_blocks.len(), 1);\n        assert_eq!(tool_blocks[0].name.as_deref(), Some(\"Read\"));\n    }\n\n    #[test]\n    fn message_content_blocks_serde() {\n        let json = r#\"[{\"type\":\"text\",\"text\":\"hello\"},{\"type\":\"tool_use\",\"name\":\"Bash\",\"input\":{\"cmd\":\"ls\"}}]\"#;\n        let content: MessageContent = serde_json::from_str(json).unwrap();\n        assert_eq!(content.tool_use_blocks().len(), 1);\n    }\n\n    #[test]\n    fn message_content_text_serde() {\n        let json = r#\"\"just a string\"\"#;\n        let content: MessageContent = serde_json::from_str(json).unwrap();\n        assert_eq!(content.as_string(), \"just a string\");\n    }\n\n    #[test]\n    fn todo_entry_serde() {\n        let json = r#\"{\"content\":\"Fix bug\",\"status\":\"pending\",\"activeForm\":\"Fixing bug\"}\"#;\n        let entry: TodoEntry = serde_json::from_str(json).unwrap();\n        assert_eq!(entry.content.as_deref(), Some(\"Fix bug\"));\n        assert_eq!(entry.status.as_deref(), Some(\"pending\"));\n        assert_eq!(entry.active_form.as_deref(), Some(\"Fixing bug\"));\n    }\n\n    #[test]\n    fn todo_entry_minimal() {\n        let json = r#\"{}\"#;\n        let entry: TodoEntry = serde_json::from_str(json).unwrap();\n        assert!(entry.content.is_none());\n    }\n\n    #[test]\n    fn token_usage_serde() {\n        let json = r#\"{\"input_tokens\":100,\"output_tokens\":200}\"#;\n        let usage: TokenUsage = serde_json::from_str(json).unwrap();\n        assert_eq!(usage.input_tokens, Some(100));\n        assert_eq!(usage.output_tokens, Some(200));\n    }\n\n    #[test]\n    fn session_default() {\n        let s = Session::default();\n        assert_eq!(s.id, \"\");\n        assert_eq!(s.message_count, 0);\n        assert_eq!(s.total_cost_usd, 0.0);\n        assert!(s.git_branch.is_none());\n    }\n\n    #[test]\n    fn usage_stats_default() {\n        let s = UsageStats::default();\n        assert_eq!(s.total_sessions, 0);\n        assert_eq!(s.total_messages, 0);\n        assert_eq!(s.total_cost, 0.0);\n    }\n\n    #[test]\n    fn sync_result_default() {\n        let r = SyncResult::default();\n        assert_eq!(r.history, 0);\n        assert_eq!(r.messages, 0);\n        assert_eq!(r.todos, 0);\n    }\n\n    #[test]\n    fn output_format_default() {\n        let f = OutputFormat::default();\n        assert!(matches!(f, OutputFormat::Table));\n    }\n\n    #[test]\n    fn debug_error_fields() {\n        let e = DebugError {\n            file: \"test.log\".to_string(),\n            line: 42,\n            content: \"error: something failed\".to_string(),\n            timestamp: 1700000000,\n        };\n        let json = serde_json::to_string(\u0026e).unwrap();\n        let re: DebugError = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(re.file, \"test.log\");\n        assert_eq!(re.line, 42);\n    }\n\n    #[test]\n    fn branch_stats_default() {\n        let b = BranchStats::default();\n        assert_eq!(b.git_branch, \"\");\n        assert_eq!(b.session_count, 0);\n    }\n\n    #[test]\n    fn tool_usage_stats_default() {\n        let t = ToolUsageStats::default();\n        assert_eq!(t.tool_name, \"\");\n        assert_eq!(t.count, 0);\n    }\n\n    #[test]\n    fn search_result_serialize() {\n        let sr = SearchResult {\n            id: \"msg-1\".to_string(),\n            session_id: \"sess-1\".to_string(),\n            role: \"user\".to_string(),\n            content: Some(\"hello\".to_string()),\n            model: None,\n            created_at: 1700000000,\n            project: \"/home/user/proj\".to_string(),\n        };\n        let json = serde_json::to_string(\u0026sr).unwrap();\n        assert!(json.contains(\"msg-1\"));\n    }\n\n    #[test]\n    fn message_entry_with_git_branch() {\n        let json = r#\"{\n            \"uuid\": \"msg-1\",\n            \"type\": \"user\",\n            \"gitBranch\": \"feature/test\",\n            \"timestamp\": \"2024-01-01T00:00:00Z\"\n        }\"#;\n        let entry: MessageEntry = serde_json::from_str(json).unwrap();\n        assert_eq!(entry.git_branch.as_deref(), Some(\"feature/test\"));\n    }\n\n    #[test]\n    fn message_entry_with_cost() {\n        let json = r#\"{\n            \"uuid\": \"msg-1\",\n            \"type\": \"assistant\",\n            \"costUSD\": 0.0123,\n            \"durationMs\": 500\n        }\"#;\n        let entry: MessageEntry = serde_json::from_str(json).unwrap();\n        assert!((entry.cost_usd.unwrap() - 0.0123).abs() \u003c f64::EPSILON);\n        assert_eq!(entry.duration_ms, Some(500));\n    }\n\n    #[test]\n    fn content_block_serde() {\n        let json = r#\"{\"type\":\"tool_use\",\"name\":\"Read\",\"input\":{\"path\":\"/tmp\"},\"id\":\"tu-1\"}\"#;\n        let block: ContentBlock = serde_json::from_str(json).unwrap();\n        assert_eq!(block.block_type.as_deref(), Some(\"tool_use\"));\n        assert_eq!(block.name.as_deref(), Some(\"Read\"));\n        assert_eq!(block.id.as_deref(), Some(\"tu-1\"));\n    }\n}\n","traces":[{"line":200,"address":[],"length":0,"stats":{"Line":11}},{"line":201,"address":[],"length":0,"stats":{"Line":11}},{"line":202,"address":[],"length":0,"stats":{"Line":21}},{"line":203,"address":[],"length":0,"stats":{"Line":16}},{"line":207,"address":[],"length":0,"stats":{"Line":6}},{"line":208,"address":[],"length":0,"stats":{"Line":6}},{"line":209,"address":[],"length":0,"stats":{"Line":1}},{"line":210,"address":[],"length":0,"stats":{"Line":10}},{"line":212,"address":[],"length":0,"stats":{"Line":25}}],"covered":9,"coverable":9},{"path":["/","Users","chi","Projects","hu","src","docs","cli.rs"],"content":"use clap::{Args, Subcommand};\nuse std::path::PathBuf;\n\n#[derive(Debug, Subcommand)]\npub enum DocsCommand {\n    /// Create a scaffold file for a topic (to be filled by Claude)\n    Add(AddArgs),\n    /// Fetch documentation from a URL\n    Get(GetArgs),\n    /// List documentation files\n    List(ListArgs),\n    /// Remove a documentation file\n    Remove(RemoveArgs),\n    /// Commit and push documentation changes\n    Sync(SyncArgs),\n}\n\n#[derive(Debug, Args)]\npub struct AddArgs {\n    /// Topic to document\n    pub topic: String,\n    /// Output directory (default: ~/Projects/docs)\n    #[arg(short, long)]\n    pub output: Option\u003cPathBuf\u003e,\n    /// Skip git commit\n    #[arg(long)]\n    pub no_commit: bool,\n}\n\n#[derive(Debug, Args)]\npub struct GetArgs {\n    /// URL to fetch\n    pub url: String,\n    /// Output filename (derived from URL if omitted)\n    pub name: Option\u003cString\u003e,\n    /// Output directory (default: ~/Projects/docs)\n    #[arg(short, long)]\n    pub output: Option\u003cPathBuf\u003e,\n    /// Skip git commit\n    #[arg(long)]\n    pub no_commit: bool,\n}\n\n#[derive(Debug, Args)]\npub struct ListArgs {\n    /// Directory to list (default: ~/Projects/docs)\n    pub path: Option\u003cPathBuf\u003e,\n    /// Output as JSON\n    #[arg(short, long)]\n    pub json: bool,\n}\n\n#[derive(Debug, Args)]\npub struct RemoveArgs {\n    /// File to remove (path or slug)\n    pub file: String,\n    /// Base directory for relative paths (default: ~/Projects/docs)\n    #[arg(short, long)]\n    pub dir: Option\u003cPathBuf\u003e,\n    /// Skip git commit\n    #[arg(long)]\n    pub no_commit: bool,\n}\n\n#[derive(Debug, Args)]\npub struct SyncArgs {\n    /// Directory to sync (default: ~/Projects/docs)\n    pub path: Option\u003cPathBuf\u003e,\n    /// Skip git push\n    #[arg(long)]\n    pub no_push: bool,\n    /// Custom commit message\n    #[arg(long, short)]\n    pub message: Option\u003cString\u003e,\n    /// Output as JSON\n    #[arg(long, short)]\n    pub json: bool,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use clap::Parser;\n\n    #[derive(Parser)]\n    struct TestCli {\n        #[command(subcommand)]\n        cmd: DocsCommand,\n    }\n\n    #[test]\n    fn parse_add() {\n        let cli = TestCli::try_parse_from([\"test\", \"add\", \"rust error handling\"]).unwrap();\n        match cli.cmd {\n            DocsCommand::Add(args) =\u003e {\n                assert_eq!(args.topic, \"rust error handling\");\n                assert!(args.output.is_none());\n                assert!(!args.no_commit);\n            }\n            _ =\u003e panic!(\"expected Add\"),\n        }\n    }\n\n    #[test]\n    fn parse_add_with_options() {\n        let cli =\n            TestCli::try_parse_from([\"test\", \"add\", \"topic\", \"--output\", \"/tmp\", \"--no-commit\"])\n                .unwrap();\n        match cli.cmd {\n            DocsCommand::Add(args) =\u003e {\n                assert_eq!(args.output, Some(PathBuf::from(\"/tmp\")));\n                assert!(args.no_commit);\n            }\n            _ =\u003e panic!(\"expected Add\"),\n        }\n    }\n\n    #[test]\n    fn parse_get() {\n        let cli = TestCli::try_parse_from([\"test\", \"get\", \"https://example.com\"]).unwrap();\n        match cli.cmd {\n            DocsCommand::Get(args) =\u003e {\n                assert_eq!(args.url, \"https://example.com\");\n                assert!(args.name.is_none());\n            }\n            _ =\u003e panic!(\"expected Get\"),\n        }\n    }\n\n    #[test]\n    fn parse_get_with_name() {\n        let cli =\n            TestCli::try_parse_from([\"test\", \"get\", \"https://example.com\", \"example\"]).unwrap();\n        match cli.cmd {\n            DocsCommand::Get(args) =\u003e {\n                assert_eq!(args.name, Some(\"example\".to_string()));\n            }\n            _ =\u003e panic!(\"expected Get\"),\n        }\n    }\n\n    #[test]\n    fn parse_list() {\n        let cli = TestCli::try_parse_from([\"test\", \"list\"]).unwrap();\n        match cli.cmd {\n            DocsCommand::List(args) =\u003e {\n                assert!(args.path.is_none());\n                assert!(!args.json);\n            }\n            _ =\u003e panic!(\"expected List\"),\n        }\n    }\n\n    #[test]\n    fn parse_list_with_path() {\n        let cli = TestCli::try_parse_from([\"test\", \"list\", \"/tmp/docs\"]).unwrap();\n        match cli.cmd {\n            DocsCommand::List(args) =\u003e {\n                assert_eq!(args.path, Some(PathBuf::from(\"/tmp/docs\")));\n            }\n            _ =\u003e panic!(\"expected List\"),\n        }\n    }\n\n    #[test]\n    fn parse_list_json() {\n        let cli = TestCli::try_parse_from([\"test\", \"list\", \"--json\"]).unwrap();\n        match cli.cmd {\n            DocsCommand::List(args) =\u003e {\n                assert!(args.json);\n            }\n            _ =\u003e panic!(\"expected List\"),\n        }\n    }\n\n    #[test]\n    fn parse_remove() {\n        let cli = TestCli::try_parse_from([\"test\", \"remove\", \"file.md\"]).unwrap();\n        match cli.cmd {\n            DocsCommand::Remove(args) =\u003e {\n                assert_eq!(args.file, \"file.md\");\n                assert!(!args.no_commit);\n            }\n            _ =\u003e panic!(\"expected Remove\"),\n        }\n    }\n\n    #[test]\n    fn parse_remove_no_commit() {\n        let cli = TestCli::try_parse_from([\"test\", \"remove\", \"file.md\", \"--no-commit\"]).unwrap();\n        match cli.cmd {\n            DocsCommand::Remove(args) =\u003e {\n                assert!(args.no_commit);\n            }\n            _ =\u003e panic!(\"expected Remove\"),\n        }\n    }\n\n    #[test]\n    fn parse_sync() {\n        let cli = TestCli::try_parse_from([\"test\", \"sync\"]).unwrap();\n        match cli.cmd {\n            DocsCommand::Sync(args) =\u003e {\n                assert!(args.path.is_none());\n                assert!(!args.no_push);\n            }\n            _ =\u003e panic!(\"expected Sync\"),\n        }\n    }\n\n    #[test]\n    fn parse_sync_with_options() {\n        let cli = TestCli::try_parse_from([\n            \"test\",\n            \"sync\",\n            \"/tmp/docs\",\n            \"--no-push\",\n            \"-m\",\n            \"custom message\",\n        ])\n        .unwrap();\n        match cli.cmd {\n            DocsCommand::Sync(args) =\u003e {\n                assert_eq!(args.path, Some(PathBuf::from(\"/tmp/docs\")));\n                assert!(args.no_push);\n                assert_eq!(args.message, Some(\"custom message\".to_string()));\n            }\n            _ =\u003e panic!(\"expected Sync\"),\n        }\n    }\n\n    #[test]\n    fn parse_remove_with_dir() {\n        let cli =\n            TestCli::try_parse_from([\"test\", \"remove\", \"file.md\", \"-d\", \"/custom/docs\"]).unwrap();\n        match cli.cmd {\n            DocsCommand::Remove(args) =\u003e {\n                assert_eq!(args.dir, Some(PathBuf::from(\"/custom/docs\")));\n            }\n            _ =\u003e panic!(\"expected Remove\"),\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","docs","display","mod.rs"],"content":"use comfy_table::presets::UTF8_FULL_CONDENSED;\nuse comfy_table::{Cell, Table};\n\nuse super::types::DocEntry;\n\n#[cfg(test)]\nmod tests;\n\n/// Format documents for display\npub fn format_docs(docs: \u0026[DocEntry], json: bool) -\u003e String {\n    if json {\n        format_json(docs)\n    } else {\n        format_table(docs)\n    }\n}\n\n/// Format documents as JSON\nfn format_json(docs: \u0026[DocEntry]) -\u003e String {\n    serde_json::to_string_pretty(docs).unwrap_or_else(|_| \"[]\".to_string())\n}\n\n/// Format documents as a table\nfn format_table(docs: \u0026[DocEntry]) -\u003e String {\n    if docs.is_empty() {\n        return \"No documentation files found.\".to_string();\n    }\n\n    let mut table = Table::new();\n    table.load_preset(UTF8_FULL_CONDENSED);\n    table.set_header(vec![\"File\", \"Title\", \"Source\", \"Date\"]);\n\n    for doc in docs {\n        let file = doc\n            .path\n            .file_name()\n            .map(|s| s.to_string_lossy().to_string())\n            .unwrap_or_default();\n\n        let source = doc\n            .source\n            .as_ref()\n            .map(|s| truncate_url(s, 40))\n            .unwrap_or_else(|| \"-\".to_string());\n\n        let date = doc.fetched.as_deref().unwrap_or(\"-\");\n\n        table.add_row(vec![\n            Cell::new(file),\n            Cell::new(truncate(\u0026doc.title, 30)),\n            Cell::new(source),\n            Cell::new(date),\n        ]);\n    }\n\n    table.to_string()\n}\n\n/// Truncate string with ellipsis\nfn truncate(s: \u0026str, max: usize) -\u003e String {\n    if s.len() \u003c= max {\n        s.to_string()\n    } else {\n        format!(\"{}...\", \u0026s[..max - 3])\n    }\n}\n\n/// Truncate URL, keeping domain visible\nfn truncate_url(url: \u0026str, max: usize) -\u003e String {\n    if url.len() \u003c= max {\n        return url.to_string();\n    }\n\n    // Try to keep domain visible\n    let url = url\n        .trim_start_matches(\"https://\")\n        .trim_start_matches(\"http://\");\n\n    if url.len() \u003c= max {\n        return url.to_string();\n    }\n\n    format!(\"{}...\", \u0026url[..max - 3])\n}\n\n/// Format sync result for display\npub fn format_sync_result(result: \u0026crate::git::SyncResult, json: bool) -\u003e String {\n    if json {\n        return serde_json::to_string_pretty(result).unwrap_or_else(|_| \"{}\".to_string());\n    }\n\n    if result.files_committed == 0 {\n        return \"Nothing to commit, working tree clean\".to_string();\n    }\n\n    let mut output = Vec::new();\n\n    if let Some(hash) = \u0026result.commit_hash {\n        let branch = result.branch.as_deref().unwrap_or(\"unknown\");\n        output.push(format!(\n            \"\\x1b[32m\\u{2713}\\x1b[0m Committed {} {} [{}] {}\",\n            result.files_committed,\n            if result.files_committed == 1 {\n                \"file\"\n            } else {\n                \"files\"\n            },\n            branch,\n            hash\n        ));\n    }\n\n    if result.pushed {\n        output.push(\"\\x1b[32m\\u{2713}\\x1b[0m Pushed to origin\".to_string());\n    } else if result.commit_hash.is_some() {\n        output.push(\"\\x1b[33m\\u{25D0}\\x1b[0m No remote or --no-push\".to_string());\n    }\n\n    output.join(\"\\n\")\n}\n\n/// Format file creation result\npub fn format_created(path: \u0026std::path::Path, topic: \u0026str) -\u003e String {\n    format!(\n        \"\\x1b[32m\\u{2713}\\x1b[0m Created {} ({})\",\n        path.display(),\n        topic\n    )\n}\n\n/// Format file removal result\npub fn format_removed(path: \u0026std::path::Path) -\u003e String {\n    format!(\"\\x1b[32m\\u{2713}\\x1b[0m Removed {}\", path.display())\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":7}},{"line":11,"address":[],"length":0,"stats":{"Line":7}},{"line":12,"address":[],"length":0,"stats":{"Line":4}},{"line":14,"address":[],"length":0,"stats":{"Line":10}},{"line":19,"address":[],"length":0,"stats":{"Line":2}},{"line":20,"address":[],"length":0,"stats":{"Line":6}},{"line":24,"address":[],"length":0,"stats":{"Line":5}},{"line":25,"address":[],"length":0,"stats":{"Line":10}},{"line":26,"address":[],"length":0,"stats":{"Line":2}},{"line":29,"address":[],"length":0,"stats":{"Line":8}},{"line":30,"address":[],"length":0,"stats":{"Line":12}},{"line":31,"address":[],"length":0,"stats":{"Line":24}},{"line":33,"address":[],"length":0,"stats":{"Line":14}},{"line":34,"address":[],"length":0,"stats":{"Line":10}},{"line":35,"address":[],"length":0,"stats":{"Line":5}},{"line":37,"address":[],"length":0,"stats":{"Line":15}},{"line":40,"address":[],"length":0,"stats":{"Line":10}},{"line":41,"address":[],"length":0,"stats":{"Line":5}},{"line":43,"address":[],"length":0,"stats":{"Line":9}},{"line":44,"address":[],"length":0,"stats":{"Line":11}},{"line":46,"address":[],"length":0,"stats":{"Line":25}},{"line":48,"address":[],"length":0,"stats":{"Line":15}},{"line":49,"address":[],"length":0,"stats":{"Line":10}},{"line":50,"address":[],"length":0,"stats":{"Line":15}},{"line":51,"address":[],"length":0,"stats":{"Line":10}},{"line":52,"address":[],"length":0,"stats":{"Line":10}},{"line":56,"address":[],"length":0,"stats":{"Line":8}},{"line":60,"address":[],"length":0,"stats":{"Line":8}},{"line":61,"address":[],"length":0,"stats":{"Line":16}},{"line":62,"address":[],"length":0,"stats":{"Line":12}},{"line":64,"address":[],"length":0,"stats":{"Line":6}},{"line":69,"address":[],"length":0,"stats":{"Line":6}},{"line":70,"address":[],"length":0,"stats":{"Line":12}},{"line":71,"address":[],"length":0,"stats":{"Line":6}},{"line":75,"address":[],"length":0,"stats":{"Line":6}},{"line":79,"address":[],"length":0,"stats":{"Line":6}},{"line":80,"address":[],"length":0,"stats":{"Line":4}},{"line":83,"address":[],"length":0,"stats":{"Line":3}},{"line":87,"address":[],"length":0,"stats":{"Line":6}},{"line":88,"address":[],"length":0,"stats":{"Line":6}},{"line":89,"address":[],"length":0,"stats":{"Line":6}},{"line":92,"address":[],"length":0,"stats":{"Line":4}},{"line":93,"address":[],"length":0,"stats":{"Line":2}},{"line":96,"address":[],"length":0,"stats":{"Line":6}},{"line":98,"address":[],"length":0,"stats":{"Line":6}},{"line":99,"address":[],"length":0,"stats":{"Line":15}},{"line":100,"address":[],"length":0,"stats":{"Line":9}},{"line":101,"address":[],"length":0,"stats":{"Line":3}},{"line":103,"address":[],"length":0,"stats":{"Line":3}},{"line":104,"address":[],"length":0,"stats":{"Line":2}},{"line":106,"address":[],"length":0,"stats":{"Line":1}},{"line":113,"address":[],"length":0,"stats":{"Line":4}},{"line":114,"address":[],"length":0,"stats":{"Line":3}},{"line":115,"address":[],"length":0,"stats":{"Line":7}},{"line":116,"address":[],"length":0,"stats":{"Line":6}},{"line":119,"address":[],"length":0,"stats":{"Line":6}},{"line":123,"address":[],"length":0,"stats":{"Line":1}},{"line":124,"address":[],"length":0,"stats":{"Line":1}},{"line":126,"address":[],"length":0,"stats":{"Line":2}},{"line":132,"address":[],"length":0,"stats":{"Line":1}},{"line":133,"address":[],"length":0,"stats":{"Line":4}}],"covered":61,"coverable":61},{"path":["/","Users","chi","Projects","hu","src","docs","display","tests.rs"],"content":"use super::*;\nuse std::path::PathBuf;\n\n#[test]\nfn format_docs_empty() {\n    let output = format_docs(\u0026[], false);\n    assert!(output.contains(\"No documentation files found\"));\n}\n\n#[test]\nfn format_docs_empty_json() {\n    let output = format_docs(\u0026[], true);\n    assert_eq!(output, \"[]\");\n}\n\n#[test]\nfn format_docs_table() {\n    let docs = vec![DocEntry {\n        path: PathBuf::from(\"/docs/test.md\"),\n        title: \"Test Doc\".to_string(),\n        source: Some(\"https://example.com\".to_string()),\n        fetched: Some(\"2024-01-01\".to_string()),\n        size: 1234,\n    }];\n\n    let output = format_docs(\u0026docs, false);\n    assert!(output.contains(\"test.md\"));\n    assert!(output.contains(\"Test Doc\"));\n    assert!(output.contains(\"example.com\"));\n    assert!(output.contains(\"2024-01-01\"));\n}\n\n#[test]\nfn format_docs_table_no_source() {\n    let docs = vec![DocEntry {\n        path: PathBuf::from(\"/docs/local.md\"),\n        title: \"Local Doc\".to_string(),\n        source: None,\n        fetched: None,\n        size: 100,\n    }];\n\n    let output = format_docs(\u0026docs, false);\n    assert!(output.contains(\"local.md\"));\n    assert!(output.contains(\"-\")); // placeholder for missing source/date\n}\n\n#[test]\nfn format_docs_json() {\n    let docs = vec![DocEntry {\n        path: PathBuf::from(\"/docs/test.md\"),\n        title: \"Test\".to_string(),\n        source: Some(\"https://test.com\".to_string()),\n        fetched: Some(\"2024-01-01\".to_string()),\n        size: 500,\n    }];\n\n    let output = format_docs(\u0026docs, true);\n    assert!(output.contains(\"\\\"title\\\"\"));\n    assert!(output.contains(\"\\\"Test\\\"\"));\n    assert!(output.contains(\"\\\"source\\\"\"));\n}\n\n#[test]\nfn truncate_short() {\n    assert_eq!(truncate(\"short\", 10), \"short\");\n}\n\n#[test]\nfn truncate_exact() {\n    assert_eq!(truncate(\"exactly10!\", 10), \"exactly10!\");\n}\n\n#[test]\nfn truncate_long() {\n    assert_eq!(truncate(\"this is too long\", 10), \"this is...\");\n}\n\n#[test]\nfn truncate_url_short() {\n    assert_eq!(\n        truncate_url(\"https://example.com\", 30),\n        \"https://example.com\"\n    );\n}\n\n#[test]\nfn truncate_url_strips_protocol() {\n    assert_eq!(\n        truncate_url(\"https://example.com/very/long/path/here\", 20),\n        \"example.com/very/...\"\n    );\n}\n\n#[test]\nfn truncate_url_http() {\n    assert_eq!(\n        truncate_url(\"http://example.com/path\", 20),\n        \"example.com/path\"\n    );\n}\n\n#[test]\nfn format_sync_result_clean() {\n    let result = crate::git::SyncResult {\n        files_committed: 0,\n        commit_hash: None,\n        pushed: false,\n        branch: None,\n    };\n    let output = format_sync_result(\u0026result, false);\n    assert!(output.contains(\"Nothing to commit\"));\n}\n\n#[test]\nfn format_sync_result_committed() {\n    let result = crate::git::SyncResult {\n        files_committed: 3,\n        commit_hash: Some(\"abc1234\".to_string()),\n        pushed: false,\n        branch: Some(\"main\".to_string()),\n    };\n    let output = format_sync_result(\u0026result, false);\n    assert!(output.contains(\"Committed 3 files\"));\n    assert!(output.contains(\"[main]\"));\n    assert!(output.contains(\"abc1234\"));\n}\n\n#[test]\nfn format_sync_result_single_file() {\n    let result = crate::git::SyncResult {\n        files_committed: 1,\n        commit_hash: Some(\"def5678\".to_string()),\n        pushed: true,\n        branch: Some(\"feature\".to_string()),\n    };\n    let output = format_sync_result(\u0026result, false);\n    assert!(output.contains(\"1 file\"));\n    assert!(!output.contains(\"1 files\"));\n    assert!(output.contains(\"Pushed to origin\"));\n}\n\n#[test]\nfn format_sync_result_json() {\n    let result = crate::git::SyncResult {\n        files_committed: 2,\n        commit_hash: Some(\"xyz\".to_string()),\n        pushed: true,\n        branch: Some(\"main\".to_string()),\n    };\n    let output = format_sync_result(\u0026result, true);\n    assert!(output.contains(\"\\\"files_committed\\\"\"));\n    assert!(output.contains(\"\\\"pushed\\\": true\"));\n}\n\n#[test]\nfn format_created_output() {\n    let path = PathBuf::from(\"/docs/test.md\");\n    let output = format_created(\u0026path, \"Test Topic\");\n    assert!(output.contains(\"/docs/test.md\"));\n    assert!(output.contains(\"Test Topic\"));\n    assert!(output.contains(\"\\u{2713}\")); // checkmark\n}\n\n#[test]\nfn format_removed_output() {\n    let path = PathBuf::from(\"/docs/removed.md\");\n    let output = format_removed(\u0026path);\n    assert!(output.contains(\"/docs/removed.md\"));\n    assert!(output.contains(\"Removed\"));\n}\n\n#[test]\nfn format_docs_multiple() {\n    let docs = vec![\n        DocEntry {\n            path: PathBuf::from(\"/docs/first.md\"),\n            title: \"First\".to_string(),\n            source: None,\n            fetched: None,\n            size: 100,\n        },\n        DocEntry {\n            path: PathBuf::from(\"/docs/second.md\"),\n            title: \"Second\".to_string(),\n            source: Some(\"https://second.com\".to_string()),\n            fetched: Some(\"2024-02-01\".to_string()),\n            size: 200,\n        },\n    ];\n\n    let output = format_docs(\u0026docs, false);\n    assert!(output.contains(\"first.md\"));\n    assert!(output.contains(\"second.md\"));\n    assert!(output.contains(\"First\"));\n    assert!(output.contains(\"Second\"));\n}\n\n#[test]\nfn format_docs_long_title_truncated() {\n    let docs = vec![DocEntry {\n        path: PathBuf::from(\"/docs/test.md\"),\n        title: \"This is a very long title that should be truncated\".to_string(),\n        source: None,\n        fetched: None,\n        size: 100,\n    }];\n\n    let output = format_docs(\u0026docs, false);\n    assert!(output.contains(\"...\"));\n}\n\n#[test]\nfn format_sync_result_no_push() {\n    let result = crate::git::SyncResult {\n        files_committed: 1,\n        commit_hash: Some(\"abc\".to_string()),\n        pushed: false,\n        branch: Some(\"main\".to_string()),\n    };\n    let output = format_sync_result(\u0026result, false);\n    assert!(output.contains(\"--no-push\"));\n}\n\n#[test]\nfn truncate_url_already_short_after_strip() {\n    // After stripping protocol, URL is short enough\n    assert_eq!(truncate_url(\"https://ex.com\", 10), \"ex.com\");\n}\n\n#[test]\nfn format_sync_json_zero_files() {\n    let result = crate::git::SyncResult {\n        files_committed: 0,\n        commit_hash: None,\n        pushed: false,\n        branch: None,\n    };\n    let output = format_sync_result(\u0026result, true);\n    assert!(output.contains(\"\\\"files_committed\\\": 0\"));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","docs","mod.rs"],"content":"mod cli;\nmod display;\nmod service;\nmod types;\n\npub use cli::DocsCommand;\n\nuse anyhow::Result;\n\n/// Run a docs subcommand\npub async fn run_command(cmd: DocsCommand) -\u003e Result\u003c()\u003e {\n    match cmd {\n        DocsCommand::Add(args) =\u003e run_add(args),\n        DocsCommand::Get(args) =\u003e run_get(args).await,\n        DocsCommand::List(args) =\u003e run_list(args),\n        DocsCommand::Remove(args) =\u003e run_remove(args),\n        DocsCommand::Sync(args) =\u003e run_sync(args),\n    }\n}\n\nfn run_add(args: cli::AddArgs) -\u003e Result\u003c()\u003e {\n    let path = service::add(\u0026args.topic, args.output.as_deref(), args.no_commit)?;\n    println!(\"{}\", display::format_created(\u0026path, \u0026args.topic));\n    Ok(())\n}\n\nasync fn run_get(args: cli::GetArgs) -\u003e Result\u003c()\u003e {\n    let path = service::get(\n        \u0026args.url,\n        args.name.as_deref(),\n        args.output.as_deref(),\n        args.no_commit,\n    )\n    .await?;\n    println!(\"\\x1b[32m\\u{2713}\\x1b[0m Fetched to {}\", path.display());\n    Ok(())\n}\n\nfn run_list(args: cli::ListArgs) -\u003e Result\u003c()\u003e {\n    let docs = service::list(args.path.as_deref())?;\n    println!(\"{}\", display::format_docs(\u0026docs, args.json));\n    Ok(())\n}\n\nfn run_remove(args: cli::RemoveArgs) -\u003e Result\u003c()\u003e {\n    let path = service::remove(\u0026args.file, args.dir.as_deref(), args.no_commit)?;\n    println!(\"{}\", display::format_removed(\u0026path));\n    Ok(())\n}\n\nfn run_sync(args: cli::SyncArgs) -\u003e Result\u003c()\u003e {\n    let result = service::sync(args.path.as_deref(), args.no_push, args.message.as_deref())?;\n    println!(\"{}\", display::format_sync_result(\u0026result, args.json));\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn docs_command_exported() {\n        let _ = std::any::type_name::\u003cDocsCommand\u003e();\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":31},{"path":["/","Users","chi","Projects","hu","src","docs","service.rs"],"content":"use anyhow::{Context, Result};\nuse chrono::Local;\nuse std::fs;\nuse std::path::{Path, PathBuf};\n\nuse super::types::{extract_title, to_slug, DocEntry, Frontmatter};\nuse crate::git::{self, SyncOptions};\n\n/// Default docs directory\npub fn default_docs_dir() -\u003e PathBuf {\n    dirs::home_dir()\n        .map(|h| h.join(\"Projects/docs\"))\n        .unwrap_or_else(|| PathBuf::from(\".\"))\n}\n\n/// Create a scaffold file for a topic\npub fn add(topic: \u0026str, output_dir: Option\u003c\u0026Path\u003e, no_commit: bool) -\u003e Result\u003cPathBuf\u003e {\n    let dir = output_dir\n        .map(PathBuf::from)\n        .unwrap_or_else(default_docs_dir);\n    fs::create_dir_all(\u0026dir)?;\n\n    let slug = to_slug(topic);\n    let filename = format!(\"{}.md\", slug);\n    let path = dir.join(\u0026filename);\n\n    if path.exists() {\n        anyhow::bail!(\"File already exists: {}\", path.display());\n    }\n\n    let date = Local::now().format(\"%Y-%m-%d\").to_string();\n    let frontmatter = Frontmatter {\n        topic: Some(topic.to_string()),\n        created: Some(date),\n        ..Default::default()\n    };\n\n    let content = format!(\n        \"{}\n# {}\n\n\u003c!-- Research and document this topic --\u003e\n\",\n        frontmatter.to_block(),\n        topic\n    );\n\n    fs::write(\u0026path, content).with_context(|| format!(\"Failed to write {}\", path.display()))?;\n\n    if !no_commit {\n        commit_file(\u0026dir, \u0026filename, \u0026format!(\"Add {}\", topic))?;\n    }\n\n    Ok(path)\n}\n\n/// Fetch documentation from a URL\npub async fn get(\n    url: \u0026str,\n    name: Option\u003c\u0026str\u003e,\n    output_dir: Option\u003c\u0026Path\u003e,\n    no_commit: bool,\n) -\u003e Result\u003cPathBuf\u003e {\n    let dir = output_dir\n        .map(PathBuf::from)\n        .unwrap_or_else(default_docs_dir);\n    fs::create_dir_all(\u0026dir)?;\n\n    // Derive filename from URL or use provided name\n    let slug = name.map(to_slug).unwrap_or_else(|| slug_from_url(url));\n    let filename = format!(\"{}.md\", slug);\n    let path = dir.join(\u0026filename);\n\n    // Fetch content\n    let html = fetch_url(url).await?;\n    let markdown = html_to_markdown(\u0026html);\n\n    let date = Local::now().format(\"%Y-%m-%d\").to_string();\n    let frontmatter = Frontmatter {\n        source: Some(url.to_string()),\n        fetched: Some(date),\n        ..Default::default()\n    };\n\n    let content = format!(\"{}\\n{}\", frontmatter.to_block(), markdown);\n\n    fs::write(\u0026path, content).with_context(|| format!(\"Failed to write {}\", path.display()))?;\n\n    if !no_commit {\n        let title = extract_title(\u0026markdown).unwrap_or_else(|| slug.clone());\n        commit_file(\u0026dir, \u0026filename, \u0026format!(\"Add docs: {}\", title))?;\n    }\n\n    Ok(path)\n}\n\n/// List documentation files in a directory\npub fn list(path: Option\u003c\u0026Path\u003e) -\u003e Result\u003cVec\u003cDocEntry\u003e\u003e {\n    let dir = path.map(PathBuf::from).unwrap_or_else(default_docs_dir);\n\n    if !dir.exists() {\n        return Ok(vec![]);\n    }\n\n    let mut entries = Vec::new();\n    collect_docs(\u0026dir, \u0026mut entries)?;\n    entries.sort_by(|a, b| a.path.cmp(\u0026b.path));\n\n    Ok(entries)\n}\n\n/// Recursively collect documentation files\nfn collect_docs(dir: \u0026Path, entries: \u0026mut Vec\u003cDocEntry\u003e) -\u003e Result\u003c()\u003e {\n    for entry in fs::read_dir(dir)? {\n        let entry = entry?;\n        let path = entry.path();\n\n        if path.is_dir() {\n            collect_docs(\u0026path, entries)?;\n        } else if path.extension().is_some_and(|e| e == \"md\") {\n            if let Ok(entry) = parse_doc_entry(\u0026path) {\n                entries.push(entry);\n            }\n        }\n    }\n    Ok(())\n}\n\n/// Parse a documentation file into a DocEntry\nfn parse_doc_entry(path: \u0026Path) -\u003e Result\u003cDocEntry\u003e {\n    let content = fs::read_to_string(path)?;\n    let metadata = fs::metadata(path)?;\n\n    let frontmatter = Frontmatter::parse(\u0026content);\n    let title = extract_title(\u0026content)\n        .or_else(|| frontmatter.as_ref().and_then(|f| f.topic.clone()))\n        .unwrap_or_else(|| {\n            path.file_stem()\n                .map(|s| s.to_string_lossy().to_string())\n                .unwrap_or_default()\n        });\n\n    Ok(DocEntry {\n        path: path.to_path_buf(),\n        title,\n        source: frontmatter.as_ref().and_then(|f| f.source.clone()),\n        fetched: frontmatter\n            .as_ref()\n            .and_then(|f| f.fetched.clone().or_else(|| f.created.clone())),\n        size: metadata.len(),\n    })\n}\n\n/// Remove a documentation file\npub fn remove(file: \u0026str, base_dir: Option\u003c\u0026Path\u003e, no_commit: bool) -\u003e Result\u003cPathBuf\u003e {\n    let dir = base_dir.map(PathBuf::from).unwrap_or_else(default_docs_dir);\n\n    // Try to resolve the file path\n    let path = resolve_file_path(file, \u0026dir)?;\n\n    if !path.exists() {\n        anyhow::bail!(\"File not found: {}\", path.display());\n    }\n\n    let filename = path\n        .file_name()\n        .map(|s| s.to_string_lossy().to_string())\n        .unwrap_or_default();\n\n    fs::remove_file(\u0026path).with_context(|| format!(\"Failed to remove {}\", path.display()))?;\n\n    if !no_commit {\n        commit_removal(\u0026dir, \u0026filename)?;\n    }\n\n    Ok(path)\n}\n\n/// Resolve file path from slug or relative/absolute path\nfn resolve_file_path(file: \u0026str, base_dir: \u0026Path) -\u003e Result\u003cPathBuf\u003e {\n    let path = PathBuf::from(file);\n\n    // If absolute path, use it directly\n    if path.is_absolute() {\n        return Ok(path);\n    }\n\n    // Try relative to base_dir\n    let in_base = base_dir.join(\u0026path);\n    if in_base.exists() {\n        return Ok(in_base);\n    }\n\n    // Try with .md extension\n    let with_ext = base_dir.join(format!(\"{}.md\", file));\n    if with_ext.exists() {\n        return Ok(with_ext);\n    }\n\n    // Try as slug\n    let slug = to_slug(file);\n    let as_slug = base_dir.join(format!(\"{}.md\", slug));\n    if as_slug.exists() {\n        return Ok(as_slug);\n    }\n\n    // Return the path in base_dir (will fail with \"not found\" later)\n    Ok(in_base)\n}\n\n/// Sync (commit and push) documentation changes\npub fn sync(path: Option\u003c\u0026Path\u003e, no_push: bool, message: Option\u003c\u0026str\u003e) -\u003e Result\u003cgit::SyncResult\u003e {\n    let dir = path.map(PathBuf::from).unwrap_or_else(default_docs_dir);\n\n    let options = SyncOptions {\n        no_commit: false,\n        no_push,\n        message: message.map(String::from),\n        path: Some(dir),\n    };\n\n    git::sync(\u0026options)\n}\n\n/// Commit a single file\nfn commit_file(dir: \u0026Path, filename: \u0026str, message: \u0026str) -\u003e Result\u003c()\u003e {\n    use std::process::Command;\n\n    Command::new(\"git\")\n        .args([\"add\", filename])\n        .current_dir(dir)\n        .output()\n        .context(\"Failed to stage file\")?;\n\n    Command::new(\"git\")\n        .args([\"commit\", \"-m\", message])\n        .current_dir(dir)\n        .output()\n        .context(\"Failed to commit\")?;\n\n    Ok(())\n}\n\n/// Commit a file removal\nfn commit_removal(dir: \u0026Path, filename: \u0026str) -\u003e Result\u003c()\u003e {\n    use std::process::Command;\n\n    Command::new(\"git\")\n        .args([\"add\", filename])\n        .current_dir(dir)\n        .output()\n        .context(\"Failed to stage removal\")?;\n\n    Command::new(\"git\")\n        .args([\"commit\", \"-m\", \u0026format!(\"Remove {}\", filename)])\n        .current_dir(dir)\n        .output()\n        .context(\"Failed to commit removal\")?;\n\n    Ok(())\n}\n\n/// Extract slug from URL\nfn slug_from_url(url: \u0026str) -\u003e String {\n    // Remove protocol\n    let url = url\n        .trim_start_matches(\"https://\")\n        .trim_start_matches(\"http://\");\n\n    // Get path parts\n    let parts: Vec\u003c\u0026str\u003e = url.split('/').filter(|s| !s.is_empty()).collect();\n\n    // Try to get meaningful slug from path\n    if parts.len() \u003e 1 {\n        // Use last path segment\n        let last = parts.last().unwrap_or(\u0026\"doc\");\n        let slug = last.trim_end_matches(\".html\").trim_end_matches(\".htm\");\n        return to_slug(slug);\n    }\n\n    // Use domain name\n    if let Some(domain) = parts.first() {\n        let domain = domain.split('.').next().unwrap_or(\"doc\");\n        return to_slug(domain);\n    }\n\n    \"doc\".to_string()\n}\n\n/// Fetch URL content (async)\nasync fn fetch_url(url: \u0026str) -\u003e Result\u003cString\u003e {\n    let client = reqwest::Client::builder()\n        .user_agent(\"hu-cli/0.1\")\n        .build()?;\n\n    let response = client\n        .get(url)\n        .send()\n        .await\n        .with_context(|| format!(\"Failed to fetch {}\", url))?;\n\n    response\n        .text()\n        .await\n        .with_context(|| format!(\"Failed to read response from {}\", url))\n}\n\n/// Convert HTML to markdown (simplified version)\nfn html_to_markdown(html: \u0026str) -\u003e String {\n    use regex::Regex;\n\n    let mut result = html.to_string();\n\n    // Remove script, style, nav, footer\n    for tag in \u0026[\"script\", \"style\", \"noscript\", \"nav\", \"footer\", \"header\"] {\n        let re = Regex::new(\u0026format!(r\"(?is)\u003c{}\\b[^\u003e]*\u003e.*?\u003c/{}\u003e\", tag, tag)).unwrap();\n        result = re.replace_all(\u0026result, \"\").to_string();\n    }\n\n    // Convert headings\n    for level in 1..=6 {\n        let prefix = \"#\".repeat(level);\n        let open_re = Regex::new(\u0026format!(r\"(?i)\u003ch{}\\b[^\u003e]*\u003e\", level)).unwrap();\n        let close_re = Regex::new(\u0026format!(r\"(?i)\u003c/h{}\u003e\", level)).unwrap();\n        result = open_re\n            .replace_all(\u0026result, format!(\"\\n{} \", prefix))\n            .to_string();\n        result = close_re.replace_all(\u0026result, \"\\n\").to_string();\n    }\n\n    // Convert links\n    let link_re = Regex::new(r#\"(?i)\u003ca\\s+[^\u003e]*href=[\"']([^\"']+)[\"'][^\u003e]*\u003e([^\u003c]*)\u003c/a\u003e\"#).unwrap();\n    result = link_re.replace_all(\u0026result, \"[$2]($1)\").to_string();\n\n    // Convert emphasis\n    for tag in [\"strong\", \"b\"] {\n        let re = Regex::new(\u0026format!(r\"(?i)\u003c{}\\b[^\u003e]*\u003e([^\u003c]*)\u003c/{}\u003e\", tag, tag)).unwrap();\n        result = re.replace_all(\u0026result, \"**$1**\").to_string();\n    }\n    for tag in [\"em\", \"i\"] {\n        let re = Regex::new(\u0026format!(r\"(?i)\u003c{}\\b[^\u003e]*\u003e([^\u003c]*)\u003c/{}\u003e\", tag, tag)).unwrap();\n        result = re.replace_all(\u0026result, \"*$1*\").to_string();\n    }\n\n    // Convert code\n    result = Regex::new(r\"(?i)\u003ccode\\b[^\u003e]*\u003e([^\u003c]*)\u003c/code\u003e\")\n        .unwrap()\n        .replace_all(\u0026result, \"`$1`\")\n        .to_string();\n\n    // Convert paragraphs\n    result = Regex::new(r\"(?i)\u003cp\\b[^\u003e]*\u003e\")\n        .unwrap()\n        .replace_all(\u0026result, \"\\n\\n\")\n        .to_string();\n    result = Regex::new(r\"(?i)\u003c/p\u003e\")\n        .unwrap()\n        .replace_all(\u0026result, \"\\n\")\n        .to_string();\n\n    // Convert lists\n    result = Regex::new(r\"(?i)\u003cli\\b[^\u003e]*\u003e\")\n        .unwrap()\n        .replace_all(\u0026result, \"\\n- \")\n        .to_string();\n    result = Regex::new(r\"(?i)\u003c/li\u003e\")\n        .unwrap()\n        .replace_all(\u0026result, \"\")\n        .to_string();\n\n    // Remove remaining tags\n    result = Regex::new(r\"\u003c[^\u003e]+\u003e\")\n        .unwrap()\n        .replace_all(\u0026result, \"\")\n        .to_string();\n\n    // Decode entities\n    result = result\n        .replace(\"\u0026amp;\", \"\u0026\")\n        .replace(\"\u0026lt;\", \"\u003c\")\n        .replace(\"\u0026gt;\", \"\u003e\")\n        .replace(\"\u0026quot;\", \"\\\"\")\n        .replace(\"\u0026#39;\", \"'\")\n        .replace(\"\u0026nbsp;\", \" \");\n\n    // Clean up whitespace\n    result = Regex::new(r\"\\n{3,}\")\n        .unwrap()\n        .replace_all(\u0026result, \"\\n\\n\")\n        .to_string();\n    result = Regex::new(r\"[ \\t]+\")\n        .unwrap()\n        .replace_all(\u0026result, \" \")\n        .to_string();\n\n    result.trim().to_string()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use tempfile::tempdir;\n\n    #[test]\n    fn default_docs_dir_exists() {\n        let dir = default_docs_dir();\n        // Should return a path (may or may not exist)\n        assert!(!dir.as_os_str().is_empty());\n    }\n\n    #[test]\n    fn slug_from_url_path() {\n        assert_eq!(slug_from_url(\"https://docs.rs/clap/latest/clap\"), \"clap\");\n    }\n\n    #[test]\n    fn slug_from_url_html() {\n        assert_eq!(\n            slug_from_url(\"https://example.com/guide/intro.html\"),\n            \"intro\"\n        );\n    }\n\n    #[test]\n    fn slug_from_url_domain_only() {\n        assert_eq!(slug_from_url(\"https://example.com/\"), \"example\");\n    }\n\n    #[test]\n    fn slug_from_url_empty() {\n        assert_eq!(slug_from_url(\"\"), \"doc\");\n    }\n\n    #[test]\n    fn add_creates_file() {\n        let tmp = tempdir().unwrap();\n        let path = add(\"Test Topic\", Some(tmp.path()), true).unwrap();\n\n        assert!(path.exists());\n        let content = fs::read_to_string(\u0026path).unwrap();\n        assert!(content.contains(\"topic: \\\"Test Topic\\\"\"));\n        assert!(content.contains(\"# Test Topic\"));\n    }\n\n    #[test]\n    fn add_fails_if_exists() {\n        let tmp = tempdir().unwrap();\n        let _ = add(\"Duplicate\", Some(tmp.path()), true).unwrap();\n        let result = add(\"Duplicate\", Some(tmp.path()), true);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn list_empty_dir() {\n        let tmp = tempdir().unwrap();\n        let entries = list(Some(tmp.path())).unwrap();\n        assert!(entries.is_empty());\n    }\n\n    #[test]\n    fn list_with_docs() {\n        let tmp = tempdir().unwrap();\n        let _ = add(\"First\", Some(tmp.path()), true).unwrap();\n        let _ = add(\"Second\", Some(tmp.path()), true).unwrap();\n\n        let entries = list(Some(tmp.path())).unwrap();\n        assert_eq!(entries.len(), 2);\n    }\n\n    #[test]\n    fn list_nonexistent_dir() {\n        let entries = list(Some(Path::new(\"/nonexistent/path/docs\"))).unwrap();\n        assert!(entries.is_empty());\n    }\n\n    #[test]\n    fn remove_deletes_file() {\n        let tmp = tempdir().unwrap();\n        let path = add(\"ToRemove\", Some(tmp.path()), true).unwrap();\n        assert!(path.exists());\n\n        remove(\"toremove.md\", Some(tmp.path()), true).unwrap();\n        assert!(!path.exists());\n    }\n\n    #[test]\n    fn remove_by_slug() {\n        let tmp = tempdir().unwrap();\n        let path = add(\"By Slug\", Some(tmp.path()), true).unwrap();\n        assert!(path.exists());\n\n        remove(\"by-slug\", Some(tmp.path()), true).unwrap();\n        assert!(!path.exists());\n    }\n\n    #[test]\n    fn remove_not_found() {\n        let tmp = tempdir().unwrap();\n        let result = remove(\"nonexistent.md\", Some(tmp.path()), true);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn resolve_file_path_absolute() {\n        let path = resolve_file_path(\"/absolute/path.md\", Path::new(\"/base\")).unwrap();\n        assert_eq!(path, PathBuf::from(\"/absolute/path.md\"));\n    }\n\n    #[test]\n    fn resolve_file_path_with_ext() {\n        let tmp = tempdir().unwrap();\n        fs::write(tmp.path().join(\"test.md\"), \"# Test\").unwrap();\n\n        let path = resolve_file_path(\"test.md\", tmp.path()).unwrap();\n        assert!(path.exists());\n    }\n\n    #[test]\n    fn resolve_file_path_without_ext() {\n        let tmp = tempdir().unwrap();\n        fs::write(tmp.path().join(\"test.md\"), \"# Test\").unwrap();\n\n        let path = resolve_file_path(\"test\", tmp.path()).unwrap();\n        assert!(path.exists());\n    }\n\n    #[test]\n    fn parse_doc_entry_basic() {\n        let tmp = tempdir().unwrap();\n        let file = tmp.path().join(\"test.md\");\n        fs::write(\u0026file, \"# My Title\\n\\nContent\").unwrap();\n\n        let entry = parse_doc_entry(\u0026file).unwrap();\n        assert_eq!(entry.title, \"My Title\");\n        assert!(entry.source.is_none());\n    }\n\n    #[test]\n    fn parse_doc_entry_with_frontmatter() {\n        let tmp = tempdir().unwrap();\n        let file = tmp.path().join(\"test.md\");\n        fs::write(\n            \u0026file,\n            \"---\\nsource: https://example.com\\nfetched: 2024-01-01\\n---\\n# Title\",\n        )\n        .unwrap();\n\n        let entry = parse_doc_entry(\u0026file).unwrap();\n        assert_eq!(entry.source, Some(\"https://example.com\".to_string()));\n        assert_eq!(entry.fetched, Some(\"2024-01-01\".to_string()));\n    }\n\n    #[test]\n    fn parse_doc_entry_title_from_topic() {\n        let tmp = tempdir().unwrap();\n        let file = tmp.path().join(\"test.md\");\n        fs::write(\u0026file, \"---\\ntopic: My Topic\\n---\\n\\nNo heading\").unwrap();\n\n        let entry = parse_doc_entry(\u0026file).unwrap();\n        assert_eq!(entry.title, \"My Topic\");\n    }\n\n    #[test]\n    fn parse_doc_entry_title_from_filename() {\n        let tmp = tempdir().unwrap();\n        let file = tmp.path().join(\"my-file.md\");\n        fs::write(\u0026file, \"No frontmatter, no heading\").unwrap();\n\n        let entry = parse_doc_entry(\u0026file).unwrap();\n        assert_eq!(entry.title, \"my-file\");\n    }\n\n    #[test]\n    fn html_to_markdown_headings() {\n        let html = \"\u003ch1\u003eTitle\u003c/h1\u003e\u003ch2\u003eSubtitle\u003c/h2\u003e\";\n        let md = html_to_markdown(html);\n        assert!(md.contains(\"# Title\"));\n        assert!(md.contains(\"## Subtitle\"));\n    }\n\n    #[test]\n    fn html_to_markdown_links() {\n        let html = r#\"\u003ca href=\"https://example.com\"\u003eLink\u003c/a\u003e\"#;\n        let md = html_to_markdown(html);\n        assert!(md.contains(\"[Link](https://example.com)\"));\n    }\n\n    #[test]\n    fn html_to_markdown_emphasis() {\n        let html = \"\u003cstrong\u003ebold\u003c/strong\u003e and \u003cem\u003eitalic\u003c/em\u003e\";\n        let md = html_to_markdown(html);\n        assert!(md.contains(\"**bold**\"));\n        assert!(md.contains(\"*italic*\"));\n    }\n\n    #[test]\n    fn html_to_markdown_code() {\n        let html = \"\u003ccode\u003einline code\u003c/code\u003e\";\n        let md = html_to_markdown(html);\n        assert!(md.contains(\"`inline code`\"));\n    }\n\n    #[test]\n    fn html_to_markdown_strips_scripts() {\n        let html = \"\u003cscript\u003ealert('x')\u003c/script\u003e\u003cp\u003eContent\u003c/p\u003e\";\n        let md = html_to_markdown(html);\n        assert!(!md.contains(\"script\"));\n        assert!(md.contains(\"Content\"));\n    }\n\n    #[test]\n    fn html_to_markdown_entities() {\n        let html = \"\u0026amp; \u0026lt; \u0026gt; \u0026quot;\";\n        let md = html_to_markdown(html);\n        assert!(md.contains(\"\u0026 \u003c \u003e \\\"\"));\n    }\n\n    #[test]\n    fn sync_not_git_repo() {\n        let tmp = tempdir().unwrap();\n        let result = sync(Some(tmp.path()), false, None);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn collect_docs_recursive() {\n        let tmp = tempdir().unwrap();\n        let subdir = tmp.path().join(\"sub\");\n        fs::create_dir(\u0026subdir).unwrap();\n\n        fs::write(tmp.path().join(\"root.md\"), \"# Root\").unwrap();\n        fs::write(subdir.join(\"nested.md\"), \"# Nested\").unwrap();\n\n        let mut entries = Vec::new();\n        collect_docs(tmp.path(), \u0026mut entries).unwrap();\n\n        assert_eq!(entries.len(), 2);\n    }\n\n    #[test]\n    fn collect_docs_ignores_non_md() {\n        let tmp = tempdir().unwrap();\n        fs::write(tmp.path().join(\"doc.md\"), \"# Doc\").unwrap();\n        fs::write(tmp.path().join(\"other.txt\"), \"text\").unwrap();\n\n        let mut entries = Vec::new();\n        collect_docs(tmp.path(), \u0026mut entries).unwrap();\n\n        assert_eq!(entries.len(), 1);\n    }\n\n    #[test]\n    fn list_sorted_by_path() {\n        let tmp = tempdir().unwrap();\n        fs::write(tmp.path().join(\"z-last.md\"), \"# Z\").unwrap();\n        fs::write(tmp.path().join(\"a-first.md\"), \"# A\").unwrap();\n\n        let entries = list(Some(tmp.path())).unwrap();\n        assert_eq!(entries.len(), 2);\n        assert!(entries[0].path.to_string_lossy().contains(\"a-first\"));\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":1}},{"line":11,"address":[],"length":0,"stats":{"Line":1}},{"line":12,"address":[],"length":0,"stats":{"Line":3}},{"line":13,"address":[],"length":0,"stats":{"Line":1}},{"line":17,"address":[],"length":0,"stats":{"Line":7}},{"line":18,"address":[],"length":0,"stats":{"Line":14}},{"line":19,"address":[],"length":0,"stats":{"Line":7}},{"line":20,"address":[],"length":0,"stats":{"Line":7}},{"line":21,"address":[],"length":0,"stats":{"Line":14}},{"line":23,"address":[],"length":0,"stats":{"Line":21}},{"line":24,"address":[],"length":0,"stats":{"Line":21}},{"line":25,"address":[],"length":0,"stats":{"Line":21}},{"line":27,"address":[],"length":0,"stats":{"Line":7}},{"line":28,"address":[],"length":0,"stats":{"Line":3}},{"line":31,"address":[],"length":0,"stats":{"Line":24}},{"line":33,"address":[],"length":0,"stats":{"Line":12}},{"line":34,"address":[],"length":0,"stats":{"Line":6}},{"line":38,"address":[],"length":0,"stats":{"Line":12}},{"line":44,"address":[],"length":0,"stats":{"Line":12}},{"line":48,"address":[],"length":0,"stats":{"Line":24}},{"line":50,"address":[],"length":0,"stats":{"Line":6}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":6}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":4}},{"line":99,"address":[],"length":0,"stats":{"Line":16}},{"line":101,"address":[],"length":0,"stats":{"Line":4}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":105,"address":[],"length":0,"stats":{"Line":6}},{"line":106,"address":[],"length":0,"stats":{"Line":9}},{"line":107,"address":[],"length":0,"stats":{"Line":12}},{"line":109,"address":[],"length":0,"stats":{"Line":3}},{"line":113,"address":[],"length":0,"stats":{"Line":6}},{"line":114,"address":[],"length":0,"stats":{"Line":21}},{"line":115,"address":[],"length":0,"stats":{"Line":18}},{"line":116,"address":[],"length":0,"stats":{"Line":27}},{"line":118,"address":[],"length":0,"stats":{"Line":9}},{"line":119,"address":[],"length":0,"stats":{"Line":3}},{"line":120,"address":[],"length":0,"stats":{"Line":32}},{"line":121,"address":[],"length":0,"stats":{"Line":21}},{"line":122,"address":[],"length":0,"stats":{"Line":14}},{"line":126,"address":[],"length":0,"stats":{"Line":6}},{"line":130,"address":[],"length":0,"stats":{"Line":11}},{"line":131,"address":[],"length":0,"stats":{"Line":33}},{"line":132,"address":[],"length":0,"stats":{"Line":33}},{"line":134,"address":[],"length":0,"stats":{"Line":33}},{"line":135,"address":[],"length":0,"stats":{"Line":33}},{"line":136,"address":[],"length":0,"stats":{"Line":19}},{"line":137,"address":[],"length":0,"stats":{"Line":12}},{"line":138,"address":[],"length":0,"stats":{"Line":2}},{"line":139,"address":[],"length":0,"stats":{"Line":3}},{"line":140,"address":[],"length":0,"stats":{"Line":1}},{"line":144,"address":[],"length":0,"stats":{"Line":22}},{"line":145,"address":[],"length":0,"stats":{"Line":11}},{"line":146,"address":[],"length":0,"stats":{"Line":41}},{"line":147,"address":[],"length":0,"stats":{"Line":11}},{"line":148,"address":[],"length":0,"stats":{"Line":11}},{"line":149,"address":[],"length":0,"stats":{"Line":29}},{"line":150,"address":[],"length":0,"stats":{"Line":22}},{"line":155,"address":[],"length":0,"stats":{"Line":3}},{"line":156,"address":[],"length":0,"stats":{"Line":12}},{"line":159,"address":[],"length":0,"stats":{"Line":12}},{"line":161,"address":[],"length":0,"stats":{"Line":3}},{"line":162,"address":[],"length":0,"stats":{"Line":3}},{"line":165,"address":[],"length":0,"stats":{"Line":4}},{"line":167,"address":[],"length":0,"stats":{"Line":6}},{"line":170,"address":[],"length":0,"stats":{"Line":6}},{"line":172,"address":[],"length":0,"stats":{"Line":2}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":2}},{"line":180,"address":[],"length":0,"stats":{"Line":6}},{"line":181,"address":[],"length":0,"stats":{"Line":18}},{"line":184,"address":[],"length":0,"stats":{"Line":6}},{"line":185,"address":[],"length":0,"stats":{"Line":1}},{"line":189,"address":[],"length":0,"stats":{"Line":20}},{"line":190,"address":[],"length":0,"stats":{"Line":5}},{"line":191,"address":[],"length":0,"stats":{"Line":2}},{"line":195,"address":[],"length":0,"stats":{"Line":15}},{"line":196,"address":[],"length":0,"stats":{"Line":3}},{"line":197,"address":[],"length":0,"stats":{"Line":2}},{"line":201,"address":[],"length":0,"stats":{"Line":3}},{"line":202,"address":[],"length":0,"stats":{"Line":5}},{"line":203,"address":[],"length":0,"stats":{"Line":1}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":1}},{"line":212,"address":[],"length":0,"stats":{"Line":1}},{"line":213,"address":[],"length":0,"stats":{"Line":4}},{"line":218,"address":[],"length":0,"stats":{"Line":2}},{"line":219,"address":[],"length":0,"stats":{"Line":1}},{"line":222,"address":[],"length":0,"stats":{"Line":2}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":4}},{"line":266,"address":[],"length":0,"stats":{"Line":8}},{"line":271,"address":[],"length":0,"stats":{"Line":44}},{"line":274,"address":[],"length":0,"stats":{"Line":4}},{"line":276,"address":[],"length":0,"stats":{"Line":8}},{"line":277,"address":[],"length":0,"stats":{"Line":6}},{"line":278,"address":[],"length":0,"stats":{"Line":4}},{"line":282,"address":[],"length":0,"stats":{"Line":3}},{"line":283,"address":[],"length":0,"stats":{"Line":5}},{"line":284,"address":[],"length":0,"stats":{"Line":2}},{"line":287,"address":[],"length":0,"stats":{"Line":2}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":6}},{"line":312,"address":[],"length":0,"stats":{"Line":18}},{"line":315,"address":[],"length":0,"stats":{"Line":114}},{"line":316,"address":[],"length":0,"stats":{"Line":180}},{"line":317,"address":[],"length":0,"stats":{"Line":108}},{"line":321,"address":[],"length":0,"stats":{"Line":114}},{"line":322,"address":[],"length":0,"stats":{"Line":180}},{"line":323,"address":[],"length":0,"stats":{"Line":180}},{"line":324,"address":[],"length":0,"stats":{"Line":180}},{"line":325,"address":[],"length":0,"stats":{"Line":144}},{"line":326,"address":[],"length":0,"stats":{"Line":144}},{"line":327,"address":[],"length":0,"stats":{"Line":72}},{"line":328,"address":[],"length":0,"stats":{"Line":108}},{"line":332,"address":[],"length":0,"stats":{"Line":24}},{"line":333,"address":[],"length":0,"stats":{"Line":24}},{"line":336,"address":[],"length":0,"stats":{"Line":30}},{"line":337,"address":[],"length":0,"stats":{"Line":60}},{"line":338,"address":[],"length":0,"stats":{"Line":36}},{"line":340,"address":[],"length":0,"stats":{"Line":30}},{"line":341,"address":[],"length":0,"stats":{"Line":60}},{"line":342,"address":[],"length":0,"stats":{"Line":36}},{"line":346,"address":[],"length":0,"stats":{"Line":24}},{"line":347,"address":[],"length":0,"stats":{"Line":12}},{"line":348,"address":[],"length":0,"stats":{"Line":6}},{"line":349,"address":[],"length":0,"stats":{"Line":6}},{"line":352,"address":[],"length":0,"stats":{"Line":24}},{"line":353,"address":[],"length":0,"stats":{"Line":12}},{"line":354,"address":[],"length":0,"stats":{"Line":6}},{"line":355,"address":[],"length":0,"stats":{"Line":6}},{"line":356,"address":[],"length":0,"stats":{"Line":24}},{"line":357,"address":[],"length":0,"stats":{"Line":12}},{"line":358,"address":[],"length":0,"stats":{"Line":6}},{"line":359,"address":[],"length":0,"stats":{"Line":6}},{"line":362,"address":[],"length":0,"stats":{"Line":24}},{"line":363,"address":[],"length":0,"stats":{"Line":12}},{"line":364,"address":[],"length":0,"stats":{"Line":6}},{"line":365,"address":[],"length":0,"stats":{"Line":6}},{"line":366,"address":[],"length":0,"stats":{"Line":24}},{"line":367,"address":[],"length":0,"stats":{"Line":12}},{"line":368,"address":[],"length":0,"stats":{"Line":6}},{"line":369,"address":[],"length":0,"stats":{"Line":6}},{"line":372,"address":[],"length":0,"stats":{"Line":24}},{"line":373,"address":[],"length":0,"stats":{"Line":12}},{"line":374,"address":[],"length":0,"stats":{"Line":6}},{"line":375,"address":[],"length":0,"stats":{"Line":6}},{"line":378,"address":[],"length":0,"stats":{"Line":48}},{"line":379,"address":[],"length":0,"stats":{"Line":36}},{"line":380,"address":[],"length":0,"stats":{"Line":30}},{"line":381,"address":[],"length":0,"stats":{"Line":24}},{"line":382,"address":[],"length":0,"stats":{"Line":18}},{"line":383,"address":[],"length":0,"stats":{"Line":12}},{"line":384,"address":[],"length":0,"stats":{"Line":6}},{"line":387,"address":[],"length":0,"stats":{"Line":24}},{"line":388,"address":[],"length":0,"stats":{"Line":12}},{"line":389,"address":[],"length":0,"stats":{"Line":6}},{"line":390,"address":[],"length":0,"stats":{"Line":6}},{"line":391,"address":[],"length":0,"stats":{"Line":24}},{"line":392,"address":[],"length":0,"stats":{"Line":12}},{"line":393,"address":[],"length":0,"stats":{"Line":6}},{"line":394,"address":[],"length":0,"stats":{"Line":6}},{"line":396,"address":[],"length":0,"stats":{"Line":12}}],"covered":158,"coverable":205},{"path":["/","Users","chi","Projects","hu","src","docs","types.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::path::PathBuf;\n\n/// Representation of a documentation file\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DocEntry {\n    /// Path to the file\n    pub path: PathBuf,\n    /// Document title (from first heading or filename)\n    pub title: String,\n    /// Source URL if fetched from web\n    pub source: Option\u003cString\u003e,\n    /// Date when document was fetched/created\n    pub fetched: Option\u003cString\u003e,\n    /// File size in bytes\n    pub size: u64,\n}\n\n/// YAML frontmatter structure for documentation files\n#[derive(Debug, Clone, Default)]\npub struct Frontmatter {\n    /// Primary source URL\n    pub source: Option\u003cString\u003e,\n    /// Date when document was fetched\n    pub fetched: Option\u003cString\u003e,\n    /// Topic for scaffold files\n    pub topic: Option\u003cString\u003e,\n    /// Date when scaffold was created\n    pub created: Option\u003cString\u003e,\n}\n\nimpl Frontmatter {\n    /// Parse frontmatter from markdown content (simple key: value parsing)\n    pub fn parse(content: \u0026str) -\u003e Option\u003cSelf\u003e {\n        if !content.starts_with(\"---\") {\n            return None;\n        }\n\n        let parts: Vec\u003c\u0026str\u003e = content.splitn(3, \"---\").collect();\n        if parts.len() \u003c 3 {\n            return None;\n        }\n\n        let yaml = parts[1].trim();\n        let mut fm = Frontmatter::default();\n\n        for line in yaml.lines() {\n            let line = line.trim();\n            if let Some((key, value)) = line.split_once(':') {\n                let key = key.trim();\n                let value = value.trim().trim_matches('\"').trim_matches('\\'');\n                match key {\n                    \"source\" =\u003e fm.source = Some(value.to_string()),\n                    \"fetched\" =\u003e fm.fetched = Some(value.to_string()),\n                    \"topic\" =\u003e fm.topic = Some(value.to_string()),\n                    \"created\" =\u003e fm.created = Some(value.to_string()),\n                    _ =\u003e {}\n                }\n            }\n        }\n\n        Some(fm)\n    }\n\n    /// Serialize frontmatter to YAML-like string\n    pub fn to_yaml(\u0026self) -\u003e String {\n        let mut lines = Vec::new();\n        if let Some(ref source) = self.source {\n            lines.push(format!(\"source: {}\", source));\n        }\n        if let Some(ref fetched) = self.fetched {\n            lines.push(format!(\"fetched: {}\", fetched));\n        }\n        if let Some(ref topic) = self.topic {\n            lines.push(format!(\"topic: \\\"{}\\\"\", topic));\n        }\n        if let Some(ref created) = self.created {\n            lines.push(format!(\"created: {}\", created));\n        }\n        if !lines.is_empty() {\n            lines.push(String::new()); // trailing newline\n        }\n        lines.join(\"\\n\")\n    }\n\n    /// Create frontmatter block for markdown\n    pub fn to_block(\u0026self) -\u003e String {\n        format!(\"---\\n{}---\\n\", self.to_yaml())\n    }\n}\n\n/// Convert a string to kebab-case slug\npub fn to_slug(s: \u0026str) -\u003e String {\n    s.to_lowercase()\n        .chars()\n        .map(|c| if c.is_alphanumeric() { c } else { '-' })\n        .collect::\u003cString\u003e()\n        .split('-')\n        .filter(|s| !s.is_empty())\n        .collect::\u003cVec\u003c_\u003e\u003e()\n        .join(\"-\")\n}\n\n/// Extract title from markdown content (first heading)\npub fn extract_title(content: \u0026str) -\u003e Option\u003cString\u003e {\n    for line in content.lines() {\n        let trimmed = line.trim();\n        if let Some(rest) = trimmed.strip_prefix('#') {\n            let title = rest.trim_start_matches('#').trim();\n            if !title.is_empty() {\n                return Some(title.to_string());\n            }\n        }\n    }\n    None\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn to_slug_basic() {\n        assert_eq!(to_slug(\"Hello World\"), \"hello-world\");\n    }\n\n    #[test]\n    fn to_slug_special_chars() {\n        assert_eq!(to_slug(\"Rust's Best Practices!\"), \"rust-s-best-practices\");\n    }\n\n    #[test]\n    fn to_slug_multiple_spaces() {\n        assert_eq!(to_slug(\"one   two  three\"), \"one-two-three\");\n    }\n\n    #[test]\n    fn to_slug_already_slug() {\n        assert_eq!(to_slug(\"already-a-slug\"), \"already-a-slug\");\n    }\n\n    #[test]\n    fn to_slug_empty() {\n        assert_eq!(to_slug(\"\"), \"\");\n    }\n\n    #[test]\n    fn to_slug_numbers() {\n        assert_eq!(to_slug(\"Chapter 1: Introduction\"), \"chapter-1-introduction\");\n    }\n\n    #[test]\n    fn frontmatter_parse_valid() {\n        let content = r#\"---\nsource: https://example.com\nfetched: 2024-01-01\n---\n# Content\"#;\n        let fm = Frontmatter::parse(content).unwrap();\n        assert_eq!(fm.source, Some(\"https://example.com\".to_string()));\n        assert_eq!(fm.fetched, Some(\"2024-01-01\".to_string()));\n    }\n\n    #[test]\n    fn frontmatter_parse_no_frontmatter() {\n        let content = \"# Just Content\";\n        assert!(Frontmatter::parse(content).is_none());\n    }\n\n    #[test]\n    fn frontmatter_parse_incomplete() {\n        let content = \"---\\nsource: test\";\n        assert!(Frontmatter::parse(content).is_none());\n    }\n\n    #[test]\n    fn frontmatter_to_yaml() {\n        let fm = Frontmatter {\n            source: Some(\"https://example.com\".to_string()),\n            fetched: Some(\"2024-01-01\".to_string()),\n            ..Default::default()\n        };\n        let yaml = fm.to_yaml();\n        assert!(yaml.contains(\"source:\"));\n        assert!(yaml.contains(\"https://example.com\"));\n    }\n\n    #[test]\n    fn frontmatter_to_block() {\n        let fm = Frontmatter {\n            source: Some(\"https://test.com\".to_string()),\n            ..Default::default()\n        };\n        let block = fm.to_block();\n        assert!(block.starts_with(\"---\\n\"));\n        assert!(block.ends_with(\"---\\n\"));\n    }\n\n    #[test]\n    fn frontmatter_skips_none_values() {\n        let fm = Frontmatter {\n            source: Some(\"url\".to_string()),\n            fetched: None,\n            topic: None,\n            created: None,\n        };\n        let yaml = fm.to_yaml();\n        assert!(!yaml.contains(\"fetched:\"));\n        assert!(!yaml.contains(\"topic:\"));\n    }\n\n    #[test]\n    fn frontmatter_parse_ignores_unknown_keys() {\n        let content = r#\"---\nsource: https://example.com\nunknown_key: some_value\nanother_unknown: test\nfetched: 2024-01-01\n---\n# Content\"#;\n        let fm = Frontmatter::parse(content).unwrap();\n        assert_eq!(fm.source, Some(\"https://example.com\".to_string()));\n        assert_eq!(fm.fetched, Some(\"2024-01-01\".to_string()));\n    }\n\n    #[test]\n    fn extract_title_h1() {\n        let content = \"# My Title\\n\\nContent here\";\n        assert_eq!(extract_title(content), Some(\"My Title\".to_string()));\n    }\n\n    #[test]\n    fn extract_title_h2() {\n        let content = \"## Second Level\\n\\nContent\";\n        assert_eq!(extract_title(content), Some(\"Second Level\".to_string()));\n    }\n\n    #[test]\n    fn extract_title_with_frontmatter() {\n        let content = \"---\\nsource: url\\n---\\n\\n# Actual Title\";\n        assert_eq!(extract_title(content), Some(\"Actual Title\".to_string()));\n    }\n\n    #[test]\n    fn extract_title_no_heading() {\n        let content = \"Just plain text\\nNo headings here\";\n        assert!(extract_title(content).is_none());\n    }\n\n    #[test]\n    fn extract_title_empty_heading() {\n        let content = \"#\\n\\nNo text after hash\";\n        assert!(extract_title(content).is_none());\n    }\n\n    #[test]\n    fn doc_entry_serialize() {\n        let entry = DocEntry {\n            path: PathBuf::from(\"/docs/test.md\"),\n            title: \"Test\".to_string(),\n            source: Some(\"https://example.com\".to_string()),\n            fetched: Some(\"2024-01-01\".to_string()),\n            size: 1234,\n        };\n        let json = serde_json::to_string(\u0026entry).unwrap();\n        assert!(json.contains(\"Test\"));\n        assert!(json.contains(\"1234\"));\n    }\n\n    #[test]\n    fn doc_entry_debug() {\n        let entry = DocEntry {\n            path: PathBuf::from(\"test.md\"),\n            title: \"Test\".to_string(),\n            source: None,\n            fetched: None,\n            size: 0,\n        };\n        let debug = format!(\"{:?}\", entry);\n        assert!(debug.contains(\"DocEntry\"));\n    }\n\n    #[test]\n    fn frontmatter_parse_with_source() {\n        let content = r#\"---\nsource: https://main.com\nfetched: 2024-02-01\n---\n# Content\"#;\n        let fm = Frontmatter::parse(content).unwrap();\n        assert_eq!(fm.source, Some(\"https://main.com\".to_string()));\n        assert_eq!(fm.fetched, Some(\"2024-02-01\".to_string()));\n    }\n\n    #[test]\n    fn frontmatter_parse_topic() {\n        let content = r#\"---\ntopic: Rust Error Handling\ncreated: 2024-01-01\n---\n# Content\"#;\n        let fm = Frontmatter::parse(content).unwrap();\n        assert_eq!(fm.topic, Some(\"Rust Error Handling\".to_string()));\n        assert_eq!(fm.created, Some(\"2024-01-01\".to_string()));\n    }\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":17}},{"line":35,"address":[],"length":0,"stats":{"Line":17}},{"line":36,"address":[],"length":0,"stats":{"Line":8}},{"line":39,"address":[],"length":0,"stats":{"Line":45}},{"line":40,"address":[],"length":0,"stats":{"Line":9}},{"line":41,"address":[],"length":0,"stats":{"Line":1}},{"line":44,"address":[],"length":0,"stats":{"Line":24}},{"line":45,"address":[],"length":0,"stats":{"Line":16}},{"line":47,"address":[],"length":0,"stats":{"Line":33}},{"line":48,"address":[],"length":0,"stats":{"Line":51}},{"line":49,"address":[],"length":0,"stats":{"Line":51}},{"line":50,"address":[],"length":0,"stats":{"Line":51}},{"line":51,"address":[],"length":0,"stats":{"Line":51}},{"line":52,"address":[],"length":0,"stats":{"Line":17}},{"line":53,"address":[],"length":0,"stats":{"Line":25}},{"line":54,"address":[],"length":0,"stats":{"Line":21}},{"line":55,"address":[],"length":0,"stats":{"Line":17}},{"line":56,"address":[],"length":0,"stats":{"Line":11}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":62,"address":[],"length":0,"stats":{"Line":8}},{"line":66,"address":[],"length":0,"stats":{"Line":9}},{"line":67,"address":[],"length":0,"stats":{"Line":18}},{"line":68,"address":[],"length":0,"stats":{"Line":15}},{"line":69,"address":[],"length":0,"stats":{"Line":9}},{"line":71,"address":[],"length":0,"stats":{"Line":11}},{"line":72,"address":[],"length":0,"stats":{"Line":3}},{"line":74,"address":[],"length":0,"stats":{"Line":21}},{"line":75,"address":[],"length":0,"stats":{"Line":18}},{"line":77,"address":[],"length":0,"stats":{"Line":21}},{"line":78,"address":[],"length":0,"stats":{"Line":18}},{"line":80,"address":[],"length":0,"stats":{"Line":18}},{"line":81,"address":[],"length":0,"stats":{"Line":18}},{"line":83,"address":[],"length":0,"stats":{"Line":18}},{"line":87,"address":[],"length":0,"stats":{"Line":7}},{"line":88,"address":[],"length":0,"stats":{"Line":28}},{"line":93,"address":[],"length":0,"stats":{"Line":17}},{"line":94,"address":[],"length":0,"stats":{"Line":17}},{"line":96,"address":[],"length":0,"stats":{"Line":697}},{"line":99,"address":[],"length":0,"stats":{"Line":87}},{"line":105,"address":[],"length":0,"stats":{"Line":16}},{"line":106,"address":[],"length":0,"stats":{"Line":73}},{"line":107,"address":[],"length":0,"stats":{"Line":123}},{"line":108,"address":[],"length":0,"stats":{"Line":54}},{"line":109,"address":[],"length":0,"stats":{"Line":39}},{"line":110,"address":[],"length":0,"stats":{"Line":13}},{"line":111,"address":[],"length":0,"stats":{"Line":12}},{"line":115,"address":[],"length":0,"stats":{"Line":4}}],"covered":47,"coverable":47},{"path":["/","Users","chi","Projects","hu","src","eks","cli.rs"],"content":"//! EKS CLI commands\n\nuse clap::Subcommand;\n\n#[derive(Debug, Subcommand)]\npub enum EksCommand {\n    /// List pods in the cluster\n    List {\n        /// Namespace to list pods from\n        #[arg(short, long)]\n        namespace: Option\u003cString\u003e,\n\n        /// List pods from all namespaces\n        #[arg(short = 'A', long)]\n        all_namespaces: bool,\n\n        /// Kubeconfig context to use\n        #[arg(short, long)]\n        context: Option\u003cString\u003e,\n\n        /// Output as JSON\n        #[arg(long)]\n        json: bool,\n    },\n\n    /// Execute a command in a pod (interactive shell by default)\n    Exec {\n        /// Pod name\n        pod: String,\n\n        /// Namespace\n        #[arg(short, long)]\n        namespace: Option\u003cString\u003e,\n\n        /// Container name (if pod has multiple containers)\n        #[arg(short, long)]\n        container: Option\u003cString\u003e,\n\n        /// Kubeconfig context to use\n        #[arg(long)]\n        context: Option\u003cString\u003e,\n\n        /// Command to run (default: /bin/sh)\n        #[arg(last = true)]\n        command: Vec\u003cString\u003e,\n    },\n\n    /// Tail logs from a pod\n    Logs {\n        /// Pod name\n        pod: String,\n\n        /// Namespace\n        #[arg(short, long)]\n        namespace: Option\u003cString\u003e,\n\n        /// Container name (if pod has multiple containers)\n        #[arg(short, long)]\n        container: Option\u003cString\u003e,\n\n        /// Follow log output\n        #[arg(short, long)]\n        follow: bool,\n\n        /// Show logs from previous container instance\n        #[arg(long)]\n        previous: bool,\n\n        /// Number of lines to show from the end\n        #[arg(long)]\n        tail: Option\u003cusize\u003e,\n\n        /// Kubeconfig context to use\n        #[arg(long)]\n        context: Option\u003cString\u003e,\n    },\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use clap::{CommandFactory, Parser};\n\n    #[derive(Parser)]\n    struct TestCli {\n        #[command(subcommand)]\n        cmd: EksCommand,\n    }\n\n    #[test]\n    fn parses_list_basic() {\n        let cli = TestCli::try_parse_from([\"test\", \"list\"]).unwrap();\n        match cli.cmd {\n            EksCommand::List {\n                namespace,\n                all_namespaces,\n                context,\n                json,\n            } =\u003e {\n                assert!(namespace.is_none());\n                assert!(!all_namespaces);\n                assert!(context.is_none());\n                assert!(!json);\n            }\n            _ =\u003e panic!(\"Expected List command\"),\n        }\n    }\n\n    #[test]\n    fn parses_list_with_namespace() {\n        let cli = TestCli::try_parse_from([\"test\", \"list\", \"-n\", \"kube-system\"]).unwrap();\n        match cli.cmd {\n            EksCommand::List { namespace, .. } =\u003e {\n                assert_eq!(namespace, Some(\"kube-system\".to_string()));\n            }\n            _ =\u003e panic!(\"Expected List command\"),\n        }\n    }\n\n    #[test]\n    fn parses_list_all_namespaces() {\n        let cli = TestCli::try_parse_from([\"test\", \"list\", \"-A\"]).unwrap();\n        match cli.cmd {\n            EksCommand::List { all_namespaces, .. } =\u003e {\n                assert!(all_namespaces);\n            }\n            _ =\u003e panic!(\"Expected List command\"),\n        }\n    }\n\n    #[test]\n    fn parses_list_with_context() {\n        let cli = TestCli::try_parse_from([\"test\", \"list\", \"-c\", \"prod\"]).unwrap();\n        match cli.cmd {\n            EksCommand::List { context, .. } =\u003e {\n                assert_eq!(context, Some(\"prod\".to_string()));\n            }\n            _ =\u003e panic!(\"Expected List command\"),\n        }\n    }\n\n    #[test]\n    fn parses_list_json() {\n        let cli = TestCli::try_parse_from([\"test\", \"list\", \"--json\"]).unwrap();\n        match cli.cmd {\n            EksCommand::List { json, .. } =\u003e {\n                assert!(json);\n            }\n            _ =\u003e panic!(\"Expected List command\"),\n        }\n    }\n\n    #[test]\n    fn parses_exec_basic() {\n        let cli = TestCli::try_parse_from([\"test\", \"exec\", \"my-pod\"]).unwrap();\n        match cli.cmd {\n            EksCommand::Exec {\n                pod,\n                namespace,\n                container,\n                command,\n                ..\n            } =\u003e {\n                assert_eq!(pod, \"my-pod\");\n                assert!(namespace.is_none());\n                assert!(container.is_none());\n                assert!(command.is_empty());\n            }\n            _ =\u003e panic!(\"Expected Exec command\"),\n        }\n    }\n\n    #[test]\n    fn parses_exec_with_namespace() {\n        let cli = TestCli::try_parse_from([\"test\", \"exec\", \"my-pod\", \"-n\", \"prod\"]).unwrap();\n        match cli.cmd {\n            EksCommand::Exec { namespace, .. } =\u003e {\n                assert_eq!(namespace, Some(\"prod\".to_string()));\n            }\n            _ =\u003e panic!(\"Expected Exec command\"),\n        }\n    }\n\n    #[test]\n    fn parses_exec_with_container() {\n        let cli = TestCli::try_parse_from([\"test\", \"exec\", \"my-pod\", \"-c\", \"app\"]).unwrap();\n        match cli.cmd {\n            EksCommand::Exec { container, .. } =\u003e {\n                assert_eq!(container, Some(\"app\".to_string()));\n            }\n            _ =\u003e panic!(\"Expected Exec command\"),\n        }\n    }\n\n    #[test]\n    fn parses_exec_with_command() {\n        let cli =\n            TestCli::try_parse_from([\"test\", \"exec\", \"my-pod\", \"--\", \"bash\", \"-c\", \"ls\"]).unwrap();\n        match cli.cmd {\n            EksCommand::Exec { command, .. } =\u003e {\n                assert_eq!(command, vec![\"bash\", \"-c\", \"ls\"]);\n            }\n            _ =\u003e panic!(\"Expected Exec command\"),\n        }\n    }\n\n    #[test]\n    fn parses_logs_basic() {\n        let cli = TestCli::try_parse_from([\"test\", \"logs\", \"my-pod\"]).unwrap();\n        match cli.cmd {\n            EksCommand::Logs {\n                pod,\n                follow,\n                previous,\n                tail,\n                ..\n            } =\u003e {\n                assert_eq!(pod, \"my-pod\");\n                assert!(!follow);\n                assert!(!previous);\n                assert!(tail.is_none());\n            }\n            _ =\u003e panic!(\"Expected Logs command\"),\n        }\n    }\n\n    #[test]\n    fn parses_logs_follow() {\n        let cli = TestCli::try_parse_from([\"test\", \"logs\", \"my-pod\", \"-f\"]).unwrap();\n        match cli.cmd {\n            EksCommand::Logs { follow, .. } =\u003e {\n                assert!(follow);\n            }\n            _ =\u003e panic!(\"Expected Logs command\"),\n        }\n    }\n\n    #[test]\n    fn parses_logs_previous() {\n        let cli = TestCli::try_parse_from([\"test\", \"logs\", \"my-pod\", \"--previous\"]).unwrap();\n        match cli.cmd {\n            EksCommand::Logs { previous, .. } =\u003e {\n                assert!(previous);\n            }\n            _ =\u003e panic!(\"Expected Logs command\"),\n        }\n    }\n\n    #[test]\n    fn parses_logs_tail() {\n        let cli = TestCli::try_parse_from([\"test\", \"logs\", \"my-pod\", \"--tail\", \"100\"]).unwrap();\n        match cli.cmd {\n            EksCommand::Logs { tail, .. } =\u003e {\n                assert_eq!(tail, Some(100));\n            }\n            _ =\u003e panic!(\"Expected Logs command\"),\n        }\n    }\n\n    #[test]\n    fn parses_logs_with_container() {\n        let cli = TestCli::try_parse_from([\"test\", \"logs\", \"my-pod\", \"-c\", \"sidecar\"]).unwrap();\n        match cli.cmd {\n            EksCommand::Logs { container, .. } =\u003e {\n                assert_eq!(container, Some(\"sidecar\".to_string()));\n            }\n            _ =\u003e panic!(\"Expected Logs command\"),\n        }\n    }\n\n    #[test]\n    fn command_debug() {\n        let cmd = EksCommand::List {\n            namespace: None,\n            all_namespaces: false,\n            context: None,\n            json: false,\n        };\n        let debug = format!(\"{:?}\", cmd);\n        assert!(debug.contains(\"List\"));\n    }\n\n    #[test]\n    fn command_has_help() {\n        let mut cmd = TestCli::command();\n        let help = cmd.render_help();\n        assert!(!help.to_string().is_empty());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","eks","display.rs"],"content":"//! EKS output formatting\n\nuse anyhow::{Context, Result};\nuse comfy_table::{presets::UTF8_FULL_CONDENSED, Cell, Color, ContentArrangement, Table};\n\nuse super::types::{OutputFormat, Pod};\n\n/// Get color for pod status\nfn status_color(status: \u0026str) -\u003e Color {\n    match status {\n        \"Running\" =\u003e Color::Green,\n        \"Pending\" =\u003e Color::Yellow,\n        \"Succeeded\" =\u003e Color::Cyan,\n        \"Failed\" =\u003e Color::Red,\n        \"Unknown\" =\u003e Color::DarkGrey,\n        _ =\u003e Color::White,\n    }\n}\n\n/// Output pods list\npub fn output_pods(pods: \u0026[Pod], format: OutputFormat, show_namespace: bool) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            if pods.is_empty() {\n                println!(\"No pods found.\");\n                return Ok(());\n            }\n\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_content_arrangement(ContentArrangement::Dynamic);\n\n            if show_namespace {\n                table.set_header(vec![\n                    \"NAMESPACE\",\n                    \"NAME\",\n                    \"READY\",\n                    \"STATUS\",\n                    \"RESTARTS\",\n                    \"AGE\",\n                ]);\n            } else {\n                table.set_header(vec![\"NAME\", \"READY\", \"STATUS\", \"RESTARTS\", \"AGE\"]);\n            }\n\n            for pod in pods {\n                if show_namespace {\n                    table.add_row(vec![\n                        Cell::new(\u0026pod.namespace),\n                        Cell::new(\u0026pod.name).fg(Color::Cyan),\n                        Cell::new(\u0026pod.ready),\n                        Cell::new(\u0026pod.status).fg(status_color(\u0026pod.status)),\n                        Cell::new(pod.restarts.to_string()),\n                        Cell::new(\u0026pod.age),\n                    ]);\n                } else {\n                    table.add_row(vec![\n                        Cell::new(\u0026pod.name).fg(Color::Cyan),\n                        Cell::new(\u0026pod.ready),\n                        Cell::new(\u0026pod.status).fg(status_color(\u0026pod.status)),\n                        Cell::new(pod.restarts.to_string()),\n                        Cell::new(\u0026pod.age),\n                    ]);\n                }\n            }\n\n            println!(\"{table}\");\n            println!(\"\\n{} pods\", pods.len());\n        }\n        OutputFormat::Json =\u003e {\n            let json = serde_json::to_string_pretty(pods).context(\"Failed to serialize pods\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn status_color_running() {\n        assert_eq!(status_color(\"Running\"), Color::Green);\n    }\n\n    #[test]\n    fn status_color_pending() {\n        assert_eq!(status_color(\"Pending\"), Color::Yellow);\n    }\n\n    #[test]\n    fn status_color_succeeded() {\n        assert_eq!(status_color(\"Succeeded\"), Color::Cyan);\n    }\n\n    #[test]\n    fn status_color_failed() {\n        assert_eq!(status_color(\"Failed\"), Color::Red);\n    }\n\n    #[test]\n    fn status_color_unknown() {\n        assert_eq!(status_color(\"Unknown\"), Color::DarkGrey);\n    }\n\n    #[test]\n    fn status_color_other() {\n        assert_eq!(status_color(\"CrashLoopBackOff\"), Color::White);\n    }\n\n    #[test]\n    fn output_pods_empty() {\n        let result = output_pods(\u0026[], OutputFormat::Table, false);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn output_pods_table() {\n        let pods = vec![Pod {\n            name: \"test-pod\".to_string(),\n            namespace: \"default\".to_string(),\n            status: \"Running\".to_string(),\n            ready: \"1/1\".to_string(),\n            restarts: 0,\n            age: \"1d\".to_string(),\n            node: None,\n        }];\n        let result = output_pods(\u0026pods, OutputFormat::Table, false);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn output_pods_table_with_namespace() {\n        let pods = vec![Pod {\n            name: \"test-pod\".to_string(),\n            namespace: \"kube-system\".to_string(),\n            status: \"Running\".to_string(),\n            ready: \"1/1\".to_string(),\n            restarts: 0,\n            age: \"1d\".to_string(),\n            node: None,\n        }];\n        let result = output_pods(\u0026pods, OutputFormat::Table, true);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn output_pods_json() {\n        let pods = vec![Pod {\n            name: \"test-pod\".to_string(),\n            namespace: \"default\".to_string(),\n            status: \"Running\".to_string(),\n            ready: \"1/1\".to_string(),\n            restarts: 0,\n            age: \"1d\".to_string(),\n            node: None,\n        }];\n        let result = output_pods(\u0026pods, OutputFormat::Json, false);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn output_pods_json_empty() {\n        let result = output_pods(\u0026[], OutputFormat::Json, false);\n        assert!(result.is_ok());\n    }\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":8}},{"line":10,"address":[],"length":0,"stats":{"Line":8}},{"line":11,"address":[],"length":0,"stats":{"Line":11}},{"line":12,"address":[],"length":0,"stats":{"Line":6}},{"line":13,"address":[],"length":0,"stats":{"Line":5}},{"line":14,"address":[],"length":0,"stats":{"Line":4}},{"line":15,"address":[],"length":0,"stats":{"Line":3}},{"line":16,"address":[],"length":0,"stats":{"Line":1}},{"line":21,"address":[],"length":0,"stats":{"Line":5}},{"line":22,"address":[],"length":0,"stats":{"Line":5}},{"line":24,"address":[],"length":0,"stats":{"Line":6}},{"line":25,"address":[],"length":0,"stats":{"Line":2}},{"line":26,"address":[],"length":0,"stats":{"Line":1}},{"line":29,"address":[],"length":0,"stats":{"Line":4}},{"line":30,"address":[],"length":0,"stats":{"Line":6}},{"line":31,"address":[],"length":0,"stats":{"Line":6}},{"line":33,"address":[],"length":0,"stats":{"Line":3}},{"line":34,"address":[],"length":0,"stats":{"Line":4}},{"line":35,"address":[],"length":0,"stats":{"Line":1}},{"line":36,"address":[],"length":0,"stats":{"Line":2}},{"line":37,"address":[],"length":0,"stats":{"Line":2}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":39,"address":[],"length":0,"stats":{"Line":1}},{"line":40,"address":[],"length":0,"stats":{"Line":1}},{"line":43,"address":[],"length":0,"stats":{"Line":6}},{"line":46,"address":[],"length":0,"stats":{"Line":6}},{"line":47,"address":[],"length":0,"stats":{"Line":3}},{"line":48,"address":[],"length":0,"stats":{"Line":4}},{"line":49,"address":[],"length":0,"stats":{"Line":3}},{"line":50,"address":[],"length":0,"stats":{"Line":5}},{"line":51,"address":[],"length":0,"stats":{"Line":3}},{"line":52,"address":[],"length":0,"stats":{"Line":6}},{"line":53,"address":[],"length":0,"stats":{"Line":4}},{"line":54,"address":[],"length":0,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":4}},{"line":58,"address":[],"length":0,"stats":{"Line":5}},{"line":59,"address":[],"length":0,"stats":{"Line":3}},{"line":60,"address":[],"length":0,"stats":{"Line":6}},{"line":61,"address":[],"length":0,"stats":{"Line":4}},{"line":62,"address":[],"length":0,"stats":{"Line":1}},{"line":67,"address":[],"length":0,"stats":{"Line":4}},{"line":68,"address":[],"length":0,"stats":{"Line":8}},{"line":71,"address":[],"length":0,"stats":{"Line":8}},{"line":72,"address":[],"length":0,"stats":{"Line":4}},{"line":75,"address":[],"length":0,"stats":{"Line":4}}],"covered":45,"coverable":45},{"path":["/","Users","chi","Projects","hu","src","eks","kubectl","mod.rs"],"content":"//! kubectl wrapper functions\n\nuse anyhow::{Context, Result};\nuse std::process::{Command, Stdio};\n\nuse super::types::{KubectlConfig, Pod, PodList};\n\n#[cfg(test)]\nmod tests;\n\n/// Build kubectl base command with context/namespace\nfn build_kubectl_cmd(config: \u0026KubectlConfig) -\u003e Command {\n    let mut cmd = Command::new(\"kubectl\");\n\n    if let Some(ctx) = \u0026config.context {\n        cmd.arg(\"--context\").arg(ctx);\n    }\n\n    if let Some(ns) = \u0026config.namespace {\n        cmd.arg(\"-n\").arg(ns);\n    }\n\n    cmd\n}\n\n/// List pods using kubectl\npub fn list_pods(config: \u0026KubectlConfig, all_namespaces: bool) -\u003e Result\u003cVec\u003cPod\u003e\u003e {\n    let mut cmd = build_kubectl_cmd(config);\n    cmd.arg(\"get\").arg(\"pods\").arg(\"-o\").arg(\"json\");\n\n    if all_namespaces {\n        cmd.arg(\"--all-namespaces\");\n    }\n\n    let output = cmd\n        .output()\n        .context(\"Failed to execute kubectl. Is kubectl installed and configured?\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"kubectl failed: {}\", stderr.trim());\n    }\n\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    parse_pod_list(\u0026stdout)\n}\n\n/// Parse kubectl JSON output into Pod list\npub fn parse_pod_list(json: \u0026str) -\u003e Result\u003cVec\u003cPod\u003e\u003e {\n    let pod_list: PodList = serde_json::from_str(json).context(\"Failed to parse kubectl output\")?;\n\n    Ok(pod_list.items.iter().map(|item| item.to_pod()).collect())\n}\n\n/// Execute into a pod (interactive)\npub fn exec_pod(\n    config: \u0026KubectlConfig,\n    pod: \u0026str,\n    container: Option\u003c\u0026str\u003e,\n    command: \u0026[String],\n) -\u003e Result\u003c()\u003e {\n    let mut cmd = build_kubectl_cmd(config);\n    cmd.arg(\"exec\").arg(\"-it\").arg(pod);\n\n    if let Some(c) = container {\n        cmd.arg(\"-c\").arg(c);\n    }\n\n    cmd.arg(\"--\");\n\n    if command.is_empty() {\n        cmd.arg(\"/bin/sh\");\n    } else {\n        for arg in command {\n            cmd.arg(arg);\n        }\n    }\n\n    // Run interactively\n    cmd.stdin(Stdio::inherit())\n        .stdout(Stdio::inherit())\n        .stderr(Stdio::inherit());\n\n    let status = cmd.status().context(\"Failed to execute kubectl exec\")?;\n\n    if !status.success() {\n        anyhow::bail!(\"kubectl exec exited with status: {}\", status);\n    }\n\n    Ok(())\n}\n\n/// Tail logs from a pod\n#[allow(clippy::too_many_arguments)]\npub fn tail_logs(\n    config: \u0026KubectlConfig,\n    pod: \u0026str,\n    container: Option\u003c\u0026str\u003e,\n    follow: bool,\n    previous: bool,\n    tail_lines: Option\u003cusize\u003e,\n) -\u003e Result\u003c()\u003e {\n    let mut cmd = build_kubectl_cmd(config);\n    cmd.arg(\"logs\").arg(pod);\n\n    if let Some(c) = container {\n        cmd.arg(\"-c\").arg(c);\n    }\n\n    if follow {\n        cmd.arg(\"-f\");\n    }\n\n    if previous {\n        cmd.arg(\"--previous\");\n    }\n\n    if let Some(n) = tail_lines {\n        cmd.arg(\"--tail\").arg(n.to_string());\n    }\n\n    // Stream output\n    cmd.stdin(Stdio::inherit())\n        .stdout(Stdio::inherit())\n        .stderr(Stdio::inherit());\n\n    let status = cmd.status().context(\"Failed to execute kubectl logs\")?;\n\n    if !status.success() {\n        anyhow::bail!(\"kubectl logs exited with status: {}\", status);\n    }\n\n    Ok(())\n}\n\n/// Get list of containers in a pod\n#[allow(dead_code)]\npub fn get_containers(config: \u0026KubectlConfig, pod: \u0026str) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n    let mut cmd = build_kubectl_cmd(config);\n    cmd.arg(\"get\")\n        .arg(\"pod\")\n        .arg(pod)\n        .arg(\"-o\")\n        .arg(\"jsonpath={.spec.containers[*].name}\");\n\n    let output = cmd.output().context(\"Failed to execute kubectl\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"kubectl failed: {}\", stderr.trim());\n    }\n\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    Ok(stdout.split_whitespace().map(|s| s.to_string()).collect())\n}\n\n/// Build kubectl command args (for testing)\n#[cfg(test)]\npub fn build_list_args(config: \u0026KubectlConfig, all_namespaces: bool) -\u003e Vec\u003cString\u003e {\n    let mut args = Vec::new();\n\n    if let Some(ctx) = \u0026config.context {\n        args.push(\"--context\".to_string());\n        args.push(ctx.clone());\n    }\n\n    if let Some(ns) = \u0026config.namespace {\n        args.push(\"-n\".to_string());\n        args.push(ns.clone());\n    }\n\n    args.push(\"get\".to_string());\n    args.push(\"pods\".to_string());\n    args.push(\"-o\".to_string());\n    args.push(\"json\".to_string());\n\n    if all_namespaces {\n        args.push(\"--all-namespaces\".to_string());\n    }\n\n    args\n}\n\n/// Build kubectl exec args (for testing)\n#[cfg(test)]\npub fn build_exec_args(\n    config: \u0026KubectlConfig,\n    pod: \u0026str,\n    container: Option\u003c\u0026str\u003e,\n    command: \u0026[String],\n) -\u003e Vec\u003cString\u003e {\n    let mut args = Vec::new();\n\n    if let Some(ctx) = \u0026config.context {\n        args.push(\"--context\".to_string());\n        args.push(ctx.clone());\n    }\n\n    if let Some(ns) = \u0026config.namespace {\n        args.push(\"-n\".to_string());\n        args.push(ns.clone());\n    }\n\n    args.push(\"exec\".to_string());\n    args.push(\"-it\".to_string());\n    args.push(pod.to_string());\n\n    if let Some(c) = container {\n        args.push(\"-c\".to_string());\n        args.push(c.to_string());\n    }\n\n    args.push(\"--\".to_string());\n\n    if command.is_empty() {\n        args.push(\"/bin/sh\".to_string());\n    } else {\n        args.extend(command.iter().cloned());\n    }\n\n    args\n}\n\n/// Build kubectl logs args (for testing)\n#[cfg(test)]\n#[allow(clippy::too_many_arguments)]\npub fn build_logs_args(\n    config: \u0026KubectlConfig,\n    pod: \u0026str,\n    container: Option\u003c\u0026str\u003e,\n    follow: bool,\n    previous: bool,\n    tail_lines: Option\u003cusize\u003e,\n) -\u003e Vec\u003cString\u003e {\n    let mut args = Vec::new();\n\n    if let Some(ctx) = \u0026config.context {\n        args.push(\"--context\".to_string());\n        args.push(ctx.clone());\n    }\n\n    if let Some(ns) = \u0026config.namespace {\n        args.push(\"-n\".to_string());\n        args.push(ns.clone());\n    }\n\n    args.push(\"logs\".to_string());\n    args.push(pod.to_string());\n\n    if let Some(c) = container {\n        args.push(\"-c\".to_string());\n        args.push(c.to_string());\n    }\n\n    if follow {\n        args.push(\"-f\".to_string());\n    }\n\n    if previous {\n        args.push(\"--previous\".to_string());\n    }\n\n    if let Some(n) = tail_lines {\n        args.push(\"--tail\".to_string());\n        args.push(n.to_string());\n    }\n\n    args\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":1}},{"line":13,"address":[],"length":0,"stats":{"Line":2}},{"line":15,"address":[],"length":0,"stats":{"Line":1}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":1}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":1}},{"line":27,"address":[],"length":0,"stats":{"Line":1}},{"line":28,"address":[],"length":0,"stats":{"Line":3}},{"line":29,"address":[],"length":0,"stats":{"Line":2}},{"line":31,"address":[],"length":0,"stats":{"Line":1}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":2}},{"line":39,"address":[],"length":0,"stats":{"Line":1}},{"line":40,"address":[],"length":0,"stats":{"Line":3}},{"line":41,"address":[],"length":0,"stats":{"Line":3}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":9}},{"line":50,"address":[],"length":0,"stats":{"Line":44}},{"line":52,"address":[],"length":0,"stats":{"Line":40}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":5}},{"line":160,"address":[],"length":0,"stats":{"Line":10}},{"line":162,"address":[],"length":0,"stats":{"Line":9}},{"line":163,"address":[],"length":0,"stats":{"Line":10}},{"line":164,"address":[],"length":0,"stats":{"Line":6}},{"line":167,"address":[],"length":0,"stats":{"Line":9}},{"line":168,"address":[],"length":0,"stats":{"Line":10}},{"line":169,"address":[],"length":0,"stats":{"Line":6}},{"line":172,"address":[],"length":0,"stats":{"Line":20}},{"line":173,"address":[],"length":0,"stats":{"Line":20}},{"line":174,"address":[],"length":0,"stats":{"Line":20}},{"line":175,"address":[],"length":0,"stats":{"Line":20}},{"line":177,"address":[],"length":0,"stats":{"Line":7}},{"line":178,"address":[],"length":0,"stats":{"Line":6}},{"line":181,"address":[],"length":0,"stats":{"Line":5}},{"line":186,"address":[],"length":0,"stats":{"Line":8}},{"line":192,"address":[],"length":0,"stats":{"Line":16}},{"line":194,"address":[],"length":0,"stats":{"Line":14}},{"line":195,"address":[],"length":0,"stats":{"Line":15}},{"line":196,"address":[],"length":0,"stats":{"Line":9}},{"line":199,"address":[],"length":0,"stats":{"Line":14}},{"line":200,"address":[],"length":0,"stats":{"Line":15}},{"line":201,"address":[],"length":0,"stats":{"Line":9}},{"line":204,"address":[],"length":0,"stats":{"Line":32}},{"line":205,"address":[],"length":0,"stats":{"Line":32}},{"line":206,"address":[],"length":0,"stats":{"Line":32}},{"line":208,"address":[],"length":0,"stats":{"Line":14}},{"line":209,"address":[],"length":0,"stats":{"Line":15}},{"line":210,"address":[],"length":0,"stats":{"Line":9}},{"line":213,"address":[],"length":0,"stats":{"Line":32}},{"line":215,"address":[],"length":0,"stats":{"Line":21}},{"line":216,"address":[],"length":0,"stats":{"Line":15}},{"line":218,"address":[],"length":0,"stats":{"Line":12}},{"line":221,"address":[],"length":0,"stats":{"Line":8}},{"line":227,"address":[],"length":0,"stats":{"Line":10}},{"line":235,"address":[],"length":0,"stats":{"Line":20}},{"line":237,"address":[],"length":0,"stats":{"Line":14}},{"line":238,"address":[],"length":0,"stats":{"Line":10}},{"line":239,"address":[],"length":0,"stats":{"Line":6}},{"line":242,"address":[],"length":0,"stats":{"Line":14}},{"line":243,"address":[],"length":0,"stats":{"Line":10}},{"line":244,"address":[],"length":0,"stats":{"Line":6}},{"line":247,"address":[],"length":0,"stats":{"Line":40}},{"line":248,"address":[],"length":0,"stats":{"Line":40}},{"line":250,"address":[],"length":0,"stats":{"Line":14}},{"line":251,"address":[],"length":0,"stats":{"Line":10}},{"line":252,"address":[],"length":0,"stats":{"Line":6}},{"line":255,"address":[],"length":0,"stats":{"Line":13}},{"line":256,"address":[],"length":0,"stats":{"Line":9}},{"line":259,"address":[],"length":0,"stats":{"Line":13}},{"line":260,"address":[],"length":0,"stats":{"Line":9}},{"line":263,"address":[],"length":0,"stats":{"Line":18}},{"line":264,"address":[],"length":0,"stats":{"Line":20}},{"line":265,"address":[],"length":0,"stats":{"Line":12}},{"line":268,"address":[],"length":0,"stats":{"Line":10}}],"covered":71,"coverable":121},{"path":["/","Users","chi","Projects","hu","src","eks","kubectl","tests.rs"],"content":"use super::*;\n\n#[test]\nfn build_list_args_basic() {\n    let config = KubectlConfig::default();\n    let args = build_list_args(\u0026config, false);\n    assert_eq!(args, vec![\"get\", \"pods\", \"-o\", \"json\"]);\n}\n\n#[test]\nfn build_list_args_with_context() {\n    let config = KubectlConfig {\n        context: Some(\"prod\".to_string()),\n        namespace: None,\n    };\n    let args = build_list_args(\u0026config, false);\n    assert_eq!(args, vec![\"--context\", \"prod\", \"get\", \"pods\", \"-o\", \"json\"]);\n}\n\n#[test]\nfn build_list_args_with_namespace() {\n    let config = KubectlConfig {\n        context: None,\n        namespace: Some(\"kube-system\".to_string()),\n    };\n    let args = build_list_args(\u0026config, false);\n    assert_eq!(args, vec![\"-n\", \"kube-system\", \"get\", \"pods\", \"-o\", \"json\"]);\n}\n\n#[test]\nfn build_list_args_all_namespaces() {\n    let config = KubectlConfig::default();\n    let args = build_list_args(\u0026config, true);\n    assert_eq!(args, vec![\"get\", \"pods\", \"-o\", \"json\", \"--all-namespaces\"]);\n}\n\n#[test]\nfn build_list_args_full() {\n    let config = KubectlConfig {\n        context: Some(\"prod\".to_string()),\n        namespace: Some(\"default\".to_string()),\n    };\n    let args = build_list_args(\u0026config, true);\n    assert_eq!(\n        args,\n        vec![\n            \"--context\",\n            \"prod\",\n            \"-n\",\n            \"default\",\n            \"get\",\n            \"pods\",\n            \"-o\",\n            \"json\",\n            \"--all-namespaces\"\n        ]\n    );\n}\n\n#[test]\nfn build_exec_args_basic() {\n    let config = KubectlConfig::default();\n    let args = build_exec_args(\u0026config, \"my-pod\", None, \u0026[]);\n    assert_eq!(args, vec![\"exec\", \"-it\", \"my-pod\", \"--\", \"/bin/sh\"]);\n}\n\n#[test]\nfn build_exec_args_with_container() {\n    let config = KubectlConfig::default();\n    let args = build_exec_args(\u0026config, \"my-pod\", Some(\"app\"), \u0026[]);\n    assert_eq!(\n        args,\n        vec![\"exec\", \"-it\", \"my-pod\", \"-c\", \"app\", \"--\", \"/bin/sh\"]\n    );\n}\n\n#[test]\nfn build_exec_args_with_command() {\n    let config = KubectlConfig::default();\n    let cmd = vec![\"bash\".to_string(), \"-c\".to_string(), \"ls -la\".to_string()];\n    let args = build_exec_args(\u0026config, \"my-pod\", None, \u0026cmd);\n    assert_eq!(\n        args,\n        vec![\"exec\", \"-it\", \"my-pod\", \"--\", \"bash\", \"-c\", \"ls -la\"]\n    );\n}\n\n#[test]\nfn build_exec_args_full() {\n    let config = KubectlConfig {\n        context: Some(\"prod\".to_string()),\n        namespace: Some(\"app\".to_string()),\n    };\n    let args = build_exec_args(\u0026config, \"my-pod\", Some(\"main\"), \u0026[]);\n    assert_eq!(\n        args,\n        vec![\n            \"--context\",\n            \"prod\",\n            \"-n\",\n            \"app\",\n            \"exec\",\n            \"-it\",\n            \"my-pod\",\n            \"-c\",\n            \"main\",\n            \"--\",\n            \"/bin/sh\"\n        ]\n    );\n}\n\n#[test]\nfn build_logs_args_basic() {\n    let config = KubectlConfig::default();\n    let args = build_logs_args(\u0026config, \"my-pod\", None, false, false, None);\n    assert_eq!(args, vec![\"logs\", \"my-pod\"]);\n}\n\n#[test]\nfn build_logs_args_follow() {\n    let config = KubectlConfig::default();\n    let args = build_logs_args(\u0026config, \"my-pod\", None, true, false, None);\n    assert_eq!(args, vec![\"logs\", \"my-pod\", \"-f\"]);\n}\n\n#[test]\nfn build_logs_args_previous() {\n    let config = KubectlConfig::default();\n    let args = build_logs_args(\u0026config, \"my-pod\", None, false, true, None);\n    assert_eq!(args, vec![\"logs\", \"my-pod\", \"--previous\"]);\n}\n\n#[test]\nfn build_logs_args_tail() {\n    let config = KubectlConfig::default();\n    let args = build_logs_args(\u0026config, \"my-pod\", None, false, false, Some(100));\n    assert_eq!(args, vec![\"logs\", \"my-pod\", \"--tail\", \"100\"]);\n}\n\n#[test]\nfn build_logs_args_full() {\n    let config = KubectlConfig {\n        context: Some(\"prod\".to_string()),\n        namespace: Some(\"app\".to_string()),\n    };\n    let args = build_logs_args(\u0026config, \"my-pod\", Some(\"main\"), true, true, Some(50));\n    assert_eq!(\n        args,\n        vec![\n            \"--context\",\n            \"prod\",\n            \"-n\",\n            \"app\",\n            \"logs\",\n            \"my-pod\",\n            \"-c\",\n            \"main\",\n            \"-f\",\n            \"--previous\",\n            \"--tail\",\n            \"50\"\n        ]\n    );\n}\n\n#[test]\nfn parse_pod_list_empty() {\n    let json = r#\"{\"items\": []}\"#;\n    let pods = parse_pod_list(json).unwrap();\n    assert!(pods.is_empty());\n}\n\n#[test]\nfn parse_pod_list_single() {\n    let json = r#\"{\n            \"items\": [{\n                \"metadata\": {\"name\": \"test\", \"namespace\": \"default\"},\n                \"status\": {\"phase\": \"Running\", \"containerStatuses\": []}\n            }]\n        }\"#;\n    let pods = parse_pod_list(json).unwrap();\n    assert_eq!(pods.len(), 1);\n    assert_eq!(pods[0].name, \"test\");\n}\n\n#[test]\nfn parse_pod_list_invalid_json() {\n    let result = parse_pod_list(\"not json\");\n    assert!(result.is_err());\n}\n\n#[test]\nfn parse_pod_list_multiple_pods() {\n    let json = r#\"{\n            \"items\": [\n                {\n                    \"metadata\": {\"name\": \"pod1\", \"namespace\": \"default\"},\n                    \"status\": {\"phase\": \"Running\", \"containerStatuses\": []}\n                },\n                {\n                    \"metadata\": {\"name\": \"pod2\", \"namespace\": \"kube-system\"},\n                    \"status\": {\"phase\": \"Pending\", \"containerStatuses\": []}\n                }\n            ]\n        }\"#;\n    let pods = parse_pod_list(json).unwrap();\n    assert_eq!(pods.len(), 2);\n    assert_eq!(pods[0].name, \"pod1\");\n    assert_eq!(pods[1].name, \"pod2\");\n    assert_eq!(pods[1].namespace, \"kube-system\");\n}\n\n#[test]\nfn parse_pod_list_with_full_metadata() {\n    let json = r#\"{\n            \"items\": [{\n                \"metadata\": {\n                    \"name\": \"full-pod\",\n                    \"namespace\": \"production\",\n                    \"creationTimestamp\": \"2026-01-15T10:30:00Z\"\n                },\n                \"spec\": {\n                    \"nodeName\": \"worker-node-1\",\n                    \"containers\": [{\"name\": \"main\"}]\n                },\n                \"status\": {\n                    \"phase\": \"Running\",\n                    \"containerStatuses\": [\n                        {\"name\": \"main\", \"ready\": true, \"restartCount\": 5}\n                    ]\n                }\n            }]\n        }\"#;\n    let pods = parse_pod_list(json).unwrap();\n    assert_eq!(pods.len(), 1);\n    assert_eq!(pods[0].name, \"full-pod\");\n    assert_eq!(pods[0].namespace, \"production\");\n    assert_eq!(pods[0].node, Some(\"worker-node-1\".to_string()));\n    assert_eq!(pods[0].restarts, 5);\n    assert_eq!(pods[0].ready, \"1/1\");\n}\n\n#[test]\nfn build_logs_args_with_container_only() {\n    let config = KubectlConfig::default();\n    let args = build_logs_args(\u0026config, \"my-pod\", Some(\"sidecar\"), false, false, None);\n    assert_eq!(args, vec![\"logs\", \"my-pod\", \"-c\", \"sidecar\"]);\n}\n\n#[test]\nfn build_exec_args_with_context_only() {\n    let config = KubectlConfig {\n        context: Some(\"staging\".to_string()),\n        namespace: None,\n    };\n    let args = build_exec_args(\u0026config, \"test-pod\", None, \u0026[]);\n    assert_eq!(\n        args,\n        vec![\n            \"--context\",\n            \"staging\",\n            \"exec\",\n            \"-it\",\n            \"test-pod\",\n            \"--\",\n            \"/bin/sh\"\n        ]\n    );\n}\n\n#[test]\nfn build_exec_args_with_namespace_only() {\n    let config = KubectlConfig {\n        context: None,\n        namespace: Some(\"monitoring\".to_string()),\n    };\n    let args = build_exec_args(\u0026config, \"test-pod\", None, \u0026[]);\n    assert_eq!(\n        args,\n        vec![\n            \"-n\",\n            \"monitoring\",\n            \"exec\",\n            \"-it\",\n            \"test-pod\",\n            \"--\",\n            \"/bin/sh\"\n        ]\n    );\n}\n\n#[test]\nfn build_logs_args_with_context_only() {\n    let config = KubectlConfig {\n        context: Some(\"dev\".to_string()),\n        namespace: None,\n    };\n    let args = build_logs_args(\u0026config, \"app-pod\", None, false, false, None);\n    assert_eq!(args, vec![\"--context\", \"dev\", \"logs\", \"app-pod\"]);\n}\n\n#[test]\nfn build_logs_args_with_namespace_only() {\n    let config = KubectlConfig {\n        context: None,\n        namespace: Some(\"logging\".to_string()),\n    };\n    let args = build_logs_args(\u0026config, \"app-pod\", None, false, false, None);\n    assert_eq!(args, vec![\"-n\", \"logging\", \"logs\", \"app-pod\"]);\n}\n\n#[test]\nfn build_logs_args_follow_and_tail() {\n    let config = KubectlConfig::default();\n    let args = build_logs_args(\u0026config, \"my-pod\", None, true, false, Some(200));\n    assert_eq!(args, vec![\"logs\", \"my-pod\", \"-f\", \"--tail\", \"200\"]);\n}\n\n#[test]\nfn build_logs_args_previous_and_tail() {\n    let config = KubectlConfig::default();\n    let args = build_logs_args(\u0026config, \"my-pod\", None, false, true, Some(50));\n    assert_eq!(args, vec![\"logs\", \"my-pod\", \"--previous\", \"--tail\", \"50\"]);\n}\n\n#[test]\nfn build_exec_args_with_multi_word_command() {\n    let config = KubectlConfig::default();\n    let cmd = vec![\n        \"python\".to_string(),\n        \"-c\".to_string(),\n        \"print('hello')\".to_string(),\n    ];\n    let args = build_exec_args(\u0026config, \"py-pod\", None, \u0026cmd);\n    assert_eq!(\n        args,\n        vec![\n            \"exec\",\n            \"-it\",\n            \"py-pod\",\n            \"--\",\n            \"python\",\n            \"-c\",\n            \"print('hello')\"\n        ]\n    );\n}\n\n#[test]\nfn build_exec_args_full_with_command() {\n    let config = KubectlConfig {\n        context: Some(\"prod\".to_string()),\n        namespace: Some(\"api\".to_string()),\n    };\n    let cmd = vec![\"cat\".to_string(), \"/etc/hosts\".to_string()];\n    let args = build_exec_args(\u0026config, \"api-pod\", Some(\"nginx\"), \u0026cmd);\n    assert_eq!(\n        args,\n        vec![\n            \"--context\",\n            \"prod\",\n            \"-n\",\n            \"api\",\n            \"exec\",\n            \"-it\",\n            \"api-pod\",\n            \"-c\",\n            \"nginx\",\n            \"--\",\n            \"cat\",\n            \"/etc/hosts\"\n        ]\n    );\n}\n\n#[test]\nfn parse_pod_list_mixed_container_states() {\n    let json = r#\"{\n            \"items\": [{\n                \"metadata\": {\"name\": \"mixed\", \"namespace\": \"default\"},\n                \"status\": {\n                    \"phase\": \"Running\",\n                    \"containerStatuses\": [\n                        {\"name\": \"a\", \"ready\": true, \"restartCount\": 0},\n                        {\"name\": \"b\", \"ready\": false, \"restartCount\": 2},\n                        {\"name\": \"c\", \"ready\": true, \"restartCount\": 1}\n                    ]\n                }\n            }]\n        }\"#;\n    let pods = parse_pod_list(json).unwrap();\n    assert_eq!(pods[0].ready, \"2/3\");\n    assert_eq!(pods[0].restarts, 3);\n}\n\n#[test]\nfn parse_pod_list_failed_status() {\n    let json = r#\"{\n            \"items\": [{\n                \"metadata\": {\"name\": \"failed\", \"namespace\": \"default\"},\n                \"status\": {\"phase\": \"Failed\", \"containerStatuses\": []}\n            }]\n        }\"#;\n    let pods = parse_pod_list(json).unwrap();\n    assert_eq!(pods[0].status, \"Failed\");\n}\n\n#[test]\nfn parse_pod_list_succeeded_status() {\n    let json = r#\"{\n            \"items\": [{\n                \"metadata\": {\"name\": \"job-pod\", \"namespace\": \"batch\"},\n                \"status\": {\"phase\": \"Succeeded\", \"containerStatuses\": []}\n            }]\n        }\"#;\n    let pods = parse_pod_list(json).unwrap();\n    assert_eq!(pods[0].status, \"Succeeded\");\n}\n\n#[test]\nfn parse_pod_list_unknown_status() {\n    let json = r#\"{\n            \"items\": [{\n                \"metadata\": {\"name\": \"mystery\", \"namespace\": \"default\"},\n                \"status\": {\"phase\": \"Unknown\", \"containerStatuses\": []}\n            }]\n        }\"#;\n    let pods = parse_pod_list(json).unwrap();\n    assert_eq!(pods[0].status, \"Unknown\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","eks","mod.rs"],"content":"//! EKS pod management\n//!\n//! List pods, exec into pods, and tail logs.\n\nmod cli;\nmod display;\nmod kubectl;\nmod types;\n\nuse anyhow::Result;\n\npub use cli::EksCommand;\nuse types::{KubectlConfig, OutputFormat};\n\n/// Run an EKS command\npub async fn run(cmd: EksCommand) -\u003e Result\u003c()\u003e {\n    match cmd {\n        EksCommand::List {\n            namespace,\n            all_namespaces,\n            context,\n            json,\n        } =\u003e cmd_list(namespace, all_namespaces, context, json),\n        EksCommand::Exec {\n            pod,\n            namespace,\n            container,\n            context,\n            command,\n        } =\u003e cmd_exec(\u0026pod, namespace, container, context, command),\n        EksCommand::Logs {\n            pod,\n            namespace,\n            container,\n            follow,\n            previous,\n            tail,\n            context,\n        } =\u003e cmd_logs(\u0026pod, namespace, container, follow, previous, tail, context),\n    }\n}\n\n/// List pods\nfn cmd_list(\n    namespace: Option\u003cString\u003e,\n    all_namespaces: bool,\n    context: Option\u003cString\u003e,\n    json: bool,\n) -\u003e Result\u003c()\u003e {\n    let config = KubectlConfig {\n        context,\n        namespace: namespace.clone(),\n    };\n\n    let pods = kubectl::list_pods(\u0026config, all_namespaces)?;\n\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n\n    // Show namespace column if listing all namespaces or no specific namespace\n    let show_namespace = all_namespaces || namespace.is_none();\n    display::output_pods(\u0026pods, format, show_namespace)?;\n\n    Ok(())\n}\n\n/// Exec into a pod\nfn cmd_exec(\n    pod: \u0026str,\n    namespace: Option\u003cString\u003e,\n    container: Option\u003cString\u003e,\n    context: Option\u003cString\u003e,\n    command: Vec\u003cString\u003e,\n) -\u003e Result\u003c()\u003e {\n    let config = KubectlConfig { context, namespace };\n\n    kubectl::exec_pod(\u0026config, pod, container.as_deref(), \u0026command)\n}\n\n/// Tail logs from a pod\n#[allow(clippy::too_many_arguments)]\nfn cmd_logs(\n    pod: \u0026str,\n    namespace: Option\u003cString\u003e,\n    container: Option\u003cString\u003e,\n    follow: bool,\n    previous: bool,\n    tail: Option\u003cusize\u003e,\n    context: Option\u003cString\u003e,\n) -\u003e Result\u003c()\u003e {\n    let config = KubectlConfig { context, namespace };\n\n    kubectl::tail_logs(\u0026config, pod, container.as_deref(), follow, previous, tail)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn kubectl_config_from_options() {\n        let config = KubectlConfig {\n            context: Some(\"prod\".to_string()),\n            namespace: Some(\"default\".to_string()),\n        };\n        assert_eq!(config.context, Some(\"prod\".to_string()));\n        assert_eq!(config.namespace, Some(\"default\".to_string()));\n    }\n\n    #[test]\n    fn kubectl_config_none_options() {\n        let config = KubectlConfig {\n            context: None,\n            namespace: None,\n        };\n        assert!(config.context.is_none());\n        assert!(config.namespace.is_none());\n    }\n\n    #[test]\n    fn output_format_table() {\n        let format = OutputFormat::Table;\n        assert_eq!(format, OutputFormat::Table);\n    }\n\n    #[test]\n    fn output_format_json() {\n        let format = OutputFormat::Json;\n        assert_eq!(format, OutputFormat::Json);\n    }\n\n    #[test]\n    fn output_format_from_bool_false() {\n        let json = false;\n        let format = if json {\n            OutputFormat::Json\n        } else {\n            OutputFormat::Table\n        };\n        assert_eq!(format, OutputFormat::Table);\n    }\n\n    #[test]\n    fn output_format_from_bool_true() {\n        let json = true;\n        let format = if json {\n            OutputFormat::Json\n        } else {\n            OutputFormat::Table\n        };\n        assert_eq!(format, OutputFormat::Json);\n    }\n\n    // Test show_namespace logic - matches cmd_list behavior\n    #[test]\n    fn show_namespace_all_namespaces() {\n        let all_namespaces = true;\n        let namespace: Option\u003cString\u003e = None;\n        let show_namespace = all_namespaces || namespace.is_none();\n        assert!(show_namespace);\n    }\n\n    #[test]\n    fn show_namespace_specific_namespace() {\n        let all_namespaces = false;\n        let namespace = Some(\"kube-system\".to_string());\n        let show_namespace = all_namespaces || namespace.is_none();\n        assert!(!show_namespace);\n    }\n\n    #[test]\n    fn show_namespace_no_namespace() {\n        let all_namespaces = false;\n        let namespace: Option\u003cString\u003e = None;\n        let show_namespace = all_namespaces || namespace.is_none();\n        assert!(show_namespace);\n    }\n\n    #[test]\n    fn show_namespace_both_set() {\n        // When both all_namespaces and specific namespace set,\n        // show_namespace should be true (all_namespaces takes precedence)\n        let all_namespaces = true;\n        let namespace = Some(\"default\".to_string());\n        let show_namespace = all_namespaces || namespace.is_none();\n        assert!(show_namespace);\n    }\n\n    // Test EksCommand variants exist and can be constructed\n    #[test]\n    fn eks_command_list_variant() {\n        let cmd = EksCommand::List {\n            namespace: None,\n            all_namespaces: false,\n            context: None,\n            json: false,\n        };\n        // Just verify it constructs\n        match cmd {\n            EksCommand::List { .. } =\u003e {}\n            _ =\u003e panic!(\"Expected List variant\"),\n        }\n    }\n\n    #[test]\n    fn eks_command_exec_variant() {\n        let cmd = EksCommand::Exec {\n            pod: \"my-pod\".to_string(),\n            namespace: None,\n            container: None,\n            context: None,\n            command: vec![],\n        };\n        match cmd {\n            EksCommand::Exec { pod, .. } =\u003e {\n                assert_eq!(pod, \"my-pod\");\n            }\n            _ =\u003e panic!(\"Expected Exec variant\"),\n        }\n    }\n\n    #[test]\n    fn eks_command_logs_variant() {\n        let cmd = EksCommand::Logs {\n            pod: \"log-pod\".to_string(),\n            namespace: Some(\"prod\".to_string()),\n            container: None,\n            follow: true,\n            previous: false,\n            tail: Some(100),\n            context: None,\n        };\n        match cmd {\n            EksCommand::Logs {\n                pod,\n                namespace,\n                follow,\n                tail,\n                ..\n            } =\u003e {\n                assert_eq!(pod, \"log-pod\");\n                assert_eq!(namespace, Some(\"prod\".to_string()));\n                assert!(follow);\n                assert_eq!(tail, Some(100));\n            }\n            _ =\u003e panic!(\"Expected Logs variant\"),\n        }\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":2}},{"line":17,"address":[],"length":0,"stats":{"Line":1}},{"line":19,"address":[],"length":0,"stats":{"Line":1}},{"line":20,"address":[],"length":0,"stats":{"Line":1}},{"line":21,"address":[],"length":0,"stats":{"Line":1}},{"line":22,"address":[],"length":0,"stats":{"Line":1}},{"line":23,"address":[],"length":0,"stats":{"Line":5}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":1}},{"line":55,"address":[],"length":0,"stats":{"Line":4}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}}],"covered":10,"coverable":36},{"path":["/","Users","chi","Projects","hu","src","eks","types","mod.rs"],"content":"//! EKS data types\n\nuse serde::{Deserialize, Serialize};\n\n#[cfg(test)]\nmod tests;\n\n/// Kubernetes pod\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Pod {\n    /// Pod name\n    pub name: String,\n    /// Namespace\n    pub namespace: String,\n    /// Pod status (Running, Pending, etc.)\n    pub status: String,\n    /// Ready containers (e.g., \"1/1\")\n    pub ready: String,\n    /// Restart count\n    pub restarts: u32,\n    /// Age (e.g., \"2d\", \"5h\")\n    pub age: String,\n    /// Node name\n    #[serde(default)]\n    pub node: Option\u003cString\u003e,\n}\n\n/// Kubectl configuration\n#[derive(Debug, Clone, Default)]\npub struct KubectlConfig {\n    /// Kubeconfig context to use\n    pub context: Option\u003cString\u003e,\n    /// Namespace to use\n    pub namespace: Option\u003cString\u003e,\n}\n\n/// Output format\n#[derive(Debug, Clone, Copy, Default, PartialEq, Eq)]\npub enum OutputFormat {\n    /// Table format\n    #[default]\n    Table,\n    /// JSON format\n    Json,\n}\n\n/// Kubectl JSON output for pods\n#[derive(Debug, Deserialize)]\npub struct PodList {\n    /// List of items\n    pub items: Vec\u003cPodItem\u003e,\n}\n\n/// Single pod item from kubectl JSON\n#[derive(Debug, Deserialize)]\npub struct PodItem {\n    /// Metadata\n    pub metadata: PodMetadata,\n    /// Spec\n    #[serde(default)]\n    pub spec: Option\u003cPodSpec\u003e,\n    /// Status\n    pub status: PodStatus,\n}\n\n/// Pod metadata\n#[derive(Debug, Deserialize)]\npub struct PodMetadata {\n    /// Pod name\n    pub name: String,\n    /// Namespace\n    pub namespace: String,\n    /// Creation timestamp\n    #[serde(rename = \"creationTimestamp\")]\n    pub creation_timestamp: Option\u003cString\u003e,\n}\n\n/// Pod spec\n#[derive(Debug, Deserialize, Default)]\npub struct PodSpec {\n    /// Node name\n    #[serde(rename = \"nodeName\")]\n    pub node_name: Option\u003cString\u003e,\n    /// Containers\n    #[serde(default)]\n    #[allow(dead_code)]\n    pub containers: Vec\u003cContainer\u003e,\n}\n\n/// Container spec\n#[derive(Debug, Deserialize)]\n#[allow(dead_code)]\npub struct Container {\n    /// Container name\n    pub name: String,\n}\n\n/// Pod status\n#[derive(Debug, Deserialize)]\npub struct PodStatus {\n    /// Phase (Running, Pending, Succeeded, Failed, Unknown)\n    pub phase: String,\n    /// Container statuses\n    #[serde(rename = \"containerStatuses\", default)]\n    pub container_statuses: Vec\u003cContainerStatus\u003e,\n}\n\n/// Container status\n#[derive(Debug, Deserialize)]\npub struct ContainerStatus {\n    /// Container name\n    #[allow(dead_code)]\n    pub name: String,\n    /// Ready state\n    pub ready: bool,\n    /// Restart count\n    #[serde(rename = \"restartCount\")]\n    pub restart_count: u32,\n}\n\nimpl PodItem {\n    /// Convert to simplified Pod struct\n    pub fn to_pod(\u0026self) -\u003e Pod {\n        let ready = self.ready_string();\n        let restarts = self.total_restarts();\n        let age = self.age_string();\n        let node = self.spec.as_ref().and_then(|s| s.node_name.clone());\n\n        Pod {\n            name: self.metadata.name.clone(),\n            namespace: self.metadata.namespace.clone(),\n            status: self.status.phase.clone(),\n            ready,\n            restarts,\n            age,\n            node,\n        }\n    }\n\n    /// Get ready string (e.g., \"1/2\")\n    fn ready_string(\u0026self) -\u003e String {\n        let total = self.status.container_statuses.len();\n        let ready = self\n            .status\n            .container_statuses\n            .iter()\n            .filter(|c| c.ready)\n            .count();\n        format!(\"{}/{}\", ready, total)\n    }\n\n    /// Get total restart count\n    fn total_restarts(\u0026self) -\u003e u32 {\n        self.status\n            .container_statuses\n            .iter()\n            .map(|c| c.restart_count)\n            .sum()\n    }\n\n    /// Get age string from creation timestamp\n    fn age_string(\u0026self) -\u003e String {\n        let Some(ts) = \u0026self.metadata.creation_timestamp else {\n            return \"-\".to_string();\n        };\n\n        let Ok(created) = chrono::DateTime::parse_from_rfc3339(ts) else {\n            return \"-\".to_string();\n        };\n\n        let now = chrono::Utc::now();\n        let duration = now.signed_duration_since(created);\n\n        if duration.num_days() \u003e 0 {\n            format!(\"{}d\", duration.num_days())\n        } else if duration.num_hours() \u003e 0 {\n            format!(\"{}h\", duration.num_hours())\n        } else if duration.num_minutes() \u003e 0 {\n            format!(\"{}m\", duration.num_minutes())\n        } else {\n            format!(\"{}s\", duration.num_seconds())\n        }\n    }\n}\n","traces":[{"line":123,"address":[],"length":0,"stats":{"Line":23}},{"line":124,"address":[],"length":0,"stats":{"Line":69}},{"line":125,"address":[],"length":0,"stats":{"Line":69}},{"line":126,"address":[],"length":0,"stats":{"Line":69}},{"line":127,"address":[],"length":0,"stats":{"Line":100}},{"line":130,"address":[],"length":0,"stats":{"Line":69}},{"line":131,"address":[],"length":0,"stats":{"Line":69}},{"line":132,"address":[],"length":0,"stats":{"Line":69}},{"line":141,"address":[],"length":0,"stats":{"Line":23}},{"line":142,"address":[],"length":0,"stats":{"Line":69}},{"line":143,"address":[],"length":0,"stats":{"Line":46}},{"line":144,"address":[],"length":0,"stats":{"Line":23}},{"line":145,"address":[],"length":0,"stats":{"Line":23}},{"line":147,"address":[],"length":0,"stats":{"Line":23}},{"line":149,"address":[],"length":0,"stats":{"Line":46}},{"line":153,"address":[],"length":0,"stats":{"Line":23}},{"line":154,"address":[],"length":0,"stats":{"Line":23}},{"line":155,"address":[],"length":0,"stats":{"Line":23}},{"line":157,"address":[],"length":0,"stats":{"Line":23}},{"line":162,"address":[],"length":0,"stats":{"Line":23}},{"line":163,"address":[],"length":0,"stats":{"Line":30}},{"line":164,"address":[],"length":0,"stats":{"Line":32}},{"line":167,"address":[],"length":0,"stats":{"Line":13}},{"line":168,"address":[],"length":0,"stats":{"Line":2}},{"line":171,"address":[],"length":0,"stats":{"Line":12}},{"line":172,"address":[],"length":0,"stats":{"Line":24}},{"line":174,"address":[],"length":0,"stats":{"Line":6}},{"line":175,"address":[],"length":0,"stats":{"Line":12}},{"line":176,"address":[],"length":0,"stats":{"Line":3}},{"line":177,"address":[],"length":0,"stats":{"Line":4}},{"line":178,"address":[],"length":0,"stats":{"Line":2}},{"line":179,"address":[],"length":0,"stats":{"Line":4}},{"line":181,"address":[],"length":0,"stats":{"Line":4}}],"covered":33,"coverable":33},{"path":["/","Users","chi","Projects","hu","src","eks","types","tests.rs"],"content":"use super::*;\n\n#[test]\nfn pod_debug() {\n    let pod = Pod {\n        name: \"test-pod\".to_string(),\n        namespace: \"default\".to_string(),\n        status: \"Running\".to_string(),\n        ready: \"1/1\".to_string(),\n        restarts: 0,\n        age: \"1d\".to_string(),\n        node: Some(\"node-1\".to_string()),\n    };\n    let debug = format!(\"{:?}\", pod);\n    assert!(debug.contains(\"test-pod\"));\n}\n\n#[test]\nfn pod_clone() {\n    let pod = Pod {\n        name: \"test-pod\".to_string(),\n        namespace: \"default\".to_string(),\n        status: \"Running\".to_string(),\n        ready: \"1/1\".to_string(),\n        restarts: 0,\n        age: \"1d\".to_string(),\n        node: None,\n    };\n    let cloned = pod.clone();\n    assert_eq!(cloned.name, pod.name);\n}\n\n#[test]\nfn kubectl_config_default() {\n    let config = KubectlConfig::default();\n    assert!(config.context.is_none());\n    assert!(config.namespace.is_none());\n}\n\n#[test]\nfn output_format_default() {\n    let format = OutputFormat::default();\n    assert_eq!(format, OutputFormat::Table);\n}\n\n#[test]\nfn parse_pod_list() {\n    let json = r#\"{\n            \"items\": [\n                {\n                    \"metadata\": {\n                        \"name\": \"my-pod\",\n                        \"namespace\": \"default\",\n                        \"creationTimestamp\": \"2026-01-01T00:00:00Z\"\n                    },\n                    \"status\": {\n                        \"phase\": \"Running\",\n                        \"containerStatuses\": [\n                            {\"name\": \"main\", \"ready\": true, \"restartCount\": 2}\n                        ]\n                    }\n                }\n            ]\n        }\"#;\n\n    let pod_list: PodList = serde_json::from_str(json).unwrap();\n    assert_eq!(pod_list.items.len(), 1);\n\n    let pod = pod_list.items[0].to_pod();\n    assert_eq!(pod.name, \"my-pod\");\n    assert_eq!(pod.namespace, \"default\");\n    assert_eq!(pod.status, \"Running\");\n    assert_eq!(pod.ready, \"1/1\");\n    assert_eq!(pod.restarts, 2);\n}\n\n#[test]\nfn parse_pod_list_multiple_containers() {\n    let json = r#\"{\n            \"items\": [\n                {\n                    \"metadata\": {\n                        \"name\": \"multi-container\",\n                        \"namespace\": \"prod\"\n                    },\n                    \"status\": {\n                        \"phase\": \"Running\",\n                        \"containerStatuses\": [\n                            {\"name\": \"app\", \"ready\": true, \"restartCount\": 1},\n                            {\"name\": \"sidecar\", \"ready\": false, \"restartCount\": 3}\n                        ]\n                    }\n                }\n            ]\n        }\"#;\n\n    let pod_list: PodList = serde_json::from_str(json).unwrap();\n    let pod = pod_list.items[0].to_pod();\n    assert_eq!(pod.ready, \"1/2\");\n    assert_eq!(pod.restarts, 4);\n}\n\n#[test]\nfn parse_pod_list_with_node() {\n    let json = r#\"{\n            \"items\": [\n                {\n                    \"metadata\": {\n                        \"name\": \"my-pod\",\n                        \"namespace\": \"default\"\n                    },\n                    \"spec\": {\n                        \"nodeName\": \"node-abc123\"\n                    },\n                    \"status\": {\n                        \"phase\": \"Running\",\n                        \"containerStatuses\": []\n                    }\n                }\n            ]\n        }\"#;\n\n    let pod_list: PodList = serde_json::from_str(json).unwrap();\n    let pod = pod_list.items[0].to_pod();\n    assert_eq!(pod.node, Some(\"node-abc123\".to_string()));\n}\n\n#[test]\nfn parse_pod_list_no_node() {\n    let json = r#\"{\n            \"items\": [\n                {\n                    \"metadata\": {\n                        \"name\": \"pending-pod\",\n                        \"namespace\": \"default\"\n                    },\n                    \"status\": {\n                        \"phase\": \"Pending\",\n                        \"containerStatuses\": []\n                    }\n                }\n            ]\n        }\"#;\n\n    let pod_list: PodList = serde_json::from_str(json).unwrap();\n    let pod = pod_list.items[0].to_pod();\n    assert!(pod.node.is_none());\n}\n\n#[test]\nfn age_string_no_timestamp() {\n    let item = PodItem {\n        metadata: PodMetadata {\n            name: \"test\".to_string(),\n            namespace: \"default\".to_string(),\n            creation_timestamp: None,\n        },\n        spec: None,\n        status: PodStatus {\n            phase: \"Running\".to_string(),\n            container_statuses: vec![],\n        },\n    };\n    let pod = item.to_pod();\n    assert_eq!(pod.age, \"-\");\n}\n\n#[test]\nfn age_string_invalid_timestamp() {\n    let item = PodItem {\n        metadata: PodMetadata {\n            name: \"test\".to_string(),\n            namespace: \"default\".to_string(),\n            creation_timestamp: Some(\"not-a-date\".to_string()),\n        },\n        spec: None,\n        status: PodStatus {\n            phase: \"Running\".to_string(),\n            container_statuses: vec![],\n        },\n    };\n    let pod = item.to_pod();\n    assert_eq!(pod.age, \"-\");\n}\n\n#[test]\nfn pod_serialize() {\n    let pod = Pod {\n        name: \"test\".to_string(),\n        namespace: \"default\".to_string(),\n        status: \"Running\".to_string(),\n        ready: \"1/1\".to_string(),\n        restarts: 0,\n        age: \"1h\".to_string(),\n        node: None,\n    };\n    let json = serde_json::to_string(\u0026pod).unwrap();\n    assert!(json.contains(\"test\"));\n}\n\n#[test]\nfn pod_deserialize() {\n    let json = r#\"{\n            \"name\": \"test-pod\",\n            \"namespace\": \"default\",\n            \"status\": \"Running\",\n            \"ready\": \"1/1\",\n            \"restarts\": 5,\n            \"age\": \"2d\",\n            \"node\": \"worker-1\"\n        }\"#;\n    let pod: Pod = serde_json::from_str(json).unwrap();\n    assert_eq!(pod.name, \"test-pod\");\n    assert_eq!(pod.restarts, 5);\n    assert_eq!(pod.node, Some(\"worker-1\".to_string()));\n}\n\n#[test]\nfn pod_deserialize_no_node() {\n    let json = r#\"{\n            \"name\": \"test-pod\",\n            \"namespace\": \"default\",\n            \"status\": \"Running\",\n            \"ready\": \"1/1\",\n            \"restarts\": 0,\n            \"age\": \"1h\"\n        }\"#;\n    let pod: Pod = serde_json::from_str(json).unwrap();\n    assert!(pod.node.is_none());\n}\n\n#[test]\nfn output_format_debug() {\n    let format = OutputFormat::Json;\n    let debug = format!(\"{:?}\", format);\n    assert!(debug.contains(\"Json\"));\n}\n\n#[test]\nfn output_format_clone() {\n    let format = OutputFormat::Table;\n    let cloned = format;\n    assert_eq!(cloned, OutputFormat::Table);\n}\n\n#[test]\nfn output_format_eq() {\n    assert_eq!(OutputFormat::Table, OutputFormat::Table);\n    assert_eq!(OutputFormat::Json, OutputFormat::Json);\n    assert_ne!(OutputFormat::Table, OutputFormat::Json);\n}\n\n#[test]\nfn kubectl_config_debug() {\n    let config = KubectlConfig {\n        context: Some(\"test\".to_string()),\n        namespace: Some(\"default\".to_string()),\n    };\n    let debug = format!(\"{:?}\", config);\n    assert!(debug.contains(\"test\"));\n}\n\n#[test]\nfn kubectl_config_clone() {\n    let config = KubectlConfig {\n        context: Some(\"prod\".to_string()),\n        namespace: None,\n    };\n    let cloned = config.clone();\n    assert_eq!(cloned.context, Some(\"prod\".to_string()));\n}\n\n#[test]\nfn pod_list_debug() {\n    let pod_list = PodList { items: vec![] };\n    let debug = format!(\"{:?}\", pod_list);\n    assert!(debug.contains(\"PodList\"));\n}\n\n#[test]\nfn pod_item_debug() {\n    let item = PodItem {\n        metadata: PodMetadata {\n            name: \"debug-test\".to_string(),\n            namespace: \"default\".to_string(),\n            creation_timestamp: None,\n        },\n        spec: None,\n        status: PodStatus {\n            phase: \"Running\".to_string(),\n            container_statuses: vec![],\n        },\n    };\n    let debug = format!(\"{:?}\", item);\n    assert!(debug.contains(\"debug-test\"));\n}\n\n#[test]\nfn pod_metadata_debug() {\n    let meta = PodMetadata {\n        name: \"test\".to_string(),\n        namespace: \"ns\".to_string(),\n        creation_timestamp: Some(\"2026-01-01T00:00:00Z\".to_string()),\n    };\n    let debug = format!(\"{:?}\", meta);\n    assert!(debug.contains(\"test\"));\n}\n\n#[test]\nfn pod_spec_debug() {\n    let spec = PodSpec {\n        node_name: Some(\"node-1\".to_string()),\n        containers: vec![Container {\n            name: \"main\".to_string(),\n        }],\n    };\n    let debug = format!(\"{:?}\", spec);\n    assert!(debug.contains(\"node-1\"));\n}\n\n#[test]\nfn pod_spec_default() {\n    let spec = PodSpec::default();\n    assert!(spec.node_name.is_none());\n    assert!(spec.containers.is_empty());\n}\n\n#[test]\nfn container_debug() {\n    let container = Container {\n        name: \"sidecar\".to_string(),\n    };\n    let debug = format!(\"{:?}\", container);\n    assert!(debug.contains(\"sidecar\"));\n}\n\n#[test]\nfn pod_status_debug() {\n    let status = PodStatus {\n        phase: \"Pending\".to_string(),\n        container_statuses: vec![],\n    };\n    let debug = format!(\"{:?}\", status);\n    assert!(debug.contains(\"Pending\"));\n}\n\n#[test]\nfn container_status_debug() {\n    let status = ContainerStatus {\n        name: \"app\".to_string(),\n        ready: true,\n        restart_count: 3,\n    };\n    let debug = format!(\"{:?}\", status);\n    assert!(debug.contains(\"app\"));\n    assert!(debug.contains(\"true\"));\n}\n\n#[test]\nfn ready_string_all_ready() {\n    let item = PodItem {\n        metadata: PodMetadata {\n            name: \"test\".to_string(),\n            namespace: \"default\".to_string(),\n            creation_timestamp: None,\n        },\n        spec: None,\n        status: PodStatus {\n            phase: \"Running\".to_string(),\n            container_statuses: vec![\n                ContainerStatus {\n                    name: \"a\".to_string(),\n                    ready: true,\n                    restart_count: 0,\n                },\n                ContainerStatus {\n                    name: \"b\".to_string(),\n                    ready: true,\n                    restart_count: 0,\n                },\n            ],\n        },\n    };\n    let pod = item.to_pod();\n    assert_eq!(pod.ready, \"2/2\");\n}\n\n#[test]\nfn ready_string_none_ready() {\n    let item = PodItem {\n        metadata: PodMetadata {\n            name: \"test\".to_string(),\n            namespace: \"default\".to_string(),\n            creation_timestamp: None,\n        },\n        spec: None,\n        status: PodStatus {\n            phase: \"Pending\".to_string(),\n            container_statuses: vec![\n                ContainerStatus {\n                    name: \"a\".to_string(),\n                    ready: false,\n                    restart_count: 0,\n                },\n                ContainerStatus {\n                    name: \"b\".to_string(),\n                    ready: false,\n                    restart_count: 0,\n                },\n            ],\n        },\n    };\n    let pod = item.to_pod();\n    assert_eq!(pod.ready, \"0/2\");\n}\n\n#[test]\nfn total_restarts_sum() {\n    let item = PodItem {\n        metadata: PodMetadata {\n            name: \"test\".to_string(),\n            namespace: \"default\".to_string(),\n            creation_timestamp: None,\n        },\n        spec: None,\n        status: PodStatus {\n            phase: \"Running\".to_string(),\n            container_statuses: vec![\n                ContainerStatus {\n                    name: \"a\".to_string(),\n                    ready: true,\n                    restart_count: 5,\n                },\n                ContainerStatus {\n                    name: \"b\".to_string(),\n                    ready: true,\n                    restart_count: 3,\n                },\n                ContainerStatus {\n                    name: \"c\".to_string(),\n                    ready: true,\n                    restart_count: 2,\n                },\n            ],\n        },\n    };\n    let pod = item.to_pod();\n    assert_eq!(pod.restarts, 10);\n}\n\n#[test]\nfn age_string_hours() {\n    // Use a timestamp from a few hours ago\n    let now = chrono::Utc::now();\n    let hours_ago = now - chrono::Duration::hours(5);\n    let ts = hours_ago.to_rfc3339();\n\n    let item = PodItem {\n        metadata: PodMetadata {\n            name: \"test\".to_string(),\n            namespace: \"default\".to_string(),\n            creation_timestamp: Some(ts),\n        },\n        spec: None,\n        status: PodStatus {\n            phase: \"Running\".to_string(),\n            container_statuses: vec![],\n        },\n    };\n    let pod = item.to_pod();\n    assert!(pod.age.ends_with('h'), \"Expected hours, got: {}\", pod.age);\n}\n\n#[test]\nfn age_string_minutes() {\n    let now = chrono::Utc::now();\n    let mins_ago = now - chrono::Duration::minutes(30);\n    let ts = mins_ago.to_rfc3339();\n\n    let item = PodItem {\n        metadata: PodMetadata {\n            name: \"test\".to_string(),\n            namespace: \"default\".to_string(),\n            creation_timestamp: Some(ts),\n        },\n        spec: None,\n        status: PodStatus {\n            phase: \"Running\".to_string(),\n            container_statuses: vec![],\n        },\n    };\n    let pod = item.to_pod();\n    assert!(pod.age.ends_with('m'), \"Expected minutes, got: {}\", pod.age);\n}\n\n#[test]\nfn age_string_seconds() {\n    let now = chrono::Utc::now();\n    let secs_ago = now - chrono::Duration::seconds(45);\n    let ts = secs_ago.to_rfc3339();\n\n    let item = PodItem {\n        metadata: PodMetadata {\n            name: \"test\".to_string(),\n            namespace: \"default\".to_string(),\n            creation_timestamp: Some(ts),\n        },\n        spec: None,\n        status: PodStatus {\n            phase: \"Running\".to_string(),\n            container_statuses: vec![],\n        },\n    };\n    let pod = item.to_pod();\n    assert!(pod.age.ends_with('s'), \"Expected seconds, got: {}\", pod.age);\n}\n\n#[test]\nfn age_string_days() {\n    let now = chrono::Utc::now();\n    let days_ago = now - chrono::Duration::days(7);\n    let ts = days_ago.to_rfc3339();\n\n    let item = PodItem {\n        metadata: PodMetadata {\n            name: \"test\".to_string(),\n            namespace: \"default\".to_string(),\n            creation_timestamp: Some(ts),\n        },\n        spec: None,\n        status: PodStatus {\n            phase: \"Running\".to_string(),\n            container_statuses: vec![],\n        },\n    };\n    let pod = item.to_pod();\n    assert!(pod.age.ends_with('d'), \"Expected days, got: {}\", pod.age);\n}\n\n#[test]\nfn pod_with_spec_node() {\n    let item = PodItem {\n        metadata: PodMetadata {\n            name: \"test\".to_string(),\n            namespace: \"default\".to_string(),\n            creation_timestamp: None,\n        },\n        spec: Some(PodSpec {\n            node_name: Some(\"worker-abc\".to_string()),\n            containers: vec![],\n        }),\n        status: PodStatus {\n            phase: \"Running\".to_string(),\n            container_statuses: vec![],\n        },\n    };\n    let pod = item.to_pod();\n    assert_eq!(pod.node, Some(\"worker-abc\".to_string()));\n}\n\n#[test]\nfn pod_with_spec_no_node() {\n    let item = PodItem {\n        metadata: PodMetadata {\n            name: \"test\".to_string(),\n            namespace: \"default\".to_string(),\n            creation_timestamp: None,\n        },\n        spec: Some(PodSpec {\n            node_name: None,\n            containers: vec![],\n        }),\n        status: PodStatus {\n            phase: \"Pending\".to_string(),\n            container_statuses: vec![],\n        },\n    };\n    let pod = item.to_pod();\n    assert!(pod.node.is_none());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","gh","auth.rs"],"content":"use anyhow::{Context, Result};\n\nuse crate::util::{load_credentials, save_credentials, GithubCredentials};\n\n#[cfg(test)]\nuse crate::util::{load_credentials_from, save_credentials_to};\n\n#[cfg(test)]\nuse std::path::PathBuf;\n\n/// Save token and fetch username\npub async fn login(token: \u0026str) -\u003e Result\u003cString\u003e {\n    let username = fetch_username_from_github(token).await?;\n    save_login(\u0026username, token)?;\n    Ok(username)\n}\n\n/// Save login credentials (extracted for testability)\npub fn save_login(username: \u0026str, token: \u0026str) -\u003e Result\u003c()\u003e {\n    let mut creds = load_credentials().unwrap_or_default();\n    creds.github = Some(GithubCredentials {\n        token: token.to_string(),\n        username: username.to_string(),\n    });\n    save_credentials(\u0026creds)\n}\n\n/// Save login to a specific path (for testing)\n#[cfg(test)]\nfn save_login_to(username: \u0026str, token: \u0026str, path: \u0026PathBuf) -\u003e Result\u003c()\u003e {\n    let mut creds = load_credentials_from(path).unwrap_or_default();\n    creds.github = Some(GithubCredentials {\n        token: token.to_string(),\n        username: username.to_string(),\n    });\n    save_credentials_to(\u0026creds, path)\n}\n\n/// Load login from a specific path (for testing)\n#[cfg(test)]\nfn load_login_from(path: \u0026PathBuf) -\u003e Option\u003c(String, String)\u003e {\n    load_credentials_from(path)\n        .ok()\n        .and_then(|c| c.github.map(|g| (g.username, g.token)))\n}\n\n/// Fetch username from GitHub API (the actual network call)\nasync fn fetch_username_from_github(token: \u0026str) -\u003e Result\u003cString\u003e {\n    let octocrab = octocrab::OctocrabBuilder::new()\n        .personal_token(token.to_string())\n        .build()\n        .context(\"Failed to create GitHub client\")?;\n\n    let user = octocrab\n        .current()\n        .user()\n        .await\n        .context(\"Failed to get current user - check your token\")?;\n\n    Ok(user.login)\n}\n\n/// Get stored token if available\npub fn get_token() -\u003e Option\u003cString\u003e {\n    load_credentials()\n        .ok()\n        .and_then(|c| c.github.map(|g| g.token))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn get_token_returns_option() {\n        let result = get_token();\n        // Result is either Some(token) or None\n        assert!(result.is_some() || result.is_none());\n    }\n\n    #[test]\n    fn get_token_consistent_results() {\n        // Calling get_token multiple times should return the same result\n        let result1 = get_token();\n        let result2 = get_token();\n        assert_eq!(result1.is_some(), result2.is_some());\n    }\n\n    #[test]\n    fn credentials_struct_usage() {\n        // Verify we can create and use the credential structs\n        let creds = GithubCredentials {\n            token: \"test_token\".to_string(),\n            username: \"testuser\".to_string(),\n        };\n        assert_eq!(creds.token, \"test_token\");\n        assert_eq!(creds.username, \"testuser\");\n    }\n\n    #[test]\n    fn credentials_optional_in_parent() {\n        use crate::util::Credentials;\n        let creds = Credentials::default();\n        assert!(creds.github.is_none());\n    }\n\n    // Tests for path-based login functions\n    #[test]\n    fn save_and_load_login_roundtrip() {\n        let temp_dir = std::env::temp_dir().join(\"hu_test_auth\");\n        let _ = std::fs::remove_dir_all(\u0026temp_dir);\n        let path = temp_dir.join(\"credentials.toml\");\n\n        // Save login\n        save_login_to(\"testuser\", \"test_token\", \u0026path).unwrap();\n\n        // Load login\n        let result = load_login_from(\u0026path);\n        assert!(result.is_some());\n        let (username, token) = result.unwrap();\n        assert_eq!(username, \"testuser\");\n        assert_eq!(token, \"test_token\");\n\n        let _ = std::fs::remove_dir_all(\u0026temp_dir);\n    }\n\n    #[test]\n    fn load_login_from_missing_file() {\n        let path = PathBuf::from(\"/nonexistent/credentials.toml\");\n        let result = load_login_from(\u0026path);\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn load_login_from_empty_credentials() {\n        let temp_dir = std::env::temp_dir().join(\"hu_test_auth_empty\");\n        let _ = std::fs::create_dir_all(\u0026temp_dir);\n        let path = temp_dir.join(\"credentials.toml\");\n\n        // Write empty credentials\n        std::fs::write(\u0026path, \"\").unwrap();\n\n        let result = load_login_from(\u0026path);\n        assert!(result.is_none());\n\n        let _ = std::fs::remove_dir_all(\u0026temp_dir);\n    }\n\n    #[test]\n    fn save_login_overwrites_existing() {\n        let temp_dir = std::env::temp_dir().join(\"hu_test_auth_overwrite\");\n        let _ = std::fs::remove_dir_all(\u0026temp_dir);\n        let path = temp_dir.join(\"credentials.toml\");\n\n        // Save first login\n        save_login_to(\"user1\", \"token1\", \u0026path).unwrap();\n\n        // Save second login\n        save_login_to(\"user2\", \"token2\", \u0026path).unwrap();\n\n        // Load and verify\n        let (username, token) = load_login_from(\u0026path).unwrap();\n        assert_eq!(username, \"user2\");\n        assert_eq!(token, \"token2\");\n\n        let _ = std::fs::remove_dir_all(\u0026temp_dir);\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":3}},{"line":31,"address":[],"length":0,"stats":{"Line":12}},{"line":32,"address":[],"length":0,"stats":{"Line":6}},{"line":33,"address":[],"length":0,"stats":{"Line":9}},{"line":34,"address":[],"length":0,"stats":{"Line":3}},{"line":36,"address":[],"length":0,"stats":{"Line":9}},{"line":41,"address":[],"length":0,"stats":{"Line":4}},{"line":42,"address":[],"length":0,"stats":{"Line":8}},{"line":44,"address":[],"length":0,"stats":{"Line":16}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":5}},{"line":65,"address":[],"length":0,"stats":{"Line":5}},{"line":67,"address":[],"length":0,"stats":{"Line":15}}],"covered":12,"coverable":28},{"path":["/","Users","chi","Projects","hu","src","gh","cli.rs"],"content":"use clap::{Args, Subcommand};\nuse std::path::PathBuf;\n\n#[derive(Debug, Subcommand)]\npub enum GhCommand {\n    /// Authenticate with GitHub using a Personal Access Token\n    Login(LoginArgs),\n    /// List open pull requests authored by you\n    Prs,\n    /// Extract test failures from CI\n    Failures(FailuresArgs),\n    /// Analyze CI failures and output investigation context\n    Fix(FixArgs),\n    /// List workflow runs\n    Runs(RunsArgs),\n    /// Commit and push all changes (quick sync)\n    Sync(SyncArgs),\n}\n\n#[derive(Debug, Args)]\npub struct SyncArgs {\n    /// Path to git repository (default: current directory)\n    pub path: Option\u003cPathBuf\u003e,\n    /// Skip git commit\n    #[arg(long)]\n    pub no_commit: bool,\n    /// Skip git push\n    #[arg(long)]\n    pub no_push: bool,\n    /// Custom commit message\n    #[arg(long, short)]\n    pub message: Option\u003cString\u003e,\n    /// Output as JSON\n    #[arg(long, short)]\n    pub json: bool,\n}\n\n#[derive(Debug, Args)]\npub struct LoginArgs {\n    /// Personal Access Token (create at https://github.com/settings/tokens)\n    #[arg(long, short)]\n    pub token: String,\n}\n\n#[derive(Debug, Args)]\npub struct FailuresArgs {\n    /// PR number (defaults to current branch's PR)\n    #[arg(long)]\n    pub pr: Option\u003cu64\u003e,\n    /// Repository in owner/repo format (defaults to current directory's repo)\n    #[arg(long, short)]\n    pub repo: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Args)]\npub struct FixArgs {\n    /// PR number\n    #[arg(long)]\n    pub pr: Option\u003cu64\u003e,\n    /// Workflow run ID\n    #[arg(long)]\n    pub run: Option\u003cu64\u003e,\n    /// Branch name\n    #[arg(long, short)]\n    pub branch: Option\u003cString\u003e,\n    /// Repository in owner/repo format\n    #[arg(long, short)]\n    pub repo: Option\u003cString\u003e,\n    /// Output as JSON\n    #[arg(long, short)]\n    pub json: bool,\n}\n\n#[derive(Debug, Args)]\npub struct RunsArgs {\n    /// Ticket key to find runs for (e.g. BFR-1234)\n    pub ticket: Option\u003cString\u003e,\n    /// Filter by status: queued, in_progress, completed, success, failure\n    #[arg(long, short)]\n    pub status: Option\u003cString\u003e,\n    /// Filter by branch name\n    #[arg(long, short)]\n    pub branch: Option\u003cString\u003e,\n    /// Repository in owner/repo format\n    #[arg(long, short)]\n    pub repo: Option\u003cString\u003e,\n    /// Max results (default: 20)\n    #[arg(long, short = 'n', default_value = \"20\")]\n    pub limit: usize,\n    /// Output as JSON\n    #[arg(long, short)]\n    pub json: bool,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","gh","client","mod.rs"],"content":"use anyhow::{Context, Result};\nuse octocrab::Octocrab;\n\nuse super::auth::get_token;\nuse super::types::{CiStatus, PullRequest, RunsQuery, WorkflowRun};\n\nmod parsing;\n\n#[cfg(test)]\nuse parsing::clean_ci_line;\npub use parsing::parse_test_failures;\n\n#[cfg(test)]\nmod tests;\n\n/// Trait for GitHub API operations (enables mocking in tests)\npub trait GithubApi: Send + Sync {\n    /// List open PRs authored by the current user\n    fn list_user_prs(\u0026self) -\u003e impl std::future::Future\u003cOutput = Result\u003cVec\u003cPullRequest\u003e\u003e\u003e + Send;\n\n    /// Get CI status for a PR\n    fn get_ci_status(\n        \u0026self,\n        owner: \u0026str,\n        repo: \u0026str,\n        pr_number: u64,\n    ) -\u003e impl std::future::Future\u003cOutput = Result\u003cCiStatus\u003e\u003e + Send;\n\n    /// Get the branch name for a PR\n    fn get_pr_branch(\n        \u0026self,\n        owner: \u0026str,\n        repo: \u0026str,\n        pr_number: u64,\n    ) -\u003e impl std::future::Future\u003cOutput = Result\u003cString\u003e\u003e + Send;\n\n    /// Get the latest failed workflow run for a branch\n    fn get_latest_failed_run_for_branch(\n        \u0026self,\n        owner: \u0026str,\n        repo: \u0026str,\n        branch: \u0026str,\n    ) -\u003e impl std::future::Future\u003cOutput = Result\u003cOption\u003cu64\u003e\u003e\u003e + Send;\n\n    /// Get failed jobs for a workflow run\n    fn get_failed_jobs(\n        \u0026self,\n        owner: \u0026str,\n        repo: \u0026str,\n        run_id: u64,\n    ) -\u003e impl std::future::Future\u003cOutput = Result\u003cVec\u003c(u64, String)\u003e\u003e\u003e + Send;\n\n    /// Download logs for a job\n    fn get_job_logs(\n        \u0026self,\n        owner: \u0026str,\n        repo: \u0026str,\n        job_id: u64,\n    ) -\u003e impl std::future::Future\u003cOutput = Result\u003cString\u003e\u003e + Send;\n\n    /// Find PR number for a branch\n    fn find_pr_for_branch(\n        \u0026self,\n        owner: \u0026str,\n        repo: \u0026str,\n        branch: \u0026str,\n    ) -\u003e impl std::future::Future\u003cOutput = Result\u003cOption\u003cu64\u003e\u003e\u003e + Send;\n\n    /// List workflow runs for a repository\n    fn list_workflow_runs(\n        \u0026self,\n        query: \u0026RunsQuery\u003c'_\u003e,\n    ) -\u003e impl std::future::Future\u003cOutput = Result\u003cVec\u003cWorkflowRun\u003e\u003e\u003e + Send;\n\n    /// Search PRs by title/branch containing a query string\n    fn search_prs_by_title(\n        \u0026self,\n        owner: \u0026str,\n        repo: \u0026str,\n        query: \u0026str,\n    ) -\u003e impl std::future::Future\u003cOutput = Result\u003cVec\u003cPullRequest\u003e\u003e\u003e + Send;\n}\n\n/// Parse CI status from GitHub API responses (pure function, testable)\npub fn parse_ci_status(state: \u0026str, check_runs: Option\u003c\u0026Vec\u003cserde_json::Value\u003e\u003e) -\u003e CiStatus {\n    if let Some(runs) = check_runs {\n        if runs.is_empty() \u0026\u0026 state == \"pending\" {\n            return CiStatus::Pending;\n        }\n\n        let any_failed = runs\n            .iter()\n            .any(|r| r[\"conclusion\"].as_str() == Some(\"failure\"));\n        let any_pending = runs.iter().any(|r| {\n            r[\"status\"].as_str() != Some(\"completed\") || r[\"conclusion\"].as_str().is_none()\n        });\n        let all_success = runs\n            .iter()\n            .all(|r| r[\"conclusion\"].as_str() == Some(\"success\"));\n\n        if any_failed {\n            CiStatus::Failed\n        } else if any_pending {\n            CiStatus::Pending\n        } else if all_success \u0026\u0026 !runs.is_empty() {\n            CiStatus::Success\n        } else {\n            parse_state_string(state)\n        }\n    } else {\n        parse_state_string(state)\n    }\n}\n\n/// Parse state string to CiStatus\nfn parse_state_string(state: \u0026str) -\u003e CiStatus {\n    match state {\n        \"success\" =\u003e CiStatus::Success,\n        \"pending\" =\u003e CiStatus::Pending,\n        \"failure\" | \"error\" =\u003e CiStatus::Failed,\n        _ =\u003e CiStatus::Unknown,\n    }\n}\n\n/// Extract failed jobs from GitHub jobs API response (pure function, testable)\npub fn extract_failed_jobs(jobs: \u0026serde_json::Value) -\u003e Vec\u003c(u64, String)\u003e {\n    jobs[\"jobs\"]\n        .as_array()\n        .unwrap_or(\u0026vec![])\n        .iter()\n        .filter(|j| j[\"conclusion\"].as_str() == Some(\"failure\"))\n        .filter_map(|j| {\n            let id = j[\"id\"].as_u64()?;\n            let name = j[\"name\"].as_str()?.to_string();\n            Some((id, name))\n        })\n        .collect()\n}\n\n/// Extract PR number from pull request list response (pure function, testable)\npub fn extract_pr_number_from_list(prs: \u0026serde_json::Value) -\u003e Option\u003cu64\u003e {\n    prs.as_array()\n        .and_then(|arr| arr.first())\n        .and_then(|pr| pr[\"number\"].as_u64())\n}\n\n/// Extract run ID from workflow runs response (pure function, testable)\npub fn extract_run_id(runs: \u0026serde_json::Value) -\u003e Option\u003cu64\u003e {\n    runs[\"workflow_runs\"]\n        .as_array()\n        .and_then(|arr| arr.first())\n        .and_then(|r| r[\"id\"].as_u64())\n}\n\n/// Extract workflow runs from GitHub API response (pure function, testable)\npub fn extract_workflow_runs(response: \u0026serde_json::Value) -\u003e Vec\u003cWorkflowRun\u003e {\n    response[\"workflow_runs\"]\n        .as_array()\n        .unwrap_or(\u0026vec![])\n        .iter()\n        .filter_map(|r| {\n            Some(WorkflowRun {\n                id: r[\"id\"].as_u64()?,\n                name: r[\"name\"].as_str()?.to_string(),\n                status: r[\"status\"].as_str().unwrap_or(\"unknown\").to_string(),\n                conclusion: r[\"conclusion\"].as_str().map(|s| s.to_string()),\n                branch: r[\"head_branch\"].as_str().unwrap_or(\"\").to_string(),\n                html_url: r[\"html_url\"].as_str().unwrap_or(\"\").to_string(),\n                created_at: r[\"created_at\"].as_str().unwrap_or(\"\").to_string(),\n                updated_at: r[\"updated_at\"].as_str().unwrap_or(\"\").to_string(),\n                run_number: r[\"run_number\"].as_u64().unwrap_or(0),\n            })\n        })\n        .collect()\n}\n\n/// Extract PRs matching a query from GitHub PR list response (pure function, testable)\npub fn extract_matching_prs(response: \u0026serde_json::Value, query: \u0026str) -\u003e Vec\u003cPullRequest\u003e {\n    let query_lower = query.to_lowercase();\n    response\n        .as_array()\n        .unwrap_or(\u0026vec![])\n        .iter()\n        .filter(|pr| {\n            let title = pr[\"title\"].as_str().unwrap_or(\"\").to_lowercase();\n            let branch = pr[\"head\"][\"ref\"].as_str().unwrap_or(\"\").to_lowercase();\n            title.contains(\u0026query_lower) || branch.contains(\u0026query_lower)\n        })\n        .filter_map(|pr| {\n            let repo_full_name = pr[\"base\"][\"repo\"][\"full_name\"]\n                .as_str()\n                .unwrap_or(\"\")\n                .to_string();\n            Some(PullRequest {\n                number: pr[\"number\"].as_u64()?,\n                title: pr[\"title\"].as_str()?.to_string(),\n                html_url: pr[\"html_url\"].as_str().unwrap_or(\"\").to_string(),\n                state: pr[\"state\"].as_str().unwrap_or(\"\").to_string(),\n                repo_full_name,\n                created_at: pr[\"created_at\"].as_str().unwrap_or(\"\").to_string(),\n                updated_at: pr[\"updated_at\"].as_str().unwrap_or(\"\").to_string(),\n                ci_status: None,\n            })\n        })\n        .collect()\n}\n\npub struct GithubClient {\n    client: Octocrab,\n}\n\nimpl GithubClient {\n    /// Create a new authenticated GitHub client\n    pub fn new() -\u003e Result\u003cSelf\u003e {\n        let token = get_token().context(\"Not authenticated. Run `hu gh login` first.\")?;\n\n        let client = Octocrab::builder()\n            .personal_token(token)\n            .build()\n            .context(\"Failed to create GitHub client\")?;\n\n        Ok(Self { client })\n    }\n\n    /// Create client from provided token (for testing)\n    #[allow(dead_code)]\n    pub fn with_token(token: \u0026str) -\u003e Result\u003cSelf\u003e {\n        let client = Octocrab::builder()\n            .personal_token(token.to_string())\n            .build()\n            .context(\"Failed to create GitHub client\")?;\n\n        Ok(Self { client })\n    }\n}\n\nimpl GithubApi for GithubClient {\n    async fn list_user_prs(\u0026self) -\u003e Result\u003cVec\u003cPullRequest\u003e\u003e {\n        // Use the search API to find PRs where author is current user\n        let result = self\n            .client\n            .search()\n            .issues_and_pull_requests(\"is:pr is:open author:@me\")\n            .send()\n            .await\n            .context(\"Failed to search for PRs\")?;\n\n        let prs: Vec\u003cPullRequest\u003e = result\n            .items\n            .into_iter()\n            .filter_map(|issue| {\n                // Extract repo from URL: https://api.github.com/repos/owner/repo/issues/123\n                let repo_full_name = issue\n                    .repository_url\n                    .path_segments()?\n                    .skip(1) // skip \"repos\"\n                    .take(2) // take \"owner\" and \"repo\"\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n                    .join(\"/\");\n\n                let state = match issue.state {\n                    octocrab::models::IssueState::Open =\u003e \"open\",\n                    octocrab::models::IssueState::Closed =\u003e \"closed\",\n                    _ =\u003e \"unknown\",\n                };\n\n                Some(PullRequest {\n                    number: issue.number,\n                    title: issue.title,\n                    html_url: issue.html_url.to_string(),\n                    state: state.to_string(),\n                    repo_full_name,\n                    created_at: issue.created_at.to_rfc3339(),\n                    updated_at: issue.updated_at.to_rfc3339(),\n                    ci_status: None,\n                })\n            })\n            .collect();\n\n        Ok(prs)\n    }\n\n    async fn get_ci_status(\u0026self, owner: \u0026str, repo: \u0026str, pr_number: u64) -\u003e Result\u003cCiStatus\u003e {\n        // Get the PR to find the head SHA\n        let pr = self\n            .client\n            .pulls(owner, repo)\n            .get(pr_number)\n            .await\n            .context(\"Failed to get PR\")?;\n\n        let sha = \u0026pr.head.sha;\n\n        // Get combined status\n        let status: serde_json::Value = self\n            .client\n            .get(\n                format!(\"/repos/{}/{}/commits/{}/status\", owner, repo, sha),\n                None::\u003c\u0026()\u003e,\n            )\n            .await\n            .context(\"Failed to get commit status\")?;\n\n        let state = status[\"state\"].as_str().unwrap_or(\"unknown\");\n\n        // Also check for check runs (GitHub Actions uses this)\n        let checks: serde_json::Value = self\n            .client\n            .get(\n                format!(\"/repos/{}/{}/commits/{}/check-runs\", owner, repo, sha),\n                None::\u003c\u0026()\u003e,\n            )\n            .await\n            .unwrap_or_default();\n\n        let check_runs = checks[\"check_runs\"].as_array();\n\n        Ok(parse_ci_status(state, check_runs))\n    }\n\n    async fn get_pr_branch(\u0026self, owner: \u0026str, repo: \u0026str, pr_number: u64) -\u003e Result\u003cString\u003e {\n        let pr = self\n            .client\n            .pulls(owner, repo)\n            .get(pr_number)\n            .await\n            .context(\"Failed to get PR\")?;\n\n        Ok(pr.head.ref_field)\n    }\n\n    async fn get_latest_failed_run_for_branch(\n        \u0026self,\n        owner: \u0026str,\n        repo: \u0026str,\n        branch: \u0026str,\n    ) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n        let runs: serde_json::Value = self\n            .client\n            .get(\n                format!(\n                    \"/repos/{}/{}/actions/runs?branch={}\u0026status=failure\u0026per_page=1\",\n                    owner, repo, branch\n                ),\n                None::\u003c\u0026()\u003e,\n            )\n            .await\n            .context(\"Failed to get workflow runs\")?;\n\n        Ok(extract_run_id(\u0026runs))\n    }\n\n    async fn get_failed_jobs(\n        \u0026self,\n        owner: \u0026str,\n        repo: \u0026str,\n        run_id: u64,\n    ) -\u003e Result\u003cVec\u003c(u64, String)\u003e\u003e {\n        let jobs: serde_json::Value = self\n            .client\n            .get(\n                format!(\"/repos/{}/{}/actions/runs/{}/jobs\", owner, repo, run_id),\n                None::\u003c\u0026()\u003e,\n            )\n            .await\n            .context(\"Failed to get jobs\")?;\n\n        Ok(extract_failed_jobs(\u0026jobs))\n    }\n\n    async fn get_job_logs(\u0026self, owner: \u0026str, repo: \u0026str, job_id: u64) -\u003e Result\u003cString\u003e {\n        // The logs endpoint returns a redirect to a download URL\n        // We need to use reqwest directly for this\n        let token = get_token().context(\"Not authenticated\")?;\n\n        let client = reqwest::Client::new();\n        let url = format!(\n            \"https://api.github.com/repos/{}/{}/actions/jobs/{}/logs\",\n            owner, repo, job_id\n        );\n\n        let response = client\n            .get(\u0026url)\n            .header(\"Authorization\", format!(\"Bearer {}\", token))\n            .header(\"User-Agent\", \"hu-cli\")\n            .header(\"Accept\", \"application/vnd.github+json\")\n            .send()\n            .await\n            .context(\"Failed to request job logs\")?;\n\n        let logs = response.text().await.context(\"Failed to read job logs\")?;\n\n        Ok(logs)\n    }\n\n    async fn find_pr_for_branch(\n        \u0026self,\n        owner: \u0026str,\n        repo: \u0026str,\n        branch: \u0026str,\n    ) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n        let prs: serde_json::Value = self\n            .client\n            .get(\n                format!(\n                    \"/repos/{}/{}/pulls?head={}:{}\u0026state=open\u0026per_page=1\",\n                    owner, repo, owner, branch\n                ),\n                None::\u003c\u0026()\u003e,\n            )\n            .await\n            .context(\"Failed to search for PR by branch\")?;\n\n        Ok(extract_pr_number_from_list(\u0026prs))\n    }\n\n    async fn list_workflow_runs(\u0026self, query: \u0026RunsQuery\u003c'_\u003e) -\u003e Result\u003cVec\u003cWorkflowRun\u003e\u003e {\n        let mut url = format!(\n            \"/repos/{}/{}/actions/runs?per_page={}\",\n            query.owner, query.repo, query.limit\n        );\n        if let Some(b) = query.branch {\n            url.push_str(\u0026format!(\"\u0026branch={}\", b));\n        }\n        if let Some(s) = query.status {\n            url.push_str(\u0026format!(\"\u0026status={}\", s));\n        }\n\n        let response: serde_json::Value = self\n            .client\n            .get(url, None::\u003c\u0026()\u003e)\n            .await\n            .context(\"Failed to list workflow runs\")?;\n\n        Ok(extract_workflow_runs(\u0026response))\n    }\n\n    async fn search_prs_by_title(\n        \u0026self,\n        owner: \u0026str,\n        repo: \u0026str,\n        query: \u0026str,\n    ) -\u003e Result\u003cVec\u003cPullRequest\u003e\u003e {\n        let response: serde_json::Value = self\n            .client\n            .get(\n                format!(\"/repos/{}/{}/pulls?state=all\u0026per_page=100\", owner, repo),\n                None::\u003c\u0026()\u003e,\n            )\n            .await\n            .context(\"Failed to list PRs for search\")?;\n\n        Ok(extract_matching_prs(\u0026response, query))\n    }\n}\n","traces":[{"line":85,"address":[],"length":0,"stats":{"Line":9}},{"line":86,"address":[],"length":0,"stats":{"Line":13}},{"line":87,"address":[],"length":0,"stats":{"Line":9}},{"line":88,"address":[],"length":0,"stats":{"Line":1}},{"line":91,"address":[],"length":0,"stats":{"Line":6}},{"line":93,"address":[],"length":0,"stats":{"Line":13}},{"line":94,"address":[],"length":0,"stats":{"Line":14}},{"line":95,"address":[],"length":0,"stats":{"Line":13}},{"line":97,"address":[],"length":0,"stats":{"Line":6}},{"line":99,"address":[],"length":0,"stats":{"Line":13}},{"line":101,"address":[],"length":0,"stats":{"Line":3}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":103,"address":[],"length":0,"stats":{"Line":2}},{"line":104,"address":[],"length":0,"stats":{"Line":1}},{"line":105,"address":[],"length":0,"stats":{"Line":2}},{"line":106,"address":[],"length":0,"stats":{"Line":1}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":10}},{"line":116,"address":[],"length":0,"stats":{"Line":10}},{"line":117,"address":[],"length":0,"stats":{"Line":10}},{"line":118,"address":[],"length":0,"stats":{"Line":12}},{"line":119,"address":[],"length":0,"stats":{"Line":10}},{"line":120,"address":[],"length":0,"stats":{"Line":14}},{"line":121,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":4}},{"line":127,"address":[],"length":0,"stats":{"Line":8}},{"line":129,"address":[],"length":0,"stats":{"Line":4}},{"line":131,"address":[],"length":0,"stats":{"Line":12}},{"line":132,"address":[],"length":0,"stats":{"Line":6}},{"line":133,"address":[],"length":0,"stats":{"Line":6}},{"line":134,"address":[],"length":0,"stats":{"Line":8}},{"line":135,"address":[],"length":0,"stats":{"Line":2}},{"line":141,"address":[],"length":0,"stats":{"Line":6}},{"line":142,"address":[],"length":0,"stats":{"Line":12}},{"line":143,"address":[],"length":0,"stats":{"Line":14}},{"line":144,"address":[],"length":0,"stats":{"Line":12}},{"line":148,"address":[],"length":0,"stats":{"Line":3}},{"line":149,"address":[],"length":0,"stats":{"Line":3}},{"line":151,"address":[],"length":0,"stats":{"Line":7}},{"line":152,"address":[],"length":0,"stats":{"Line":5}},{"line":156,"address":[],"length":0,"stats":{"Line":5}},{"line":157,"address":[],"length":0,"stats":{"Line":10}},{"line":159,"address":[],"length":0,"stats":{"Line":5}},{"line":161,"address":[],"length":0,"stats":{"Line":9}},{"line":163,"address":[],"length":0,"stats":{"Line":9}},{"line":164,"address":[],"length":0,"stats":{"Line":9}},{"line":165,"address":[],"length":0,"stats":{"Line":12}},{"line":166,"address":[],"length":0,"stats":{"Line":13}},{"line":167,"address":[],"length":0,"stats":{"Line":12}},{"line":168,"address":[],"length":0,"stats":{"Line":12}},{"line":169,"address":[],"length":0,"stats":{"Line":12}},{"line":170,"address":[],"length":0,"stats":{"Line":12}},{"line":171,"address":[],"length":0,"stats":{"Line":9}},{"line":178,"address":[],"length":0,"stats":{"Line":6}},{"line":179,"address":[],"length":0,"stats":{"Line":18}},{"line":180,"address":[],"length":0,"stats":{"Line":12}},{"line":182,"address":[],"length":0,"stats":{"Line":6}},{"line":184,"address":[],"length":0,"stats":{"Line":11}},{"line":185,"address":[],"length":0,"stats":{"Line":25}},{"line":186,"address":[],"length":0,"stats":{"Line":25}},{"line":187,"address":[],"length":0,"stats":{"Line":16}},{"line":189,"address":[],"length":0,"stats":{"Line":9}},{"line":190,"address":[],"length":0,"stats":{"Line":9}},{"line":191,"address":[],"length":0,"stats":{"Line":6}},{"line":192,"address":[],"length":0,"stats":{"Line":3}},{"line":193,"address":[],"length":0,"stats":{"Line":3}},{"line":195,"address":[],"length":0,"stats":{"Line":6}},{"line":196,"address":[],"length":0,"stats":{"Line":9}},{"line":197,"address":[],"length":0,"stats":{"Line":12}},{"line":198,"address":[],"length":0,"stats":{"Line":12}},{"line":199,"address":[],"length":0,"stats":{"Line":3}},{"line":200,"address":[],"length":0,"stats":{"Line":12}},{"line":201,"address":[],"length":0,"stats":{"Line":12}},{"line":202,"address":[],"length":0,"stats":{"Line":3}},{"line":214,"address":[],"length":0,"stats":{"Line":1}},{"line":215,"address":[],"length":0,"stats":{"Line":3}},{"line":217,"address":[],"length":0,"stats":{"Line":2}},{"line":218,"address":[],"length":0,"stats":{"Line":2}},{"line":222,"address":[],"length":0,"stats":{"Line":1}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":2}},{"line":240,"address":[],"length":0,"stats":{"Line":3}},{"line":241,"address":[],"length":0,"stats":{"Line":2}},{"line":245,"address":[],"length":0,"stats":{"Line":1}},{"line":248,"address":[],"length":0,"stats":{"Line":3}},{"line":249,"address":[],"length":0,"stats":{"Line":1}},{"line":251,"address":[],"length":0,"stats":{"Line":1}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":1}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}}],"covered":86,"coverable":191},{"path":["/","Users","chi","Projects","hu","src","gh","client","parsing.rs"],"content":"use super::super::types::TestFailure;\n\n/// Extract test failures from logs (RSpec format)\npub fn parse_test_failures(logs: \u0026str) -\u003e Vec\u003cTestFailure\u003e {\n    let mut failures = Vec::new();\n\n    // Collect failure error messages in order\n    let mut error_messages: Vec\u003cString\u003e = Vec::new();\n\n    // Find the Failures section and parse each failure block\n    if let Some(failures_start) = logs.find(\"Failures:\") {\n        let failures_end = logs.find(\"Failed examples:\").unwrap_or(logs.len());\n        let failures_section = \u0026logs[failures_start..failures_end];\n\n        // Split by numbered failure pattern \"N) description\"\n        let block_starts: Vec\u003cusize\u003e = regex::Regex::new(r\"\\d+\\)\\s+\\S\")\n            .ok()\n            .map(|re| re.find_iter(failures_section).map(|m| m.start()).collect())\n            .unwrap_or_default();\n\n        let mut positions = block_starts.clone();\n        positions.push(failures_section.len());\n\n        for i in 0..block_starts.len() {\n            let block = \u0026failures_section[positions[i]..positions[i + 1]];\n\n            // Extract error: code line after Failure/Error: and the error message on next line\n            if let Some(fe_idx) = block.find(\"Failure/Error:\") {\n                let after_fe = \u0026block[fe_idx..];\n                let lines: Vec\u003cString\u003e = after_fe\n                    .lines()\n                    .map(clean_ci_line)\n                    .filter(|l| !l.is_empty())\n                    .take(4)\n                    .collect();\n\n                // lines[0] = \"Failure/Error: \u003ccode\u003e\"\n                // lines[1] = \"\u003cerror message\u003e\" or \"# \u003cstack trace\u003e\"\n                let code_line = lines\n                    .first()\n                    .map(|l| l.strip_prefix(\"Failure/Error:\").unwrap_or(l).trim())\n                    .unwrap_or(\"\");\n                let error_msg = lines.get(1).map(|s| s.as_str()).unwrap_or(\"\");\n\n                let error_text = if error_msg.is_empty() || error_msg.starts_with(\"# \") {\n                    code_line.to_string()\n                } else {\n                    format!(\"{}\\n{}\", code_line, error_msg)\n                };\n\n                error_messages.push(error_text);\n            }\n        }\n    }\n\n    // Extract failed examples from the \"Failed examples:\" section\n    // Format: rspec ./spec/helpers/prices_api_helper_spec.rb:289 # description\n    let failed_examples_re = regex::Regex::new(r\"rspec\\s+(\\./spec/[^\\s]+:\\d+)\").ok();\n\n    if let Some(re) = \u0026failed_examples_re {\n        for (i, cap) in re.captures_iter(logs).enumerate() {\n            let spec_file = cap.get(1).map(|m| m.as_str()).unwrap_or(\"\");\n\n            // Get error message by index (failures appear in same order)\n            let failure_text = error_messages\n                .get(i)\n                .cloned()\n                .unwrap_or_else(|| \"Test failed\".to_string());\n\n            // Avoid duplicates\n            if !failures\n                .iter()\n                .any(|f: \u0026TestFailure| f.spec_file == spec_file)\n            {\n                failures.push(TestFailure {\n                    spec_file: spec_file.to_string(),\n                    failure_text,\n                });\n            }\n        }\n    }\n\n    failures\n}\n\n/// Clean up CI log line by removing timestamp prefix\npub(super) fn clean_ci_line(line: \u0026str) -\u003e String {\n    // Remove timestamp prefix like \"2026-01-27T18:51:46.1029380Z\"\n    let re = regex::Regex::new(r\"^\\d{4}-\\d{2}-\\d{2}T[\\d:.]+Z\\s*\").ok();\n    if let Some(re) = re {\n        re.replace(line, \"\").trim().to_string()\n    } else {\n        line.trim().to_string()\n    }\n}\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":17}},{"line":5,"address":[],"length":0,"stats":{"Line":34}},{"line":8,"address":[],"length":0,"stats":{"Line":51}},{"line":11,"address":[],"length":0,"stats":{"Line":30}},{"line":12,"address":[],"length":0,"stats":{"Line":78}},{"line":13,"address":[],"length":0,"stats":{"Line":39}},{"line":16,"address":[],"length":0,"stats":{"Line":52}},{"line":18,"address":[],"length":0,"stats":{"Line":114}},{"line":21,"address":[],"length":0,"stats":{"Line":39}},{"line":22,"address":[],"length":0,"stats":{"Line":52}},{"line":24,"address":[],"length":0,"stats":{"Line":44}},{"line":25,"address":[],"length":0,"stats":{"Line":72}},{"line":28,"address":[],"length":0,"stats":{"Line":32}},{"line":29,"address":[],"length":0,"stats":{"Line":28}},{"line":30,"address":[],"length":0,"stats":{"Line":42}},{"line":32,"address":[],"length":0,"stats":{"Line":14}},{"line":33,"address":[],"length":0,"stats":{"Line":94}},{"line":39,"address":[],"length":0,"stats":{"Line":28}},{"line":41,"address":[],"length":0,"stats":{"Line":56}},{"line":43,"address":[],"length":0,"stats":{"Line":90}},{"line":45,"address":[],"length":0,"stats":{"Line":62}},{"line":46,"address":[],"length":0,"stats":{"Line":12}},{"line":48,"address":[],"length":0,"stats":{"Line":16}},{"line":51,"address":[],"length":0,"stats":{"Line":42}},{"line":58,"address":[],"length":0,"stats":{"Line":68}},{"line":60,"address":[],"length":0,"stats":{"Line":34}},{"line":61,"address":[],"length":0,"stats":{"Line":96}},{"line":62,"address":[],"length":0,"stats":{"Line":112}},{"line":65,"address":[],"length":0,"stats":{"Line":42}},{"line":66,"address":[],"length":0,"stats":{"Line":14}},{"line":68,"address":[],"length":0,"stats":{"Line":16}},{"line":71,"address":[],"length":0,"stats":{"Line":14}},{"line":72,"address":[],"length":0,"stats":{"Line":14}},{"line":73,"address":[],"length":0,"stats":{"Line":18}},{"line":75,"address":[],"length":0,"stats":{"Line":39}},{"line":76,"address":[],"length":0,"stats":{"Line":26}},{"line":77,"address":[],"length":0,"stats":{"Line":13}},{"line":83,"address":[],"length":0,"stats":{"Line":17}},{"line":87,"address":[],"length":0,"stats":{"Line":47}},{"line":89,"address":[],"length":0,"stats":{"Line":188}},{"line":90,"address":[],"length":0,"stats":{"Line":94}},{"line":91,"address":[],"length":0,"stats":{"Line":141}},{"line":93,"address":[],"length":0,"stats":{"Line":0}}],"covered":42,"coverable":43},{"path":["/","Users","chi","Projects","hu","src","gh","client","tests.rs"],"content":"use super::*;\nuse serde_json::json;\n\n#[test]\nfn get_token_returns_option() {\n    // Just verify get_token doesn't panic\n    let token = get_token();\n    assert!(token.is_some() || token.is_none());\n}\n\n// parse_ci_status tests\n#[test]\nfn parse_ci_status_success_from_runs() {\n    let runs = vec![json!({\"status\": \"completed\", \"conclusion\": \"success\"})];\n    assert_eq!(parse_ci_status(\"pending\", Some(\u0026runs)), CiStatus::Success);\n}\n\n#[test]\nfn parse_ci_status_failed_from_runs() {\n    let runs = vec![\n        json!({\"status\": \"completed\", \"conclusion\": \"success\"}),\n        json!({\"status\": \"completed\", \"conclusion\": \"failure\"}),\n    ];\n    assert_eq!(parse_ci_status(\"pending\", Some(\u0026runs)), CiStatus::Failed);\n}\n\n#[test]\nfn parse_ci_status_pending_from_runs() {\n    let runs = vec![\n        json!({\"status\": \"completed\", \"conclusion\": \"success\"}),\n        json!({\"status\": \"in_progress\", \"conclusion\": null}),\n    ];\n    assert_eq!(parse_ci_status(\"pending\", Some(\u0026runs)), CiStatus::Pending);\n}\n\n#[test]\nfn parse_ci_status_empty_runs_pending() {\n    let runs: Vec\u003cserde_json::Value\u003e = vec![];\n    assert_eq!(parse_ci_status(\"pending\", Some(\u0026runs)), CiStatus::Pending);\n}\n\n#[test]\nfn parse_ci_status_no_runs_uses_state() {\n    assert_eq!(parse_ci_status(\"success\", None), CiStatus::Success);\n    assert_eq!(parse_ci_status(\"failure\", None), CiStatus::Failed);\n    assert_eq!(parse_ci_status(\"error\", None), CiStatus::Failed);\n    assert_eq!(parse_ci_status(\"pending\", None), CiStatus::Pending);\n    assert_eq!(parse_ci_status(\"unknown\", None), CiStatus::Unknown);\n}\n\n#[test]\nfn parse_state_string_all_cases() {\n    assert_eq!(parse_state_string(\"success\"), CiStatus::Success);\n    assert_eq!(parse_state_string(\"pending\"), CiStatus::Pending);\n    assert_eq!(parse_state_string(\"failure\"), CiStatus::Failed);\n    assert_eq!(parse_state_string(\"error\"), CiStatus::Failed);\n    assert_eq!(parse_state_string(\"other\"), CiStatus::Unknown);\n}\n\n// extract_failed_jobs tests\n#[test]\nfn extract_failed_jobs_filters_failures() {\n    let jobs = json!({\n        \"jobs\": [\n            {\"id\": 1, \"name\": \"build\", \"conclusion\": \"success\"},\n            {\"id\": 2, \"name\": \"test\", \"conclusion\": \"failure\"},\n            {\"id\": 3, \"name\": \"lint\", \"conclusion\": \"failure\"},\n        ]\n    });\n    let failed = extract_failed_jobs(\u0026jobs);\n    assert_eq!(failed.len(), 2);\n    assert_eq!(failed[0], (2, \"test\".to_string()));\n    assert_eq!(failed[1], (3, \"lint\".to_string()));\n}\n\n#[test]\nfn extract_failed_jobs_empty_when_all_success() {\n    let jobs = json!({\n        \"jobs\": [\n            {\"id\": 1, \"name\": \"build\", \"conclusion\": \"success\"},\n        ]\n    });\n    assert!(extract_failed_jobs(\u0026jobs).is_empty());\n}\n\n#[test]\nfn extract_failed_jobs_handles_missing_jobs() {\n    let jobs = json!({});\n    assert!(extract_failed_jobs(\u0026jobs).is_empty());\n}\n\n#[test]\nfn extract_failed_jobs_handles_null_jobs() {\n    let jobs = json!({\"jobs\": null});\n    assert!(extract_failed_jobs(\u0026jobs).is_empty());\n}\n\n// extract_run_id tests\n#[test]\nfn extract_run_id_finds_first() {\n    let runs = json!({\n        \"workflow_runs\": [\n            {\"id\": 123},\n            {\"id\": 456},\n        ]\n    });\n    assert_eq!(extract_run_id(\u0026runs), Some(123));\n}\n\n#[test]\nfn extract_run_id_empty_array() {\n    let runs = json!({\"workflow_runs\": []});\n    assert_eq!(extract_run_id(\u0026runs), None);\n}\n\n#[test]\nfn extract_run_id_missing_key() {\n    let runs = json!({});\n    assert_eq!(extract_run_id(\u0026runs), None);\n}\n\n// extract_pr_number_from_list tests\n#[test]\nfn extract_pr_number_from_list_finds_first() {\n    let prs = json!([{\"number\": 42}, {\"number\": 99}]);\n    assert_eq!(extract_pr_number_from_list(\u0026prs), Some(42));\n}\n\n#[test]\nfn extract_pr_number_from_list_single() {\n    let prs = json!([{\"number\": 7}]);\n    assert_eq!(extract_pr_number_from_list(\u0026prs), Some(7));\n}\n\n#[test]\nfn extract_pr_number_from_list_empty() {\n    let prs = json!([]);\n    assert_eq!(extract_pr_number_from_list(\u0026prs), None);\n}\n\n#[test]\nfn extract_pr_number_from_list_missing_number() {\n    let prs = json!([{\"title\": \"no number\"}]);\n    assert_eq!(extract_pr_number_from_list(\u0026prs), None);\n}\n\n#[test]\nfn extract_pr_number_from_list_not_array() {\n    let prs = json!({\"number\": 42});\n    assert_eq!(extract_pr_number_from_list(\u0026prs), None);\n}\n\n#[test]\nfn extract_pr_number_from_list_null() {\n    let prs = json!(null);\n    assert_eq!(extract_pr_number_from_list(\u0026prs), None);\n}\n\n#[test]\nfn clean_ci_line_removes_timestamp() {\n    let line = \"2026-01-27T18:51:46.1029380Z      Failure/Error: some code\";\n    assert_eq!(clean_ci_line(line), \"Failure/Error: some code\");\n}\n\n#[test]\nfn clean_ci_line_preserves_line_without_timestamp() {\n    let line = \"  some regular line  \";\n    assert_eq!(clean_ci_line(line), \"some regular line\");\n}\n\n#[test]\nfn clean_ci_line_handles_empty() {\n    assert_eq!(clean_ci_line(\"\"), \"\");\n    assert_eq!(clean_ci_line(\"   \"), \"\");\n}\n\n#[test]\nfn parse_test_failures_extracts_rspec_failures() {\n    let logs = r#\"\n2026-01-27T18:51:46.1025638Z Failures:\n2026-01-27T18:51:46.1026049Z\n2026-01-27T18:51:46.1027821Z   1) MyClass does something\n2026-01-27T18:51:46.1029380Z      Failure/Error: expect(result).to eq(expected)\n2026-01-27T18:51:46.1167230Z        expected: 42\n2026-01-27T18:51:46.1168761Z      # ./spec/my_class_spec.rb:10:in `block'\n2026-01-27T18:51:46.1174151Z\n2026-01-27T18:51:46.1253383Z Failed examples:\n2026-01-27T18:51:46.1255271Z rspec ./spec/my_class_spec.rb:8 # MyClass does something\n\"#;\n    let failures = parse_test_failures(logs);\n    assert_eq!(failures.len(), 1);\n    assert_eq!(failures[0].spec_file, \"./spec/my_class_spec.rb:8\");\n    assert!(failures[0]\n        .failure_text\n        .contains(\"expect(result).to eq(expected)\"));\n    assert!(failures[0].failure_text.contains(\"expected: 42\"));\n}\n\n#[test]\nfn parse_test_failures_handles_multiple_failures() {\n    let logs = r#\"\nFailures:\n\n  1) First test fails\n     Failure/Error: assert false\n       error one\n     # ./spec/first_spec.rb:5\n\n  2) Second test fails\n     Failure/Error: raise \"boom\"\n       error two\n     # ./spec/second_spec.rb:10\n\nFailed examples:\n\nrspec ./spec/first_spec.rb:3 # First test fails\nrspec ./spec/second_spec.rb:8 # Second test fails\n\"#;\n    let failures = parse_test_failures(logs);\n    assert_eq!(failures.len(), 2);\n    assert_eq!(failures[0].spec_file, \"./spec/first_spec.rb:3\");\n    assert_eq!(failures[1].spec_file, \"./spec/second_spec.rb:8\");\n    assert!(failures[0].failure_text.contains(\"assert false\"));\n    assert!(failures[1].failure_text.contains(\"raise \\\"boom\\\"\"));\n}\n\n#[test]\nfn parse_test_failures_handles_no_failures() {\n    let logs = \"All tests passed!\\n0 failures\";\n    let failures = parse_test_failures(logs);\n    assert!(failures.is_empty());\n}\n\n#[test]\nfn parse_test_failures_handles_empty_logs() {\n    let failures = parse_test_failures(\"\");\n    assert!(failures.is_empty());\n}\n\n#[test]\nfn parse_test_failures_deduplicates() {\n    let logs = r#\"\nFailures:\n\n  1) Test fails\n     Failure/Error: fail\n     # ./spec/test_spec.rb:5\n\nFailed examples:\n\nrspec ./spec/test_spec.rb:3 # Test fails\nrspec ./spec/test_spec.rb:3 # Test fails duplicate\n\"#;\n    let failures = parse_test_failures(logs);\n    assert_eq!(failures.len(), 1);\n}\n\n#[test]\nfn parse_test_failures_mock_error_format() {\n    // Test the actual format from the CI logs\n    let logs = r#\"\n2026-01-27T18:51:46.1025638Z Failures:\n2026-01-27T18:51:46.1027821Z   1) PricesApiHelper pax value includes pax\n2026-01-27T18:51:46.1029380Z      Failure/Error: found_lowest_prices += service.method\n2026-01-27T18:51:46.1167230Z        #\u003cInstanceDouble(Packages::Items)\u003e received unexpected message :method\n2026-01-27T18:51:46.1168761Z      # ./app/helpers/prices_api_helper.rb:62\n2026-01-27T18:51:46.1253383Z Failed examples:\n2026-01-27T18:51:46.1255271Z rspec ./spec/helpers/prices_api_helper_spec.rb:289 # PricesApiHelper pax value includes pax\n\"#;\n    let failures = parse_test_failures(logs);\n    assert_eq!(failures.len(), 1);\n    assert_eq!(\n        failures[0].spec_file,\n        \"./spec/helpers/prices_api_helper_spec.rb:289\"\n    );\n    assert!(failures[0]\n        .failure_text\n        .contains(\"received unexpected message\"));\n}\n\n#[test]\nfn parse_test_failures_code_only_when_error_is_stacktrace() {\n    let logs = r#\"\nFailures:\n\n  1) Test with stack trace only\n     Failure/Error: some_method_call\n     # ./spec/test_spec.rb:5\n\nFailed examples:\n\nrspec ./spec/test_spec.rb:3 # Test with stack trace only\n\"#;\n    let failures = parse_test_failures(logs);\n    assert_eq!(failures.len(), 1);\n    // Should only have the code line since next line starts with #\n    assert_eq!(failures[0].failure_text, \"some_method_call\");\n}\n\n#[test]\nfn parse_test_failures_handles_failures_section_only() {\n    // Missing \"Failed examples:\" section\n    let logs = r#\"\nFailures:\n\n  1) Test fails\n     Failure/Error: expect(1).to eq(2)\n       expected: 2\n     # ./spec/test_spec.rb:5\n\"#;\n    let failures = parse_test_failures(logs);\n    // No failed examples section means we can't extract spec files\n    assert!(failures.is_empty());\n}\n\n#[test]\nfn parse_test_failures_handles_nested_spec_paths() {\n    let logs = r#\"\nFailures:\n\n  1) Deep path test\n     Failure/Error: fail \"deep\"\n       error msg\n\nFailed examples:\n\nrspec ./spec/features/admin/users/permissions_spec.rb:42 # Deep path test\n\"#;\n    let failures = parse_test_failures(logs);\n    assert_eq!(failures.len(), 1);\n    assert_eq!(\n        failures[0].spec_file,\n        \"./spec/features/admin/users/permissions_spec.rb:42\"\n    );\n}\n\n// extract_workflow_runs tests\n#[test]\nfn extract_workflow_runs_valid_response() {\n    let response = json!({\n        \"workflow_runs\": [\n            {\n                \"id\": 100,\n                \"name\": \"CI\",\n                \"status\": \"completed\",\n                \"conclusion\": \"success\",\n                \"head_branch\": \"main\",\n                \"html_url\": \"https://github.com/o/r/actions/runs/100\",\n                \"created_at\": \"2024-01-15T10:00:00Z\",\n                \"updated_at\": \"2024-01-15T10:05:00Z\",\n                \"run_number\": 42\n            },\n            {\n                \"id\": 101,\n                \"name\": \"Lint\",\n                \"status\": \"in_progress\",\n                \"conclusion\": null,\n                \"head_branch\": \"feature\",\n                \"html_url\": \"https://github.com/o/r/actions/runs/101\",\n                \"created_at\": \"2024-01-15T11:00:00Z\",\n                \"updated_at\": \"2024-01-15T11:01:00Z\",\n                \"run_number\": 43\n            }\n        ]\n    });\n    let runs = extract_workflow_runs(\u0026response);\n    assert_eq!(runs.len(), 2);\n    assert_eq!(runs[0].id, 100);\n    assert_eq!(runs[0].name, \"CI\");\n    assert_eq!(runs[0].conclusion, Some(\"success\".to_string()));\n    assert_eq!(runs[0].branch, \"main\");\n    assert_eq!(runs[1].id, 101);\n    assert!(runs[1].conclusion.is_none());\n}\n\n#[test]\nfn extract_workflow_runs_empty() {\n    let response = json!({\"workflow_runs\": []});\n    assert!(extract_workflow_runs(\u0026response).is_empty());\n}\n\n#[test]\nfn extract_workflow_runs_missing_key() {\n    let response = json!({});\n    assert!(extract_workflow_runs(\u0026response).is_empty());\n}\n\n#[test]\nfn extract_workflow_runs_skips_invalid() {\n    let response = json!({\n        \"workflow_runs\": [\n            {\"name\": \"no id\"},\n            {\n                \"id\": 100,\n                \"name\": \"Valid\",\n                \"status\": \"completed\",\n                \"conclusion\": \"success\",\n                \"head_branch\": \"main\",\n                \"html_url\": \"url\",\n                \"created_at\": \"c\",\n                \"updated_at\": \"u\",\n                \"run_number\": 1\n            }\n        ]\n    });\n    let runs = extract_workflow_runs(\u0026response);\n    assert_eq!(runs.len(), 1);\n    assert_eq!(runs[0].id, 100);\n}\n\n#[test]\nfn extract_workflow_runs_null_runs() {\n    let response = json!({\"workflow_runs\": null});\n    assert!(extract_workflow_runs(\u0026response).is_empty());\n}\n\n// extract_matching_prs tests\n#[test]\nfn extract_matching_prs_by_title() {\n    let response = json!([\n        {\n            \"number\": 1,\n            \"title\": \"BFR-1234 Fix login\",\n            \"html_url\": \"https://github.com/o/r/pull/1\",\n            \"state\": \"open\",\n            \"head\": {\"ref\": \"some-branch\"},\n            \"base\": {\"repo\": {\"full_name\": \"o/r\"}},\n            \"created_at\": \"c\",\n            \"updated_at\": \"u\"\n        },\n        {\n            \"number\": 2,\n            \"title\": \"Unrelated change\",\n            \"html_url\": \"https://github.com/o/r/pull/2\",\n            \"state\": \"open\",\n            \"head\": {\"ref\": \"other\"},\n            \"base\": {\"repo\": {\"full_name\": \"o/r\"}},\n            \"created_at\": \"c\",\n            \"updated_at\": \"u\"\n        }\n    ]);\n    let prs = extract_matching_prs(\u0026response, \"BFR-1234\");\n    assert_eq!(prs.len(), 1);\n    assert_eq!(prs[0].number, 1);\n}\n\n#[test]\nfn extract_matching_prs_by_branch() {\n    let response = json!([\n        {\n            \"number\": 1,\n            \"title\": \"Some PR\",\n            \"html_url\": \"url\",\n            \"state\": \"open\",\n            \"head\": {\"ref\": \"bfr-1234-fix\"},\n            \"base\": {\"repo\": {\"full_name\": \"o/r\"}},\n            \"created_at\": \"c\",\n            \"updated_at\": \"u\"\n        }\n    ]);\n    let prs = extract_matching_prs(\u0026response, \"BFR-1234\");\n    assert_eq!(prs.len(), 1);\n}\n\n#[test]\nfn extract_matching_prs_empty() {\n    let response = json!([]);\n    assert!(extract_matching_prs(\u0026response, \"BFR-1234\").is_empty());\n}\n\n#[test]\nfn extract_matching_prs_no_match() {\n    let response = json!([\n        {\n            \"number\": 1,\n            \"title\": \"Unrelated\",\n            \"html_url\": \"url\",\n            \"state\": \"open\",\n            \"head\": {\"ref\": \"other\"},\n            \"base\": {\"repo\": {\"full_name\": \"o/r\"}},\n            \"created_at\": \"c\",\n            \"updated_at\": \"u\"\n        }\n    ]);\n    assert!(extract_matching_prs(\u0026response, \"BFR-999\").is_empty());\n}\n\n#[test]\nfn extract_matching_prs_not_array() {\n    let response = json!({\"not\": \"array\"});\n    assert!(extract_matching_prs(\u0026response, \"query\").is_empty());\n}\n\n#[test]\nfn extract_matching_prs_case_insensitive() {\n    let response = json!([\n        {\n            \"number\": 1,\n            \"title\": \"bfr-1234 lowercase\",\n            \"html_url\": \"url\",\n            \"state\": \"open\",\n            \"head\": {\"ref\": \"main\"},\n            \"base\": {\"repo\": {\"full_name\": \"o/r\"}},\n            \"created_at\": \"c\",\n            \"updated_at\": \"u\"\n        }\n    ]);\n    let prs = extract_matching_prs(\u0026response, \"BFR-1234\");\n    assert_eq!(prs.len(), 1);\n}\n\n#[test]\nfn clean_ci_line_various_timestamps() {\n    // Different timestamp formats from CI\n    assert_eq!(\n        clean_ci_line(\"2026-01-27T10:00:00.000Z some text\"),\n        \"some text\"\n    );\n    assert_eq!(clean_ci_line(\"2026-01-27T10:00:00.1234567Z text\"), \"text\");\n    assert_eq!(\n        clean_ci_line(\"2020-12-31T23:59:59.9Z end of year\"),\n        \"end of year\"\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","gh","failures","mod.rs"],"content":"use anyhow::Result;\n\nuse super::cli::FailuresArgs;\nuse super::client::{parse_test_failures, GithubApi, GithubClient};\nuse super::helpers::{get_current_repo, is_test_job, parse_owner_repo};\n\n#[cfg(test)]\nmod tests;\n\n/// Handle the `hu gh failures` command\npub async fn run(args: FailuresArgs) -\u003e Result\u003c()\u003e {\n    let client = GithubClient::new()?;\n\n    // Get repo info from args or current directory\n    let (owner, repo) = if let Some(repo_arg) = \u0026args.repo {\n        parse_owner_repo(repo_arg)?\n    } else {\n        get_current_repo()?\n    };\n\n    // Determine which PR to check\n    let pr_number = if let Some(pr) = args.pr {\n        pr\n    } else {\n        get_current_branch_pr(\u0026client, \u0026owner, \u0026repo).await?\n    };\n\n    process_failures(\u0026client, \u0026owner, \u0026repo, pr_number).await\n}\n\n/// Process failures using the given API client (testable)\npub async fn process_failures(\n    client: \u0026impl GithubApi,\n    owner: \u0026str,\n    repo: \u0026str,\n    pr_number: u64,\n) -\u003e Result\u003c()\u003e {\n    eprintln!(\n        \"Fetching failures for PR #{} in {}/{}...\",\n        pr_number, owner, repo\n    );\n\n    // Get the PR's branch name\n    let branch = client.get_pr_branch(owner, repo, pr_number).await?;\n\n    // Get the latest failed workflow run for this branch\n    let run_id = client\n        .get_latest_failed_run_for_branch(owner, repo, \u0026branch)\n        .await?;\n\n    let run_id = match run_id {\n        Some(id) =\u003e id,\n        None =\u003e {\n            println!(\"No failed workflow runs found for PR #{}.\", pr_number);\n            return Ok(());\n        }\n    };\n\n    // Get failed jobs in that run\n    let failed_jobs = client.get_failed_jobs(owner, repo, run_id).await?;\n\n    if failed_jobs.is_empty() {\n        println!(\"No failed jobs found in run {}.\", run_id);\n        return Ok(());\n    }\n\n    // Only process test-related jobs (rspec, jest, etc.)\n    let test_jobs: Vec\u003c_\u003e = failed_jobs\n        .into_iter()\n        .filter(|(_, name)| is_test_job(name))\n        .collect();\n\n    if test_jobs.is_empty() {\n        println!(\"No test-related job failures found.\");\n        return Ok(());\n    }\n\n    let mut all_failures = Vec::new();\n\n    for (job_id, job_name) in test_jobs {\n        eprintln!(\"Fetching logs for job: {}\", job_name);\n\n        match client.get_job_logs(owner, repo, job_id).await {\n            Ok(logs) =\u003e {\n                let failures = parse_test_failures(\u0026logs);\n                all_failures.extend(failures);\n            }\n            Err(e) =\u003e {\n                eprintln!(\"Warning: Failed to fetch logs for {}: {}\", job_name, e);\n            }\n        }\n    }\n\n    if all_failures.is_empty() {\n        println!(\"No test failures found in logs.\");\n        return Ok(());\n    }\n\n    // Output in a format useful for Claude\n    println!(\"\\n# Test Failures\\n\");\n    for failure in \u0026all_failures {\n        println!(\"## {}\\n\", failure.spec_file);\n        println!(\"```\");\n        println!(\"{}\", failure.failure_text);\n        println!(\"```\\n\");\n    }\n\n    // Also output the rspec commands to rerun\n    println!(\"# Rerun Commands\\n\");\n    println!(\"```bash\");\n    for failure in \u0026all_failures {\n        println!(\"bundle exec rspec {}\", failure.spec_file);\n    }\n    println!(\"```\");\n\n    Ok(())\n}\n\n/// Get PR number for current branch using octocrab\nasync fn get_current_branch_pr(client: \u0026impl GithubApi, owner: \u0026str, repo: \u0026str) -\u003e Result\u003cu64\u003e {\n    let branch = super::helpers::get_current_branch()?;\n\n    match client.find_pr_for_branch(owner, repo, \u0026branch).await? {\n        Some(pr) =\u003e Ok(pr),\n        None =\u003e anyhow::bail!(\n            \"No PR found for branch '{}'. Use --pr to specify a PR number.\",\n            branch\n        ),\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":7}},{"line":38,"address":[],"length":0,"stats":{"Line":7}},{"line":39,"address":[],"length":0,"stats":{"Line":7}},{"line":44,"address":[],"length":0,"stats":{"Line":42}},{"line":47,"address":[],"length":0,"stats":{"Line":21}},{"line":48,"address":[],"length":0,"stats":{"Line":28}},{"line":49,"address":[],"length":0,"stats":{"Line":7}},{"line":51,"address":[],"length":0,"stats":{"Line":13}},{"line":52,"address":[],"length":0,"stats":{"Line":12}},{"line":54,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":60,"address":[],"length":0,"stats":{"Line":36}},{"line":62,"address":[],"length":0,"stats":{"Line":12}},{"line":63,"address":[],"length":0,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":1}},{"line":68,"address":[],"length":0,"stats":{"Line":15}},{"line":70,"address":[],"length":0,"stats":{"Line":21}},{"line":73,"address":[],"length":0,"stats":{"Line":10}},{"line":74,"address":[],"length":0,"stats":{"Line":2}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":78,"address":[],"length":0,"stats":{"Line":8}},{"line":80,"address":[],"length":0,"stats":{"Line":19}},{"line":81,"address":[],"length":0,"stats":{"Line":10}},{"line":83,"address":[],"length":0,"stats":{"Line":30}},{"line":84,"address":[],"length":0,"stats":{"Line":8}},{"line":85,"address":[],"length":0,"stats":{"Line":16}},{"line":86,"address":[],"length":0,"stats":{"Line":8}},{"line":88,"address":[],"length":0,"stats":{"Line":2}},{"line":89,"address":[],"length":0,"stats":{"Line":1}},{"line":94,"address":[],"length":0,"stats":{"Line":8}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":96,"address":[],"length":0,"stats":{"Line":2}},{"line":100,"address":[],"length":0,"stats":{"Line":4}},{"line":101,"address":[],"length":0,"stats":{"Line":11}},{"line":102,"address":[],"length":0,"stats":{"Line":9}},{"line":103,"address":[],"length":0,"stats":{"Line":9}},{"line":104,"address":[],"length":0,"stats":{"Line":9}},{"line":105,"address":[],"length":0,"stats":{"Line":3}},{"line":109,"address":[],"length":0,"stats":{"Line":4}},{"line":110,"address":[],"length":0,"stats":{"Line":4}},{"line":111,"address":[],"length":0,"stats":{"Line":11}},{"line":112,"address":[],"length":0,"stats":{"Line":3}},{"line":114,"address":[],"length":0,"stats":{"Line":4}},{"line":116,"address":[],"length":0,"stats":{"Line":2}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}}],"covered":44,"coverable":58},{"path":["/","Users","chi","Projects","hu","src","gh","failures","tests.rs"],"content":"use super::*;\n\n// Mock implementation for testing\nuse crate::gh::types::PullRequest;\n\nstruct MockGithubApi {\n    branch: String,\n    run_id: Option\u003cu64\u003e,\n    failed_jobs: Vec\u003c(u64, String)\u003e,\n    logs: String,\n}\n\nimpl GithubApi for MockGithubApi {\n    async fn list_user_prs(\u0026self) -\u003e Result\u003cVec\u003cPullRequest\u003e\u003e {\n        Ok(vec![])\n    }\n\n    async fn get_ci_status(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _pr: u64,\n    ) -\u003e Result\u003ccrate::gh::types::CiStatus\u003e {\n        Ok(crate::gh::types::CiStatus::Unknown)\n    }\n\n    async fn get_pr_branch(\u0026self, _owner: \u0026str, _repo: \u0026str, _pr: u64) -\u003e Result\u003cString\u003e {\n        Ok(self.branch.clone())\n    }\n\n    async fn get_latest_failed_run_for_branch(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _branch: \u0026str,\n    ) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n        Ok(self.run_id)\n    }\n\n    async fn get_failed_jobs(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _run_id: u64,\n    ) -\u003e Result\u003cVec\u003c(u64, String)\u003e\u003e {\n        Ok(self.failed_jobs.clone())\n    }\n\n    async fn get_job_logs(\u0026self, _owner: \u0026str, _repo: \u0026str, _job_id: u64) -\u003e Result\u003cString\u003e {\n        Ok(self.logs.clone())\n    }\n\n    async fn find_pr_for_branch(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _branch: \u0026str,\n    ) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n        Ok(None)\n    }\n\n    async fn list_workflow_runs(\n        \u0026self,\n        _query: \u0026crate::gh::types::RunsQuery\u003c'_\u003e,\n    ) -\u003e Result\u003cVec\u003ccrate::gh::types::WorkflowRun\u003e\u003e {\n        Ok(vec![])\n    }\n\n    async fn search_prs_by_title(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _query: \u0026str,\n    ) -\u003e Result\u003cVec\u003cPullRequest\u003e\u003e {\n        Ok(vec![])\n    }\n}\n\n#[tokio::test]\nasync fn process_failures_no_failed_runs() {\n    let mock = MockGithubApi {\n        branch: \"main\".to_string(),\n        run_id: None,\n        failed_jobs: vec![],\n        logs: String::new(),\n    };\n    let result = process_failures(\u0026mock, \"owner\", \"repo\", 123).await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn process_failures_no_failed_jobs() {\n    let mock = MockGithubApi {\n        branch: \"main\".to_string(),\n        run_id: Some(1),\n        failed_jobs: vec![],\n        logs: String::new(),\n    };\n    let result = process_failures(\u0026mock, \"owner\", \"repo\", 123).await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn process_failures_no_test_jobs() {\n    let mock = MockGithubApi {\n        branch: \"main\".to_string(),\n        run_id: Some(1),\n        failed_jobs: vec![(1, \"build\".to_string()), (2, \"deploy\".to_string())],\n        logs: String::new(),\n    };\n    let result = process_failures(\u0026mock, \"owner\", \"repo\", 123).await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn process_failures_with_test_failures() {\n    let mock = MockGithubApi {\n        branch: \"main\".to_string(),\n        run_id: Some(1),\n        failed_jobs: vec![(1, \"rspec-tests\".to_string())],\n        logs: r#\"\nFailures:\n\n  1) Test fails\n     Failure/Error: expect(1).to eq(2)\n       expected: 2\n\nFailed examples:\n\nrspec ./spec/test_spec.rb:10 # Test fails\n\"#\n        .to_string(),\n    };\n    let result = process_failures(\u0026mock, \"owner\", \"repo\", 123).await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn process_failures_empty_logs() {\n    let mock = MockGithubApi {\n        branch: \"main\".to_string(),\n        run_id: Some(1),\n        failed_jobs: vec![(1, \"test-suite\".to_string())],\n        logs: String::new(),\n    };\n    let result = process_failures(\u0026mock, \"owner\", \"repo\", 123).await;\n    assert!(result.is_ok());\n}\n\n// Mock with error handling\nstruct MockGithubApiWithLogError {\n    branch: String,\n    run_id: Option\u003cu64\u003e,\n    failed_jobs: Vec\u003c(u64, String)\u003e,\n}\n\nimpl GithubApi for MockGithubApiWithLogError {\n    async fn list_user_prs(\u0026self) -\u003e Result\u003cVec\u003cPullRequest\u003e\u003e {\n        Ok(vec![])\n    }\n\n    async fn get_ci_status(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _pr: u64,\n    ) -\u003e Result\u003ccrate::gh::types::CiStatus\u003e {\n        Ok(crate::gh::types::CiStatus::Unknown)\n    }\n\n    async fn get_pr_branch(\u0026self, _owner: \u0026str, _repo: \u0026str, _pr: u64) -\u003e Result\u003cString\u003e {\n        Ok(self.branch.clone())\n    }\n\n    async fn get_latest_failed_run_for_branch(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _branch: \u0026str,\n    ) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n        Ok(self.run_id)\n    }\n\n    async fn get_failed_jobs(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _run_id: u64,\n    ) -\u003e Result\u003cVec\u003c(u64, String)\u003e\u003e {\n        Ok(self.failed_jobs.clone())\n    }\n\n    async fn get_job_logs(\u0026self, _owner: \u0026str, _repo: \u0026str, _job_id: u64) -\u003e Result\u003cString\u003e {\n        Err(anyhow::anyhow!(\"Failed to fetch logs\"))\n    }\n\n    async fn find_pr_for_branch(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _branch: \u0026str,\n    ) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n        Ok(None)\n    }\n\n    async fn list_workflow_runs(\n        \u0026self,\n        _query: \u0026crate::gh::types::RunsQuery\u003c'_\u003e,\n    ) -\u003e Result\u003cVec\u003ccrate::gh::types::WorkflowRun\u003e\u003e {\n        Ok(vec![])\n    }\n\n    async fn search_prs_by_title(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _query: \u0026str,\n    ) -\u003e Result\u003cVec\u003cPullRequest\u003e\u003e {\n        Ok(vec![])\n    }\n}\n\n#[tokio::test]\nasync fn process_failures_handles_log_fetch_error() {\n    let mock = MockGithubApiWithLogError {\n        branch: \"feature\".to_string(),\n        run_id: Some(42),\n        failed_jobs: vec![(100, \"rspec-tests\".to_string())],\n    };\n    let result = process_failures(\u0026mock, \"owner\", \"repo\", 123).await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn process_failures_multiple_test_jobs() {\n    let mock = MockGithubApi {\n        branch: \"main\".to_string(),\n        run_id: Some(1),\n        failed_jobs: vec![\n            (1, \"rspec-tests\".to_string()),\n            (2, \"jest-tests\".to_string()),\n            (3, \"build\".to_string()),\n        ],\n        logs: r#\"\nFailures:\n\n  1) Test fails\n     Failure/Error: expect(1).to eq(2)\n       expected: 2\n\nFailed examples:\n\nrspec ./spec/test_spec.rb:10 # Test fails\n\"#\n        .to_string(),\n    };\n    let result = process_failures(\u0026mock, \"owner\", \"repo\", 123).await;\n    assert!(result.is_ok());\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":12}},{"line":28,"address":[],"length":0,"stats":{"Line":6}},{"line":31,"address":[],"length":0,"stats":{"Line":6}},{"line":37,"address":[],"length":0,"stats":{"Line":6}},{"line":40,"address":[],"length":0,"stats":{"Line":5}},{"line":46,"address":[],"length":0,"stats":{"Line":5}},{"line":49,"address":[],"length":0,"stats":{"Line":8}},{"line":50,"address":[],"length":0,"stats":{"Line":4}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":2}},{"line":172,"address":[],"length":0,"stats":{"Line":1}},{"line":175,"address":[],"length":0,"stats":{"Line":1}},{"line":181,"address":[],"length":0,"stats":{"Line":1}},{"line":184,"address":[],"length":0,"stats":{"Line":1}},{"line":190,"address":[],"length":0,"stats":{"Line":1}},{"line":193,"address":[],"length":0,"stats":{"Line":2}},{"line":194,"address":[],"length":0,"stats":{"Line":1}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}}],"covered":16,"coverable":36},{"path":["/","Users","chi","Projects","hu","src","gh","fix","mapping","mod.rs"],"content":"/// Strip line number suffix from a path (e.g., \"spec/foo_spec.rb:10\" -\u003e \"spec/foo_spec.rb\")\npub fn strip_line_number(path: \u0026str) -\u003e \u0026str {\n    // Find last colon followed by digits\n    if let Some(idx) = path.rfind(':') {\n        if path[idx + 1..].chars().all(|c| c.is_ascii_digit()) \u0026\u0026 !path[idx + 1..].is_empty() {\n            return \u0026path[..idx];\n        }\n    }\n    path\n}\n\n/// Detect the language/framework from a test file path\npub fn detect_language(test_file: \u0026str) -\u003e \u0026'static str {\n    let path = strip_line_number(test_file);\n\n    if path.ends_with(\"_spec.rb\") || path.starts_with(\"spec/\") || path.starts_with(\"./spec/\") {\n        \"ruby\"\n    } else if path.ends_with(\"_test.py\")\n        || (path.ends_with(\".py\") \u0026\u0026 (path.starts_with(\"tests/test_\") || path.starts_with(\"test_\")))\n    {\n        \"python\"\n    } else if path.ends_with(\".test.js\")\n        || path.ends_with(\".test.ts\")\n        || path.ends_with(\".test.tsx\")\n        || path.ends_with(\".test.jsx\")\n        || path.ends_with(\".spec.js\")\n        || path.ends_with(\".spec.ts\")\n        || path.ends_with(\".spec.tsx\")\n        || path.ends_with(\".spec.jsx\")\n    {\n        \"javascript\"\n    } else if path.ends_with(\".rs\")\n        || (path.starts_with(\"tests/\") \u0026\u0026 !path.ends_with(\".py\"))\n        || path.contains(\"/tests.rs\")\n        || path.contains(\"/tests/\")\n    {\n        \"rust\"\n    } else {\n        \"unknown\"\n    }\n}\n\n/// Map a test file path to likely source file paths\npub fn map_test_to_source(test_file: \u0026str) -\u003e Vec\u003cString\u003e {\n    let path = strip_line_number(test_file);\n    let lang = detect_language(test_file);\n\n    match lang {\n        \"ruby\" =\u003e map_rspec(path),\n        \"rust\" =\u003e map_rust(path),\n        \"python\" =\u003e map_python(path),\n        \"javascript\" =\u003e map_javascript(path),\n        _ =\u003e vec![],\n    }\n}\n\n/// Map RSpec test file to Ruby source files\n/// spec/models/user_spec.rb -\u003e app/models/user.rb\n/// spec/helpers/pricing_helper_spec.rb -\u003e app/helpers/pricing_helper.rb\nfn map_rspec(path: \u0026str) -\u003e Vec\u003cString\u003e {\n    let path = path\n        .strip_prefix(\"./\")\n        .unwrap_or(path)\n        .strip_prefix(\"spec/\")\n        .unwrap_or(path);\n\n    let path = path.strip_suffix(\"_spec.rb\").unwrap_or(path);\n\n    vec![format!(\"app/{}.rb\", path), format!(\"lib/{}.rb\", path)]\n}\n\n/// Map Rust test file to source files\n/// tests/test_sync.rs -\u003e src/sync.rs\n/// src/data/tests.rs -\u003e src/data/mod.rs\nfn map_rust(path: \u0026str) -\u003e Vec\u003cString\u003e {\n    let path = path.strip_prefix(\"./\").unwrap_or(path);\n\n    if let Some(parent) = path.strip_suffix(\"/tests.rs\") {\n        return vec![format!(\"{}/mod.rs\", parent)];\n    }\n\n    if let Some(rest) = path.strip_prefix(\"tests/\") {\n        let without_prefix = rest.strip_prefix(\"test_\").unwrap_or(rest);\n        let name = without_prefix.strip_suffix(\".rs\").unwrap_or(without_prefix);\n        return vec![format!(\"src/{}.rs\", name), format!(\"src/{}/mod.rs\", name)];\n    }\n\n    vec![]\n}\n\n/// Map Python test file to source files\n/// tests/test_utils.py -\u003e src/utils.py, utils.py\n/// utils_test.py -\u003e utils.py\nfn map_python(path: \u0026str) -\u003e Vec\u003cString\u003e {\n    let path = path.strip_prefix(\"./\").unwrap_or(path);\n\n    if path.starts_with(\"tests/test_\") || path.starts_with(\"test_\") {\n        let name = path\n            .strip_prefix(\"tests/\")\n            .unwrap_or(path)\n            .strip_prefix(\"test_\")\n            .unwrap_or(path);\n        return vec![format!(\"src/{}\", name), name.to_string()];\n    }\n\n    if let Some(base) = path.strip_suffix(\"_test.py\") {\n        return vec![format!(\"{}.py\", base), format!(\"src/{}.py\", base)];\n    }\n\n    vec![]\n}\n\n/// Map JS/TS test file to source files\n/// components/Button.test.tsx -\u003e components/Button.tsx\n/// utils/format.spec.ts -\u003e utils/format.ts\nfn map_javascript(path: \u0026str) -\u003e Vec\u003cString\u003e {\n    let path = path.strip_prefix(\"./\").unwrap_or(path);\n\n    for suffix in \u0026[\n        \".test.js\",\n        \".test.ts\",\n        \".test.tsx\",\n        \".test.jsx\",\n        \".spec.js\",\n        \".spec.ts\",\n        \".spec.tsx\",\n        \".spec.jsx\",\n    ] {\n        if let Some(base) = path.strip_suffix(suffix) {\n            let ext = \u0026suffix[suffix.rfind('.').unwrap_or(0)..];\n            return vec![format!(\"{}{}\", base, ext)];\n        }\n    }\n\n    vec![]\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[{"line":2,"address":[],"length":0,"stats":{"Line":90}},{"line":4,"address":[],"length":0,"stats":{"Line":125}},{"line":5,"address":[],"length":0,"stats":{"Line":220}},{"line":6,"address":[],"length":0,"stats":{"Line":33}},{"line":9,"address":[],"length":0,"stats":{"Line":57}},{"line":13,"address":[],"length":0,"stats":{"Line":51}},{"line":14,"address":[],"length":0,"stats":{"Line":153}},{"line":16,"address":[],"length":0,"stats":{"Line":234}},{"line":17,"address":[],"length":0,"stats":{"Line":18}},{"line":18,"address":[],"length":0,"stats":{"Line":66}},{"line":19,"address":[],"length":0,"stats":{"Line":74}},{"line":21,"address":[],"length":0,"stats":{"Line":6}},{"line":22,"address":[],"length":0,"stats":{"Line":54}},{"line":23,"address":[],"length":0,"stats":{"Line":48}},{"line":24,"address":[],"length":0,"stats":{"Line":48}},{"line":25,"address":[],"length":0,"stats":{"Line":40}},{"line":26,"address":[],"length":0,"stats":{"Line":40}},{"line":27,"address":[],"length":0,"stats":{"Line":40}},{"line":28,"address":[],"length":0,"stats":{"Line":36}},{"line":29,"address":[],"length":0,"stats":{"Line":36}},{"line":31,"address":[],"length":0,"stats":{"Line":11}},{"line":32,"address":[],"length":0,"stats":{"Line":32}},{"line":33,"address":[],"length":0,"stats":{"Line":14}},{"line":34,"address":[],"length":0,"stats":{"Line":14}},{"line":35,"address":[],"length":0,"stats":{"Line":14}},{"line":37,"address":[],"length":0,"stats":{"Line":9}},{"line":39,"address":[],"length":0,"stats":{"Line":7}},{"line":44,"address":[],"length":0,"stats":{"Line":25}},{"line":45,"address":[],"length":0,"stats":{"Line":75}},{"line":46,"address":[],"length":0,"stats":{"Line":75}},{"line":48,"address":[],"length":0,"stats":{"Line":25}},{"line":49,"address":[],"length":0,"stats":{"Line":45}},{"line":50,"address":[],"length":0,"stats":{"Line":23}},{"line":51,"address":[],"length":0,"stats":{"Line":17}},{"line":52,"address":[],"length":0,"stats":{"Line":18}},{"line":53,"address":[],"length":0,"stats":{"Line":3}},{"line":60,"address":[],"length":0,"stats":{"Line":10}},{"line":61,"address":[],"length":0,"stats":{"Line":30}},{"line":63,"address":[],"length":0,"stats":{"Line":10}},{"line":65,"address":[],"length":0,"stats":{"Line":20}},{"line":67,"address":[],"length":0,"stats":{"Line":50}},{"line":69,"address":[],"length":0,"stats":{"Line":50}},{"line":75,"address":[],"length":0,"stats":{"Line":5}},{"line":76,"address":[],"length":0,"stats":{"Line":25}},{"line":78,"address":[],"length":0,"stats":{"Line":6}},{"line":79,"address":[],"length":0,"stats":{"Line":3}},{"line":82,"address":[],"length":0,"stats":{"Line":7}},{"line":83,"address":[],"length":0,"stats":{"Line":15}},{"line":84,"address":[],"length":0,"stats":{"Line":15}},{"line":85,"address":[],"length":0,"stats":{"Line":15}},{"line":88,"address":[],"length":0,"stats":{"Line":1}},{"line":94,"address":[],"length":0,"stats":{"Line":4}},{"line":95,"address":[],"length":0,"stats":{"Line":20}},{"line":97,"address":[],"length":0,"stats":{"Line":14}},{"line":98,"address":[],"length":0,"stats":{"Line":6}},{"line":100,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":4}},{"line":103,"address":[],"length":0,"stats":{"Line":10}},{"line":106,"address":[],"length":0,"stats":{"Line":3}},{"line":107,"address":[],"length":0,"stats":{"Line":5}},{"line":110,"address":[],"length":0,"stats":{"Line":1}},{"line":116,"address":[],"length":0,"stats":{"Line":6}},{"line":117,"address":[],"length":0,"stats":{"Line":30}},{"line":119,"address":[],"length":0,"stats":{"Line":59}},{"line":120,"address":[],"length":0,"stats":{"Line":30}},{"line":121,"address":[],"length":0,"stats":{"Line":30}},{"line":122,"address":[],"length":0,"stats":{"Line":30}},{"line":123,"address":[],"length":0,"stats":{"Line":30}},{"line":124,"address":[],"length":0,"stats":{"Line":30}},{"line":125,"address":[],"length":0,"stats":{"Line":30}},{"line":126,"address":[],"length":0,"stats":{"Line":30}},{"line":127,"address":[],"length":0,"stats":{"Line":30}},{"line":129,"address":[],"length":0,"stats":{"Line":63}},{"line":130,"address":[],"length":0,"stats":{"Line":20}},{"line":131,"address":[],"length":0,"stats":{"Line":15}},{"line":135,"address":[],"length":0,"stats":{"Line":1}}],"covered":76,"coverable":76},{"path":["/","Users","chi","Projects","hu","src","gh","fix","mapping","tests.rs"],"content":"use super::*;\n\n// strip_line_number tests\n#[test]\nfn strip_line_number_with_line() {\n    assert_eq!(strip_line_number(\"spec/foo_spec.rb:10\"), \"spec/foo_spec.rb\");\n}\n\n#[test]\nfn strip_line_number_without_line() {\n    assert_eq!(strip_line_number(\"spec/foo_spec.rb\"), \"spec/foo_spec.rb\");\n}\n\n#[test]\nfn strip_line_number_colon_no_digits() {\n    assert_eq!(strip_line_number(\"foo:bar\"), \"foo:bar\");\n}\n\n#[test]\nfn strip_line_number_empty() {\n    assert_eq!(strip_line_number(\"\"), \"\");\n}\n\n#[test]\nfn strip_line_number_multiple_colons() {\n    assert_eq!(\n        strip_line_number(\"./spec/foo_spec.rb:10\"),\n        \"./spec/foo_spec.rb\"\n    );\n}\n\n#[test]\nfn strip_line_number_trailing_colon() {\n    assert_eq!(strip_line_number(\"foo:\"), \"foo:\");\n}\n\n// detect_language tests\n#[test]\nfn detect_ruby() {\n    assert_eq!(detect_language(\"spec/models/user_spec.rb\"), \"ruby\");\n    assert_eq!(detect_language(\"./spec/models/user_spec.rb:10\"), \"ruby\");\n    assert_eq!(detect_language(\"spec/helpers/foo_spec.rb\"), \"ruby\");\n}\n\n#[test]\nfn detect_rust() {\n    assert_eq!(detect_language(\"tests/test_sync.rs\"), \"rust\");\n    assert_eq!(detect_language(\"src/data/tests.rs\"), \"rust\");\n    assert_eq!(detect_language(\"src/gh/fix/tests.rs\"), \"rust\");\n}\n\n#[test]\nfn detect_python() {\n    assert_eq!(detect_language(\"tests/test_utils.py\"), \"python\");\n    assert_eq!(detect_language(\"utils_test.py\"), \"python\");\n    assert_eq!(detect_language(\"test_main.py\"), \"python\");\n}\n\n#[test]\nfn detect_javascript() {\n    assert_eq!(detect_language(\"Button.test.tsx\"), \"javascript\");\n    assert_eq!(detect_language(\"utils/format.spec.ts\"), \"javascript\");\n    assert_eq!(detect_language(\"app.test.js\"), \"javascript\");\n    assert_eq!(detect_language(\"component.spec.jsx\"), \"javascript\");\n}\n\n#[test]\nfn detect_unknown() {\n    assert_eq!(detect_language(\"README.md\"), \"unknown\");\n    assert_eq!(detect_language(\"main.go\"), \"unknown\");\n    assert_eq!(detect_language(\"\"), \"unknown\");\n}\n\n// map_test_to_source: Ruby\n#[test]\nfn map_rspec_model() {\n    let sources = map_test_to_source(\"spec/models/user_spec.rb\");\n    assert!(sources.contains(\u0026\"app/models/user.rb\".to_string()));\n    assert!(sources.contains(\u0026\"lib/models/user.rb\".to_string()));\n}\n\n#[test]\nfn map_rspec_helper() {\n    let sources = map_test_to_source(\"spec/helpers/pricing_helper_spec.rb:289\");\n    assert!(sources.contains(\u0026\"app/helpers/pricing_helper.rb\".to_string()));\n}\n\n#[test]\nfn map_rspec_with_dot_prefix() {\n    let sources = map_test_to_source(\"./spec/models/user_spec.rb:10\");\n    assert!(sources.contains(\u0026\"app/models/user.rb\".to_string()));\n}\n\n#[test]\nfn map_rspec_nested_path() {\n    let sources = map_test_to_source(\"spec/features/admin/users/permissions_spec.rb:42\");\n    assert!(sources.contains(\u0026\"app/features/admin/users/permissions.rb\".to_string()));\n}\n\n// map_test_to_source: Rust\n#[test]\nfn map_rust_integration_test() {\n    let sources = map_test_to_source(\"tests/test_sync.rs\");\n    assert!(sources.contains(\u0026\"src/sync.rs\".to_string()));\n    assert!(sources.contains(\u0026\"src/sync/mod.rs\".to_string()));\n}\n\n#[test]\nfn map_rust_module_tests() {\n    let sources = map_test_to_source(\"src/data/tests.rs\");\n    assert_eq!(sources, vec![\"src/data/mod.rs\"]);\n}\n\n#[test]\nfn map_rust_integration_test_no_prefix() {\n    let sources = map_test_to_source(\"tests/utils.rs\");\n    assert!(sources.contains(\u0026\"src/utils.rs\".to_string()));\n}\n\n// map_test_to_source: Python\n#[test]\nfn map_python_test_file() {\n    let sources = map_test_to_source(\"tests/test_utils.py\");\n    assert!(sources.contains(\u0026\"src/utils.py\".to_string()));\n    assert!(sources.contains(\u0026\"utils.py\".to_string()));\n}\n\n#[test]\nfn map_python_suffix_test() {\n    let sources = map_test_to_source(\"utils_test.py\");\n    assert!(sources.contains(\u0026\"utils.py\".to_string()));\n    assert!(sources.contains(\u0026\"src/utils.py\".to_string()));\n}\n\n#[test]\nfn map_python_bare_test() {\n    let sources = map_test_to_source(\"test_main.py\");\n    assert!(sources.contains(\u0026\"src/main.py\".to_string()));\n    assert!(sources.contains(\u0026\"main.py\".to_string()));\n}\n\n// map_test_to_source: JavaScript/TypeScript\n#[test]\nfn map_js_test() {\n    let sources = map_test_to_source(\"components/Button.test.tsx\");\n    assert_eq!(sources, vec![\"components/Button.tsx\"]);\n}\n\n#[test]\nfn map_js_spec() {\n    let sources = map_test_to_source(\"utils/format.spec.ts\");\n    assert_eq!(sources, vec![\"utils/format.ts\"]);\n}\n\n#[test]\nfn map_js_plain() {\n    let sources = map_test_to_source(\"app.test.js\");\n    assert_eq!(sources, vec![\"app.js\"]);\n}\n\n#[test]\nfn map_jsx_spec() {\n    let sources = map_test_to_source(\"component.spec.jsx\");\n    assert_eq!(sources, vec![\"component.jsx\"]);\n}\n\n// map_test_to_source: Unknown\n#[test]\nfn map_unknown_returns_empty() {\n    let sources = map_test_to_source(\"README.md\");\n    assert!(sources.is_empty());\n}\n\n#[test]\nfn map_empty_returns_empty() {\n    let sources = map_test_to_source(\"\");\n    assert!(sources.is_empty());\n}\n\n// Edge cases\n#[test]\nfn map_with_line_number_stripped() {\n    let sources = map_test_to_source(\"spec/models/user_spec.rb:42\");\n    assert!(sources.contains(\u0026\"app/models/user.rb\".to_string()));\n}\n\n#[test]\nfn detect_language_with_line_number() {\n    assert_eq!(detect_language(\"tests/test_sync.rs:100\"), \"rust\");\n    assert_eq!(detect_language(\"app.test.js:55\"), \"javascript\");\n}\n\n// Direct mapper fallback tests\n#[test]\nfn map_rust_non_test_file() {\n    assert!(map_rust(\"src/main.rs\").is_empty());\n}\n\n#[test]\nfn map_python_non_test_file() {\n    assert!(map_python(\"main.py\").is_empty());\n}\n\n#[test]\nfn map_javascript_non_test_file() {\n    assert!(map_javascript(\"index.js\").is_empty());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","gh","fix","mod.rs"],"content":"use anyhow::Result;\n\nuse super::cli::FixArgs;\nuse super::client::{parse_test_failures, GithubApi, GithubClient};\nuse super::helpers::{get_current_branch, get_current_repo, is_test_job, parse_owner_repo};\nuse super::types::{FixFailure, FixReport, TestFailure};\n\nmod mapping;\n\n#[cfg(test)]\nmod tests;\n\n/// Query parameters for building a fix report\n#[derive(Debug, Clone)]\npub struct FixQuery {\n    pub owner: String,\n    pub repo: String,\n    pub pr: Option\u003cu64\u003e,\n    pub run: Option\u003cu64\u003e,\n    pub branch: Option\u003cString\u003e,\n}\n\n/// Handle the `hu gh fix` command\n#[cfg(not(tarpaulin_include))]\npub async fn run(args: FixArgs) -\u003e Result\u003c()\u003e {\n    let client = GithubClient::new()?;\n\n    let (owner, repo) = if let Some(repo_arg) = \u0026args.repo {\n        parse_owner_repo(repo_arg)?\n    } else {\n        get_current_repo()?\n    };\n\n    let query = FixQuery {\n        owner,\n        repo,\n        pr: args.pr,\n        run: args.run,\n        branch: args.branch,\n    };\n\n    let report = build_fix_report(\u0026client, \u0026query).await?;\n\n    match report {\n        Some(r) =\u003e output_report(\u0026r, args.json),\n        None =\u003e {\n            println!(\"No failures found.\");\n            Ok(())\n        }\n    }\n}\n\n/// Build a fix report from CI failures (testable, no I/O except API calls)\npub async fn build_fix_report(\n    client: \u0026impl GithubApi,\n    query: \u0026FixQuery,\n) -\u003e Result\u003cOption\u003cFixReport\u003e\u003e {\n    let repository = format!(\"{}/{}\", query.owner, query.repo);\n    let owner = \u0026query.owner;\n    let repo = \u0026query.repo;\n\n    // Determine run_id from args\n    let (run_id, pr_number) = if let Some(run_id) = query.run {\n        (run_id, query.pr)\n    } else if let Some(pr_number) = query.pr {\n        let branch = client.get_pr_branch(owner, repo, pr_number).await?;\n        let run_id = client\n            .get_latest_failed_run_for_branch(owner, repo, \u0026branch)\n            .await?;\n        match run_id {\n            Some(id) =\u003e (id, Some(pr_number)),\n            None =\u003e return Ok(None),\n        }\n    } else {\n        // Use branch arg or current branch\n        let branch_name = match \u0026query.branch {\n            Some(b) =\u003e b.clone(),\n            None =\u003e get_current_branch()?,\n        };\n\n        let pr_number = client.find_pr_for_branch(owner, repo, \u0026branch_name).await?;\n\n        let run_id = client\n            .get_latest_failed_run_for_branch(owner, repo, \u0026branch_name)\n            .await?;\n\n        match run_id {\n            Some(id) =\u003e (id, pr_number),\n            None =\u003e return Ok(None),\n        }\n    };\n\n    // Get failed jobs\n    let failed_jobs = client.get_failed_jobs(owner, repo, run_id).await?;\n\n    if failed_jobs.is_empty() {\n        return Ok(None);\n    }\n\n    // Filter to test jobs and fetch logs\n    let test_jobs: Vec\u003c_\u003e = failed_jobs\n        .into_iter()\n        .filter(|(_, name)| is_test_job(name))\n        .collect();\n\n    if test_jobs.is_empty() {\n        return Ok(None);\n    }\n\n    let mut all_failures = Vec::new();\n\n    for (job_id, job_name) in test_jobs {\n        eprintln!(\"Fetching logs for job: {}\", job_name);\n        match client.get_job_logs(owner, repo, job_id).await {\n            Ok(logs) =\u003e {\n                let failures = parse_test_failures(\u0026logs);\n                all_failures.extend(failures);\n            }\n            Err(e) =\u003e {\n                eprintln!(\"Warning: Failed to fetch logs for {}: {}\", job_name, e);\n            }\n        }\n    }\n\n    if all_failures.is_empty() {\n        return Ok(None);\n    }\n\n    let fix_failures = enrich_failures(\u0026all_failures);\n    let test_files: Vec\u003cString\u003e = fix_failures.iter().map(|f| f.test_file.clone()).collect();\n    let source_files: Vec\u003cString\u003e = fix_failures\n        .iter()\n        .flat_map(|f| f.source_files.clone())\n        .collect::\u003cstd::collections::HashSet\u003c_\u003e\u003e()\n        .into_iter()\n        .collect();\n\n    Ok(Some(FixReport {\n        repository,\n        pr_number,\n        run_id,\n        failures: fix_failures,\n        test_files,\n        source_files,\n    }))\n}\n\n/// Enrich test failures with source file mappings (pure function)\npub fn enrich_failures(failures: \u0026[TestFailure]) -\u003e Vec\u003cFixFailure\u003e {\n    failures\n        .iter()\n        .map(|f| {\n            let language = mapping::detect_language(\u0026f.spec_file).to_string();\n            let source_files = mapping::map_test_to_source(\u0026f.spec_file);\n            let test_file = mapping::strip_line_number(\u0026f.spec_file).to_string();\n\n            FixFailure {\n                test_file,\n                source_files,\n                failure_text: f.failure_text.clone(),\n                language,\n            }\n        })\n        .collect()\n}\n\n/// Output the fix report (markdown or JSON)\nfn output_report(report: \u0026FixReport, json: bool) -\u003e Result\u003c()\u003e {\n    if json {\n        println!(\"{}\", serde_json::to_string_pretty(report)?);\n    } else {\n        print!(\"{}\", format_markdown(report));\n    }\n    Ok(())\n}\n\n/// Format report as markdown (pure function, testable)\npub fn format_markdown(report: \u0026FixReport) -\u003e String {\n    let mut out = String::new();\n\n    out.push_str(\u0026format!(\"# Fix Report: {}\\n\\n\", report.repository));\n\n    if let Some(pr) = report.pr_number {\n        out.push_str(\u0026format!(\"**PR:** #{}\\n\", pr));\n    }\n    out.push_str(\u0026format!(\"**Run:** {}\\n\", report.run_id));\n    out.push_str(\u0026format!(\"**Failures:** {}\\n\\n\", report.failures.len()));\n\n    // Failures\n    for failure in \u0026report.failures {\n        out.push_str(\u0026format!(\"## {}\\n\\n\", failure.test_file));\n        out.push_str(\u0026format!(\"**Language:** {}\\n\", failure.language));\n\n        if !failure.source_files.is_empty() {\n            out.push_str(\"**Source files:**\\n\");\n            for sf in \u0026failure.source_files {\n                out.push_str(\u0026format!(\"- `{}`\\n\", sf));\n            }\n        }\n\n        out.push_str(\"\\n```\\n\");\n        out.push_str(\u0026failure.failure_text);\n        out.push_str(\"\\n```\\n\\n\");\n    }\n\n    // Rerun commands\n    out.push_str(\u0026format_rerun_commands(\u0026report.failures));\n\n    // File lists\n    if !report.source_files.is_empty() {\n        out.push_str(\"## Source Files to Investigate\\n\\n\");\n        for f in \u0026report.source_files {\n            out.push_str(\u0026format!(\"- `{}`\\n\", f));\n        }\n        out.push('\\n');\n    }\n\n    out\n}\n\n/// Format rerun commands section (pure function, testable)\npub fn format_rerun_commands(failures: \u0026[FixFailure]) -\u003e String {\n    if failures.is_empty() {\n        return String::new();\n    }\n\n    let mut out = String::from(\"## Rerun Commands\\n\\n```bash\\n\");\n\n    for failure in failures {\n        match failure.language.as_str() {\n            \"ruby\" =\u003e out.push_str(\u0026format!(\"bundle exec rspec {}\\n\", failure.test_file)),\n            \"rust\" =\u003e out.push_str(\u0026format!(\"cargo test {}\\n\", failure.test_file)),\n            \"python\" =\u003e out.push_str(\u0026format!(\"pytest {}\\n\", failure.test_file)),\n            \"javascript\" =\u003e out.push_str(\u0026format!(\"npx jest {}\\n\", failure.test_file)),\n            _ =\u003e out.push_str(\u0026format!(\"# run {}\\n\", failure.test_file)),\n        }\n    }\n\n    out.push_str(\"```\\n\\n\");\n    out\n}\n","traces":[{"line":54,"address":[],"length":0,"stats":{"Line":10}},{"line":58,"address":[],"length":0,"stats":{"Line":30}},{"line":59,"address":[],"length":0,"stats":{"Line":20}},{"line":60,"address":[],"length":0,"stats":{"Line":20}},{"line":63,"address":[],"length":0,"stats":{"Line":25}},{"line":64,"address":[],"length":0,"stats":{"Line":1}},{"line":65,"address":[],"length":0,"stats":{"Line":15}},{"line":66,"address":[],"length":0,"stats":{"Line":36}},{"line":67,"address":[],"length":0,"stats":{"Line":18}},{"line":68,"address":[],"length":0,"stats":{"Line":24}},{"line":69,"address":[],"length":0,"stats":{"Line":6}},{"line":70,"address":[],"length":0,"stats":{"Line":6}},{"line":71,"address":[],"length":0,"stats":{"Line":10}},{"line":72,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":6}},{"line":77,"address":[],"length":0,"stats":{"Line":6}},{"line":78,"address":[],"length":0,"stats":{"Line":1}},{"line":81,"address":[],"length":0,"stats":{"Line":18}},{"line":83,"address":[],"length":0,"stats":{"Line":9}},{"line":84,"address":[],"length":0,"stats":{"Line":12}},{"line":85,"address":[],"length":0,"stats":{"Line":3}},{"line":87,"address":[],"length":0,"stats":{"Line":3}},{"line":88,"address":[],"length":0,"stats":{"Line":2}},{"line":89,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":42}},{"line":96,"address":[],"length":0,"stats":{"Line":14}},{"line":97,"address":[],"length":0,"stats":{"Line":1}},{"line":101,"address":[],"length":0,"stats":{"Line":18}},{"line":103,"address":[],"length":0,"stats":{"Line":20}},{"line":106,"address":[],"length":0,"stats":{"Line":12}},{"line":107,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":10}},{"line":112,"address":[],"length":0,"stats":{"Line":20}},{"line":113,"address":[],"length":0,"stats":{"Line":10}},{"line":114,"address":[],"length":0,"stats":{"Line":30}},{"line":115,"address":[],"length":0,"stats":{"Line":8}},{"line":116,"address":[],"length":0,"stats":{"Line":16}},{"line":117,"address":[],"length":0,"stats":{"Line":8}},{"line":119,"address":[],"length":0,"stats":{"Line":2}},{"line":120,"address":[],"length":0,"stats":{"Line":1}},{"line":125,"address":[],"length":0,"stats":{"Line":10}},{"line":126,"address":[],"length":0,"stats":{"Line":2}},{"line":129,"address":[],"length":0,"stats":{"Line":9}},{"line":130,"address":[],"length":0,"stats":{"Line":21}},{"line":131,"address":[],"length":0,"stats":{"Line":9}},{"line":133,"address":[],"length":0,"stats":{"Line":9}},{"line":138,"address":[],"length":0,"stats":{"Line":3}},{"line":139,"address":[],"length":0,"stats":{"Line":6}},{"line":140,"address":[],"length":0,"stats":{"Line":6}},{"line":141,"address":[],"length":0,"stats":{"Line":6}},{"line":142,"address":[],"length":0,"stats":{"Line":6}},{"line":143,"address":[],"length":0,"stats":{"Line":3}},{"line":144,"address":[],"length":0,"stats":{"Line":3}},{"line":149,"address":[],"length":0,"stats":{"Line":7}},{"line":150,"address":[],"length":0,"stats":{"Line":7}},{"line":152,"address":[],"length":0,"stats":{"Line":15}},{"line":153,"address":[],"length":0,"stats":{"Line":24}},{"line":154,"address":[],"length":0,"stats":{"Line":24}},{"line":155,"address":[],"length":0,"stats":{"Line":24}},{"line":157,"address":[],"length":0,"stats":{"Line":8}},{"line":158,"address":[],"length":0,"stats":{"Line":16}},{"line":159,"address":[],"length":0,"stats":{"Line":16}},{"line":160,"address":[],"length":0,"stats":{"Line":16}},{"line":161,"address":[],"length":0,"stats":{"Line":8}},{"line":168,"address":[],"length":0,"stats":{"Line":2}},{"line":169,"address":[],"length":0,"stats":{"Line":2}},{"line":170,"address":[],"length":0,"stats":{"Line":4}},{"line":172,"address":[],"length":0,"stats":{"Line":3}},{"line":174,"address":[],"length":0,"stats":{"Line":2}},{"line":178,"address":[],"length":0,"stats":{"Line":5}},{"line":179,"address":[],"length":0,"stats":{"Line":10}},{"line":181,"address":[],"length":0,"stats":{"Line":15}},{"line":183,"address":[],"length":0,"stats":{"Line":9}},{"line":184,"address":[],"length":0,"stats":{"Line":6}},{"line":186,"address":[],"length":0,"stats":{"Line":15}},{"line":187,"address":[],"length":0,"stats":{"Line":25}},{"line":190,"address":[],"length":0,"stats":{"Line":13}},{"line":191,"address":[],"length":0,"stats":{"Line":12}},{"line":192,"address":[],"length":0,"stats":{"Line":12}},{"line":194,"address":[],"length":0,"stats":{"Line":4}},{"line":195,"address":[],"length":0,"stats":{"Line":9}},{"line":196,"address":[],"length":0,"stats":{"Line":12}},{"line":197,"address":[],"length":0,"stats":{"Line":9}},{"line":201,"address":[],"length":0,"stats":{"Line":12}},{"line":202,"address":[],"length":0,"stats":{"Line":12}},{"line":203,"address":[],"length":0,"stats":{"Line":12}},{"line":207,"address":[],"length":0,"stats":{"Line":15}},{"line":210,"address":[],"length":0,"stats":{"Line":5}},{"line":211,"address":[],"length":0,"stats":{"Line":6}},{"line":212,"address":[],"length":0,"stats":{"Line":11}},{"line":213,"address":[],"length":0,"stats":{"Line":9}},{"line":215,"address":[],"length":0,"stats":{"Line":4}},{"line":218,"address":[],"length":0,"stats":{"Line":5}},{"line":222,"address":[],"length":0,"stats":{"Line":12}},{"line":223,"address":[],"length":0,"stats":{"Line":24}},{"line":224,"address":[],"length":0,"stats":{"Line":3}},{"line":227,"address":[],"length":0,"stats":{"Line":18}},{"line":229,"address":[],"length":0,"stats":{"Line":31}},{"line":230,"address":[],"length":0,"stats":{"Line":11}},{"line":231,"address":[],"length":0,"stats":{"Line":23}},{"line":232,"address":[],"length":0,"stats":{"Line":13}},{"line":233,"address":[],"length":0,"stats":{"Line":8}},{"line":234,"address":[],"length":0,"stats":{"Line":10}},{"line":235,"address":[],"length":0,"stats":{"Line":6}},{"line":239,"address":[],"length":0,"stats":{"Line":27}},{"line":240,"address":[],"length":0,"stats":{"Line":9}}],"covered":106,"coverable":106},{"path":["/","Users","chi","Projects","hu","src","gh","fix","tests.rs"],"content":"use super::*;\nuse crate::gh::client::GithubApi;\nuse crate::gh::types::{CiStatus, PullRequest};\n\n// Mock implementation\nstruct MockGithubApi {\n    branch: String,\n    run_id: Option\u003cu64\u003e,\n    failed_jobs: Vec\u003c(u64, String)\u003e,\n    logs: String,\n    pr_for_branch: Option\u003cu64\u003e,\n}\n\nimpl GithubApi for MockGithubApi {\n    async fn list_user_prs(\u0026self) -\u003e Result\u003cVec\u003cPullRequest\u003e\u003e {\n        Ok(vec![])\n    }\n\n    async fn get_ci_status(\u0026self, _owner: \u0026str, _repo: \u0026str, _pr: u64) -\u003e Result\u003cCiStatus\u003e {\n        Ok(CiStatus::Unknown)\n    }\n\n    async fn get_pr_branch(\u0026self, _owner: \u0026str, _repo: \u0026str, _pr: u64) -\u003e Result\u003cString\u003e {\n        Ok(self.branch.clone())\n    }\n\n    async fn get_latest_failed_run_for_branch(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _branch: \u0026str,\n    ) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n        Ok(self.run_id)\n    }\n\n    async fn get_failed_jobs(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _run_id: u64,\n    ) -\u003e Result\u003cVec\u003c(u64, String)\u003e\u003e {\n        Ok(self.failed_jobs.clone())\n    }\n\n    async fn get_job_logs(\u0026self, _owner: \u0026str, _repo: \u0026str, _job_id: u64) -\u003e Result\u003cString\u003e {\n        Ok(self.logs.clone())\n    }\n\n    async fn find_pr_for_branch(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _branch: \u0026str,\n    ) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n        Ok(self.pr_for_branch)\n    }\n\n    async fn list_workflow_runs(\n        \u0026self,\n        _query: \u0026crate::gh::types::RunsQuery\u003c'_\u003e,\n    ) -\u003e Result\u003cVec\u003ccrate::gh::types::WorkflowRun\u003e\u003e {\n        Ok(vec![])\n    }\n\n    async fn search_prs_by_title(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _query: \u0026str,\n    ) -\u003e Result\u003cVec\u003cPullRequest\u003e\u003e {\n        Ok(vec![])\n    }\n}\n\nfn query(owner: \u0026str, repo: \u0026str) -\u003e FixQuery {\n    FixQuery {\n        owner: owner.to_string(),\n        repo: repo.to_string(),\n        pr: None,\n        run: None,\n        branch: None,\n    }\n}\n\n// build_fix_report tests\n#[tokio::test]\nasync fn build_fix_report_no_runs() {\n    let mock = MockGithubApi {\n        branch: \"main\".to_string(),\n        run_id: None,\n        failed_jobs: vec![],\n        logs: String::new(),\n        pr_for_branch: None,\n    };\n    let mut q = query(\"owner\", \"repo\");\n    q.pr = Some(42);\n    let result = build_fix_report(\u0026mock, \u0026q).await;\n    assert!(result.unwrap().is_none());\n}\n\n#[tokio::test]\nasync fn build_fix_report_no_failed_jobs() {\n    let mock = MockGithubApi {\n        branch: \"main\".to_string(),\n        run_id: Some(100),\n        failed_jobs: vec![],\n        logs: String::new(),\n        pr_for_branch: None,\n    };\n    let mut q = query(\"owner\", \"repo\");\n    q.pr = Some(42);\n    let result = build_fix_report(\u0026mock, \u0026q).await;\n    assert!(result.unwrap().is_none());\n}\n\n#[tokio::test]\nasync fn build_fix_report_no_test_jobs() {\n    let mock = MockGithubApi {\n        branch: \"main\".to_string(),\n        run_id: Some(100),\n        failed_jobs: vec![(1, \"build\".to_string()), (2, \"deploy\".to_string())],\n        logs: String::new(),\n        pr_for_branch: None,\n    };\n    let mut q = query(\"owner\", \"repo\");\n    q.pr = Some(42);\n    let result = build_fix_report(\u0026mock, \u0026q).await;\n    assert!(result.unwrap().is_none());\n}\n\n#[tokio::test]\nasync fn build_fix_report_with_failures() {\n    let mock = MockGithubApi {\n        branch: \"feature\".to_string(),\n        run_id: Some(100),\n        failed_jobs: vec![(1, \"rspec-tests\".to_string())],\n        logs: r#\"\nFailures:\n\n  1) User model validates name\n     Failure/Error: expect(user).to be_valid\n       expected true, got false\n\nFailed examples:\n\nrspec ./spec/models/user_spec.rb:10 # User model validates name\n\"#\n        .to_string(),\n        pr_for_branch: Some(42),\n    };\n\n    let mut q = query(\"owner\", \"repo\");\n    q.pr = Some(42);\n    let result = build_fix_report(\u0026mock, \u0026q).await.unwrap();\n\n    assert!(result.is_some());\n    let report = result.unwrap();\n    assert_eq!(report.repository, \"owner/repo\");\n    assert_eq!(report.pr_number, Some(42));\n    assert_eq!(report.run_id, 100);\n    assert_eq!(report.failures.len(), 1);\n    assert_eq!(report.failures[0].test_file, \"./spec/models/user_spec.rb\");\n    assert_eq!(report.failures[0].language, \"ruby\");\n    assert!(!report.failures[0].source_files.is_empty());\n}\n\n#[tokio::test]\nasync fn build_fix_report_with_run_id() {\n    let mock = MockGithubApi {\n        branch: \"main\".to_string(),\n        run_id: Some(200),\n        failed_jobs: vec![(1, \"test-suite\".to_string())],\n        logs: r#\"\nFailures:\n\n  1) Test fails\n     Failure/Error: fail\n       err\n\nFailed examples:\n\nrspec ./spec/test_spec.rb:5 # Test fails\n\"#\n        .to_string(),\n        pr_for_branch: None,\n    };\n\n    let mut q = query(\"owner\", \"repo\");\n    q.run = Some(200);\n    let result = build_fix_report(\u0026mock, \u0026q).await.unwrap();\n\n    assert!(result.is_some());\n    let report = result.unwrap();\n    assert_eq!(report.run_id, 200);\n    assert!(report.pr_number.is_none());\n}\n\n#[tokio::test]\nasync fn build_fix_report_with_branch() {\n    let mock = MockGithubApi {\n        branch: \"feature-x\".to_string(),\n        run_id: Some(300),\n        failed_jobs: vec![(1, \"rspec\".to_string())],\n        logs: r#\"\nFailures:\n\n  1) Fail\n     Failure/Error: x\n       y\n\nFailed examples:\n\nrspec ./spec/x_spec.rb:1 # Fail\n\"#\n        .to_string(),\n        pr_for_branch: Some(99),\n    };\n\n    let mut q = query(\"o\", \"r\");\n    q.branch = Some(\"feature-x\".to_string());\n    let result = build_fix_report(\u0026mock, \u0026q).await.unwrap();\n\n    assert!(result.is_some());\n    let report = result.unwrap();\n    assert_eq!(report.pr_number, Some(99));\n}\n\n#[tokio::test]\nasync fn build_fix_report_empty_logs() {\n    let mock = MockGithubApi {\n        branch: \"main\".to_string(),\n        run_id: Some(100),\n        failed_jobs: vec![(1, \"test\".to_string())],\n        logs: String::new(),\n        pr_for_branch: None,\n    };\n    let mut q = query(\"o\", \"r\");\n    q.pr = Some(1);\n    let result = build_fix_report(\u0026mock, \u0026q).await.unwrap();\n    assert!(result.is_none());\n}\n\n// FixQuery tests\n#[test]\nfn fix_query_debug() {\n    let q = query(\"owner\", \"repo\");\n    let d = format!(\"{:?}\", q);\n    assert!(d.contains(\"FixQuery\"));\n}\n\n#[test]\nfn fix_query_clone() {\n    let q = query(\"owner\", \"repo\");\n    let c = q.clone();\n    assert_eq!(c.owner, q.owner);\n    assert_eq!(c.repo, q.repo);\n}\n\n// Mock that errors on get_job_logs\nstruct MockGithubApiWithLogError {\n    branch: String,\n    run_id: Option\u003cu64\u003e,\n    failed_jobs: Vec\u003c(u64, String)\u003e,\n    pr_for_branch: Option\u003cu64\u003e,\n}\n\nimpl GithubApi for MockGithubApiWithLogError {\n    async fn list_user_prs(\u0026self) -\u003e Result\u003cVec\u003cPullRequest\u003e\u003e {\n        Ok(vec![])\n    }\n\n    async fn get_ci_status(\u0026self, _owner: \u0026str, _repo: \u0026str, _pr: u64) -\u003e Result\u003cCiStatus\u003e {\n        Ok(CiStatus::Unknown)\n    }\n\n    async fn get_pr_branch(\u0026self, _owner: \u0026str, _repo: \u0026str, _pr: u64) -\u003e Result\u003cString\u003e {\n        Ok(self.branch.clone())\n    }\n\n    async fn get_latest_failed_run_for_branch(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _branch: \u0026str,\n    ) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n        Ok(self.run_id)\n    }\n\n    async fn get_failed_jobs(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _run_id: u64,\n    ) -\u003e Result\u003cVec\u003c(u64, String)\u003e\u003e {\n        Ok(self.failed_jobs.clone())\n    }\n\n    async fn get_job_logs(\u0026self, _owner: \u0026str, _repo: \u0026str, _job_id: u64) -\u003e Result\u003cString\u003e {\n        Err(anyhow::anyhow!(\"Failed to fetch logs\"))\n    }\n\n    async fn find_pr_for_branch(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _branch: \u0026str,\n    ) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n        Ok(self.pr_for_branch)\n    }\n\n    async fn list_workflow_runs(\n        \u0026self,\n        _query: \u0026crate::gh::types::RunsQuery\u003c'_\u003e,\n    ) -\u003e Result\u003cVec\u003ccrate::gh::types::WorkflowRun\u003e\u003e {\n        Ok(vec![])\n    }\n\n    async fn search_prs_by_title(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _query: \u0026str,\n    ) -\u003e Result\u003cVec\u003cPullRequest\u003e\u003e {\n        Ok(vec![])\n    }\n}\n\n#[tokio::test]\nasync fn build_fix_report_handles_log_error() {\n    let mock = MockGithubApiWithLogError {\n        branch: \"main\".to_string(),\n        run_id: Some(100),\n        failed_jobs: vec![(1, \"rspec-tests\".to_string())],\n        pr_for_branch: None,\n    };\n    let mut q = query(\"o\", \"r\");\n    q.pr = Some(1);\n    let result = build_fix_report(\u0026mock, \u0026q).await.unwrap();\n    // Logs failed, so no failures extracted -\u003e None\n    assert!(result.is_none());\n}\n\n#[tokio::test]\nasync fn build_fix_report_uses_current_branch() {\n    // No pr, no run, no branch -\u003e uses get_current_branch()\n    let mock = MockGithubApi {\n        branch: \"main\".to_string(),\n        run_id: None,\n        failed_jobs: vec![],\n        logs: String::new(),\n        pr_for_branch: None,\n    };\n    let q = query(\"o\", \"r\"); // no pr, run, or branch set\n    let result = build_fix_report(\u0026mock, \u0026q).await.unwrap();\n    assert!(result.is_none());\n}\n\n#[tokio::test]\nasync fn build_fix_report_branch_no_runs() {\n    let mock = MockGithubApi {\n        branch: \"main\".to_string(),\n        run_id: None,\n        failed_jobs: vec![],\n        logs: String::new(),\n        pr_for_branch: None,\n    };\n    let mut q = query(\"o\", \"r\");\n    q.branch = Some(\"feature\".to_string());\n    let result = build_fix_report(\u0026mock, \u0026q).await.unwrap();\n    assert!(result.is_none());\n}\n\n// enrich_failures tests\n#[test]\nfn enrich_failures_ruby() {\n    let failures = vec![TestFailure {\n        spec_file: \"./spec/models/user_spec.rb:10\".to_string(),\n        failure_text: \"expected true\".to_string(),\n    }];\n    let enriched = enrich_failures(\u0026failures);\n    assert_eq!(enriched.len(), 1);\n    assert_eq!(enriched[0].language, \"ruby\");\n    assert_eq!(enriched[0].test_file, \"./spec/models/user_spec.rb\");\n    assert!(enriched[0]\n        .source_files\n        .contains(\u0026\"app/models/user.rb\".to_string()));\n}\n\n#[test]\nfn enrich_failures_mixed_languages() {\n    let failures = vec![\n        TestFailure {\n            spec_file: \"spec/user_spec.rb:5\".to_string(),\n            failure_text: \"ruby error\".to_string(),\n        },\n        TestFailure {\n            spec_file: \"tests/test_sync.rs\".to_string(),\n            failure_text: \"rust error\".to_string(),\n        },\n        TestFailure {\n            spec_file: \"Button.test.tsx\".to_string(),\n            failure_text: \"js error\".to_string(),\n        },\n    ];\n    let enriched = enrich_failures(\u0026failures);\n    assert_eq!(enriched.len(), 3);\n    assert_eq!(enriched[0].language, \"ruby\");\n    assert_eq!(enriched[1].language, \"rust\");\n    assert_eq!(enriched[2].language, \"javascript\");\n}\n\n#[test]\nfn enrich_failures_empty() {\n    let enriched = enrich_failures(\u0026[]);\n    assert!(enriched.is_empty());\n}\n\n#[test]\nfn enrich_failures_unknown_language() {\n    let failures = vec![TestFailure {\n        spec_file: \"README.md\".to_string(),\n        failure_text: \"error\".to_string(),\n    }];\n    let enriched = enrich_failures(\u0026failures);\n    assert_eq!(enriched[0].language, \"unknown\");\n    assert!(enriched[0].source_files.is_empty());\n}\n\n// format_markdown tests\n#[test]\nfn format_markdown_basic() {\n    let report = FixReport {\n        repository: \"owner/repo\".to_string(),\n        pr_number: Some(42),\n        run_id: 100,\n        failures: vec![FixFailure {\n            test_file: \"spec/models/user_spec.rb\".to_string(),\n            source_files: vec![\"app/models/user.rb\".to_string()],\n            failure_text: \"expected true\".to_string(),\n            language: \"ruby\".to_string(),\n        }],\n        test_files: vec![\"spec/models/user_spec.rb\".to_string()],\n        source_files: vec![\"app/models/user.rb\".to_string()],\n    };\n\n    let md = format_markdown(\u0026report);\n    assert!(md.contains(\"# Fix Report: owner/repo\"));\n    assert!(md.contains(\"**PR:** #42\"));\n    assert!(md.contains(\"**Run:** 100\"));\n    assert!(md.contains(\"## spec/models/user_spec.rb\"));\n    assert!(md.contains(\"**Language:** ruby\"));\n    assert!(md.contains(\"`app/models/user.rb`\"));\n    assert!(md.contains(\"expected true\"));\n    assert!(md.contains(\"bundle exec rspec\"));\n}\n\n#[test]\nfn format_markdown_no_pr() {\n    let report = FixReport {\n        repository: \"o/r\".to_string(),\n        pr_number: None,\n        run_id: 1,\n        failures: vec![],\n        test_files: vec![],\n        source_files: vec![],\n    };\n\n    let md = format_markdown(\u0026report);\n    assert!(!md.contains(\"**PR:**\"));\n    assert!(md.contains(\"**Run:** 1\"));\n}\n\n#[test]\nfn format_markdown_multiple_failures() {\n    let report = FixReport {\n        repository: \"o/r\".to_string(),\n        pr_number: Some(1),\n        run_id: 1,\n        failures: vec![\n            FixFailure {\n                test_file: \"spec/a_spec.rb\".to_string(),\n                source_files: vec![\"app/a.rb\".to_string()],\n                failure_text: \"err1\".to_string(),\n                language: \"ruby\".to_string(),\n            },\n            FixFailure {\n                test_file: \"tests/test_b.rs\".to_string(),\n                source_files: vec![\"src/b.rs\".to_string()],\n                failure_text: \"err2\".to_string(),\n                language: \"rust\".to_string(),\n            },\n        ],\n        test_files: vec![\"spec/a_spec.rb\".to_string(), \"tests/test_b.rs\".to_string()],\n        source_files: vec![\"app/a.rb\".to_string(), \"src/b.rs\".to_string()],\n    };\n\n    let md = format_markdown(\u0026report);\n    assert!(md.contains(\"## spec/a_spec.rb\"));\n    assert!(md.contains(\"## tests/test_b.rs\"));\n    assert!(md.contains(\"bundle exec rspec\"));\n    assert!(md.contains(\"cargo test\"));\n}\n\n// format_rerun_commands tests\n#[test]\nfn format_rerun_commands_ruby() {\n    let failures = vec![FixFailure {\n        test_file: \"spec/user_spec.rb\".to_string(),\n        source_files: vec![],\n        failure_text: String::new(),\n        language: \"ruby\".to_string(),\n    }];\n    let cmds = format_rerun_commands(\u0026failures);\n    assert!(cmds.contains(\"bundle exec rspec spec/user_spec.rb\"));\n}\n\n#[test]\nfn format_rerun_commands_rust() {\n    let failures = vec![FixFailure {\n        test_file: \"tests/test_sync.rs\".to_string(),\n        source_files: vec![],\n        failure_text: String::new(),\n        language: \"rust\".to_string(),\n    }];\n    let cmds = format_rerun_commands(\u0026failures);\n    assert!(cmds.contains(\"cargo test tests/test_sync.rs\"));\n}\n\n#[test]\nfn format_rerun_commands_python() {\n    let failures = vec![FixFailure {\n        test_file: \"tests/test_utils.py\".to_string(),\n        source_files: vec![],\n        failure_text: String::new(),\n        language: \"python\".to_string(),\n    }];\n    let cmds = format_rerun_commands(\u0026failures);\n    assert!(cmds.contains(\"pytest tests/test_utils.py\"));\n}\n\n#[test]\nfn format_rerun_commands_javascript() {\n    let failures = vec![FixFailure {\n        test_file: \"Button.test.tsx\".to_string(),\n        source_files: vec![],\n        failure_text: String::new(),\n        language: \"javascript\".to_string(),\n    }];\n    let cmds = format_rerun_commands(\u0026failures);\n    assert!(cmds.contains(\"npx jest Button.test.tsx\"));\n}\n\n#[test]\nfn format_rerun_commands_unknown() {\n    let failures = vec![FixFailure {\n        test_file: \"foo.go\".to_string(),\n        source_files: vec![],\n        failure_text: String::new(),\n        language: \"unknown\".to_string(),\n    }];\n    let cmds = format_rerun_commands(\u0026failures);\n    assert!(cmds.contains(\"# run foo.go\"));\n}\n\n#[test]\nfn format_rerun_commands_empty() {\n    let cmds = format_rerun_commands(\u0026[]);\n    assert!(cmds.is_empty());\n}\n\n#[test]\nfn format_rerun_commands_mixed() {\n    let failures = vec![\n        FixFailure {\n            test_file: \"spec/a_spec.rb\".to_string(),\n            source_files: vec![],\n            failure_text: String::new(),\n            language: \"ruby\".to_string(),\n        },\n        FixFailure {\n            test_file: \"app.test.js\".to_string(),\n            source_files: vec![],\n            failure_text: String::new(),\n            language: \"javascript\".to_string(),\n        },\n    ];\n    let cmds = format_rerun_commands(\u0026failures);\n    assert!(cmds.contains(\"bundle exec rspec\"));\n    assert!(cmds.contains(\"npx jest\"));\n}\n\n// JSON output test\n#[test]\nfn fix_report_json_output() {\n    let report = FixReport {\n        repository: \"owner/repo\".to_string(),\n        pr_number: Some(42),\n        run_id: 100,\n        failures: vec![FixFailure {\n            test_file: \"spec/user_spec.rb\".to_string(),\n            source_files: vec![\"app/user.rb\".to_string()],\n            failure_text: \"error\".to_string(),\n            language: \"ruby\".to_string(),\n        }],\n        test_files: vec![\"spec/user_spec.rb\".to_string()],\n        source_files: vec![\"app/user.rb\".to_string()],\n    };\n\n    let json = serde_json::to_string_pretty(\u0026report).unwrap();\n    assert!(json.contains(\"\\\"repository\\\": \\\"owner/repo\\\"\"));\n    assert!(json.contains(\"\\\"pr_number\\\": 42\"));\n    assert!(json.contains(\"\\\"run_id\\\": 100\"));\n    assert!(json.contains(\"\\\"test_file\\\": \\\"spec/user_spec.rb\\\"\"));\n    assert!(json.contains(\"\\\"language\\\": \\\"ruby\\\"\"));\n}\n\n// output_report tests\n#[test]\nfn output_report_json() {\n    let report = FixReport {\n        repository: \"o/r\".to_string(),\n        pr_number: None,\n        run_id: 1,\n        failures: vec![],\n        test_files: vec![],\n        source_files: vec![],\n    };\n    let result = output_report(\u0026report, true);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_report_markdown() {\n    let report = FixReport {\n        repository: \"o/r\".to_string(),\n        pr_number: None,\n        run_id: 1,\n        failures: vec![],\n        test_files: vec![],\n        source_files: vec![],\n    };\n    let result = output_report(\u0026report, false);\n    assert!(result.is_ok());\n}\n\n// format_markdown edge cases\n#[test]\nfn format_markdown_no_source_files() {\n    let report = FixReport {\n        repository: \"o/r\".to_string(),\n        pr_number: None,\n        run_id: 1,\n        failures: vec![FixFailure {\n            test_file: \"README.md\".to_string(),\n            source_files: vec![],\n            failure_text: \"err\".to_string(),\n            language: \"unknown\".to_string(),\n        }],\n        test_files: vec![\"README.md\".to_string()],\n        source_files: vec![],\n    };\n\n    let md = format_markdown(\u0026report);\n    assert!(!md.contains(\"Source Files to Investigate\"));\n    assert!(!md.contains(\"**Source files:**\"));\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":10}},{"line":24,"address":[],"length":0,"stats":{"Line":5}},{"line":27,"address":[],"length":0,"stats":{"Line":8}},{"line":33,"address":[],"length":0,"stats":{"Line":8}},{"line":36,"address":[],"length":0,"stats":{"Line":6}},{"line":42,"address":[],"length":0,"stats":{"Line":6}},{"line":45,"address":[],"length":0,"stats":{"Line":8}},{"line":46,"address":[],"length":0,"stats":{"Line":4}},{"line":49,"address":[],"length":0,"stats":{"Line":3}},{"line":55,"address":[],"length":0,"stats":{"Line":3}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":12}},{"line":77,"address":[],"length":0,"stats":{"Line":36}},{"line":78,"address":[],"length":0,"stats":{"Line":36}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":2}},{"line":277,"address":[],"length":0,"stats":{"Line":1}},{"line":280,"address":[],"length":0,"stats":{"Line":1}},{"line":286,"address":[],"length":0,"stats":{"Line":1}},{"line":289,"address":[],"length":0,"stats":{"Line":1}},{"line":295,"address":[],"length":0,"stats":{"Line":1}},{"line":298,"address":[],"length":0,"stats":{"Line":2}},{"line":299,"address":[],"length":0,"stats":{"Line":1}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}}],"covered":21,"coverable":39},{"path":["/","Users","chi","Projects","hu","src","gh","helpers.rs"],"content":"use anyhow::{Context, Result};\n\n/// Parse owner/repo from command line argument\npub fn parse_owner_repo(repo: \u0026str) -\u003e Result\u003c(String, String)\u003e {\n    let parts: Vec\u003c\u0026str\u003e = repo.split('/').collect();\n    if parts.len() != 2 {\n        anyhow::bail!(\"Invalid repo format. Expected owner/repo, got: {}\", repo);\n    }\n    Ok((parts[0].to_string(), parts[1].to_string()))\n}\n\n/// Get owner/repo from git remote\npub fn get_current_repo() -\u003e Result\u003c(String, String)\u003e {\n    let output = run_git_command(\u0026[\"remote\", \"get-url\", \"origin\"])?;\n    parse_github_url(output.trim())\n}\n\n/// Run a git command and return stdout\npub fn run_git_command(args: \u0026[\u0026str]) -\u003e Result\u003cString\u003e {\n    let output = std::process::Command::new(\"git\")\n        .args(args)\n        .output()\n        .context(\"Failed to run git command\")?;\n\n    Ok(String::from_utf8_lossy(\u0026output.stdout).to_string())\n}\n\n/// Parse GitHub URL to extract owner/repo\npub fn parse_github_url(url: \u0026str) -\u003e Result\u003c(String, String)\u003e {\n    let url = url.trim_end_matches(\".git\").trim_end_matches('/');\n\n    if url.contains(\"github.com:\") {\n        // SSH format: git@github.com:owner/repo.git\n        let parts: Vec\u003c\u0026str\u003e = url.split(':').collect();\n        if let Some(path) = parts.last() {\n            let segments: Vec\u003c\u0026str\u003e = path.split('/').collect();\n            if segments.len() \u003e= 2 {\n                return Ok((\n                    segments[segments.len() - 2].to_string(),\n                    segments[segments.len() - 1].to_string(),\n                ));\n            }\n        }\n    } else if url.contains(\"github.com/\") {\n        // HTTPS format: https://github.com/owner/repo.git\n        let parts: Vec\u003c\u0026str\u003e = url.split(\"github.com/\").collect();\n        if let Some(path) = parts.last() {\n            let segments: Vec\u003c\u0026str\u003e = path.split('/').collect();\n            if segments.len() \u003e= 2 {\n                return Ok((segments[0].to_string(), segments[1].to_string()));\n            }\n        }\n    }\n\n    anyhow::bail!(\"Could not parse GitHub URL: {}\", url)\n}\n\n/// Check if a job name is test-related\npub fn is_test_job(name: \u0026str) -\u003e bool {\n    let name_lower = name.to_lowercase();\n    name_lower.contains(\"rspec\") || name_lower.contains(\"test\") || name_lower.contains(\"spec\")\n}\n\n/// Get current git branch name\npub fn get_current_branch() -\u003e Result\u003cString\u003e {\n    let branch = run_git_command(\u0026[\"branch\", \"--show-current\"])?;\n    let branch = branch.trim().to_string();\n    if branch.is_empty() {\n        anyhow::bail!(\"Not on a branch. Use --pr or --branch to specify.\");\n    }\n    Ok(branch)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // parse_github_url tests\n    #[test]\n    fn parse_ssh_url() {\n        let (owner, repo) = parse_github_url(\"git@github.com:owner/repo.git\").unwrap();\n        assert_eq!(owner, \"owner\");\n        assert_eq!(repo, \"repo\");\n    }\n\n    #[test]\n    fn parse_https_url() {\n        let (owner, repo) = parse_github_url(\"https://github.com/owner/repo.git\").unwrap();\n        assert_eq!(owner, \"owner\");\n        assert_eq!(repo, \"repo\");\n    }\n\n    #[test]\n    fn parse_https_url_no_git_suffix() {\n        let (owner, repo) = parse_github_url(\"https://github.com/owner/repo\").unwrap();\n        assert_eq!(owner, \"owner\");\n        assert_eq!(repo, \"repo\");\n    }\n\n    #[test]\n    fn parse_ssh_url_no_git_suffix() {\n        let (owner, repo) = parse_github_url(\"git@github.com:owner/repo\").unwrap();\n        assert_eq!(owner, \"owner\");\n        assert_eq!(repo, \"repo\");\n    }\n\n    #[test]\n    fn parse_https_url_trailing_slash() {\n        let (owner, repo) = parse_github_url(\"https://github.com/owner/repo/\").unwrap();\n        assert_eq!(owner, \"owner\");\n        assert_eq!(repo, \"repo\");\n    }\n\n    #[test]\n    fn parse_github_url_invalid() {\n        assert!(parse_github_url(\"not-a-github-url\").is_err());\n        assert!(parse_github_url(\"https://gitlab.com/owner/repo\").is_err());\n        assert!(parse_github_url(\"\").is_err());\n    }\n\n    #[test]\n    fn parse_github_url_ssh_with_org() {\n        let (owner, repo) = parse_github_url(\"git@github.com:my-org/my-repo.git\").unwrap();\n        assert_eq!(owner, \"my-org\");\n        assert_eq!(repo, \"my-repo\");\n    }\n\n    #[test]\n    fn parse_github_url_empty_string() {\n        assert!(parse_github_url(\"\").is_err());\n    }\n\n    #[test]\n    fn parse_github_url_missing_repo() {\n        assert!(parse_github_url(\"git@github.com:owner\").is_err());\n    }\n\n    // parse_owner_repo tests\n    #[test]\n    fn parse_owner_repo_valid() {\n        let (owner, repo) = parse_owner_repo(\"owner/repo\").unwrap();\n        assert_eq!(owner, \"owner\");\n        assert_eq!(repo, \"repo\");\n    }\n\n    #[test]\n    fn parse_owner_repo_with_dashes() {\n        let (owner, repo) = parse_owner_repo(\"my-org/my-repo\").unwrap();\n        assert_eq!(owner, \"my-org\");\n        assert_eq!(repo, \"my-repo\");\n    }\n\n    #[test]\n    fn parse_owner_repo_invalid_no_slash() {\n        assert!(parse_owner_repo(\"noslash\").is_err());\n    }\n\n    #[test]\n    fn parse_owner_repo_invalid_too_many_slashes() {\n        assert!(parse_owner_repo(\"a/b/c\").is_err());\n    }\n\n    #[test]\n    fn parse_owner_repo_invalid_empty() {\n        assert!(parse_owner_repo(\"\").is_err());\n    }\n\n    // is_test_job tests\n    #[test]\n    fn is_test_job_rspec() {\n        assert!(is_test_job(\"run-rspec-tests\"));\n        assert!(is_test_job(\"RSpec\"));\n    }\n\n    #[test]\n    fn is_test_job_test() {\n        assert!(is_test_job(\"unit-tests\"));\n        assert!(is_test_job(\"Test Suite\"));\n    }\n\n    #[test]\n    fn is_test_job_spec() {\n        assert!(is_test_job(\"run-specs\"));\n        assert!(is_test_job(\"Spec Runner\"));\n    }\n\n    #[test]\n    fn is_test_job_non_test() {\n        assert!(!is_test_job(\"build\"));\n        assert!(!is_test_job(\"deploy\"));\n        assert!(!is_test_job(\"lint\"));\n    }\n\n    #[test]\n    fn is_test_job_mixed_case() {\n        assert!(is_test_job(\"RSPEC\"));\n        assert!(is_test_job(\"TEST\"));\n        assert!(is_test_job(\"SPEC\"));\n    }\n\n    #[test]\n    fn is_test_job_partial_names() {\n        assert!(is_test_job(\"run-rspec-tests (3, 0)\"));\n        assert!(is_test_job(\"unit-test-suite\"));\n        assert!(is_test_job(\"integration-spec\"));\n    }\n\n    // run_git_command test\n    #[test]\n    fn run_git_command_version() {\n        let result = run_git_command(\u0026[\"--version\"]);\n        assert!(result.is_ok());\n        assert!(result.unwrap().contains(\"git version\"));\n    }\n\n    // get_current_repo test\n    #[test]\n    fn get_current_repo_returns_result() {\n        let result = get_current_repo();\n        assert!(result.is_ok() || result.is_err());\n    }\n\n    // get_current_branch test\n    #[test]\n    fn get_current_branch_returns_result() {\n        let result = get_current_branch();\n        // In a git repo on a branch, it should succeed\n        assert!(result.is_ok() || result.is_err());\n    }\n}\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":5}},{"line":5,"address":[],"length":0,"stats":{"Line":25}},{"line":6,"address":[],"length":0,"stats":{"Line":5}},{"line":7,"address":[],"length":0,"stats":{"Line":6}},{"line":9,"address":[],"length":0,"stats":{"Line":6}},{"line":13,"address":[],"length":0,"stats":{"Line":1}},{"line":14,"address":[],"length":0,"stats":{"Line":3}},{"line":15,"address":[],"length":0,"stats":{"Line":2}},{"line":19,"address":[],"length":0,"stats":{"Line":4}},{"line":20,"address":[],"length":0,"stats":{"Line":12}},{"line":21,"address":[],"length":0,"stats":{"Line":4}},{"line":25,"address":[],"length":0,"stats":{"Line":4}},{"line":29,"address":[],"length":0,"stats":{"Line":12}},{"line":30,"address":[],"length":0,"stats":{"Line":36}},{"line":32,"address":[],"length":0,"stats":{"Line":24}},{"line":34,"address":[],"length":0,"stats":{"Line":25}},{"line":35,"address":[],"length":0,"stats":{"Line":10}},{"line":36,"address":[],"length":0,"stats":{"Line":25}},{"line":37,"address":[],"length":0,"stats":{"Line":5}},{"line":38,"address":[],"length":0,"stats":{"Line":4}},{"line":39,"address":[],"length":0,"stats":{"Line":16}},{"line":40,"address":[],"length":0,"stats":{"Line":8}},{"line":44,"address":[],"length":0,"stats":{"Line":14}},{"line":46,"address":[],"length":0,"stats":{"Line":15}},{"line":47,"address":[],"length":0,"stats":{"Line":6}},{"line":48,"address":[],"length":0,"stats":{"Line":15}},{"line":49,"address":[],"length":0,"stats":{"Line":3}},{"line":50,"address":[],"length":0,"stats":{"Line":9}},{"line":55,"address":[],"length":0,"stats":{"Line":10}},{"line":59,"address":[],"length":0,"stats":{"Line":30}},{"line":60,"address":[],"length":0,"stats":{"Line":90}},{"line":61,"address":[],"length":0,"stats":{"Line":62}},{"line":65,"address":[],"length":0,"stats":{"Line":2}},{"line":66,"address":[],"length":0,"stats":{"Line":6}},{"line":67,"address":[],"length":0,"stats":{"Line":6}},{"line":68,"address":[],"length":0,"stats":{"Line":4}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":2}}],"covered":37,"coverable":38},{"path":["/","Users","chi","Projects","hu","src","gh","login.rs"],"content":"use anyhow::Result;\n\nuse super::auth;\nuse super::cli::LoginArgs;\n\n/// Handle the `hu gh login` command\npub async fn run(args: LoginArgs) -\u003e Result\u003c()\u003e {\n    let username = auth::login(\u0026args.token).await?;\n    println!(\"{}\", format_login_success(\u0026username));\n    Ok(())\n}\n\n/// Format the login success message (extracted for testability)\npub fn format_login_success(username: \u0026str) -\u003e String {\n    format!(\" Logged in as {}\", username)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn format_login_success_includes_username() {\n        let msg = format_login_success(\"testuser\");\n        assert!(msg.contains(\"testuser\"));\n        assert!(msg.contains(\"\"));\n        assert!(msg.contains(\"Logged in as\"));\n    }\n\n    #[test]\n    fn format_login_success_handles_special_chars() {\n        let msg = format_login_success(\"user-name_123\");\n        assert!(msg.contains(\"user-name_123\"));\n    }\n\n    #[test]\n    fn login_args_has_token_field() {\n        let args = LoginArgs {\n            token: \"test_token\".to_string(),\n        };\n        assert_eq!(args.token, \"test_token\");\n    }\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":2}},{"line":15,"address":[],"length":0,"stats":{"Line":4}}],"covered":2,"coverable":6},{"path":["/","Users","chi","Projects","hu","src","gh","mod.rs"],"content":"//! GitHub integration\n//!\n//! # CLI Usage\n//! Use [`run_command`] for CLI commands that format and print output.\n//!\n//! # Programmatic Usage (MCP/HTTP)\n//! Use the reusable functions that return typed data:\n//! - [`list_user_prs`] - List open PRs by current user\n//! - [`get_ci_status`] - Get CI status for a PR\n//! - [`list_workflow_runs`] - List workflow runs\n//! - [`search_prs`] - Search PRs by title/branch\n\nmod auth;\nmod cli;\nmod client;\nmod failures;\nmod fix;\nmod helpers;\nmod login;\nmod prs;\nmod runs;\nmod service;\nmod sync;\nmod types;\n\nuse anyhow::Result;\n\npub use cli::GhCommand;\npub use types::{CiStatus, PullRequest, RunsQuery, WorkflowRun};\n\n/// Run a GitHub command (CLI entry point - formats and prints)\n#[cfg(not(tarpaulin_include))]\npub async fn run_command(cmd: GhCommand) -\u003e anyhow::Result\u003c()\u003e {\n    match cmd {\n        GhCommand::Login(args) =\u003e login::run(args).await,\n        GhCommand::Prs =\u003e prs::run().await,\n        GhCommand::Failures(args) =\u003e failures::run(args).await,\n        GhCommand::Fix(args) =\u003e fix::run(args).await,\n        GhCommand::Runs(args) =\u003e runs::run(args).await,\n        GhCommand::Sync(args) =\u003e sync::run(args),\n    }\n}\n\n// ============================================================================\n// Reusable functions for MCP/HTTP - return typed data, never print\n// ============================================================================\n\n/// List open PRs authored by the current user (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn list_user_prs() -\u003e Result\u003cVec\u003cPullRequest\u003e\u003e {\n    let client = service::create_client()?;\n    service::list_user_prs(\u0026client).await\n}\n\n/// Get CI status for a PR (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn get_ci_status(owner: \u0026str, repo: \u0026str, pr_number: u64) -\u003e Result\u003cCiStatus\u003e {\n    let client = service::create_client()?;\n    service::get_ci_status(\u0026client, owner, repo, pr_number).await\n}\n\n/// List workflow runs for a repository (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn list_workflow_runs(query: \u0026RunsQuery\u003c'_\u003e) -\u003e Result\u003cVec\u003cWorkflowRun\u003e\u003e {\n    let client = service::create_client()?;\n    service::list_workflow_runs(\u0026client, query).await\n}\n\n/// Search PRs by title/branch (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn search_prs(owner: \u0026str, repo: \u0026str, query: \u0026str) -\u003e Result\u003cVec\u003cPullRequest\u003e\u003e {\n    let client = service::create_client()?;\n    service::search_prs(\u0026client, owner, repo, query).await\n}\n\n/// Find PR number for a branch (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn find_pr_for_branch(owner: \u0026str, repo: \u0026str, branch: \u0026str) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n    let client = service::create_client()?;\n    service::find_pr_for_branch(\u0026client, owner, repo, branch).await\n}\n\n/// Get failed jobs for a workflow run (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn get_failed_jobs(owner: \u0026str, repo: \u0026str, run_id: u64) -\u003e Result\u003cVec\u003c(u64, String)\u003e\u003e {\n    let client = service::create_client()?;\n    service::get_failed_jobs(\u0026client, owner, repo, run_id).await\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn gh_command_exported() {\n        // Verify GhCommand is accessible\n        let _ = std::any::type_name::\u003cGhCommand\u003e();\n    }\n}\n","traces":[{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["/","Users","chi","Projects","hu","src","gh","prs.rs"],"content":"use anyhow::Result;\n\nuse super::client::{GithubApi, GithubClient};\nuse super::types::CiStatus;\n\n// ANSI color codes\nconst GREEN: \u0026str = \"\\x1b[32m\";\nconst YELLOW: \u0026str = \"\\x1b[33m\";\nconst RED: \u0026str = \"\\x1b[31m\";\nconst GRAY: \u0026str = \"\\x1b[90m\";\nconst RESET: \u0026str = \"\\x1b[0m\";\n\n/// Handle the `hu gh prs` command\npub async fn run() -\u003e Result\u003c()\u003e {\n    let client = GithubClient::new()?;\n    run_with_client(\u0026client).await\n}\n\nfn get_terminal_width() -\u003e usize {\n    terminal_size::terminal_size()\n        .map(|(w, _)| w.0 as usize)\n        .unwrap_or(80)\n}\n\nfn print_prs_table(prs: \u0026[super::types::PullRequest]) {\n    let term_width = get_terminal_width();\n\n    // Calculate max link length\n    let max_link_len = prs.iter().map(|p| p.html_url.len()).max().unwrap_or(40);\n\n    // Layout:  S  Title...  Link \n    // Borders take: 1 + 1 + 3 + 3 + 1 = 9 chars ( S  ...  ... )\n    let status_col = 1;\n    let border_overhead = 10; // \" \" + \"  \" + \"  \" + \"\"\n\n    let available = term_width.saturating_sub(border_overhead + status_col + max_link_len);\n    let title_width = available.max(20);\n    let link_width = max_link_len;\n\n    // Top border\n    println!(\n        \"{}{}\",\n        \"\".repeat(title_width + 2),\n        \"\".repeat(link_width + 2)\n    );\n\n    // Rows\n    for pr in prs {\n        let status_icon = match pr.ci_status.unwrap_or(CiStatus::Unknown) {\n            CiStatus::Success =\u003e format!(\"{}{}{}\", GREEN, \"\", RESET),\n            CiStatus::Pending =\u003e format!(\"{}{}{}\", YELLOW, \"\", RESET),\n            CiStatus::Failed =\u003e format!(\"{}{}{}\", RED, \"\", RESET),\n            CiStatus::Unknown =\u003e format!(\"{}{}{}\", GRAY, \"\", RESET),\n        };\n\n        let title = truncate(\u0026pr.title, title_width);\n        let link = format!(\"{}{}{}\", GRAY, \u0026pr.html_url, RESET);\n\n        println!(\n            \" {}  {:\u003cwidth$}  {} \",\n            status_icon,\n            title,\n            link,\n            width = title_width\n        );\n    }\n\n    // Bottom border\n    println!(\n        \"{}{}\",\n        \"\".repeat(title_width + 2),\n        \"\".repeat(link_width + 2)\n    );\n}\n\nfn truncate(s: \u0026str, max_len: usize) -\u003e String {\n    if s.chars().count() \u003c= max_len {\n        s.to_string()\n    } else {\n        let truncated: String = s.chars().take(max_len.saturating_sub(1)).collect();\n        format!(\"{}\", truncated)\n    }\n}\n\n/// Fetch and display PRs using the given API client\npub async fn run_with_client(client: \u0026impl GithubApi) -\u003e Result\u003c()\u003e {\n    let mut prs = client.list_user_prs().await?;\n\n    if prs.is_empty() {\n        println!(\"No open pull requests found.\");\n        return Ok(());\n    }\n\n    // Fetch CI status for each PR\n    for pr in \u0026mut prs {\n        let parts: Vec\u003c\u0026str\u003e = pr.repo_full_name.split('/').collect();\n        if parts.len() == 2 {\n            if let Ok(status) = client.get_ci_status(parts[0], parts[1], pr.number).await {\n                pr.ci_status = Some(status);\n            }\n        }\n    }\n\n    print_prs_table(\u0026prs);\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::gh::types::PullRequest;\n\n    #[test]\n    fn truncate_short_string() {\n        assert_eq!(truncate(\"hello\", 10), \"hello\");\n    }\n\n    #[test]\n    fn truncate_long_string() {\n        assert_eq!(truncate(\"hello world\", 8), \"hello w\");\n    }\n\n    #[test]\n    fn truncate_exact_length() {\n        assert_eq!(truncate(\"hello\", 5), \"hello\");\n    }\n\n    #[test]\n    fn truncate_unicode() {\n        // Unicode chars are counted by char, not byte\n        assert_eq!(truncate(\"hllo\", 5), \"hllo\");\n        assert_eq!(truncate(\"hllo world\", 6), \"hllo\");\n    }\n\n    #[test]\n    fn truncate_empty() {\n        assert_eq!(truncate(\"\", 10), \"\");\n    }\n\n    #[test]\n    fn truncate_zero_length() {\n        // Edge case: max_len = 0 means we try to take 0 chars + ellipsis\n        // saturating_sub(1) on 0 = 0, so we get just \"\" if string is not empty\n        let result = truncate(\"hello\", 0);\n        // With max_len=0, chars.count()=5 \u003e 0, so we truncate\n        // take(0.saturating_sub(1)) = take(0), so we get \"\" + \"\" = \"\"\n        assert_eq!(result, \"\");\n    }\n\n    #[test]\n    fn status_icons_render() {\n        let _ = format!(\"{}{}\", GREEN, RESET);\n        let _ = format!(\"{}{}\", YELLOW, RESET);\n        let _ = format!(\"{}{}\", RED, RESET);\n    }\n\n    #[test]\n    fn get_terminal_width_returns_reasonable_value() {\n        let width = get_terminal_width();\n        // Should return at least 80 (default) or actual terminal width\n        assert!(width \u003e= 20);\n    }\n\n    #[test]\n    fn status_icon_formatting_success() {\n        let icon = format!(\"{}{}{}\", GREEN, \"\", RESET);\n        assert!(icon.contains(\"\"));\n        assert!(icon.starts_with(\"\\x1b[32m\"));\n        assert!(icon.ends_with(\"\\x1b[0m\"));\n    }\n\n    #[test]\n    fn status_icon_formatting_pending() {\n        let icon = format!(\"{}{}{}\", YELLOW, \"\", RESET);\n        assert!(icon.contains(\"\"));\n    }\n\n    #[test]\n    fn status_icon_formatting_failed() {\n        let icon = format!(\"{}{}{}\", RED, \"\", RESET);\n        assert!(icon.contains(\"\"));\n    }\n\n    #[test]\n    fn status_icon_formatting_unknown() {\n        let icon = format!(\"{}{}{}\", GRAY, \"\", RESET);\n        assert!(icon.contains(\"\"));\n    }\n\n    #[test]\n    fn print_prs_table_renders_without_panic() {\n        let prs = vec![\n            PullRequest {\n                number: 1,\n                title: \"Short title\".to_string(),\n                html_url: \"https://github.com/o/r/pull/1\".to_string(),\n                state: \"open\".to_string(),\n                repo_full_name: \"o/r\".to_string(),\n                created_at: \"2024-01-01T00:00:00Z\".to_string(),\n                updated_at: \"2024-01-01T00:00:00Z\".to_string(),\n                ci_status: Some(CiStatus::Success),\n            },\n            PullRequest {\n                number: 2,\n                title: \"A very long title that will definitely need truncation because it exceeds the available width\".to_string(),\n                html_url: \"https://github.com/owner/repo/pull/2\".to_string(),\n                state: \"open\".to_string(),\n                repo_full_name: \"owner/repo\".to_string(),\n                created_at: \"2024-01-01T00:00:00Z\".to_string(),\n                updated_at: \"2024-01-01T00:00:00Z\".to_string(),\n                ci_status: Some(CiStatus::Failed),\n            },\n            PullRequest {\n                number: 3,\n                title: \"Pending PR\".to_string(),\n                html_url: \"https://github.com/o/r/pull/3\".to_string(),\n                state: \"open\".to_string(),\n                repo_full_name: \"o/r\".to_string(),\n                created_at: \"2024-01-01T00:00:00Z\".to_string(),\n                updated_at: \"2024-01-01T00:00:00Z\".to_string(),\n                ci_status: Some(CiStatus::Pending),\n            },\n            PullRequest {\n                number: 4,\n                title: \"Unknown status\".to_string(),\n                html_url: \"https://github.com/o/r/pull/4\".to_string(),\n                state: \"open\".to_string(),\n                repo_full_name: \"o/r\".to_string(),\n                created_at: \"2024-01-01T00:00:00Z\".to_string(),\n                updated_at: \"2024-01-01T00:00:00Z\".to_string(),\n                ci_status: None,\n            },\n        ];\n        // This just verifies it doesn't panic\n        print_prs_table(\u0026prs);\n    }\n\n    #[test]\n    fn print_prs_table_empty_list() {\n        let prs: Vec\u003cPullRequest\u003e = vec![];\n        print_prs_table(\u0026prs);\n    }\n\n    // Mock implementation for testing\n    struct MockGithubApi {\n        prs: Vec\u003cPullRequest\u003e,\n        ci_status: CiStatus,\n    }\n\n    impl GithubApi for MockGithubApi {\n        async fn list_user_prs(\u0026self) -\u003e Result\u003cVec\u003cPullRequest\u003e\u003e {\n            Ok(self.prs.clone())\n        }\n\n        async fn get_ci_status(\u0026self, _owner: \u0026str, _repo: \u0026str, _pr: u64) -\u003e Result\u003cCiStatus\u003e {\n            Ok(self.ci_status)\n        }\n\n        async fn get_pr_branch(\u0026self, _owner: \u0026str, _repo: \u0026str, _pr: u64) -\u003e Result\u003cString\u003e {\n            Ok(\"main\".to_string())\n        }\n\n        async fn get_latest_failed_run_for_branch(\n            \u0026self,\n            _owner: \u0026str,\n            _repo: \u0026str,\n            _branch: \u0026str,\n        ) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n            Ok(None)\n        }\n\n        async fn get_failed_jobs(\n            \u0026self,\n            _owner: \u0026str,\n            _repo: \u0026str,\n            _run_id: u64,\n        ) -\u003e Result\u003cVec\u003c(u64, String)\u003e\u003e {\n            Ok(vec![])\n        }\n\n        async fn get_job_logs(\u0026self, _owner: \u0026str, _repo: \u0026str, _job_id: u64) -\u003e Result\u003cString\u003e {\n            Ok(String::new())\n        }\n\n        async fn find_pr_for_branch(\n            \u0026self,\n            _owner: \u0026str,\n            _repo: \u0026str,\n            _branch: \u0026str,\n        ) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n            Ok(None)\n        }\n\n        async fn list_workflow_runs(\n            \u0026self,\n            _query: \u0026crate::gh::types::RunsQuery\u003c'_\u003e,\n        ) -\u003e Result\u003cVec\u003ccrate::gh::types::WorkflowRun\u003e\u003e {\n            Ok(vec![])\n        }\n\n        async fn search_prs_by_title(\n            \u0026self,\n            _owner: \u0026str,\n            _repo: \u0026str,\n            _query: \u0026str,\n        ) -\u003e Result\u003cVec\u003ccrate::gh::types::PullRequest\u003e\u003e {\n            Ok(vec![])\n        }\n    }\n\n    #[tokio::test]\n    async fn run_with_client_empty_prs() {\n        let mock = MockGithubApi {\n            prs: vec![],\n            ci_status: CiStatus::Unknown,\n        };\n        let result = run_with_client(\u0026mock).await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn run_with_client_with_prs() {\n        let mock = MockGithubApi {\n            prs: vec![PullRequest {\n                number: 1,\n                title: \"Test PR\".to_string(),\n                html_url: \"https://github.com/o/r/pull/1\".to_string(),\n                state: \"open\".to_string(),\n                repo_full_name: \"o/r\".to_string(),\n                created_at: \"2024-01-01T00:00:00Z\".to_string(),\n                updated_at: \"2024-01-01T00:00:00Z\".to_string(),\n                ci_status: None,\n            }],\n            ci_status: CiStatus::Success,\n        };\n        let result = run_with_client(\u0026mock).await;\n        assert!(result.is_ok());\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":2}},{"line":15,"address":[],"length":0,"stats":{"Line":2}},{"line":16,"address":[],"length":0,"stats":{"Line":2}},{"line":19,"address":[],"length":0,"stats":{"Line":4}},{"line":20,"address":[],"length":0,"stats":{"Line":4}},{"line":21,"address":[],"length":0,"stats":{"Line":8}},{"line":25,"address":[],"length":0,"stats":{"Line":3}},{"line":26,"address":[],"length":0,"stats":{"Line":6}},{"line":29,"address":[],"length":0,"stats":{"Line":28}},{"line":33,"address":[],"length":0,"stats":{"Line":6}},{"line":34,"address":[],"length":0,"stats":{"Line":6}},{"line":36,"address":[],"length":0,"stats":{"Line":12}},{"line":37,"address":[],"length":0,"stats":{"Line":9}},{"line":38,"address":[],"length":0,"stats":{"Line":6}},{"line":41,"address":[],"length":0,"stats":{"Line":3}},{"line":42,"address":[],"length":0,"stats":{"Line":3}},{"line":43,"address":[],"length":0,"stats":{"Line":9}},{"line":44,"address":[],"length":0,"stats":{"Line":9}},{"line":48,"address":[],"length":0,"stats":{"Line":13}},{"line":49,"address":[],"length":0,"stats":{"Line":15}},{"line":50,"address":[],"length":0,"stats":{"Line":4}},{"line":51,"address":[],"length":0,"stats":{"Line":2}},{"line":52,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":56,"address":[],"length":0,"stats":{"Line":20}},{"line":57,"address":[],"length":0,"stats":{"Line":20}},{"line":59,"address":[],"length":0,"stats":{"Line":5}},{"line":60,"address":[],"length":0,"stats":{"Line":5}},{"line":69,"address":[],"length":0,"stats":{"Line":3}},{"line":70,"address":[],"length":0,"stats":{"Line":3}},{"line":71,"address":[],"length":0,"stats":{"Line":9}},{"line":72,"address":[],"length":0,"stats":{"Line":9}},{"line":76,"address":[],"length":0,"stats":{"Line":12}},{"line":77,"address":[],"length":0,"stats":{"Line":36}},{"line":78,"address":[],"length":0,"stats":{"Line":18}},{"line":80,"address":[],"length":0,"stats":{"Line":24}},{"line":81,"address":[],"length":0,"stats":{"Line":6}},{"line":86,"address":[],"length":0,"stats":{"Line":6}},{"line":87,"address":[],"length":0,"stats":{"Line":9}},{"line":89,"address":[],"length":0,"stats":{"Line":6}},{"line":90,"address":[],"length":0,"stats":{"Line":4}},{"line":91,"address":[],"length":0,"stats":{"Line":2}},{"line":95,"address":[],"length":0,"stats":{"Line":3}},{"line":96,"address":[],"length":0,"stats":{"Line":4}},{"line":97,"address":[],"length":0,"stats":{"Line":1}},{"line":98,"address":[],"length":0,"stats":{"Line":8}},{"line":99,"address":[],"length":0,"stats":{"Line":1}},{"line":104,"address":[],"length":0,"stats":{"Line":2}},{"line":105,"address":[],"length":0,"stats":{"Line":1}}],"covered":49,"coverable":49},{"path":["/","Users","chi","Projects","hu","src","gh","runs","mod.rs"],"content":"use anyhow::Result;\n\nuse super::cli::RunsArgs;\nuse super::client::{GithubApi, GithubClient};\nuse super::helpers::{get_current_repo, parse_owner_repo};\nuse super::types::{RunsQuery, WorkflowRun};\n\n#[cfg(test)]\nmod tests;\n\n// ANSI color codes\nconst GREEN: \u0026str = \"\\x1b[32m\";\nconst YELLOW: \u0026str = \"\\x1b[33m\";\nconst RED: \u0026str = \"\\x1b[31m\";\nconst GRAY: \u0026str = \"\\x1b[90m\";\nconst RESET: \u0026str = \"\\x1b[0m\";\n\n/// Handle the `hu gh runs` command\npub async fn run(args: RunsArgs) -\u003e Result\u003c()\u003e {\n    let client = GithubClient::new()?;\n    let (owner, repo) = match \u0026args.repo {\n        Some(r) =\u003e parse_owner_repo(r)?,\n        None =\u003e get_current_repo()?,\n    };\n    run_with_client(\u0026client, \u0026owner, \u0026repo, \u0026args).await\n}\n\n/// Fetch and display workflow runs using the given API client\npub async fn run_with_client(\n    client: \u0026impl GithubApi,\n    owner: \u0026str,\n    repo: \u0026str,\n    args: \u0026RunsArgs,\n) -\u003e Result\u003c()\u003e {\n    let runs = if let Some(ticket) = \u0026args.ticket {\n        fetch_runs_for_ticket(client, owner, repo, ticket, args).await?\n    } else {\n        let query = RunsQuery {\n            owner,\n            repo,\n            branch: args.branch.as_deref(),\n            status: args.status.as_deref(),\n            limit: args.limit,\n        };\n        client.list_workflow_runs(\u0026query).await?\n    };\n\n    if runs.is_empty() {\n        println!(\"No workflow runs found.\");\n        return Ok(());\n    }\n\n    if args.json {\n        print_runs_json(\u0026runs);\n    } else {\n        print_runs_table(\u0026runs);\n    }\n\n    Ok(())\n}\n\n/// Find runs associated with a ticket by searching PRs and their branches\nasync fn fetch_runs_for_ticket(\n    client: \u0026impl GithubApi,\n    owner: \u0026str,\n    repo: \u0026str,\n    ticket: \u0026str,\n    args: \u0026RunsArgs,\n) -\u003e Result\u003cVec\u003cWorkflowRun\u003e\u003e {\n    let prs = client.search_prs_by_title(owner, repo, ticket).await?;\n\n    if prs.is_empty() {\n        return Ok(vec![]);\n    }\n\n    let mut all_runs = Vec::new();\n    let mut seen_branches = std::collections::HashSet::new();\n\n    for pr in \u0026prs {\n        // Get the branch for this PR\n        let parts: Vec\u003c\u0026str\u003e = pr.repo_full_name.split('/').collect();\n        let (pr_owner, pr_repo) = if parts.len() == 2 {\n            (parts[0], parts[1])\n        } else {\n            (owner, repo)\n        };\n\n        if let Ok(branch) = client.get_pr_branch(pr_owner, pr_repo, pr.number).await {\n            if seen_branches.insert(branch.clone()) {\n                let query = RunsQuery {\n                    owner: pr_owner,\n                    repo: pr_repo,\n                    branch: Some(\u0026branch),\n                    status: args.status.as_deref(),\n                    limit: args.limit,\n                };\n                let runs = client.list_workflow_runs(\u0026query).await?;\n                all_runs.extend(runs);\n            }\n        }\n    }\n\n    // Sort by created_at descending and truncate to limit\n    all_runs.sort_by(|a, b| b.created_at.cmp(\u0026a.created_at));\n    all_runs.truncate(args.limit);\n\n    Ok(all_runs)\n}\n\n/// Get status icon with color for a workflow run\nfn status_icon(run: \u0026WorkflowRun) -\u003e String {\n    match run.conclusion.as_deref() {\n        Some(\"success\") =\u003e format!(\"{GREEN}{RESET}\"),\n        Some(\"failure\") =\u003e format!(\"{RED}{RESET}\"),\n        Some(\"cancelled\") =\u003e format!(\"{GRAY}{RESET}\"),\n        _ =\u003e match run.status.as_str() {\n            \"in_progress\" =\u003e format!(\"{YELLOW}{RESET}\"),\n            \"queued\" =\u003e format!(\"{GRAY}{RESET}\"),\n            _ =\u003e format!(\"{GRAY}{RESET}\"),\n        },\n    }\n}\n\nfn get_terminal_width() -\u003e usize {\n    terminal_size::terminal_size()\n        .map(|(w, _)| w.0 as usize)\n        .unwrap_or(80)\n}\n\nfn truncate(s: \u0026str, max_len: usize) -\u003e String {\n    if s.chars().count() \u003c= max_len {\n        s.to_string()\n    } else {\n        let truncated: String = s.chars().take(max_len.saturating_sub(1)).collect();\n        format!(\"{truncated}\")\n    }\n}\n\nfn print_runs_table(runs: \u0026[WorkflowRun]) {\n    let term_width = get_terminal_width();\n\n    let max_link_len = runs.iter().map(|r| r.html_url.len()).max().unwrap_or(40);\n    let max_branch_len = runs\n        .iter()\n        .map(|r| r.branch.len())\n        .max()\n        .unwrap_or(10)\n        .min(30);\n\n    // Layout:  S  Name  Branch  Link \n    let status_col = 1;\n    let border_overhead = 14; // \" \" + \"  \" + \"  \" + \"  \" + \"\"\n\n    let available =\n        term_width.saturating_sub(border_overhead + status_col + max_branch_len + max_link_len);\n    let name_width = available.max(15);\n    let branch_width = max_branch_len;\n    let link_width = max_link_len;\n\n    // Top border\n    println!(\n        \"{}{}{}\",\n        \"\".repeat(name_width + 2),\n        \"\".repeat(branch_width + 2),\n        \"\".repeat(link_width + 2),\n    );\n\n    for run in runs {\n        let icon = status_icon(run);\n        let name = truncate(\u0026run.name, name_width);\n        let branch = truncate(\u0026run.branch, branch_width);\n        let link = format!(\"{GRAY}{}{RESET}\", \u0026run.html_url);\n\n        println!(\n            \" {}  {:\u003cnw$}  {:\u003cbw$}  {} \",\n            icon,\n            name,\n            branch,\n            link,\n            nw = name_width,\n            bw = branch_width,\n        );\n    }\n\n    // Bottom border\n    println!(\n        \"{}{}{}\",\n        \"\".repeat(name_width + 2),\n        \"\".repeat(branch_width + 2),\n        \"\".repeat(link_width + 2),\n    );\n}\n\nfn print_runs_json(runs: \u0026[WorkflowRun]) {\n    let json = serde_json::to_string_pretty(runs).unwrap_or_default();\n    println!(\"{json}\");\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":7}},{"line":35,"address":[],"length":0,"stats":{"Line":16}},{"line":36,"address":[],"length":0,"stats":{"Line":12}},{"line":41,"address":[],"length":0,"stats":{"Line":15}},{"line":42,"address":[],"length":0,"stats":{"Line":10}},{"line":43,"address":[],"length":0,"stats":{"Line":5}},{"line":45,"address":[],"length":0,"stats":{"Line":15}},{"line":48,"address":[],"length":0,"stats":{"Line":14}},{"line":49,"address":[],"length":0,"stats":{"Line":4}},{"line":50,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":6}},{"line":54,"address":[],"length":0,"stats":{"Line":1}},{"line":56,"address":[],"length":0,"stats":{"Line":4}},{"line":59,"address":[],"length":0,"stats":{"Line":5}},{"line":63,"address":[],"length":0,"stats":{"Line":7}},{"line":70,"address":[],"length":0,"stats":{"Line":42}},{"line":72,"address":[],"length":0,"stats":{"Line":14}},{"line":73,"address":[],"length":0,"stats":{"Line":2}},{"line":76,"address":[],"length":0,"stats":{"Line":10}},{"line":77,"address":[],"length":0,"stats":{"Line":10}},{"line":79,"address":[],"length":0,"stats":{"Line":17}},{"line":81,"address":[],"length":0,"stats":{"Line":24}},{"line":82,"address":[],"length":0,"stats":{"Line":18}},{"line":83,"address":[],"length":0,"stats":{"Line":10}},{"line":85,"address":[],"length":0,"stats":{"Line":1}},{"line":88,"address":[],"length":0,"stats":{"Line":42}},{"line":89,"address":[],"length":0,"stats":{"Line":24}},{"line":93,"address":[],"length":0,"stats":{"Line":10}},{"line":94,"address":[],"length":0,"stats":{"Line":10}},{"line":95,"address":[],"length":0,"stats":{"Line":5}},{"line":97,"address":[],"length":0,"stats":{"Line":20}},{"line":98,"address":[],"length":0,"stats":{"Line":15}},{"line":104,"address":[],"length":0,"stats":{"Line":22}},{"line":105,"address":[],"length":0,"stats":{"Line":15}},{"line":107,"address":[],"length":0,"stats":{"Line":5}},{"line":111,"address":[],"length":0,"stats":{"Line":15}},{"line":112,"address":[],"length":0,"stats":{"Line":15}},{"line":113,"address":[],"length":0,"stats":{"Line":21}},{"line":114,"address":[],"length":0,"stats":{"Line":16}},{"line":115,"address":[],"length":0,"stats":{"Line":3}},{"line":116,"address":[],"length":0,"stats":{"Line":4}},{"line":117,"address":[],"length":0,"stats":{"Line":8}},{"line":118,"address":[],"length":0,"stats":{"Line":4}},{"line":119,"address":[],"length":0,"stats":{"Line":2}},{"line":124,"address":[],"length":0,"stats":{"Line":8}},{"line":125,"address":[],"length":0,"stats":{"Line":8}},{"line":126,"address":[],"length":0,"stats":{"Line":16}},{"line":130,"address":[],"length":0,"stats":{"Line":22}},{"line":131,"address":[],"length":0,"stats":{"Line":66}},{"line":132,"address":[],"length":0,"stats":{"Line":42}},{"line":134,"address":[],"length":0,"stats":{"Line":8}},{"line":135,"address":[],"length":0,"stats":{"Line":2}},{"line":139,"address":[],"length":0,"stats":{"Line":7}},{"line":140,"address":[],"length":0,"stats":{"Line":14}},{"line":142,"address":[],"length":0,"stats":{"Line":60}},{"line":143,"address":[],"length":0,"stats":{"Line":14}},{"line":145,"address":[],"length":0,"stats":{"Line":25}},{"line":151,"address":[],"length":0,"stats":{"Line":14}},{"line":152,"address":[],"length":0,"stats":{"Line":14}},{"line":154,"address":[],"length":0,"stats":{"Line":7}},{"line":155,"address":[],"length":0,"stats":{"Line":21}},{"line":156,"address":[],"length":0,"stats":{"Line":21}},{"line":157,"address":[],"length":0,"stats":{"Line":14}},{"line":158,"address":[],"length":0,"stats":{"Line":14}},{"line":161,"address":[],"length":0,"stats":{"Line":7}},{"line":162,"address":[],"length":0,"stats":{"Line":7}},{"line":163,"address":[],"length":0,"stats":{"Line":21}},{"line":164,"address":[],"length":0,"stats":{"Line":21}},{"line":165,"address":[],"length":0,"stats":{"Line":21}},{"line":168,"address":[],"length":0,"stats":{"Line":34}},{"line":169,"address":[],"length":0,"stats":{"Line":36}},{"line":170,"address":[],"length":0,"stats":{"Line":45}},{"line":171,"address":[],"length":0,"stats":{"Line":45}},{"line":172,"address":[],"length":0,"stats":{"Line":45}},{"line":174,"address":[],"length":0,"stats":{"Line":9}},{"line":175,"address":[],"length":0,"stats":{"Line":9}},{"line":176,"address":[],"length":0,"stats":{"Line":9}},{"line":177,"address":[],"length":0,"stats":{"Line":9}},{"line":178,"address":[],"length":0,"stats":{"Line":9}},{"line":179,"address":[],"length":0,"stats":{"Line":9}},{"line":180,"address":[],"length":0,"stats":{"Line":9}},{"line":181,"address":[],"length":0,"stats":{"Line":9}},{"line":186,"address":[],"length":0,"stats":{"Line":7}},{"line":187,"address":[],"length":0,"stats":{"Line":7}},{"line":188,"address":[],"length":0,"stats":{"Line":21}},{"line":189,"address":[],"length":0,"stats":{"Line":21}},{"line":190,"address":[],"length":0,"stats":{"Line":21}},{"line":194,"address":[],"length":0,"stats":{"Line":3}},{"line":195,"address":[],"length":0,"stats":{"Line":12}},{"line":196,"address":[],"length":0,"stats":{"Line":6}}],"covered":90,"coverable":96},{"path":["/","Users","chi","Projects","hu","src","gh","runs","tests.rs"],"content":"use super::*;\nuse crate::gh::client::GithubApi;\nuse crate::gh::types::{CiStatus, PullRequest, RunsQuery, WorkflowRun};\nuse anyhow::Result;\n\n// Mock implementation\nstruct MockGithubApi {\n    prs: Vec\u003cPullRequest\u003e,\n    runs: Vec\u003cWorkflowRun\u003e,\n    branches: std::collections::HashMap\u003cu64, String\u003e,\n}\n\nimpl MockGithubApi {\n    fn new() -\u003e Self {\n        Self {\n            prs: vec![],\n            runs: vec![],\n            branches: std::collections::HashMap::new(),\n        }\n    }\n\n    fn with_runs(mut self, runs: Vec\u003cWorkflowRun\u003e) -\u003e Self {\n        self.runs = runs;\n        self\n    }\n\n    fn with_prs(mut self, prs: Vec\u003cPullRequest\u003e) -\u003e Self {\n        self.prs = prs;\n        self\n    }\n\n    fn with_branch(mut self, pr_number: u64, branch: String) -\u003e Self {\n        self.branches.insert(pr_number, branch);\n        self\n    }\n}\n\nimpl GithubApi for MockGithubApi {\n    async fn list_user_prs(\u0026self) -\u003e Result\u003cVec\u003cPullRequest\u003e\u003e {\n        Ok(self.prs.clone())\n    }\n\n    async fn get_ci_status(\u0026self, _owner: \u0026str, _repo: \u0026str, _pr: u64) -\u003e Result\u003cCiStatus\u003e {\n        Ok(CiStatus::Unknown)\n    }\n\n    async fn get_pr_branch(\u0026self, _owner: \u0026str, _repo: \u0026str, pr: u64) -\u003e Result\u003cString\u003e {\n        Ok(self\n            .branches\n            .get(\u0026pr)\n            .cloned()\n            .unwrap_or_else(|| \"main\".to_string()))\n    }\n\n    async fn get_latest_failed_run_for_branch(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _branch: \u0026str,\n    ) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n        Ok(None)\n    }\n\n    async fn get_failed_jobs(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _run_id: u64,\n    ) -\u003e Result\u003cVec\u003c(u64, String)\u003e\u003e {\n        Ok(vec![])\n    }\n\n    async fn get_job_logs(\u0026self, _owner: \u0026str, _repo: \u0026str, _job_id: u64) -\u003e Result\u003cString\u003e {\n        Ok(String::new())\n    }\n\n    async fn find_pr_for_branch(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _branch: \u0026str,\n    ) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n        Ok(None)\n    }\n\n    async fn list_workflow_runs(\u0026self, query: \u0026RunsQuery\u003c'_\u003e) -\u003e Result\u003cVec\u003cWorkflowRun\u003e\u003e {\n        let mut runs: Vec\u003cWorkflowRun\u003e = self\n            .runs\n            .iter()\n            .filter(|r| query.branch.is_none_or(|b| r.branch == b))\n            .filter(|r| {\n                query\n                    .status\n                    .is_none_or(|s| r.status == s || r.conclusion.as_deref() == Some(s))\n            })\n            .cloned()\n            .collect();\n        runs.truncate(query.limit);\n        Ok(runs)\n    }\n\n    async fn search_prs_by_title(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        query: \u0026str,\n    ) -\u003e Result\u003cVec\u003cPullRequest\u003e\u003e {\n        let query_lower = query.to_lowercase();\n        Ok(self\n            .prs\n            .iter()\n            .filter(|pr| pr.title.to_lowercase().contains(\u0026query_lower))\n            .cloned()\n            .collect())\n    }\n}\n\nfn make_run(\n    id: u64,\n    name: \u0026str,\n    status: \u0026str,\n    conclusion: Option\u003c\u0026str\u003e,\n    branch: \u0026str,\n) -\u003e WorkflowRun {\n    WorkflowRun {\n        id,\n        name: name.to_string(),\n        status: status.to_string(),\n        conclusion: conclusion.map(|s| s.to_string()),\n        branch: branch.to_string(),\n        html_url: format!(\"https://github.com/o/r/actions/runs/{id}\"),\n        created_at: format!(\"2024-01-15T{:02}:00:00Z\", id % 24),\n        updated_at: format!(\"2024-01-15T{:02}:05:00Z\", id % 24),\n        run_number: id,\n    }\n}\n\nfn make_pr(number: u64, title: \u0026str) -\u003e PullRequest {\n    PullRequest {\n        number,\n        title: title.to_string(),\n        html_url: format!(\"https://github.com/o/r/pull/{number}\"),\n        state: \"open\".to_string(),\n        repo_full_name: \"o/r\".to_string(),\n        created_at: \"2024-01-01T00:00:00Z\".to_string(),\n        updated_at: \"2024-01-01T00:00:00Z\".to_string(),\n        ci_status: None,\n    }\n}\n\nfn default_args() -\u003e RunsArgs {\n    RunsArgs {\n        ticket: None,\n        status: None,\n        branch: None,\n        repo: None,\n        limit: 20,\n        json: false,\n    }\n}\n\n// status_icon tests\n#[test]\nfn status_icon_success() {\n    let run = make_run(1, \"CI\", \"completed\", Some(\"success\"), \"main\");\n    let icon = status_icon(\u0026run);\n    assert!(icon.contains(\"\"));\n    assert!(icon.contains(GREEN));\n}\n\n#[test]\nfn status_icon_failure() {\n    let run = make_run(1, \"CI\", \"completed\", Some(\"failure\"), \"main\");\n    let icon = status_icon(\u0026run);\n    assert!(icon.contains(\"\"));\n    assert!(icon.contains(RED));\n}\n\n#[test]\nfn status_icon_in_progress() {\n    let run = make_run(1, \"CI\", \"in_progress\", None, \"main\");\n    let icon = status_icon(\u0026run);\n    assert!(icon.contains(\"\"));\n    assert!(icon.contains(YELLOW));\n}\n\n#[test]\nfn status_icon_queued() {\n    let run = make_run(1, \"CI\", \"queued\", None, \"main\");\n    let icon = status_icon(\u0026run);\n    assert!(icon.contains(\"\"));\n    assert!(icon.contains(GRAY));\n}\n\n#[test]\nfn status_icon_cancelled() {\n    let run = make_run(1, \"CI\", \"completed\", Some(\"cancelled\"), \"main\");\n    let icon = status_icon(\u0026run);\n    assert!(icon.contains(\"\"));\n    assert!(icon.contains(GRAY));\n}\n\n#[test]\nfn status_icon_unknown_status() {\n    let run = make_run(1, \"CI\", \"unknown\", None, \"main\");\n    let icon = status_icon(\u0026run);\n    assert!(icon.contains(\"\"));\n}\n\n// truncate tests\n#[test]\nfn truncate_short() {\n    assert_eq!(truncate(\"hello\", 10), \"hello\");\n}\n\n#[test]\nfn truncate_long() {\n    assert_eq!(truncate(\"hello world\", 8), \"hello w\");\n}\n\n#[test]\nfn truncate_exact() {\n    assert_eq!(truncate(\"hello\", 5), \"hello\");\n}\n\n#[test]\nfn truncate_empty() {\n    assert_eq!(truncate(\"\", 10), \"\");\n}\n\n// print_runs_table tests\n#[test]\nfn print_runs_table_renders_without_panic() {\n    let runs = vec![\n        make_run(1, \"CI\", \"completed\", Some(\"success\"), \"main\"),\n        make_run(2, \"Lint\", \"completed\", Some(\"failure\"), \"feature\"),\n        make_run(3, \"Deploy\", \"in_progress\", None, \"main\"),\n    ];\n    print_runs_table(\u0026runs);\n}\n\n#[test]\nfn print_runs_table_empty() {\n    let runs: Vec\u003cWorkflowRun\u003e = vec![];\n    print_runs_table(\u0026runs);\n}\n\n#[test]\nfn print_runs_table_long_names() {\n    let runs = vec![make_run(\n        1,\n        \"A very long workflow name that should be truncated\",\n        \"completed\",\n        Some(\"success\"),\n        \"a-very-long-branch-name-too\",\n    )];\n    print_runs_table(\u0026runs);\n}\n\n// print_runs_json tests\n#[test]\nfn print_runs_json_renders() {\n    let runs = vec![make_run(1, \"CI\", \"completed\", Some(\"success\"), \"main\")];\n    print_runs_json(\u0026runs);\n}\n\n#[test]\nfn print_runs_json_empty() {\n    let runs: Vec\u003cWorkflowRun\u003e = vec![];\n    print_runs_json(\u0026runs);\n}\n\n// get_terminal_width test\n#[test]\nfn get_terminal_width_reasonable() {\n    let width = get_terminal_width();\n    assert!(width \u003e= 20);\n}\n\n// run_with_client tests\n#[tokio::test]\nasync fn run_with_client_no_runs() {\n    let mock = MockGithubApi::new();\n    let args = default_args();\n    let result = run_with_client(\u0026mock, \"o\", \"r\", \u0026args).await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn run_with_client_with_runs() {\n    let runs = vec![\n        make_run(1, \"CI\", \"completed\", Some(\"success\"), \"main\"),\n        make_run(2, \"Lint\", \"completed\", Some(\"failure\"), \"main\"),\n    ];\n    let mock = MockGithubApi::new().with_runs(runs);\n    let args = default_args();\n    let result = run_with_client(\u0026mock, \"o\", \"r\", \u0026args).await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn run_with_client_json_output() {\n    let runs = vec![make_run(1, \"CI\", \"completed\", Some(\"success\"), \"main\")];\n    let mock = MockGithubApi::new().with_runs(runs);\n    let mut args = default_args();\n    args.json = true;\n    let result = run_with_client(\u0026mock, \"o\", \"r\", \u0026args).await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn run_with_client_branch_filter() {\n    let runs = vec![\n        make_run(1, \"CI\", \"completed\", Some(\"success\"), \"main\"),\n        make_run(2, \"CI\", \"completed\", Some(\"failure\"), \"feature\"),\n    ];\n    let mock = MockGithubApi::new().with_runs(runs);\n    let mut args = default_args();\n    args.branch = Some(\"feature\".to_string());\n    let result = run_with_client(\u0026mock, \"o\", \"r\", \u0026args).await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn run_with_client_status_filter() {\n    let runs = vec![\n        make_run(1, \"CI\", \"completed\", Some(\"success\"), \"main\"),\n        make_run(2, \"CI\", \"completed\", Some(\"failure\"), \"main\"),\n    ];\n    let mock = MockGithubApi::new().with_runs(runs);\n    let mut args = default_args();\n    args.status = Some(\"failure\".to_string());\n    let result = run_with_client(\u0026mock, \"o\", \"r\", \u0026args).await;\n    assert!(result.is_ok());\n}\n\n// fetch_runs_for_ticket tests\n#[tokio::test]\nasync fn fetch_runs_for_ticket_no_prs() {\n    let mock = MockGithubApi::new();\n    let args = default_args();\n    let runs = fetch_runs_for_ticket(\u0026mock, \"o\", \"r\", \"BFR-999\", \u0026args).await;\n    assert!(runs.is_ok());\n    assert!(runs.unwrap().is_empty());\n}\n\n#[tokio::test]\nasync fn fetch_runs_for_ticket_with_prs() {\n    let pr = make_pr(1, \"BFR-1234 Fix bug\");\n    let runs = vec![\n        make_run(10, \"CI\", \"completed\", Some(\"success\"), \"bfr-1234-fix\"),\n        make_run(11, \"Lint\", \"completed\", Some(\"success\"), \"bfr-1234-fix\"),\n    ];\n    let mock = MockGithubApi::new()\n        .with_prs(vec![pr])\n        .with_runs(runs)\n        .with_branch(1, \"bfr-1234-fix\".to_string());\n    let args = default_args();\n    let result = fetch_runs_for_ticket(\u0026mock, \"o\", \"r\", \"BFR-1234\", \u0026args).await;\n    assert!(result.is_ok());\n    assert_eq!(result.unwrap().len(), 2);\n}\n\n#[tokio::test]\nasync fn fetch_runs_for_ticket_deduplicates_branches() {\n    let prs = vec![\n        make_pr(1, \"BFR-1234 First PR\"),\n        make_pr(2, \"BFR-1234 Second PR\"),\n    ];\n    let runs = vec![make_run(\n        10,\n        \"CI\",\n        \"completed\",\n        Some(\"success\"),\n        \"same-branch\",\n    )];\n    let mock = MockGithubApi::new()\n        .with_prs(prs)\n        .with_runs(runs)\n        .with_branch(1, \"same-branch\".to_string())\n        .with_branch(2, \"same-branch\".to_string());\n    let args = default_args();\n    let result = fetch_runs_for_ticket(\u0026mock, \"o\", \"r\", \"BFR-1234\", \u0026args).await;\n    assert!(result.is_ok());\n    // Should only query once since both PRs point to same branch\n    assert_eq!(result.unwrap().len(), 1);\n}\n\n#[tokio::test]\nasync fn fetch_runs_for_ticket_respects_limit() {\n    let pr = make_pr(1, \"BFR-1234 Fix\");\n    let runs: Vec\u003cWorkflowRun\u003e = (0..10)\n        .map(|i| make_run(i, \"CI\", \"completed\", Some(\"success\"), \"feature\"))\n        .collect();\n    let mock = MockGithubApi::new()\n        .with_prs(vec![pr])\n        .with_runs(runs)\n        .with_branch(1, \"feature\".to_string());\n    let mut args = default_args();\n    args.limit = 3;\n    let result = fetch_runs_for_ticket(\u0026mock, \"o\", \"r\", \"BFR-1234\", \u0026args).await;\n    assert!(result.is_ok());\n    assert!(result.unwrap().len() \u003c= 3);\n}\n\n#[tokio::test]\nasync fn run_with_client_ticket_search() {\n    let pr = make_pr(1, \"BFR-1234 Fix bug\");\n    let runs = vec![make_run(10, \"CI\", \"completed\", Some(\"success\"), \"bfr-1234\")];\n    let mock = MockGithubApi::new()\n        .with_prs(vec![pr])\n        .with_runs(runs)\n        .with_branch(1, \"bfr-1234\".to_string());\n    let mut args = default_args();\n    args.ticket = Some(\"BFR-1234\".to_string());\n    let result = run_with_client(\u0026mock, \"o\", \"r\", \u0026args).await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn fetch_runs_for_ticket_invalid_repo_name() {\n    let mut pr = make_pr(1, \"BFR-1234 Fix bug\");\n    pr.repo_full_name = \"invalid-no-slash\".to_string();\n    let runs = vec![make_run(10, \"CI\", \"completed\", Some(\"success\"), \"feature\")];\n    let mock = MockGithubApi::new()\n        .with_prs(vec![pr])\n        .with_runs(runs)\n        .with_branch(1, \"feature\".to_string());\n    let args = default_args();\n    let result = fetch_runs_for_ticket(\u0026mock, \"o\", \"r\", \"BFR-1234\", \u0026args).await;\n    assert!(result.is_ok());\n    // Should still work, falling back to owner/repo params\n    assert_eq!(result.unwrap().len(), 1);\n}\n\n#[tokio::test]\nasync fn run_with_client_ticket_no_results() {\n    let mock = MockGithubApi::new();\n    let mut args = default_args();\n    args.ticket = Some(\"NONE-999\".to_string());\n    let result = run_with_client(\u0026mock, \"o\", \"r\", \u0026args).await;\n    assert!(result.is_ok());\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":12}},{"line":16,"address":[],"length":0,"stats":{"Line":24}},{"line":17,"address":[],"length":0,"stats":{"Line":12}},{"line":18,"address":[],"length":0,"stats":{"Line":12}},{"line":22,"address":[],"length":0,"stats":{"Line":9}},{"line":23,"address":[],"length":0,"stats":{"Line":18}},{"line":24,"address":[],"length":0,"stats":{"Line":9}},{"line":27,"address":[],"length":0,"stats":{"Line":5}},{"line":28,"address":[],"length":0,"stats":{"Line":10}},{"line":29,"address":[],"length":0,"stats":{"Line":5}},{"line":32,"address":[],"length":0,"stats":{"Line":6}},{"line":33,"address":[],"length":0,"stats":{"Line":24}},{"line":34,"address":[],"length":0,"stats":{"Line":6}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":12}},{"line":48,"address":[],"length":0,"stats":{"Line":6}},{"line":49,"address":[],"length":0,"stats":{"Line":6}},{"line":50,"address":[],"length":0,"stats":{"Line":12}},{"line":51,"address":[],"length":0,"stats":{"Line":6}},{"line":52,"address":[],"length":0,"stats":{"Line":6}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":20}},{"line":87,"address":[],"length":0,"stats":{"Line":30}},{"line":88,"address":[],"length":0,"stats":{"Line":10}},{"line":90,"address":[],"length":0,"stats":{"Line":88}},{"line":91,"address":[],"length":0,"stats":{"Line":31}},{"line":92,"address":[],"length":0,"stats":{"Line":21}},{"line":93,"address":[],"length":0,"stats":{"Line":21}},{"line":94,"address":[],"length":0,"stats":{"Line":25}},{"line":98,"address":[],"length":0,"stats":{"Line":30}},{"line":99,"address":[],"length":0,"stats":{"Line":10}},{"line":102,"address":[],"length":0,"stats":{"Line":7}},{"line":108,"address":[],"length":0,"stats":{"Line":21}},{"line":109,"address":[],"length":0,"stats":{"Line":7}},{"line":110,"address":[],"length":0,"stats":{"Line":7}},{"line":111,"address":[],"length":0,"stats":{"Line":7}},{"line":112,"address":[],"length":0,"stats":{"Line":25}},{"line":113,"address":[],"length":0,"stats":{"Line":7}},{"line":114,"address":[],"length":0,"stats":{"Line":7}},{"line":118,"address":[],"length":0,"stats":{"Line":33}},{"line":127,"address":[],"length":0,"stats":{"Line":66}},{"line":128,"address":[],"length":0,"stats":{"Line":66}},{"line":129,"address":[],"length":0,"stats":{"Line":124}},{"line":130,"address":[],"length":0,"stats":{"Line":66}},{"line":131,"address":[],"length":0,"stats":{"Line":66}},{"line":132,"address":[],"length":0,"stats":{"Line":99}},{"line":133,"address":[],"length":0,"stats":{"Line":99}},{"line":138,"address":[],"length":0,"stats":{"Line":6}},{"line":141,"address":[],"length":0,"stats":{"Line":18}},{"line":142,"address":[],"length":0,"stats":{"Line":18}},{"line":143,"address":[],"length":0,"stats":{"Line":18}},{"line":144,"address":[],"length":0,"stats":{"Line":18}},{"line":145,"address":[],"length":0,"stats":{"Line":18}},{"line":146,"address":[],"length":0,"stats":{"Line":12}},{"line":151,"address":[],"length":0,"stats":{"Line":12}}],"covered":53,"coverable":65},{"path":["/","Users","chi","Projects","hu","src","gh","service.rs"],"content":"//! GitHub service layer - business logic that returns data\n//!\n//! Functions in this module accept trait objects and return typed data.\n//! They never print - that's the CLI layer's job.\n\nuse anyhow::Result;\n\nuse super::client::{GithubApi, GithubClient};\nuse super::types::{CiStatus, PullRequest, RunsQuery, WorkflowRun};\n\n/// List open PRs authored by the current user\npub async fn list_user_prs(api: \u0026impl GithubApi) -\u003e Result\u003cVec\u003cPullRequest\u003e\u003e {\n    api.list_user_prs().await\n}\n\n/// Get CI status for a PR\npub async fn get_ci_status(\n    api: \u0026impl GithubApi,\n    owner: \u0026str,\n    repo: \u0026str,\n    pr_number: u64,\n) -\u003e Result\u003cCiStatus\u003e {\n    api.get_ci_status(owner, repo, pr_number).await\n}\n\n/// Get the branch name for a PR\n#[allow(dead_code)]\npub async fn get_pr_branch(\n    api: \u0026impl GithubApi,\n    owner: \u0026str,\n    repo: \u0026str,\n    pr_number: u64,\n) -\u003e Result\u003cString\u003e {\n    api.get_pr_branch(owner, repo, pr_number).await\n}\n\n/// Get the latest failed workflow run for a branch\n#[allow(dead_code)]\npub async fn get_latest_failed_run(\n    api: \u0026impl GithubApi,\n    owner: \u0026str,\n    repo: \u0026str,\n    branch: \u0026str,\n) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n    api.get_latest_failed_run_for_branch(owner, repo, branch)\n        .await\n}\n\n/// Get failed jobs for a workflow run\npub async fn get_failed_jobs(\n    api: \u0026impl GithubApi,\n    owner: \u0026str,\n    repo: \u0026str,\n    run_id: u64,\n) -\u003e Result\u003cVec\u003c(u64, String)\u003e\u003e {\n    api.get_failed_jobs(owner, repo, run_id).await\n}\n\n/// Download logs for a job\n#[allow(dead_code)]\npub async fn get_job_logs(\n    api: \u0026impl GithubApi,\n    owner: \u0026str,\n    repo: \u0026str,\n    job_id: u64,\n) -\u003e Result\u003cString\u003e {\n    api.get_job_logs(owner, repo, job_id).await\n}\n\n/// Find PR number for a branch\npub async fn find_pr_for_branch(\n    api: \u0026impl GithubApi,\n    owner: \u0026str,\n    repo: \u0026str,\n    branch: \u0026str,\n) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n    api.find_pr_for_branch(owner, repo, branch).await\n}\n\n/// List workflow runs for a repository\npub async fn list_workflow_runs(\n    api: \u0026impl GithubApi,\n    query: \u0026RunsQuery\u003c'_\u003e,\n) -\u003e Result\u003cVec\u003cWorkflowRun\u003e\u003e {\n    api.list_workflow_runs(query).await\n}\n\n/// Search PRs by title/branch containing a query string\npub async fn search_prs(\n    api: \u0026impl GithubApi,\n    owner: \u0026str,\n    repo: \u0026str,\n    query: \u0026str,\n) -\u003e Result\u003cVec\u003cPullRequest\u003e\u003e {\n    api.search_prs_by_title(owner, repo, query).await\n}\n\n/// Create a new authenticated client\npub fn create_client() -\u003e Result\u003cGithubClient\u003e {\n    GithubClient::new()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    struct MockApi {\n        prs: Vec\u003cPullRequest\u003e,\n        runs: Vec\u003cWorkflowRun\u003e,\n    }\n\n    impl MockApi {\n        fn new() -\u003e Self {\n            Self {\n                prs: vec![],\n                runs: vec![],\n            }\n        }\n\n        fn with_prs(mut self, prs: Vec\u003cPullRequest\u003e) -\u003e Self {\n            self.prs = prs;\n            self\n        }\n\n        fn with_runs(mut self, runs: Vec\u003cWorkflowRun\u003e) -\u003e Self {\n            self.runs = runs;\n            self\n        }\n    }\n\n    impl GithubApi for MockApi {\n        async fn list_user_prs(\u0026self) -\u003e Result\u003cVec\u003cPullRequest\u003e\u003e {\n            Ok(self.prs.clone())\n        }\n\n        async fn get_ci_status(\u0026self, _owner: \u0026str, _repo: \u0026str, _pr: u64) -\u003e Result\u003cCiStatus\u003e {\n            Ok(CiStatus::Success)\n        }\n\n        async fn get_pr_branch(\u0026self, _owner: \u0026str, _repo: \u0026str, _pr: u64) -\u003e Result\u003cString\u003e {\n            Ok(\"main\".to_string())\n        }\n\n        async fn get_latest_failed_run_for_branch(\n            \u0026self,\n            _owner: \u0026str,\n            _repo: \u0026str,\n            _branch: \u0026str,\n        ) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n            Ok(self.runs.first().map(|r| r.id))\n        }\n\n        async fn get_failed_jobs(\n            \u0026self,\n            _owner: \u0026str,\n            _repo: \u0026str,\n            _run_id: u64,\n        ) -\u003e Result\u003cVec\u003c(u64, String)\u003e\u003e {\n            Ok(vec![(123, \"test\".to_string())])\n        }\n\n        async fn get_job_logs(\u0026self, _owner: \u0026str, _repo: \u0026str, _job: u64) -\u003e Result\u003cString\u003e {\n            Ok(\"Test logs\".to_string())\n        }\n\n        async fn find_pr_for_branch(\n            \u0026self,\n            _owner: \u0026str,\n            _repo: \u0026str,\n            _branch: \u0026str,\n        ) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n            Ok(self.prs.first().map(|p| p.number))\n        }\n\n        async fn list_workflow_runs(\u0026self, _query: \u0026RunsQuery\u003c'_\u003e) -\u003e Result\u003cVec\u003cWorkflowRun\u003e\u003e {\n            Ok(self.runs.clone())\n        }\n\n        async fn search_prs_by_title(\n            \u0026self,\n            _owner: \u0026str,\n            _repo: \u0026str,\n            query: \u0026str,\n        ) -\u003e Result\u003cVec\u003cPullRequest\u003e\u003e {\n            let query_lower = query.to_lowercase();\n            Ok(self\n                .prs\n                .iter()\n                .filter(|p| p.title.to_lowercase().contains(\u0026query_lower))\n                .cloned()\n                .collect())\n        }\n    }\n\n    fn make_pr(number: u64, title: \u0026str) -\u003e PullRequest {\n        PullRequest {\n            number,\n            title: title.to_string(),\n            html_url: format!(\"https://github.com/owner/repo/pull/{}\", number),\n            state: \"open\".to_string(),\n            repo_full_name: \"owner/repo\".to_string(),\n            created_at: \"2024-01-01T00:00:00Z\".to_string(),\n            updated_at: \"2024-01-01T00:00:00Z\".to_string(),\n            ci_status: None,\n        }\n    }\n\n    fn make_run(id: u64, name: \u0026str, status: \u0026str) -\u003e WorkflowRun {\n        WorkflowRun {\n            id,\n            name: name.to_string(),\n            status: status.to_string(),\n            conclusion: Some(\"success\".to_string()),\n            branch: \"main\".to_string(),\n            html_url: format!(\"https://github.com/owner/repo/actions/runs/{}\", id),\n            created_at: \"2024-01-01T00:00:00Z\".to_string(),\n            updated_at: \"2024-01-01T00:00:00Z\".to_string(),\n            run_number: id,\n        }\n    }\n\n    #[tokio::test]\n    async fn list_user_prs_returns_all() {\n        let api = MockApi::new().with_prs(vec![make_pr(1, \"Fix bug\"), make_pr(2, \"Add feature\")]);\n\n        let result = list_user_prs(\u0026api).await.unwrap();\n        assert_eq!(result.len(), 2);\n    }\n\n    #[tokio::test]\n    async fn get_ci_status_returns_status() {\n        let api = MockApi::new();\n        let result = get_ci_status(\u0026api, \"owner\", \"repo\", 1).await.unwrap();\n        assert_eq!(result, CiStatus::Success);\n    }\n\n    #[tokio::test]\n    async fn list_workflow_runs_returns_all() {\n        let api = MockApi::new().with_runs(vec![\n            make_run(1, \"CI\", \"completed\"),\n            make_run(2, \"Deploy\", \"in_progress\"),\n        ]);\n\n        let query = RunsQuery {\n            owner: \"owner\",\n            repo: \"repo\",\n            branch: None,\n            status: None,\n            limit: 10,\n        };\n        let result = list_workflow_runs(\u0026api, \u0026query).await.unwrap();\n        assert_eq!(result.len(), 2);\n    }\n\n    #[tokio::test]\n    async fn search_prs_filters_by_title() {\n        let api = MockApi::new().with_prs(vec![\n            make_pr(1, \"Fix authentication bug\"),\n            make_pr(2, \"Add new feature\"),\n        ]);\n\n        let result = search_prs(\u0026api, \"owner\", \"repo\", \"bug\").await.unwrap();\n        assert_eq!(result.len(), 1);\n        assert_eq!(result[0].title, \"Fix authentication bug\");\n    }\n\n    #[tokio::test]\n    async fn find_pr_for_branch_returns_first() {\n        let api = MockApi::new().with_prs(vec![make_pr(42, \"My PR\")]);\n        let result = find_pr_for_branch(\u0026api, \"owner\", \"repo\", \"feature\")\n            .await\n            .unwrap();\n        assert_eq!(result, Some(42));\n    }\n\n    #[tokio::test]\n    async fn get_failed_jobs_returns_list() {\n        let api = MockApi::new();\n        let result = get_failed_jobs(\u0026api, \"owner\", \"repo\", 123).await.unwrap();\n        assert_eq!(result.len(), 1);\n        assert_eq!(result[0].1, \"test\");\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":2}},{"line":13,"address":[],"length":0,"stats":{"Line":2}},{"line":17,"address":[],"length":0,"stats":{"Line":1}},{"line":23,"address":[],"length":0,"stats":{"Line":5}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":1}},{"line":56,"address":[],"length":0,"stats":{"Line":5}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":77,"address":[],"length":0,"stats":{"Line":5}},{"line":81,"address":[],"length":0,"stats":{"Line":1}},{"line":85,"address":[],"length":0,"stats":{"Line":3}},{"line":89,"address":[],"length":0,"stats":{"Line":1}},{"line":95,"address":[],"length":0,"stats":{"Line":5}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}}],"covered":12,"coverable":21},{"path":["/","Users","chi","Projects","hu","src","gh","sync.rs"],"content":"use anyhow::Result;\n\nuse crate::git::{self, SyncOptions};\n\nuse super::cli::SyncArgs;\n\npub fn run(args: SyncArgs) -\u003e Result\u003c()\u003e {\n    let options = SyncOptions {\n        no_commit: args.no_commit,\n        no_push: args.no_push,\n        message: args.message,\n        path: args.path,\n    };\n\n    let result = git::sync(\u0026options)?;\n\n    if args.json {\n        println!(\"{}\", serde_json::to_string_pretty(\u0026result)?);\n        return Ok(());\n    }\n\n    if result.files_committed == 0 {\n        println!(\"Nothing to commit, working tree clean\");\n        return Ok(());\n    }\n\n    if let Some(hash) = \u0026result.commit_hash {\n        let branch = result.branch.as_deref().unwrap_or(\"unknown\");\n        println!(\n            \"\\x1b[32m\\u{2713}\\x1b[0m Committed {} {} [{}] {}\",\n            result.files_committed,\n            if result.files_committed == 1 {\n                \"file\"\n            } else {\n                \"files\"\n            },\n            branch,\n            hash\n        );\n    } else if args.no_commit {\n        println!(\n            \"\\x1b[33m\\u{25D0}\\x1b[0m {} {} changed (--no-commit)\",\n            result.files_committed,\n            if result.files_committed == 1 {\n                \"file\"\n            } else {\n                \"files\"\n            }\n        );\n    }\n\n    if result.pushed {\n        println!(\"\\x1b[32m\\u{2713}\\x1b[0m Pushed to origin\");\n    } else if !args.no_push \u0026\u0026 result.commit_hash.is_some() {\n        println!(\"\\x1b[33m\\u{25D0}\\x1b[0m No remote configured, skipping push\");\n    }\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::path::PathBuf;\n\n    #[test]\n    fn sync_args_to_options() {\n        let args = SyncArgs {\n            path: Some(PathBuf::from(\"/tmp\")),\n            no_commit: true,\n            no_push: true,\n            message: Some(\"test\".to_string()),\n            json: false,\n        };\n\n        let options = SyncOptions {\n            no_commit: args.no_commit,\n            no_push: args.no_push,\n            message: args.message.clone(),\n            path: args.path.clone(),\n        };\n\n        assert!(options.no_commit);\n        assert!(options.no_push);\n        assert_eq!(options.message.unwrap(), \"test\");\n        assert_eq!(options.path.unwrap(), PathBuf::from(\"/tmp\"));\n    }\n\n    #[test]\n    fn run_not_git_repo() {\n        let args = SyncArgs {\n            path: Some(PathBuf::from(\"/tmp\")),\n            no_commit: false,\n            no_push: false,\n            message: None,\n            json: false,\n        };\n        let result = run(args);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn run_json_not_repo() {\n        let args = SyncArgs {\n            path: Some(PathBuf::from(\"/tmp\")),\n            no_commit: false,\n            no_push: false,\n            message: None,\n            json: true,\n        };\n        let result = run(args);\n        assert!(result.is_err());\n    }\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":2}},{"line":9,"address":[],"length":0,"stats":{"Line":4}},{"line":10,"address":[],"length":0,"stats":{"Line":4}},{"line":11,"address":[],"length":0,"stats":{"Line":2}},{"line":12,"address":[],"length":0,"stats":{"Line":2}},{"line":15,"address":[],"length":0,"stats":{"Line":6}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}}],"covered":6,"coverable":30},{"path":["/","Users","chi","Projects","hu","src","gh","types.rs"],"content":"use serde::{Deserialize, Serialize};\n\n/// CI check status\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]\npub enum CiStatus {\n    Success,\n    Pending,\n    Failed,\n    #[default]\n    Unknown,\n}\n\n/// Pull request data for display\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PullRequest {\n    pub number: u64,\n    pub title: String,\n    pub html_url: String,\n    pub state: String,\n    pub repo_full_name: String,\n    pub created_at: String,\n    pub updated_at: String,\n    #[serde(skip)]\n    pub ci_status: Option\u003cCiStatus\u003e,\n}\n\n/// A GitHub Actions workflow run\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct WorkflowRun {\n    pub id: u64,\n    pub name: String,\n    pub status: String,\n    pub conclusion: Option\u003cString\u003e,\n    pub branch: String,\n    pub html_url: String,\n    pub created_at: String,\n    pub updated_at: String,\n    pub run_number: u64,\n}\n\n/// Parameters for listing workflow runs\n#[derive(Debug, Clone, Default)]\npub struct RunsQuery\u003c'a\u003e {\n    pub owner: \u0026'a str,\n    pub repo: \u0026'a str,\n    pub branch: Option\u003c\u0026'a str\u003e,\n    pub status: Option\u003c\u0026'a str\u003e,\n    pub limit: usize,\n}\n\n/// A test failure extracted from CI logs\n#[derive(Debug, Clone)]\npub struct TestFailure {\n    /// The spec file path (e.g., \"spec/models/user_spec.rb\")\n    pub spec_file: String,\n    /// The failure message/output\n    pub failure_text: String,\n}\n\n/// A test failure enriched with source file mapping\n#[derive(Debug, Clone, Serialize)]\npub struct FixFailure {\n    pub test_file: String,\n    pub source_files: Vec\u003cString\u003e,\n    pub failure_text: String,\n    pub language: String,\n}\n\n/// Full fix report for a failed CI run\n#[derive(Debug, Clone, Serialize)]\npub struct FixReport {\n    pub repository: String,\n    pub pr_number: Option\u003cu64\u003e,\n    pub run_id: u64,\n    pub failures: Vec\u003cFixFailure\u003e,\n    pub test_files: Vec\u003cString\u003e,\n    pub source_files: Vec\u003cString\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn pull_request_serializes() {\n        let pr = PullRequest {\n            number: 123,\n            title: \"Fix bug\".to_string(),\n            html_url: \"https://github.com/org/repo/pull/123\".to_string(),\n            state: \"open\".to_string(),\n            repo_full_name: \"org/repo\".to_string(),\n            created_at: \"2024-01-15T10:00:00Z\".to_string(),\n            updated_at: \"2024-01-15T12:00:00Z\".to_string(),\n            ci_status: None,\n        };\n\n        let json = serde_json::to_string(\u0026pr).unwrap();\n        assert!(json.contains(\"Fix bug\"));\n        assert!(json.contains(\"org/repo\"));\n    }\n\n    #[test]\n    fn pull_request_deserializes() {\n        let json = r#\"{\n            \"number\": 456,\n            \"title\": \"Add feature\",\n            \"html_url\": \"https://github.com/org/repo/pull/456\",\n            \"state\": \"open\",\n            \"repo_full_name\": \"org/repo\",\n            \"created_at\": \"2024-01-15T10:00:00Z\",\n            \"updated_at\": \"2024-01-15T12:00:00Z\"\n        }\"#;\n\n        let pr: PullRequest = serde_json::from_str(json).unwrap();\n        assert_eq!(pr.number, 456);\n        assert_eq!(pr.title, \"Add feature\");\n        assert!(pr.ci_status.is_none());\n    }\n\n    #[test]\n    fn ci_status_default_is_unknown() {\n        let status = CiStatus::default();\n        assert_eq!(status, CiStatus::Unknown);\n    }\n\n    #[test]\n    fn ci_status_equality() {\n        assert_eq!(CiStatus::Success, CiStatus::Success);\n        assert_eq!(CiStatus::Pending, CiStatus::Pending);\n        assert_eq!(CiStatus::Failed, CiStatus::Failed);\n        assert_eq!(CiStatus::Unknown, CiStatus::Unknown);\n        assert_ne!(CiStatus::Success, CiStatus::Failed);\n    }\n\n    #[test]\n    fn ci_status_clone() {\n        let status = CiStatus::Success;\n        let cloned = status;\n        assert_eq!(status, cloned);\n    }\n\n    #[test]\n    fn ci_status_debug_format() {\n        let debug_str = format!(\"{:?}\", CiStatus::Pending);\n        assert!(debug_str.contains(\"Pending\"));\n    }\n\n    #[test]\n    fn test_failure_clone() {\n        let failure = TestFailure {\n            spec_file: \"./spec/test_spec.rb:10\".to_string(),\n            failure_text: \"expected true, got false\".to_string(),\n        };\n        let cloned = failure.clone();\n        assert_eq!(cloned.spec_file, failure.spec_file);\n        assert_eq!(cloned.failure_text, failure.failure_text);\n    }\n\n    #[test]\n    fn test_failure_debug_format() {\n        let failure = TestFailure {\n            spec_file: \"./spec/test_spec.rb:10\".to_string(),\n            failure_text: \"error\".to_string(),\n        };\n        let debug_str = format!(\"{:?}\", failure);\n        assert!(debug_str.contains(\"TestFailure\"));\n        assert!(debug_str.contains(\"spec_file\"));\n    }\n\n    #[test]\n    fn pull_request_clone() {\n        let pr = PullRequest {\n            number: 123,\n            title: \"Test\".to_string(),\n            html_url: \"https://github.com/a/b/pull/123\".to_string(),\n            state: \"open\".to_string(),\n            repo_full_name: \"a/b\".to_string(),\n            created_at: \"2024-01-01T00:00:00Z\".to_string(),\n            updated_at: \"2024-01-01T00:00:00Z\".to_string(),\n            ci_status: Some(CiStatus::Success),\n        };\n        let cloned = pr.clone();\n        assert_eq!(cloned.number, pr.number);\n        assert_eq!(cloned.ci_status, pr.ci_status);\n    }\n\n    #[test]\n    fn pull_request_debug_format() {\n        let pr = PullRequest {\n            number: 1,\n            title: \"T\".to_string(),\n            html_url: \"u\".to_string(),\n            state: \"open\".to_string(),\n            repo_full_name: \"r\".to_string(),\n            created_at: \"c\".to_string(),\n            updated_at: \"u\".to_string(),\n            ci_status: None,\n        };\n        let debug_str = format!(\"{:?}\", pr);\n        assert!(debug_str.contains(\"PullRequest\"));\n    }\n\n    #[test]\n    fn fix_failure_serializes() {\n        let f = FixFailure {\n            test_file: \"spec/models/user_spec.rb:10\".to_string(),\n            source_files: vec![\"app/models/user.rb\".to_string()],\n            failure_text: \"expected true\".to_string(),\n            language: \"ruby\".to_string(),\n        };\n        let json = serde_json::to_string(\u0026f).unwrap();\n        assert!(json.contains(\"user_spec.rb\"));\n        assert!(json.contains(\"app/models/user.rb\"));\n        assert!(json.contains(\"ruby\"));\n    }\n\n    #[test]\n    fn fix_failure_clone() {\n        let f = FixFailure {\n            test_file: \"test.rb\".to_string(),\n            source_files: vec![\"src.rb\".to_string()],\n            failure_text: \"err\".to_string(),\n            language: \"ruby\".to_string(),\n        };\n        let c = f.clone();\n        assert_eq!(c.test_file, f.test_file);\n        assert_eq!(c.source_files, f.source_files);\n    }\n\n    #[test]\n    fn fix_failure_debug() {\n        let f = FixFailure {\n            test_file: \"t\".to_string(),\n            source_files: vec![],\n            failure_text: \"e\".to_string(),\n            language: \"rust\".to_string(),\n        };\n        let d = format!(\"{:?}\", f);\n        assert!(d.contains(\"FixFailure\"));\n    }\n\n    #[test]\n    fn fix_report_serializes() {\n        let r = FixReport {\n            repository: \"owner/repo\".to_string(),\n            pr_number: Some(42),\n            run_id: 123,\n            failures: vec![],\n            test_files: vec![\"spec/a_spec.rb\".to_string()],\n            source_files: vec![\"app/a.rb\".to_string()],\n        };\n        let json = serde_json::to_string(\u0026r).unwrap();\n        assert!(json.contains(\"owner/repo\"));\n        assert!(json.contains(\"42\"));\n        assert!(json.contains(\"123\"));\n    }\n\n    #[test]\n    fn fix_report_clone() {\n        let r = FixReport {\n            repository: \"o/r\".to_string(),\n            pr_number: None,\n            run_id: 1,\n            failures: vec![],\n            test_files: vec![],\n            source_files: vec![],\n        };\n        let c = r.clone();\n        assert_eq!(c.repository, r.repository);\n        assert_eq!(c.pr_number, r.pr_number);\n    }\n\n    #[test]\n    fn fix_report_debug() {\n        let r = FixReport {\n            repository: \"o/r\".to_string(),\n            pr_number: None,\n            run_id: 1,\n            failures: vec![],\n            test_files: vec![],\n            source_files: vec![],\n        };\n        let d = format!(\"{:?}\", r);\n        assert!(d.contains(\"FixReport\"));\n    }\n\n    #[test]\n    fn workflow_run_serializes() {\n        let run = WorkflowRun {\n            id: 100,\n            name: \"Test Suite\".to_string(),\n            status: \"completed\".to_string(),\n            conclusion: Some(\"success\".to_string()),\n            branch: \"main\".to_string(),\n            html_url: \"https://github.com/o/r/actions/runs/100\".to_string(),\n            created_at: \"2024-01-15T10:00:00Z\".to_string(),\n            updated_at: \"2024-01-15T10:05:00Z\".to_string(),\n            run_number: 42,\n        };\n        let json = serde_json::to_string(\u0026run).unwrap();\n        assert!(json.contains(\"Test Suite\"));\n        assert!(json.contains(\"100\"));\n        assert!(json.contains(\"main\"));\n    }\n\n    #[test]\n    fn workflow_run_deserializes() {\n        let json = r#\"{\n            \"id\": 200,\n            \"name\": \"Lint\",\n            \"status\": \"in_progress\",\n            \"conclusion\": null,\n            \"branch\": \"feature\",\n            \"html_url\": \"https://github.com/o/r/actions/runs/200\",\n            \"created_at\": \"2024-01-15T10:00:00Z\",\n            \"updated_at\": \"2024-01-15T10:05:00Z\",\n            \"run_number\": 7\n        }\"#;\n        let run: WorkflowRun = serde_json::from_str(json).unwrap();\n        assert_eq!(run.id, 200);\n        assert_eq!(run.name, \"Lint\");\n        assert!(run.conclusion.is_none());\n    }\n\n    #[test]\n    fn workflow_run_clone() {\n        let run = WorkflowRun {\n            id: 1,\n            name: \"CI\".to_string(),\n            status: \"completed\".to_string(),\n            conclusion: Some(\"failure\".to_string()),\n            branch: \"dev\".to_string(),\n            html_url: \"u\".to_string(),\n            created_at: \"c\".to_string(),\n            updated_at: \"u\".to_string(),\n            run_number: 1,\n        };\n        let cloned = run.clone();\n        assert_eq!(cloned.id, run.id);\n        assert_eq!(cloned.conclusion, run.conclusion);\n    }\n\n    #[test]\n    fn runs_query_debug() {\n        let q = RunsQuery {\n            owner: \"o\",\n            repo: \"r\",\n            branch: Some(\"main\"),\n            status: None,\n            limit: 20,\n        };\n        let d = format!(\"{:?}\", q);\n        assert!(d.contains(\"RunsQuery\"));\n    }\n\n    #[test]\n    fn runs_query_clone() {\n        let q = RunsQuery {\n            owner: \"o\",\n            repo: \"r\",\n            branch: None,\n            status: Some(\"completed\"),\n            limit: 10,\n        };\n        let c = q.clone();\n        assert_eq!(c.owner, q.owner);\n        assert_eq!(c.limit, q.limit);\n    }\n\n    #[test]\n    fn runs_query_default() {\n        let q = RunsQuery::default();\n        assert_eq!(q.owner, \"\");\n        assert_eq!(q.repo, \"\");\n        assert!(q.branch.is_none());\n        assert!(q.status.is_none());\n        assert_eq!(q.limit, 0);\n    }\n\n    #[test]\n    fn workflow_run_debug() {\n        let run = WorkflowRun {\n            id: 1,\n            name: \"N\".to_string(),\n            status: \"s\".to_string(),\n            conclusion: None,\n            branch: \"b\".to_string(),\n            html_url: \"u\".to_string(),\n            created_at: \"c\".to_string(),\n            updated_at: \"u\".to_string(),\n            run_number: 1,\n        };\n        let d = format!(\"{:?}\", run);\n        assert!(d.contains(\"WorkflowRun\"));\n    }\n\n    #[test]\n    fn fix_report_no_pr() {\n        let r = FixReport {\n            repository: \"o/r\".to_string(),\n            pr_number: None,\n            run_id: 1,\n            failures: vec![],\n            test_files: vec![],\n            source_files: vec![],\n        };\n        let json = serde_json::to_string(\u0026r).unwrap();\n        assert!(json.contains(\"null\"));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","git","mod.rs"],"content":"mod service;\nmod types;\n\npub use service::sync;\npub use types::{SyncOptions, SyncResult};\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn exports_are_accessible() {\n        let _ = std::any::type_name::\u003cSyncOptions\u003e();\n        let _ = std::any::type_name::\u003cSyncResult\u003e();\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","git","service.rs"],"content":"use anyhow::{Context, Result};\nuse chrono::Local;\nuse std::path::Path;\nuse std::process::Command;\n\nuse super::types::{GitStatus, SyncOptions, SyncResult};\n\n/// Run a git command in a directory\nfn run_git(args: \u0026[\u0026str], cwd: \u0026Path) -\u003e Result\u003cString\u003e {\n    let output = Command::new(\"git\")\n        .args(args)\n        .current_dir(cwd)\n        .output()\n        .with_context(|| format!(\"Failed to run git {:?}\", args))?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"git {:?} failed: {}\", args, stderr.trim());\n    }\n\n    Ok(String::from_utf8_lossy(\u0026output.stdout).to_string())\n}\n\n/// Check if directory is a git repository\npub fn is_git_repo(path: \u0026Path) -\u003e bool {\n    Command::new(\"git\")\n        .args([\"rev-parse\", \"--git-dir\"])\n        .current_dir(path)\n        .output()\n        .map(|o| o.status.success())\n        .unwrap_or(false)\n}\n\n/// Get current branch name\npub fn get_branch(path: \u0026Path) -\u003e Result\u003cString\u003e {\n    let output = run_git(\u0026[\"branch\", \"--show-current\"], path)?;\n    let branch = output.trim().to_string();\n    if branch.is_empty() {\n        anyhow::bail!(\"Not on a branch (detached HEAD?)\");\n    }\n    Ok(branch)\n}\n\n/// Get git status\npub fn get_status(path: \u0026Path) -\u003e Result\u003cGitStatus\u003e {\n    let output = run_git(\u0026[\"status\", \"--porcelain\"], path)?;\n    parse_status_output(\u0026output)\n}\n\n/// Parse git status --porcelain output\npub fn parse_status_output(output: \u0026str) -\u003e Result\u003cGitStatus\u003e {\n    let mut status = GitStatus {\n        modified: vec![],\n        staged: vec![],\n        untracked: vec![],\n        deleted: vec![],\n    };\n\n    for line in output.lines() {\n        if line.len() \u003c 3 {\n            continue;\n        }\n\n        let index = line.chars().next().unwrap_or(' ');\n        let worktree = line.chars().nth(1).unwrap_or(' ');\n        let file = line[3..].trim().to_string();\n        let path = std::path::PathBuf::from(\u0026file);\n\n        // Handle staged changes (index column)\n        match index {\n            'A' | 'M' | 'R' | 'C' =\u003e status.staged.push(path.clone()),\n            'D' =\u003e status.deleted.push(path.clone()),\n            _ =\u003e {}\n        }\n\n        // Handle worktree changes (second column)\n        match worktree {\n            'M' =\u003e {\n                if !status.staged.contains(\u0026path) {\n                    status.modified.push(path);\n                }\n            }\n            'D' =\u003e {\n                if !status.deleted.contains(\u0026path) {\n                    status.deleted.push(path);\n                }\n            }\n            '?' =\u003e status.untracked.push(path),\n            _ =\u003e {}\n        }\n    }\n\n    Ok(status)\n}\n\n/// Generate default commit message\npub fn generate_commit_message(file_count: usize) -\u003e String {\n    let timestamp = Local::now().format(\"%Y-%m-%d %H:%M:%S\");\n    let files_word = if file_count == 1 { \"file\" } else { \"files\" };\n    format!(\"Update {}, {} {}\", timestamp, file_count, files_word)\n}\n\n/// Stage all changes\npub fn stage_all(path: \u0026Path) -\u003e Result\u003c()\u003e {\n    run_git(\u0026[\"add\", \"-A\"], path)?;\n    Ok(())\n}\n\n/// Commit staged changes\npub fn commit(path: \u0026Path, message: \u0026str) -\u003e Result\u003cString\u003e {\n    run_git(\u0026[\"commit\", \"-m\", message], path)?;\n    let hash = run_git(\u0026[\"rev-parse\", \"--short\", \"HEAD\"], path)?;\n    Ok(hash.trim().to_string())\n}\n\n/// Push to remote\npub fn push(path: \u0026Path) -\u003e Result\u003c()\u003e {\n    run_git(\u0026[\"push\"], path)?;\n    Ok(())\n}\n\n/// Check if there's a remote configured\npub fn has_remote(path: \u0026Path) -\u003e bool {\n    run_git(\u0026[\"remote\"], path)\n        .map(|o| !o.trim().is_empty())\n        .unwrap_or(false)\n}\n\n/// Perform full sync: stage, commit, push\npub fn sync(options: \u0026SyncOptions) -\u003e Result\u003cSyncResult\u003e {\n    let path = options\n        .path\n        .clone()\n        .unwrap_or_else(|| std::env::current_dir().unwrap());\n\n    if !is_git_repo(\u0026path) {\n        anyhow::bail!(\"Not a git repository: {}\", path.display());\n    }\n\n    let status = get_status(\u0026path)?;\n    if status.is_clean() {\n        return Ok(SyncResult {\n            files_committed: 0,\n            commit_hash: None,\n            pushed: false,\n            branch: get_branch(\u0026path).ok(),\n        });\n    }\n\n    let file_count = status.file_count();\n    let mut result = SyncResult {\n        files_committed: file_count,\n        commit_hash: None,\n        pushed: false,\n        branch: get_branch(\u0026path).ok(),\n    };\n\n    if options.no_commit {\n        return Ok(result);\n    }\n\n    // Stage all changes\n    stage_all(\u0026path)?;\n\n    // Commit\n    let message = options\n        .message\n        .clone()\n        .unwrap_or_else(|| generate_commit_message(file_count));\n    let hash = commit(\u0026path, \u0026message)?;\n    result.commit_hash = Some(hash);\n\n    // Push if requested and remote exists\n    if !options.no_push \u0026\u0026 has_remote(\u0026path) {\n        push(\u0026path)?;\n        result.pushed = true;\n    }\n\n    Ok(result)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn parse_status_empty() {\n        let status = parse_status_output(\"\").unwrap();\n        assert!(status.is_clean());\n    }\n\n    #[test]\n    fn parse_status_modified() {\n        let status = parse_status_output(\" M file.txt\").unwrap();\n        assert_eq!(status.modified.len(), 1);\n        assert_eq!(status.modified[0].to_str().unwrap(), \"file.txt\");\n    }\n\n    #[test]\n    fn parse_status_staged() {\n        let status = parse_status_output(\"M  file.txt\").unwrap();\n        assert_eq!(status.staged.len(), 1);\n        assert_eq!(status.staged[0].to_str().unwrap(), \"file.txt\");\n    }\n\n    #[test]\n    fn parse_status_untracked() {\n        let status = parse_status_output(\"?? new_file.txt\").unwrap();\n        assert_eq!(status.untracked.len(), 1);\n        assert_eq!(status.untracked[0].to_str().unwrap(), \"new_file.txt\");\n    }\n\n    #[test]\n    fn parse_status_deleted() {\n        let status = parse_status_output(\"D  removed.txt\").unwrap();\n        assert_eq!(status.deleted.len(), 1);\n        assert_eq!(status.deleted[0].to_str().unwrap(), \"removed.txt\");\n    }\n\n    #[test]\n    fn parse_status_added() {\n        let status = parse_status_output(\"A  new.txt\").unwrap();\n        assert_eq!(status.staged.len(), 1);\n        assert_eq!(status.staged[0].to_str().unwrap(), \"new.txt\");\n    }\n\n    #[test]\n    fn parse_status_renamed() {\n        let status = parse_status_output(\"R  old.txt -\u003e new.txt\").unwrap();\n        assert_eq!(status.staged.len(), 1);\n    }\n\n    #[test]\n    fn parse_status_multiple() {\n        let output = \" M modified.txt\\nA  added.txt\\n?? untracked.txt\\nD  deleted.txt\";\n        let status = parse_status_output(output).unwrap();\n        assert_eq!(status.modified.len(), 1);\n        assert_eq!(status.staged.len(), 1);\n        assert_eq!(status.untracked.len(), 1);\n        assert_eq!(status.deleted.len(), 1);\n    }\n\n    #[test]\n    fn parse_status_worktree_deleted() {\n        let status = parse_status_output(\" D removed.txt\").unwrap();\n        assert_eq!(status.deleted.len(), 1);\n    }\n\n    #[test]\n    fn parse_status_both_staged_and_modified() {\n        // File is staged but also has unstaged modifications\n        let status = parse_status_output(\"MM file.txt\").unwrap();\n        // Staged takes precedence, modified is skipped to avoid duplicates\n        assert_eq!(status.staged.len(), 1);\n        assert_eq!(status.modified.len(), 0);\n    }\n\n    #[test]\n    fn parse_status_short_line() {\n        let status = parse_status_output(\"X\").unwrap();\n        assert!(status.is_clean());\n    }\n\n    #[test]\n    fn parse_status_copied() {\n        let status = parse_status_output(\"C  src.txt -\u003e dst.txt\").unwrap();\n        assert_eq!(status.staged.len(), 1);\n    }\n\n    #[test]\n    fn generate_commit_message_single() {\n        let msg = generate_commit_message(1);\n        assert!(msg.contains(\"1 file\"));\n        assert!(!msg.contains(\"1 files\"));\n    }\n\n    #[test]\n    fn generate_commit_message_multiple() {\n        let msg = generate_commit_message(5);\n        assert!(msg.contains(\"5 files\"));\n    }\n\n    #[test]\n    fn generate_commit_message_contains_date() {\n        let msg = generate_commit_message(1);\n        let today = Local::now().format(\"%Y-%m-%d\").to_string();\n        assert!(msg.contains(\u0026today));\n    }\n\n    #[test]\n    fn is_git_repo_current() {\n        // Current directory should be a git repo (we're in hu project)\n        assert!(is_git_repo(Path::new(\".\")));\n    }\n\n    #[test]\n    fn is_git_repo_not_repo() {\n        assert!(!is_git_repo(Path::new(\"/tmp\")));\n    }\n\n    #[test]\n    fn get_branch_current() {\n        let result = get_branch(Path::new(\".\"));\n        assert!(result.is_ok());\n        assert!(!result.unwrap().is_empty());\n    }\n\n    #[test]\n    fn has_remote_current() {\n        // hu project should have a remote\n        assert!(has_remote(Path::new(\".\")));\n    }\n\n    #[test]\n    fn has_remote_no_repo() {\n        assert!(!has_remote(Path::new(\"/tmp\")));\n    }\n\n    #[test]\n    fn sync_not_git_repo() {\n        let opts = SyncOptions {\n            path: Some(std::path::PathBuf::from(\"/tmp\")),\n            ..Default::default()\n        };\n        let result = sync(\u0026opts);\n        assert!(result.is_err());\n        assert!(result\n            .unwrap_err()\n            .to_string()\n            .contains(\"Not a git repository\"));\n    }\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":3}},{"line":10,"address":[],"length":0,"stats":{"Line":12}},{"line":11,"address":[],"length":0,"stats":{"Line":6}},{"line":12,"address":[],"length":0,"stats":{"Line":3}},{"line":14,"address":[],"length":0,"stats":{"Line":3}},{"line":16,"address":[],"length":0,"stats":{"Line":3}},{"line":17,"address":[],"length":0,"stats":{"Line":3}},{"line":18,"address":[],"length":0,"stats":{"Line":3}},{"line":21,"address":[],"length":0,"stats":{"Line":2}},{"line":25,"address":[],"length":0,"stats":{"Line":6}},{"line":26,"address":[],"length":0,"stats":{"Line":18}},{"line":27,"address":[],"length":0,"stats":{"Line":12}},{"line":28,"address":[],"length":0,"stats":{"Line":6}},{"line":30,"address":[],"length":0,"stats":{"Line":18}},{"line":35,"address":[],"length":0,"stats":{"Line":1}},{"line":36,"address":[],"length":0,"stats":{"Line":4}},{"line":37,"address":[],"length":0,"stats":{"Line":3}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":1}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":12}},{"line":53,"address":[],"length":0,"stats":{"Line":24}},{"line":54,"address":[],"length":0,"stats":{"Line":24}},{"line":55,"address":[],"length":0,"stats":{"Line":12}},{"line":56,"address":[],"length":0,"stats":{"Line":12}},{"line":59,"address":[],"length":0,"stats":{"Line":38}},{"line":60,"address":[],"length":0,"stats":{"Line":14}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":64,"address":[],"length":0,"stats":{"Line":52}},{"line":65,"address":[],"length":0,"stats":{"Line":52}},{"line":66,"address":[],"length":0,"stats":{"Line":39}},{"line":67,"address":[],"length":0,"stats":{"Line":39}},{"line":70,"address":[],"length":0,"stats":{"Line":13}},{"line":71,"address":[],"length":0,"stats":{"Line":24}},{"line":72,"address":[],"length":0,"stats":{"Line":8}},{"line":73,"address":[],"length":0,"stats":{"Line":5}},{"line":77,"address":[],"length":0,"stats":{"Line":13}},{"line":79,"address":[],"length":0,"stats":{"Line":8}},{"line":80,"address":[],"length":0,"stats":{"Line":4}},{"line":84,"address":[],"length":0,"stats":{"Line":3}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":88,"address":[],"length":0,"stats":{"Line":6}},{"line":89,"address":[],"length":0,"stats":{"Line":7}},{"line":93,"address":[],"length":0,"stats":{"Line":12}},{"line":97,"address":[],"length":0,"stats":{"Line":3}},{"line":98,"address":[],"length":0,"stats":{"Line":12}},{"line":99,"address":[],"length":0,"stats":{"Line":9}},{"line":100,"address":[],"length":0,"stats":{"Line":6}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":2}},{"line":124,"address":[],"length":0,"stats":{"Line":6}},{"line":125,"address":[],"length":0,"stats":{"Line":4}},{"line":130,"address":[],"length":0,"stats":{"Line":4}},{"line":131,"address":[],"length":0,"stats":{"Line":8}},{"line":132,"address":[],"length":0,"stats":{"Line":4}},{"line":134,"address":[],"length":0,"stats":{"Line":4}},{"line":136,"address":[],"length":0,"stats":{"Line":4}},{"line":137,"address":[],"length":0,"stats":{"Line":12}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}}],"covered":56,"coverable":91},{"path":["/","Users","chi","Projects","hu","src","git","types.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::path::PathBuf;\n\n/// Result of git status operation\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GitStatus {\n    /// Files that have been modified\n    pub modified: Vec\u003cPathBuf\u003e,\n    /// Files that are staged for commit\n    pub staged: Vec\u003cPathBuf\u003e,\n    /// Untracked files\n    pub untracked: Vec\u003cPathBuf\u003e,\n    /// Deleted files\n    pub deleted: Vec\u003cPathBuf\u003e,\n}\n\nimpl GitStatus {\n    /// Returns true if there are no changes\n    pub fn is_clean(\u0026self) -\u003e bool {\n        self.modified.is_empty()\n            \u0026\u0026 self.staged.is_empty()\n            \u0026\u0026 self.untracked.is_empty()\n            \u0026\u0026 self.deleted.is_empty()\n    }\n\n    /// Total number of changed files\n    pub fn file_count(\u0026self) -\u003e usize {\n        self.modified.len() + self.staged.len() + self.untracked.len() + self.deleted.len()\n    }\n}\n\n/// Result of sync operation\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SyncResult {\n    /// Number of files committed\n    pub files_committed: usize,\n    /// Commit hash (short form)\n    pub commit_hash: Option\u003cString\u003e,\n    /// Whether changes were pushed\n    pub pushed: bool,\n    /// Branch name\n    pub branch: Option\u003cString\u003e,\n}\n\n/// Options for sync operation\n#[derive(Debug, Clone, Default)]\npub struct SyncOptions {\n    /// Skip git commit\n    pub no_commit: bool,\n    /// Skip git push\n    pub no_push: bool,\n    /// Custom commit message (if None, uses default format)\n    pub message: Option\u003cString\u003e,\n    /// Working directory (if None, uses current directory)\n    pub path: Option\u003cPathBuf\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn git_status_is_clean_when_empty() {\n        let status = GitStatus {\n            modified: vec![],\n            staged: vec![],\n            untracked: vec![],\n            deleted: vec![],\n        };\n        assert!(status.is_clean());\n    }\n\n    #[test]\n    fn git_status_is_not_clean_with_modified() {\n        let status = GitStatus {\n            modified: vec![PathBuf::from(\"file.txt\")],\n            staged: vec![],\n            untracked: vec![],\n            deleted: vec![],\n        };\n        assert!(!status.is_clean());\n    }\n\n    #[test]\n    fn git_status_is_not_clean_with_staged() {\n        let status = GitStatus {\n            modified: vec![],\n            staged: vec![PathBuf::from(\"file.txt\")],\n            untracked: vec![],\n            deleted: vec![],\n        };\n        assert!(!status.is_clean());\n    }\n\n    #[test]\n    fn git_status_is_not_clean_with_untracked() {\n        let status = GitStatus {\n            modified: vec![],\n            staged: vec![],\n            untracked: vec![PathBuf::from(\"file.txt\")],\n            deleted: vec![],\n        };\n        assert!(!status.is_clean());\n    }\n\n    #[test]\n    fn git_status_is_not_clean_with_deleted() {\n        let status = GitStatus {\n            modified: vec![],\n            staged: vec![],\n            untracked: vec![],\n            deleted: vec![PathBuf::from(\"file.txt\")],\n        };\n        assert!(!status.is_clean());\n    }\n\n    #[test]\n    fn git_status_file_count() {\n        let status = GitStatus {\n            modified: vec![PathBuf::from(\"a.txt\"), PathBuf::from(\"b.txt\")],\n            staged: vec![PathBuf::from(\"c.txt\")],\n            untracked: vec![PathBuf::from(\"d.txt\")],\n            deleted: vec![],\n        };\n        assert_eq!(status.file_count(), 4);\n    }\n\n    #[test]\n    fn git_status_file_count_empty() {\n        let status = GitStatus {\n            modified: vec![],\n            staged: vec![],\n            untracked: vec![],\n            deleted: vec![],\n        };\n        assert_eq!(status.file_count(), 0);\n    }\n\n    #[test]\n    fn sync_options_default() {\n        let opts = SyncOptions::default();\n        assert!(!opts.no_commit);\n        assert!(!opts.no_push);\n        assert!(opts.message.is_none());\n        assert!(opts.path.is_none());\n    }\n\n    #[test]\n    fn sync_result_debug() {\n        let result = SyncResult {\n            files_committed: 5,\n            commit_hash: Some(\"abc1234\".to_string()),\n            pushed: true,\n            branch: Some(\"main\".to_string()),\n        };\n        let debug = format!(\"{:?}\", result);\n        assert!(debug.contains(\"abc1234\"));\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":7}},{"line":20,"address":[],"length":0,"stats":{"Line":14}},{"line":21,"address":[],"length":0,"stats":{"Line":12}},{"line":22,"address":[],"length":0,"stats":{"Line":10}},{"line":23,"address":[],"length":0,"stats":{"Line":8}},{"line":27,"address":[],"length":0,"stats":{"Line":2}},{"line":28,"address":[],"length":0,"stats":{"Line":10}}],"covered":7,"coverable":7},{"path":["/","Users","chi","Projects","hu","src","install","cli.rs"],"content":"use clap::{Args, Subcommand};\n\n#[derive(Subcommand)]\npub enum InstallCommand {\n    /// Install hooks and commands to Claude Code configuration\n    Run(InstallArgs),\n\n    /// Show what would be installed without making changes\n    Preview(InstallArgs),\n\n    /// List available components\n    List,\n}\n\n#[derive(Args)]\npub struct InstallArgs {\n    /// Install to global ~/.claude directory (default)\n    #[arg(short, long, conflicts_with = \"local\")]\n    pub global: bool,\n\n    /// Install to current project's .claude directory\n    #[arg(short, long)]\n    pub local: bool,\n\n    /// Override existing files\n    #[arg(short, long)]\n    pub force: bool,\n\n    /// Install only hooks (shell scripts)\n    #[arg(long, conflicts_with = \"commands_only\")]\n    pub hooks_only: bool,\n\n    /// Install only commands (slash command documentation)\n    #[arg(long)]\n    pub commands_only: bool,\n\n    /// Specific components to install (e.g., \"hooks/hu/pre-read\", \"commands/hu/read\")\n    #[arg(value_name = \"COMPONENT\")]\n    pub components: Vec\u003cString\u003e,\n}\n\nimpl InstallArgs {\n    pub fn target_dir(\u0026self) -\u003e TargetDir {\n        if self.local {\n            TargetDir::Local\n        } else {\n            TargetDir::Global\n        }\n    }\n\n    pub fn install_hooks(\u0026self) -\u003e bool {\n        !self.commands_only\n    }\n\n    pub fn install_commands(\u0026self) -\u003e bool {\n        !self.hooks_only\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum TargetDir {\n    Global,\n    Local,\n}\n\nimpl TargetDir {\n    pub fn path(\u0026self) -\u003e std::path::PathBuf {\n        match self {\n            TargetDir::Global =\u003e dirs::home_dir()\n                .expect(\"could not find home directory\")\n                .join(\".claude\"),\n            TargetDir::Local =\u003e std::env::current_dir()\n                .expect(\"could not get current directory\")\n                .join(\".claude\"),\n        }\n    }\n\n    pub fn display_name(\u0026self) -\u003e \u0026'static str {\n        match self {\n            TargetDir::Global =\u003e \"~/.claude (global)\",\n            TargetDir::Local =\u003e \"./.claude (local)\",\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn target_dir_defaults_to_global() {\n        let args = InstallArgs {\n            global: false,\n            local: false,\n            force: false,\n            hooks_only: false,\n            commands_only: false,\n            components: vec![],\n        };\n        assert_eq!(args.target_dir(), TargetDir::Global);\n    }\n\n    #[test]\n    fn target_dir_local_when_specified() {\n        let args = InstallArgs {\n            global: false,\n            local: true,\n            force: false,\n            hooks_only: false,\n            commands_only: false,\n            components: vec![],\n        };\n        assert_eq!(args.target_dir(), TargetDir::Local);\n    }\n\n    #[test]\n    fn install_both_by_default() {\n        let args = InstallArgs {\n            global: false,\n            local: false,\n            force: false,\n            hooks_only: false,\n            commands_only: false,\n            components: vec![],\n        };\n        assert!(args.install_hooks());\n        assert!(args.install_commands());\n    }\n\n    #[test]\n    fn hooks_only_excludes_commands() {\n        let args = InstallArgs {\n            global: false,\n            local: false,\n            force: false,\n            hooks_only: true,\n            commands_only: false,\n            components: vec![],\n        };\n        assert!(args.install_hooks());\n        assert!(!args.install_commands());\n    }\n\n    #[test]\n    fn commands_only_excludes_hooks() {\n        let args = InstallArgs {\n            global: false,\n            local: false,\n            force: false,\n            hooks_only: false,\n            commands_only: true,\n            components: vec![],\n        };\n        assert!(!args.install_hooks());\n        assert!(args.install_commands());\n    }\n}\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":1}},{"line":47,"address":[],"length":0,"stats":{"Line":1}},{"line":51,"address":[],"length":0,"stats":{"Line":3}},{"line":52,"address":[],"length":0,"stats":{"Line":3}},{"line":55,"address":[],"length":0,"stats":{"Line":3}},{"line":56,"address":[],"length":0,"stats":{"Line":3}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}}],"covered":8,"coverable":16},{"path":["/","Users","chi","Projects","hu","src","install","mod.rs"],"content":"mod cli;\nmod templates;\nmod types;\n\npub use cli::InstallCommand;\n\nuse std::fs;\nuse std::os::unix::fs::PermissionsExt;\n\nuse anyhow::{bail, Context, Result};\nuse comfy_table::{presets::UTF8_FULL_CONDENSED, Cell, Color, Table};\n\nuse cli::{InstallArgs, TargetDir};\nuse templates::{get_components, COMPONENTS};\nuse types::{Component, ComponentKind, ComponentStatus, InstallStatus};\n\npub async fn run_command(cmd: InstallCommand) -\u003e Result\u003c()\u003e {\n    match cmd {\n        InstallCommand::Run(args) =\u003e run_install(args, false),\n        InstallCommand::Preview(args) =\u003e run_install(args, true),\n        InstallCommand::List =\u003e list_components(),\n    }\n}\n\nfn list_components() -\u003e Result\u003c()\u003e {\n    let mut table = Table::new();\n    table.load_preset(UTF8_FULL_CONDENSED);\n    table.set_header(vec![\"ID\", \"Type\", \"Description\"]);\n\n    for component in COMPONENTS {\n        table.add_row(vec![\n            Cell::new(component.id),\n            Cell::new(component.kind.label()),\n            Cell::new(component.description),\n        ]);\n    }\n\n    println!(\"{table}\");\n    println!();\n    println!(\"Hooks:    {}\", templates::get_hooks().len());\n    println!(\"Commands: {}\", templates::get_commands().len());\n    Ok(())\n}\n\nfn run_install(args: InstallArgs, preview: bool) -\u003e Result\u003c()\u003e {\n    let target = args.target_dir();\n    let base_dir = target.path();\n\n    // Filter components based on args\n    let components: Vec\u003c\u0026Component\u003e = if !args.components.is_empty() {\n        // User specified specific components\n        let mut selected = Vec::new();\n        for id in \u0026args.components {\n            match COMPONENTS.iter().find(|c| c.id == id.as_str()) {\n                Some(c) =\u003e selected.push(c),\n                None =\u003e bail!(\"Unknown component: {}\", id),\n            }\n        }\n        selected\n    } else {\n        // Use flags to filter\n        get_components(args.install_hooks(), args.install_commands())\n    };\n\n    if components.is_empty() {\n        println!(\"No components selected for installation.\");\n        return Ok(());\n    }\n\n    // Check status of each component\n    let statuses: Vec\u003cComponentStatus\u003e = components\n        .iter()\n        .map(|c| check_component_status(c, \u0026base_dir))\n        .collect();\n\n    // Display status table\n    print_status_table(\u0026statuses, \u0026target);\n\n    // Determine what to install\n    let to_install: Vec\u003c_\u003e = statuses\n        .iter()\n        .filter(|s| {\n            matches!(s.status, InstallStatus::Missing)\n                || (args.force \u0026\u0026 matches!(s.status, InstallStatus::Modified))\n        })\n        .collect();\n\n    let to_skip: Vec\u003c_\u003e = statuses\n        .iter()\n        .filter(|s| !args.force \u0026\u0026 matches!(s.status, InstallStatus::Modified))\n        .collect();\n\n    if !to_skip.is_empty() {\n        println!();\n        println!(\n            \"Skipping {} modified component(s). Use --force to override.\",\n            to_skip.len()\n        );\n    }\n\n    if to_install.is_empty() {\n        println!();\n        println!(\"Nothing to install. All components are current.\");\n        return Ok(());\n    }\n\n    if preview {\n        println!();\n        println!(\n            \"Preview mode. Would install {} component(s):\",\n            to_install.len()\n        );\n        for status in \u0026to_install {\n            println!(\"  {} {}\", status.status.symbol(), status.component.id);\n        }\n        return Ok(());\n    }\n\n    // Install components\n    println!();\n    println!(\"Installing {} component(s)...\", to_install.len());\n\n    let has_hooks = to_install\n        .iter()\n        .any(|s| s.component.kind == ComponentKind::Hook);\n\n    for status in \u0026to_install {\n        install_component(status.component, \u0026base_dir)?;\n        println!(\"   {}\", status.component.id);\n    }\n\n    // Update settings.json if we installed hooks\n    if has_hooks {\n        update_settings_json(\u0026base_dir)?;\n        println!(\"   Updated settings.json with hook configuration\");\n    }\n\n    println!();\n    println!(\"Installation complete.\");\n\n    // Check if hu CLI is available\n    if !is_hu_available() {\n        println!();\n        println!(\"Warning: 'hu' CLI not found in PATH.\");\n        println!(\"Hooks require 'hu' to be installed. Run:\");\n        println!(\"  cargo install --path ~/Projects/hu\");\n    }\n\n    Ok(())\n}\n\nfn check_component_status(\n    component: \u0026'static Component,\n    base_dir: \u0026std::path::Path,\n) -\u003e ComponentStatus {\n    let target_path = component.target_path(base_dir);\n\n    let status = if !target_path.exists() {\n        InstallStatus::Missing\n    } else {\n        match fs::read_to_string(\u0026target_path) {\n            Ok(content) if content == component.content =\u003e InstallStatus::Current,\n            _ =\u003e InstallStatus::Modified,\n        }\n    };\n\n    ComponentStatus { component, status }\n}\n\nfn print_status_table(statuses: \u0026[ComponentStatus], target: \u0026TargetDir) {\n    println!(\"Target: {}\", target.display_name());\n    println!();\n\n    let mut table = Table::new();\n    table.load_preset(UTF8_FULL_CONDENSED);\n    table.set_header(vec![\"\", \"Component\", \"Status\"]);\n\n    for status in statuses {\n        let (symbol, color) = match status.status {\n            InstallStatus::Missing =\u003e (\"\", Color::Yellow),\n            InstallStatus::Current =\u003e (\"\", Color::Green),\n            InstallStatus::Modified =\u003e (\"\", Color::Cyan),\n        };\n\n        table.add_row(vec![\n            Cell::new(symbol).fg(color),\n            Cell::new(status.component.id),\n            Cell::new(status.status.label()).fg(color),\n        ]);\n    }\n\n    println!(\"{table}\");\n}\n\nfn install_component(component: \u0026Component, base_dir: \u0026std::path::Path) -\u003e Result\u003c()\u003e {\n    let target_path = component.target_path(base_dir);\n\n    // Create parent directories\n    if let Some(parent) = target_path.parent() {\n        fs::create_dir_all(parent)\n            .with_context(|| format!(\"Failed to create {}\", parent.display()))?;\n    }\n\n    // Write content\n    fs::write(\u0026target_path, component.content)\n        .with_context(|| format!(\"Failed to write {}\", target_path.display()))?;\n\n    // Make hooks executable\n    if component.kind == ComponentKind::Hook {\n        let mut perms = fs::metadata(\u0026target_path)?.permissions();\n        perms.set_mode(0o755);\n        fs::set_permissions(\u0026target_path, perms)?;\n    }\n\n    Ok(())\n}\n\nfn update_settings_json(base_dir: \u0026std::path::Path) -\u003e Result\u003c()\u003e {\n    let settings_path = base_dir.join(\"settings.json\");\n\n    // Read existing settings or create new\n    let mut settings: serde_json::Value = if settings_path.exists() {\n        let content = fs::read_to_string(\u0026settings_path)?;\n        serde_json::from_str(\u0026content)?\n    } else {\n        serde_json::json!({})\n    };\n\n    // Ensure env section exists with defaults\n    if settings.get(\"env\").is_none() {\n        settings[\"env\"] = serde_json::json!({\n            \"HU_MAX_FILE_LINES\": \"500\",\n            \"HU_MAX_GREP_RESULTS\": \"20\",\n            \"HU_CLEANUP_DAYS\": \"7\"\n        });\n    }\n\n    // Build hooks configuration\n    let hooks_dir = if base_dir.ends_with(\".claude\") {\n        base_dir.display().to_string()\n    } else {\n        format!(\"{}\", base_dir.display())\n    };\n\n    // Use ~ for home directory in paths for portability\n    let hooks_prefix = if hooks_dir.starts_with(\u0026dirs::home_dir().unwrap().display().to_string()) {\n        \"~/.claude\"\n    } else {\n        \"./.claude\"\n    };\n\n    let hooks_config = serde_json::json!({\n        \"PreToolUse\": [\n            {\n                \"matcher\": \"Read\",\n                \"hooks\": [{\n                    \"type\": \"command\",\n                    \"command\": format!(\"{}/hooks/hu/pre-read.sh\", hooks_prefix),\n                    \"timeout\": 5000\n                }]\n            },\n            {\n                \"matcher\": \"Grep\",\n                \"hooks\": [{\n                    \"type\": \"command\",\n                    \"command\": format!(\"{}/hooks/hu/pre-grep.sh\", hooks_prefix),\n                    \"timeout\": 5000\n                }]\n            },\n            {\n                \"matcher\": \"WebFetch\",\n                \"hooks\": [{\n                    \"type\": \"command\",\n                    \"command\": format!(\"{}/hooks/hu/pre-webfetch.sh\", hooks_prefix),\n                    \"timeout\": 5000\n                }]\n            },\n            {\n                \"matcher\": \"WebSearch\",\n                \"hooks\": [{\n                    \"type\": \"command\",\n                    \"command\": format!(\"{}/hooks/hu/pre-websearch.sh\", hooks_prefix),\n                    \"timeout\": 5000\n                }]\n            }\n        ],\n        \"SessionStart\": [{\n            \"hooks\": [{\n                \"type\": \"command\",\n                \"command\": format!(\"{}/hooks/hu/session-start.sh\", hooks_prefix),\n                \"timeout\": 30000\n            }]\n        }],\n        \"SessionEnd\": [{\n            \"hooks\": [{\n                \"type\": \"command\",\n                \"command\": format!(\"{}/hooks/hu/session-end.sh\", hooks_prefix),\n                \"timeout\": 10000\n            }]\n        }]\n    });\n\n    settings[\"hooks\"] = hooks_config;\n\n    // Write back with pretty formatting\n    let content = serde_json::to_string_pretty(\u0026settings)?;\n    fs::write(\u0026settings_path, content)?;\n\n    Ok(())\n}\n\nfn is_hu_available() -\u003e bool {\n    std::process::Command::new(\"hu\")\n        .arg(\"--version\")\n        .output()\n        .is_ok()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::TempDir;\n\n    #[test]\n    fn check_status_missing() {\n        let temp = TempDir::new().unwrap();\n        let component = \u0026templates::COMPONENTS[0];\n        let status = check_component_status(component, \u0026temp.path().to_path_buf());\n        assert_eq!(status.status, InstallStatus::Missing);\n    }\n\n    #[test]\n    fn check_status_current() {\n        let temp = TempDir::new().unwrap();\n        let component = \u0026templates::COMPONENTS[0];\n\n        // Create the file with matching content\n        let target = temp.path().join(component.path);\n        fs::create_dir_all(target.parent().unwrap()).unwrap();\n        fs::write(\u0026target, component.content).unwrap();\n\n        let status = check_component_status(component, \u0026temp.path().to_path_buf());\n        assert_eq!(status.status, InstallStatus::Current);\n    }\n\n    #[test]\n    fn check_status_modified() {\n        let temp = TempDir::new().unwrap();\n        let component = \u0026templates::COMPONENTS[0];\n\n        // Create the file with different content\n        let target = temp.path().join(component.path);\n        fs::create_dir_all(target.parent().unwrap()).unwrap();\n        fs::write(\u0026target, \"modified content\").unwrap();\n\n        let status = check_component_status(component, \u0026temp.path().to_path_buf());\n        assert_eq!(status.status, InstallStatus::Modified);\n    }\n\n    #[test]\n    fn install_creates_file() {\n        let temp = TempDir::new().unwrap();\n        let component = \u0026templates::COMPONENTS[0];\n\n        install_component(component, \u0026temp.path().to_path_buf()).unwrap();\n\n        let target = temp.path().join(component.path);\n        assert!(target.exists());\n        assert_eq!(fs::read_to_string(\u0026target).unwrap(), component.content);\n    }\n\n    #[test]\n    fn install_hook_is_executable() {\n        let temp = TempDir::new().unwrap();\n        let hook = templates::get_hooks()[0];\n\n        install_component(hook, \u0026temp.path().to_path_buf()).unwrap();\n\n        let target = temp.path().join(hook.path);\n        let perms = fs::metadata(\u0026target).unwrap().permissions();\n        assert_eq!(perms.mode() \u0026 0o111, 0o111); // Executable bits set\n    }\n\n    #[test]\n    fn update_settings_creates_file() {\n        let temp = TempDir::new().unwrap();\n        update_settings_json(\u0026temp.path().to_path_buf()).unwrap();\n\n        let settings_path = temp.path().join(\"settings.json\");\n        assert!(settings_path.exists());\n\n        let content: serde_json::Value =\n            serde_json::from_str(\u0026fs::read_to_string(\u0026settings_path).unwrap()).unwrap();\n        assert!(content.get(\"hooks\").is_some());\n        assert!(content.get(\"env\").is_some());\n    }\n\n    #[test]\n    fn update_settings_preserves_existing() {\n        let temp = TempDir::new().unwrap();\n        let settings_path = temp.path().join(\"settings.json\");\n\n        // Create existing settings with custom values\n        fs::write(\n            \u0026settings_path,\n            r#\"{\"model\": \"opus\", \"permissions\": {\"allow\": [\"Bash\"]}}\"#,\n        )\n        .unwrap();\n\n        update_settings_json(\u0026temp.path().to_path_buf()).unwrap();\n\n        let content: serde_json::Value =\n            serde_json::from_str(\u0026fs::read_to_string(\u0026settings_path).unwrap()).unwrap();\n\n        // Check preserved values\n        assert_eq!(content[\"model\"], \"opus\");\n        assert!(content[\"permissions\"][\"allow\"].as_array().is_some());\n\n        // Check new values added\n        assert!(content.get(\"hooks\").is_some());\n    }\n\n    #[test]\n    fn get_components_with_both() {\n        let components = get_components(true, true);\n        let has_hooks = components.iter().any(|c| c.kind == ComponentKind::Hook);\n        let has_commands = components.iter().any(|c| c.kind == ComponentKind::Command);\n        assert!(has_hooks);\n        assert!(has_commands);\n    }\n\n    #[test]\n    fn get_components_hooks_only() {\n        let components = get_components(true, false);\n        assert!(components.iter().all(|c| c.kind == ComponentKind::Hook));\n    }\n\n    #[test]\n    fn get_components_commands_only() {\n        let components = get_components(false, true);\n        assert!(components.iter().all(|c| c.kind == ComponentKind::Command));\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":3}},{"line":156,"address":[],"length":0,"stats":{"Line":12}},{"line":158,"address":[],"length":0,"stats":{"Line":6}},{"line":159,"address":[],"length":0,"stats":{"Line":1}},{"line":161,"address":[],"length":0,"stats":{"Line":4}},{"line":162,"address":[],"length":0,"stats":{"Line":5}},{"line":163,"address":[],"length":0,"stats":{"Line":1}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":2}},{"line":196,"address":[],"length":0,"stats":{"Line":8}},{"line":199,"address":[],"length":0,"stats":{"Line":4}},{"line":200,"address":[],"length":0,"stats":{"Line":4}},{"line":201,"address":[],"length":0,"stats":{"Line":2}},{"line":205,"address":[],"length":0,"stats":{"Line":6}},{"line":206,"address":[],"length":0,"stats":{"Line":2}},{"line":209,"address":[],"length":0,"stats":{"Line":2}},{"line":210,"address":[],"length":0,"stats":{"Line":8}},{"line":211,"address":[],"length":0,"stats":{"Line":4}},{"line":212,"address":[],"length":0,"stats":{"Line":6}},{"line":215,"address":[],"length":0,"stats":{"Line":2}},{"line":218,"address":[],"length":0,"stats":{"Line":2}},{"line":219,"address":[],"length":0,"stats":{"Line":6}},{"line":222,"address":[],"length":0,"stats":{"Line":6}},{"line":223,"address":[],"length":0,"stats":{"Line":3}},{"line":224,"address":[],"length":0,"stats":{"Line":2}},{"line":226,"address":[],"length":0,"stats":{"Line":1}},{"line":230,"address":[],"length":0,"stats":{"Line":6}},{"line":231,"address":[],"length":0,"stats":{"Line":6}},{"line":232,"address":[],"length":0,"stats":{"Line":4}},{"line":233,"address":[],"length":0,"stats":{"Line":2}},{"line":234,"address":[],"length":0,"stats":{"Line":2}},{"line":239,"address":[],"length":0,"stats":{"Line":6}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":8}},{"line":246,"address":[],"length":0,"stats":{"Line":8}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":2}},{"line":252,"address":[],"length":0,"stats":{"Line":4}},{"line":253,"address":[],"length":0,"stats":{"Line":2}},{"line":255,"address":[],"length":0,"stats":{"Line":2}},{"line":256,"address":[],"length":0,"stats":{"Line":2}},{"line":257,"address":[],"length":0,"stats":{"Line":2}},{"line":258,"address":[],"length":0,"stats":{"Line":6}},{"line":259,"address":[],"length":0,"stats":{"Line":2}},{"line":263,"address":[],"length":0,"stats":{"Line":2}},{"line":264,"address":[],"length":0,"stats":{"Line":2}},{"line":265,"address":[],"length":0,"stats":{"Line":2}},{"line":266,"address":[],"length":0,"stats":{"Line":6}},{"line":267,"address":[],"length":0,"stats":{"Line":2}},{"line":271,"address":[],"length":0,"stats":{"Line":2}},{"line":272,"address":[],"length":0,"stats":{"Line":2}},{"line":273,"address":[],"length":0,"stats":{"Line":2}},{"line":274,"address":[],"length":0,"stats":{"Line":6}},{"line":275,"address":[],"length":0,"stats":{"Line":2}},{"line":279,"address":[],"length":0,"stats":{"Line":2}},{"line":280,"address":[],"length":0,"stats":{"Line":2}},{"line":281,"address":[],"length":0,"stats":{"Line":2}},{"line":282,"address":[],"length":0,"stats":{"Line":6}},{"line":283,"address":[],"length":0,"stats":{"Line":2}},{"line":287,"address":[],"length":0,"stats":{"Line":2}},{"line":288,"address":[],"length":0,"stats":{"Line":2}},{"line":289,"address":[],"length":0,"stats":{"Line":2}},{"line":290,"address":[],"length":0,"stats":{"Line":6}},{"line":291,"address":[],"length":0,"stats":{"Line":2}},{"line":294,"address":[],"length":0,"stats":{"Line":2}},{"line":295,"address":[],"length":0,"stats":{"Line":2}},{"line":296,"address":[],"length":0,"stats":{"Line":2}},{"line":297,"address":[],"length":0,"stats":{"Line":6}},{"line":298,"address":[],"length":0,"stats":{"Line":2}},{"line":303,"address":[],"length":0,"stats":{"Line":4}},{"line":306,"address":[],"length":0,"stats":{"Line":6}},{"line":307,"address":[],"length":0,"stats":{"Line":6}},{"line":309,"address":[],"length":0,"stats":{"Line":2}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}}],"covered":70,"coverable":167},{"path":["/","Users","chi","Projects","hu","src","install","templates.rs"],"content":"use crate::install::types::{Component, ComponentKind};\n\n// ============================================================================\n// HOOKS\n// ============================================================================\n\npub const HOOK_PRE_READ: \u0026str = r#\"#!/bin/bash\n# Pre-Read Hook: Prevent duplicate reads and auto-truncate large files\nset -euo pipefail\n[[ \"${HU_SKIP_HOOKS:-}\" == \"1\" ]] \u0026\u0026 exit 0\n\nMAX_LINES=\"${HU_MAX_FILE_LINES:-500}\"\nINPUT=$(cat)\nFILE_PATH=$(echo \"$INPUT\" | jq -r '.file_path // empty')\n[[ -z \"$FILE_PATH\" ]] \u0026\u0026 exit 0\n\nif command -v hu \u0026\u003e/dev/null; then\n    STATUS=$(hu context check \"$FILE_PATH\" 2\u003e/dev/null || echo \"\")\n    if echo \"$STATUS\" | grep -q \"loaded\"; then\n        AGO=$(echo \"$STATUS\" | grep -oE '[0-9]+ (seconds?|minutes?|hours?) ago' || echo \"recently\")\n        echo \"File already in context (loaded $AGO). Use --force to re-read.\"\n        exit 0\n    fi\nfi\n\nif [[ -f \"$FILE_PATH\" ]]; then\n    LINE_COUNT=$(wc -l \u003c \"$FILE_PATH\" 2\u003e/dev/null || echo \"0\")\n    if [[ \"$LINE_COUNT\" -gt \"$MAX_LINES\" ]]; then\n        echo \"Warning: $FILE_PATH has $LINE_COUNT lines (\u003e${MAX_LINES} threshold).\"\n        echo \"Consider: hu read '$FILE_PATH' --outline | --interface | --around N\"\n    fi\n    command -v hu \u0026\u003e/dev/null \u0026\u0026 hu context track \"$FILE_PATH\" 2\u003e/dev/null || true\nfi\nexit 0\n\"#;\n\npub const HOOK_PRE_GREP: \u0026str = r#\"#!/bin/bash\n# Pre-Grep Hook: Warn on broad patterns\nset -euo pipefail\n[[ \"${HU_SKIP_HOOKS:-}\" == \"1\" ]] \u0026\u0026 exit 0\n\nINPUT=$(cat)\nPATTERN=$(echo \"$INPUT\" | jq -r '.pattern // empty')\n[[ -z \"$PATTERN\" ]] \u0026\u0026 exit 0\n\nBROAD_PATTERNS=(\"^.$\" \"^..$\" \"the\" \"function\" \"import\" \"return\" \"if\" \"for\" \"var\" \"let\" \"const\")\nPATTERN_LOWER=$(echo \"$PATTERN\" | tr '[:upper:]' '[:lower:]')\nfor BROAD in \"${BROAD_PATTERNS[@]}\"; do\n    if [[ \"$PATTERN_LOWER\" =~ $BROAD ]]; then\n        echo \"Warning: Pattern '$PATTERN' may match many results.\"\n        break\n    fi\ndone\nexit 0\n\"#;\n\npub const HOOK_PRE_WEBFETCH: \u0026str = r#\"#!/bin/bash\n# Pre-WebFetch Hook: Log URL fetches\nset -euo pipefail\n[[ \"${HU_SKIP_HOOKS:-}\" == \"1\" ]] \u0026\u0026 exit 0\n\nINPUT=$(cat)\nURL=$(echo \"$INPUT\" | jq -r '.url // empty')\n[[ -z \"$URL\" ]] \u0026\u0026 exit 0\n\necho \"WebFetch: $URL\"\n[[ \"$URL\" == http://* ]] \u0026\u0026 echo \"Warning: Using HTTP instead of HTTPS\"\nexit 0\n\"#;\n\npub const HOOK_PRE_WEBSEARCH: \u0026str = r#\"#!/bin/bash\n# Pre-WebSearch Hook: Log searches\nset -euo pipefail\n[[ \"${HU_SKIP_HOOKS:-}\" == \"1\" ]] \u0026\u0026 exit 0\n\nINPUT=$(cat)\nQUERY=$(echo \"$INPUT\" | jq -r '.query // empty')\n[[ -z \"$QUERY\" ]] \u0026\u0026 exit 0\n\necho \"WebSearch: \\\"$QUERY\\\"\"\n[[ ${#QUERY} -lt 5 ]] \u0026\u0026 echo \"Warning: Query is very short.\"\nexit 0\n\"#;\n\npub const HOOK_SESSION_START: \u0026str = r#\"#!/bin/bash\n# Session-Start Hook: Initialize context tracking and cleanup\nset -euo pipefail\n[[ \"${HU_SKIP_HOOKS:-}\" == \"1\" ]] \u0026\u0026 exit 0\n\nCLEANUP_DAYS=\"${HU_CLEANUP_DAYS:-7}\"\nCLAUDE_DIR=\"${HOME}/.claude\"\n\n[[ -d \"$CLAUDE_DIR/debug\" ]] \u0026\u0026 find \"$CLAUDE_DIR/debug\" -type f -mtime +$CLEANUP_DAYS -delete 2\u003e/dev/null || true\necho \"Cleaned debug files older than $CLEANUP_DAYS days\"\n\n[[ -d \"$CLAUDE_DIR/shell-snapshots\" ]] \u0026\u0026 find \"$CLAUDE_DIR/shell-snapshots\" -type f -mtime +$CLEANUP_DAYS -delete 2\u003e/dev/null || true\n[[ -d \"$CLAUDE_DIR/paste-cache\" ]] \u0026\u0026 find \"$CLAUDE_DIR/paste-cache\" -type f -mtime +$CLEANUP_DAYS -delete 2\u003e/dev/null || true\n\nif command -v hu \u0026\u003e/dev/null; then\n    hu context clear 2\u003e/dev/null || true\n    echo \"Context tracking initialized\"\nfi\n\nif [[ -d \".git\" ]] \u0026\u0026 [[ -d \"doc\" || -d \"docs\" ]]; then\n    DOC_DIR=\"doc\"; [[ -d \"docs\" ]] \u0026\u0026 DOC_DIR=\"docs\"\n    if command -v hu \u0026\u003e/dev/null; then\n        INDEX_FILE=\"/tmp/hu-docs-index-$(basename \"$(pwd)\").json\"\n        (hu utils docs-index \"$DOC_DIR\" -o \"$INDEX_FILE\" 2\u003e/dev/null \u0026)\n        echo \"Building docs index in background: $INDEX_FILE\"\n    fi\nfi\n\necho -e \"\\nSession initialized. Token-saving features active:\"\necho \"  - Context tracking: prevents duplicate file reads\"\necho \"  - Large file warnings: suggests --outline/--around\"\necho \"  - Grep limits: caps broad searches\"\necho -e \"\\nBypass with: HU_SKIP_HOOKS=1\"\nexit 0\n\"#;\n\npub const HOOK_SESSION_END: \u0026str = r#\"#!/bin/bash\n# Session-End Hook: Cleanup context tracking\nset -euo pipefail\n[[ \"${HU_SKIP_HOOKS:-}\" == \"1\" ]] \u0026\u0026 exit 0\n\nif command -v hu \u0026\u003e/dev/null; then\n    SUMMARY=$(hu context summary 2\u003e/dev/null || echo \"\")\n    if [[ -n \"$SUMMARY\" ]] \u0026\u0026 ! echo \"$SUMMARY\" | grep -q \"No files\"; then\n        echo \"Session context summary:\"\n        echo \"$SUMMARY\"\n    fi\n    hu context clear 2\u003e/dev/null || true\nfi\n\nINDEX_FILE=\"/tmp/hu-docs-index-$(basename \"$(pwd)\").json\"\n[[ -f \"$INDEX_FILE\" ]] \u0026\u0026 rm -f \"$INDEX_FILE\"\necho \"Session cleanup complete\"\nexit 0\n\"#;\n\n// ============================================================================\n// COMMANDS - Context\n// ============================================================================\n\npub const CMD_CONTEXT_TRACK: \u0026str = r#\"Track file(s) as loaded in context.\n\n```bash\nhu context track \u003cfile\u003e...\n```\n\nPrevents duplicate reads of the same files in a session.\n\"#;\n\npub const CMD_CONTEXT_CHECK: \u0026str = r#\"Check if file(s) are already in context.\n\n```bash\nhu context check \u003cfile\u003e...\n# Output: src/main.rs: loaded 5 minutes ago\n```\n\"#;\n\npub const CMD_CONTEXT_SUMMARY: \u0026str = r#\"Show summary of all tracked files in context.\n\n```bash\nhu context summary\n```\n\nShows all files currently tracked in the session context with load times.\n\"#;\n\npub const CMD_CONTEXT_CLEAR: \u0026str = r#\"Clear all tracked files from context.\n\n```bash\nhu context clear\n```\n\nResets the context tracking. Use at session end or to force re-reads.\n\"#;\n\n// ============================================================================\n// COMMANDS - Read\n// ============================================================================\n\npub const CMD_READ: \u0026str = r#\"Smart file reading with outline, interface, around, and diff modes.\n\n```bash\nhu read src/main.rs                        # Full file\nhu read src/main.rs -o                     # Outline (functions, structs, classes)\nhu read src/main.rs -i                     # Public interface only\nhu read src/main.rs -a 42                  # Lines around line 42\nhu read src/main.rs -a 42 -n 20            # 20 context lines around line 42\nhu read src/main.rs -d                     # Git diff (vs HEAD)\nhu read src/main.rs -d --commit abc123     # Diff against specific commit\n```\n\n| Flag | Description |\n|------|-------------|\n| `-o, --outline` | Show file outline (functions, structs, classes) |\n| `-i, --interface` | Public interface only (pub items in Rust, exports in JS) |\n| `-a, --around` | Show lines around a specific line number |\n| `-n, --context` | Context lines for `--around` (default: 10) |\n| `-d, --diff` | Show git diff |\n| `--commit` | Commit to diff against (default: HEAD) |\n\"#;\n\n// ============================================================================\n// COMMANDS - Jira\n// ============================================================================\n\npub const CMD_JIRA_AUTH: \u0026str = r#\"Authenticate with Jira via OAuth 2.0.\n\n```bash\nhu jira auth\n```\n\nOpens browser for OAuth flow, stores credentials in `~/.config/hu/credentials.toml`.\n\"#;\n\npub const CMD_JIRA_TICKETS: \u0026str = r#\"List my tickets in current sprint.\n\n```bash\nhu jira tickets           # List assigned tickets\nhu jira tickets -j        # JSON output\n```\n\"#;\n\npub const CMD_JIRA_SPRINT: \u0026str = r#\"Show all issues in current sprint.\n\n```bash\nhu jira sprint            # List all sprint issues\nhu jira sprint -j         # JSON output\n```\n\"#;\n\npub const CMD_JIRA_SEARCH: \u0026str = r#\"Search tickets using JQL.\n\n```bash\nhu jira search \"project = PROJ AND status = Open\"\nhu jira search \"assignee = currentUser()\" -j\n```\n\"#;\n\npub const CMD_JIRA_SHOW: \u0026str = r#\"Show ticket details.\n\n```bash\nhu jira show PROJ-123     # Show ticket details\nhu jira show PROJ-123 -j  # JSON output\n```\n\"#;\n\npub const CMD_JIRA_UPDATE: \u0026str = r#\"Update a Jira ticket.\n\n```bash\nhu jira update PROJ-123 --status \"In Progress\"\nhu jira update PROJ-123 --assignee \"user@example.com\"\nhu jira update PROJ-123 --comment \"Working on this\"\n```\n\"#;\n\n// ============================================================================\n// COMMANDS - GitHub\n// ============================================================================\n\npub const CMD_GH_LOGIN: \u0026str = r#\"Authenticate with GitHub using a Personal Access Token.\n\n```bash\nhu gh login \u003ctoken\u003e\n```\n\nStores token in `~/.config/hu/credentials.toml`.\n\"#;\n\npub const CMD_GH_PRS: \u0026str = r#\"List open pull requests authored by you.\n\n```bash\nhu gh prs                 # List your PRs\nhu gh prs -s \"search\"     # Search PRs\nhu gh prs -j              # JSON output\n```\n\"#;\n\npub const CMD_GH_RUNS: \u0026str = r#\"List GitHub workflow runs.\n\n```bash\nhu gh runs                # List recent runs\nhu gh runs -b main        # Filter by branch\nhu gh runs -j             # JSON output\n```\n\"#;\n\npub const CMD_GH_FAILURES: \u0026str = r#\"Extract test failures from CI.\n\n```bash\nhu gh failures            # Get failures from current branch\nhu gh failures --pr 123   # Get failures from PR\nhu gh failures -j         # JSON output\n```\n\"#;\n\npub const CMD_GH_FIX: \u0026str = r#\"Analyze CI failures and output investigation context.\n\n```bash\nhu gh fix                 # Analyze failures from current branch\nhu gh fix --pr 123        # Analyze failures from PR\nhu gh fix -j              # JSON output with file paths\n```\n\"#;\n\n// ============================================================================\n// COMMANDS - Slack\n// ============================================================================\n\npub const CMD_SLACK_AUTH: \u0026str = r#\"Authenticate with Slack (OAuth flow or direct token).\n\n```bash\nhu slack auth             # Start OAuth flow\nhu slack auth \u003ctoken\u003e     # Use direct token\n```\n\"#;\n\npub const CMD_SLACK_CHANNELS: \u0026str = r#\"List channels in the workspace.\n\n```bash\nhu slack channels         # List all channels\nhu slack channels -j      # JSON output\n```\n\"#;\n\npub const CMD_SLACK_INFO: \u0026str = r#\"Show channel details.\n\n```bash\nhu slack info #channel    # Show channel info\nhu slack info C123456     # By channel ID\n```\n\"#;\n\npub const CMD_SLACK_SEND: \u0026str = r#\"Send a message to a channel.\n\n```bash\nhu slack send #channel \"Hello world\"\nhu slack send C123456 \"Message text\"\n```\n\"#;\n\npub const CMD_SLACK_HISTORY: \u0026str = r#\"Show message history for a channel.\n\n```bash\nhu slack history #channel      # Recent messages\nhu slack history #channel -n 50  # Last 50 messages\n```\n\"#;\n\npub const CMD_SLACK_SEARCH: \u0026str = r#\"Search Slack messages.\n\n```bash\nhu slack search \"query\"        # Search messages\nhu slack search \"from:@user\"   # Search by user\n```\n\"#;\n\npub const CMD_SLACK_USERS: \u0026str = r#\"List users in the workspace.\n\n```bash\nhu slack users            # List all users\nhu slack users -j         # JSON output\n```\n\"#;\n\npub const CMD_SLACK_CONFIG: \u0026str = r#\"Show Slack configuration status.\n\n```bash\nhu slack config           # Show config\nhu slack config -j        # JSON output\n```\n\"#;\n\npub const CMD_SLACK_WHOAMI: \u0026str = r#\"Show current user info from token.\n\n```bash\nhu slack whoami           # Show current user\n```\n\"#;\n\npub const CMD_SLACK_TIDY: \u0026str = r#\"Mark channels as read if no direct mentions.\n\n```bash\nhu slack tidy             # Tidy all channels\nhu slack tidy -d          # Dry run\n```\n\"#;\n\n// ============================================================================\n// COMMANDS - PagerDuty\n// ============================================================================\n\npub const CMD_PD_CONFIG: \u0026str = r#\"Show PagerDuty configuration status.\n\n```bash\nhu pagerduty config       # Show config\nhu pagerduty config -j    # JSON output\n```\n\"#;\n\npub const CMD_PD_AUTH: \u0026str = r#\"Set PagerDuty API token.\n\n```bash\nhu pagerduty auth \u003ctoken\u003e\n```\n\"#;\n\npub const CMD_PD_ONCALL: \u0026str = r#\"Show who's currently on call.\n\n```bash\nhu pagerduty oncall       # Show on-call\nhu pagerduty oncall -j    # JSON output\n```\n\"#;\n\npub const CMD_PD_ALERTS: \u0026str = r#\"List active alerts (triggered + acknowledged).\n\n```bash\nhu pagerduty alerts       # List alerts\nhu pagerduty alerts -j    # JSON output\n```\n\"#;\n\npub const CMD_PD_INCIDENTS: \u0026str = r#\"List incidents with filters.\n\n```bash\nhu pagerduty incidents              # List incidents\nhu pagerduty incidents --status triggered\nhu pagerduty incidents -j           # JSON output\n```\n\"#;\n\npub const CMD_PD_SHOW: \u0026str = r#\"Show incident details.\n\n```bash\nhu pagerduty show \u003cincident-id\u003e\nhu pagerduty show \u003cincident-id\u003e -j  # JSON output\n```\n\"#;\n\npub const CMD_PD_WHOAMI: \u0026str = r#\"Show current PagerDuty user info.\n\n```bash\nhu pagerduty whoami\n```\n\"#;\n\n// ============================================================================\n// COMMANDS - Sentry\n// ============================================================================\n\npub const CMD_SENTRY_CONFIG: \u0026str = r#\"Show Sentry configuration status.\n\n```bash\nhu sentry config          # Show config\nhu sentry config -j       # JSON output\n```\n\"#;\n\npub const CMD_SENTRY_AUTH: \u0026str = r#\"Set Sentry auth token.\n\n```bash\nhu sentry auth \u003ctoken\u003e\n```\n\"#;\n\npub const CMD_SENTRY_ISSUES: \u0026str = r#\"List Sentry issues.\n\n```bash\nhu sentry issues          # List recent issues\nhu sentry issues -j       # JSON output\n```\n\"#;\n\npub const CMD_SENTRY_SHOW: \u0026str = r#\"Show Sentry issue details.\n\n```bash\nhu sentry show \u003cissue-id\u003e\nhu sentry show \u003cissue-id\u003e -j  # JSON output\n```\n\"#;\n\npub const CMD_SENTRY_EVENTS: \u0026str = r#\"List events for a Sentry issue.\n\n```bash\nhu sentry events \u003cissue-id\u003e\nhu sentry events \u003cissue-id\u003e -j  # JSON output\n```\n\"#;\n\n// ============================================================================\n// COMMANDS - NewRelic\n// ============================================================================\n\npub const CMD_NR_CONFIG: \u0026str = r#\"Show NewRelic configuration status.\n\n```bash\nhu newrelic config        # Show config\nhu newrelic config -j     # JSON output\n```\n\"#;\n\npub const CMD_NR_AUTH: \u0026str = r#\"Set NewRelic API key and account ID.\n\n```bash\nhu newrelic auth \u003capi-key\u003e \u003caccount-id\u003e\n```\n\"#;\n\npub const CMD_NR_ISSUES: \u0026str = r#\"List recent NewRelic issues.\n\n```bash\nhu newrelic issues        # List issues\nhu newrelic issues -j     # JSON output\n```\n\"#;\n\npub const CMD_NR_INCIDENTS: \u0026str = r#\"List recent NewRelic incidents.\n\n```bash\nhu newrelic incidents     # List incidents\nhu newrelic incidents -j  # JSON output\n```\n\"#;\n\npub const CMD_NR_QUERY: \u0026str = r#\"Run NRQL query.\n\n```bash\nhu newrelic query \"SELECT * FROM Transaction LIMIT 10\"\nhu newrelic query \"SELECT count(*) FROM Transaction\" -j\n```\n\"#;\n\n// ============================================================================\n// COMMANDS - EKS\n// ============================================================================\n\npub const CMD_EKS_LIST: \u0026str = r#\"List pods in the EKS cluster.\n\n```bash\nhu eks list               # List all pods\nhu eks list -n namespace  # Filter by namespace\nhu eks list -j            # JSON output\n```\n\"#;\n\npub const CMD_EKS_EXEC: \u0026str = r#\"Execute a command in a pod (interactive shell by default).\n\n```bash\nhu eks exec \u003cpod\u003e                    # Open shell\nhu eks exec \u003cpod\u003e -- ls -la          # Run command\nhu eks exec \u003cpod\u003e -n namespace       # Specify namespace\n```\n\"#;\n\npub const CMD_EKS_LOGS: \u0026str = r#\"Tail logs from a pod.\n\n```bash\nhu eks logs \u003cpod\u003e                    # Tail logs\nhu eks logs \u003cpod\u003e -f                 # Follow logs\nhu eks logs \u003cpod\u003e -n namespace       # Specify namespace\nhu eks logs \u003cpod\u003e --since 1h         # Logs from last hour\n```\n\"#;\n\n// ============================================================================\n// COMMANDS - Pipeline\n// ============================================================================\n\npub const CMD_PIPELINE_LIST: \u0026str = r#\"List all CodePipeline pipelines.\n\n```bash\nhu pipeline list          # List pipelines\nhu pipeline list -j       # JSON output\n```\n\"#;\n\npub const CMD_PIPELINE_STATUS: \u0026str = r#\"Show pipeline status (stages and actions).\n\n```bash\nhu pipeline status \u003cpipeline-name\u003e\nhu pipeline status \u003cpipeline-name\u003e -j  # JSON output\n```\n\"#;\n\npub const CMD_PIPELINE_HISTORY: \u0026str = r#\"Show pipeline execution history.\n\n```bash\nhu pipeline history \u003cpipeline-name\u003e\nhu pipeline history \u003cpipeline-name\u003e -n 10  # Last 10 executions\n```\n\"#;\n\n// ============================================================================\n// COMMANDS - Utils\n// ============================================================================\n\npub const CMD_UTILS_FETCH_HTML: \u0026str = r#\"Fetch URL and convert to markdown.\n\n```bash\nhu utils fetch-html \u003curl\u003e              # Fetch and convert\nhu utils fetch-html \u003curl\u003e -c           # Extra cleaning\nhu utils fetch-html \u003curl\u003e -s \"article\" # Target CSS selector\nhu utils fetch-html \u003curl\u003e -o out.md    # Write to file\n```\n\"#;\n\npub const CMD_UTILS_GREP: \u0026str = r#\"Smart grep with token-saving options.\n\n```bash\nhu utils grep \"pattern\" path/          # Search in path\nhu utils grep \"pattern\" -g \"*.rs\"      # Filter by glob\nhu utils grep \"pattern\" --refs         # File paths only\nhu utils grep \"pattern\" -n 20          # Limit results\n```\n\"#;\n\npub const CMD_UTILS_WEB_SEARCH: \u0026str = r#\"Web search using Brave Search API.\n\n```bash\nhu utils web-search \"query\"            # Search web\nhu utils web-search \"query\" -n 10      # Limit results\nhu utils web-search \"query\" -j         # JSON output\n```\n\"#;\n\npub const CMD_UTILS_DOCS_INDEX: \u0026str = r#\"Build heading index for markdown files.\n\n```bash\nhu utils docs-index docs/              # Build index\nhu utils docs-index docs/ -o index.json  # Output to file\n```\n\"#;\n\npub const CMD_UTILS_DOCS_SEARCH: \u0026str = r#\"Search docs index for matching sections.\n\n```bash\nhu utils docs-search \"query\" -i index.json\nhu utils docs-search \"authentication\" -i docs-index.json\n```\n\"#;\n\npub const CMD_UTILS_DOCS_SECTION: \u0026str = r#\"Extract a section from a markdown file by heading.\n\n```bash\nhu utils docs-section docs/api.md \"Authentication\"\nhu utils docs-section README.md \"Installation\"\n```\n\"#;\n\n// ============================================================================\n// COMMANDS - Data\n// ============================================================================\n\npub const CMD_DATA_SYNC: \u0026str = r#\"Sync Claude Code data to local database.\n\n```bash\nhu data sync              # Incremental sync\nhu data sync -f           # Force full sync\n```\n\"#;\n\npub const CMD_DATA_CONFIG: \u0026str = r#\"Show data configuration.\n\n```bash\nhu data config            # Show config\nhu data config -j         # JSON output\n```\n\"#;\n\npub const CMD_DATA_STATS: \u0026str = r#\"Usage statistics.\n\n```bash\nhu data stats             # Show stats\nhu data stats -j          # JSON output\n```\n\"#;\n\npub const CMD_DATA_SEARCH: \u0026str = r#\"Search messages.\n\n```bash\nhu data search \"query\"    # Search messages\nhu data search \"error\" -n 20  # Limit results\n```\n\"#;\n\npub const CMD_DATA_TODOS: \u0026str = r#\"Todo operations.\n\n```bash\nhu data todos pending     # Show pending todos\nhu data todos all         # Show all todos\nhu data todos -j          # JSON output\n```\n\"#;\n\npub const CMD_DATA_TOOLS: \u0026str = r#\"Tool usage statistics.\n\n```bash\nhu data tools             # Show tool usage\nhu data tools -j          # JSON output\n```\n\"#;\n\npub const CMD_DATA_ERRORS: \u0026str = r#\"Extract errors from debug logs.\n\n```bash\nhu data errors            # Show recent errors\nhu data errors -n 50      # Last 50 errors\n```\n\"#;\n\npub const CMD_DATA_PRICING: \u0026str = r#\"Pricing analysis.\n\n```bash\nhu data pricing           # Show pricing analysis\nhu data pricing -j        # JSON output\n```\n\"#;\n\npub const CMD_DATA_SESSION: \u0026str = r#\"Session operations.\n\n```bash\nhu data session list      # List sessions\nhu data session list -p . # Filter by project\nhu data session show \u003cid\u003e # Show session details\n```\n\"#;\n\npub const CMD_DATA_BRANCHES: \u0026str = r#\"Branch activity statistics.\n\n```bash\nhu data branches          # Show branch stats\nhu data branches -j       # JSON output\n```\n\"#;\n\n// ============================================================================\n// COMMANDS - Install\n// ============================================================================\n\npub const CMD_INSTALL_LIST: \u0026str = r#\"List available components.\n\n```bash\nhu install list           # List all components\n```\n\"#;\n\npub const CMD_INSTALL_PREVIEW: \u0026str = r#\"Show what would be installed without making changes.\n\n```bash\nhu install preview              # Preview global install\nhu install preview --local      # Preview local install\nhu install preview --hooks-only # Preview hooks only\n```\n\"#;\n\npub const CMD_INSTALL_RUN: \u0026str = r#\"Install hooks and commands to Claude Code.\n\n```bash\nhu install run                  # Install to ~/.claude (global)\nhu install run --local          # Install to ./.claude (local)\nhu install run --force          # Override modified files\nhu install run --hooks-only     # Install only hooks\nhu install run --commands-only  # Install only commands\nhu install run hooks/hu/pre-read   # Install specific component\n```\n\"#;\n\n// ============================================================================\n// COMPONENT REGISTRY\n// ============================================================================\n\n/// All available components\npub static COMPONENTS: \u0026[Component] = \u0026[\n    // Hooks (6)\n    Component {\n        id: \"hooks/hu/pre-read\",\n        kind: ComponentKind::Hook,\n        description: \"Prevents duplicate file reads, warns on large files\",\n        path: \"hooks/hu/pre-read.sh\",\n        content: HOOK_PRE_READ,\n    },\n    Component {\n        id: \"hooks/hu/pre-grep\",\n        kind: ComponentKind::Hook,\n        description: \"Warns on broad patterns, suggests efficient modes\",\n        path: \"hooks/hu/pre-grep.sh\",\n        content: HOOK_PRE_GREP,\n    },\n    Component {\n        id: \"hooks/hu/pre-webfetch\",\n        kind: ComponentKind::Hook,\n        description: \"Logs URL fetches, warns on HTTP\",\n        path: \"hooks/hu/pre-webfetch.sh\",\n        content: HOOK_PRE_WEBFETCH,\n    },\n    Component {\n        id: \"hooks/hu/pre-websearch\",\n        kind: ComponentKind::Hook,\n        description: \"Logs searches, warns on sensitive terms\",\n        path: \"hooks/hu/pre-websearch.sh\",\n        content: HOOK_PRE_WEBSEARCH,\n    },\n    Component {\n        id: \"hooks/hu/session-start\",\n        kind: ComponentKind::Hook,\n        description: \"Cleans old files, initializes context tracking\",\n        path: \"hooks/hu/session-start.sh\",\n        content: HOOK_SESSION_START,\n    },\n    Component {\n        id: \"hooks/hu/session-end\",\n        kind: ComponentKind::Hook,\n        description: \"Shows context summary, clears tracking\",\n        path: \"hooks/hu/session-end.sh\",\n        content: HOOK_SESSION_END,\n    },\n    // Context commands (4)\n    Component {\n        id: \"commands/hu/context/track\",\n        kind: ComponentKind::Command,\n        description: \"Track files as loaded in context\",\n        path: \"commands/hu/context/track.md\",\n        content: CMD_CONTEXT_TRACK,\n    },\n    Component {\n        id: \"commands/hu/context/check\",\n        kind: ComponentKind::Command,\n        description: \"Check if files are in context\",\n        path: \"commands/hu/context/check.md\",\n        content: CMD_CONTEXT_CHECK,\n    },\n    Component {\n        id: \"commands/hu/context/summary\",\n        kind: ComponentKind::Command,\n        description: \"Show context summary\",\n        path: \"commands/hu/context/summary.md\",\n        content: CMD_CONTEXT_SUMMARY,\n    },\n    Component {\n        id: \"commands/hu/context/clear\",\n        kind: ComponentKind::Command,\n        description: \"Clear context tracking\",\n        path: \"commands/hu/context/clear.md\",\n        content: CMD_CONTEXT_CLEAR,\n    },\n    // Read command (1)\n    Component {\n        id: \"commands/hu/read\",\n        kind: ComponentKind::Command,\n        description: \"Smart file reading modes\",\n        path: \"commands/hu/read.md\",\n        content: CMD_READ,\n    },\n    // Jira commands (6)\n    Component {\n        id: \"commands/hu/jira/auth\",\n        kind: ComponentKind::Command,\n        description: \"Authenticate with Jira\",\n        path: \"commands/hu/jira/auth.md\",\n        content: CMD_JIRA_AUTH,\n    },\n    Component {\n        id: \"commands/hu/jira/tickets\",\n        kind: ComponentKind::Command,\n        description: \"List my tickets in sprint\",\n        path: \"commands/hu/jira/tickets.md\",\n        content: CMD_JIRA_TICKETS,\n    },\n    Component {\n        id: \"commands/hu/jira/sprint\",\n        kind: ComponentKind::Command,\n        description: \"Show sprint issues\",\n        path: \"commands/hu/jira/sprint.md\",\n        content: CMD_JIRA_SPRINT,\n    },\n    Component {\n        id: \"commands/hu/jira/search\",\n        kind: ComponentKind::Command,\n        description: \"Search tickets with JQL\",\n        path: \"commands/hu/jira/search.md\",\n        content: CMD_JIRA_SEARCH,\n    },\n    Component {\n        id: \"commands/hu/jira/show\",\n        kind: ComponentKind::Command,\n        description: \"Show ticket details\",\n        path: \"commands/hu/jira/show.md\",\n        content: CMD_JIRA_SHOW,\n    },\n    Component {\n        id: \"commands/hu/jira/update\",\n        kind: ComponentKind::Command,\n        description: \"Update a ticket\",\n        path: \"commands/hu/jira/update.md\",\n        content: CMD_JIRA_UPDATE,\n    },\n    // GitHub commands (5)\n    Component {\n        id: \"commands/hu/gh/login\",\n        kind: ComponentKind::Command,\n        description: \"Authenticate with GitHub\",\n        path: \"commands/hu/gh/login.md\",\n        content: CMD_GH_LOGIN,\n    },\n    Component {\n        id: \"commands/hu/gh/prs\",\n        kind: ComponentKind::Command,\n        description: \"List pull requests\",\n        path: \"commands/hu/gh/prs.md\",\n        content: CMD_GH_PRS,\n    },\n    Component {\n        id: \"commands/hu/gh/runs\",\n        kind: ComponentKind::Command,\n        description: \"List workflow runs\",\n        path: \"commands/hu/gh/runs.md\",\n        content: CMD_GH_RUNS,\n    },\n    Component {\n        id: \"commands/hu/gh/failures\",\n        kind: ComponentKind::Command,\n        description: \"Extract CI test failures\",\n        path: \"commands/hu/gh/failures.md\",\n        content: CMD_GH_FAILURES,\n    },\n    Component {\n        id: \"commands/hu/gh/fix\",\n        kind: ComponentKind::Command,\n        description: \"Analyze CI failures\",\n        path: \"commands/hu/gh/fix.md\",\n        content: CMD_GH_FIX,\n    },\n    // Slack commands (10)\n    Component {\n        id: \"commands/hu/slack/auth\",\n        kind: ComponentKind::Command,\n        description: \"Authenticate with Slack\",\n        path: \"commands/hu/slack/auth.md\",\n        content: CMD_SLACK_AUTH,\n    },\n    Component {\n        id: \"commands/hu/slack/channels\",\n        kind: ComponentKind::Command,\n        description: \"List channels\",\n        path: \"commands/hu/slack/channels.md\",\n        content: CMD_SLACK_CHANNELS,\n    },\n    Component {\n        id: \"commands/hu/slack/info\",\n        kind: ComponentKind::Command,\n        description: \"Show channel info\",\n        path: \"commands/hu/slack/info.md\",\n        content: CMD_SLACK_INFO,\n    },\n    Component {\n        id: \"commands/hu/slack/send\",\n        kind: ComponentKind::Command,\n        description: \"Send message\",\n        path: \"commands/hu/slack/send.md\",\n        content: CMD_SLACK_SEND,\n    },\n    Component {\n        id: \"commands/hu/slack/history\",\n        kind: ComponentKind::Command,\n        description: \"Show message history\",\n        path: \"commands/hu/slack/history.md\",\n        content: CMD_SLACK_HISTORY,\n    },\n    Component {\n        id: \"commands/hu/slack/search\",\n        kind: ComponentKind::Command,\n        description: \"Search messages\",\n        path: \"commands/hu/slack/search.md\",\n        content: CMD_SLACK_SEARCH,\n    },\n    Component {\n        id: \"commands/hu/slack/users\",\n        kind: ComponentKind::Command,\n        description: \"List users\",\n        path: \"commands/hu/slack/users.md\",\n        content: CMD_SLACK_USERS,\n    },\n    Component {\n        id: \"commands/hu/slack/config\",\n        kind: ComponentKind::Command,\n        description: \"Show Slack config\",\n        path: \"commands/hu/slack/config.md\",\n        content: CMD_SLACK_CONFIG,\n    },\n    Component {\n        id: \"commands/hu/slack/whoami\",\n        kind: ComponentKind::Command,\n        description: \"Show current user\",\n        path: \"commands/hu/slack/whoami.md\",\n        content: CMD_SLACK_WHOAMI,\n    },\n    Component {\n        id: \"commands/hu/slack/tidy\",\n        kind: ComponentKind::Command,\n        description: \"Mark channels as read\",\n        path: \"commands/hu/slack/tidy.md\",\n        content: CMD_SLACK_TIDY,\n    },\n    // PagerDuty commands (7)\n    Component {\n        id: \"commands/hu/pagerduty/config\",\n        kind: ComponentKind::Command,\n        description: \"Show PagerDuty config\",\n        path: \"commands/hu/pagerduty/config.md\",\n        content: CMD_PD_CONFIG,\n    },\n    Component {\n        id: \"commands/hu/pagerduty/auth\",\n        kind: ComponentKind::Command,\n        description: \"Set API token\",\n        path: \"commands/hu/pagerduty/auth.md\",\n        content: CMD_PD_AUTH,\n    },\n    Component {\n        id: \"commands/hu/pagerduty/oncall\",\n        kind: ComponentKind::Command,\n        description: \"Show on-call schedule\",\n        path: \"commands/hu/pagerduty/oncall.md\",\n        content: CMD_PD_ONCALL,\n    },\n    Component {\n        id: \"commands/hu/pagerduty/alerts\",\n        kind: ComponentKind::Command,\n        description: \"List active alerts\",\n        path: \"commands/hu/pagerduty/alerts.md\",\n        content: CMD_PD_ALERTS,\n    },\n    Component {\n        id: \"commands/hu/pagerduty/incidents\",\n        kind: ComponentKind::Command,\n        description: \"List incidents\",\n        path: \"commands/hu/pagerduty/incidents.md\",\n        content: CMD_PD_INCIDENTS,\n    },\n    Component {\n        id: \"commands/hu/pagerduty/show\",\n        kind: ComponentKind::Command,\n        description: \"Show incident details\",\n        path: \"commands/hu/pagerduty/show.md\",\n        content: CMD_PD_SHOW,\n    },\n    Component {\n        id: \"commands/hu/pagerduty/whoami\",\n        kind: ComponentKind::Command,\n        description: \"Show current user\",\n        path: \"commands/hu/pagerduty/whoami.md\",\n        content: CMD_PD_WHOAMI,\n    },\n    // Sentry commands (5)\n    Component {\n        id: \"commands/hu/sentry/config\",\n        kind: ComponentKind::Command,\n        description: \"Show Sentry config\",\n        path: \"commands/hu/sentry/config.md\",\n        content: CMD_SENTRY_CONFIG,\n    },\n    Component {\n        id: \"commands/hu/sentry/auth\",\n        kind: ComponentKind::Command,\n        description: \"Set auth token\",\n        path: \"commands/hu/sentry/auth.md\",\n        content: CMD_SENTRY_AUTH,\n    },\n    Component {\n        id: \"commands/hu/sentry/issues\",\n        kind: ComponentKind::Command,\n        description: \"List issues\",\n        path: \"commands/hu/sentry/issues.md\",\n        content: CMD_SENTRY_ISSUES,\n    },\n    Component {\n        id: \"commands/hu/sentry/show\",\n        kind: ComponentKind::Command,\n        description: \"Show issue details\",\n        path: \"commands/hu/sentry/show.md\",\n        content: CMD_SENTRY_SHOW,\n    },\n    Component {\n        id: \"commands/hu/sentry/events\",\n        kind: ComponentKind::Command,\n        description: \"List issue events\",\n        path: \"commands/hu/sentry/events.md\",\n        content: CMD_SENTRY_EVENTS,\n    },\n    // NewRelic commands (5)\n    Component {\n        id: \"commands/hu/newrelic/config\",\n        kind: ComponentKind::Command,\n        description: \"Show NewRelic config\",\n        path: \"commands/hu/newrelic/config.md\",\n        content: CMD_NR_CONFIG,\n    },\n    Component {\n        id: \"commands/hu/newrelic/auth\",\n        kind: ComponentKind::Command,\n        description: \"Set API key\",\n        path: \"commands/hu/newrelic/auth.md\",\n        content: CMD_NR_AUTH,\n    },\n    Component {\n        id: \"commands/hu/newrelic/issues\",\n        kind: ComponentKind::Command,\n        description: \"List issues\",\n        path: \"commands/hu/newrelic/issues.md\",\n        content: CMD_NR_ISSUES,\n    },\n    Component {\n        id: \"commands/hu/newrelic/incidents\",\n        kind: ComponentKind::Command,\n        description: \"List incidents\",\n        path: \"commands/hu/newrelic/incidents.md\",\n        content: CMD_NR_INCIDENTS,\n    },\n    Component {\n        id: \"commands/hu/newrelic/query\",\n        kind: ComponentKind::Command,\n        description: \"Run NRQL query\",\n        path: \"commands/hu/newrelic/query.md\",\n        content: CMD_NR_QUERY,\n    },\n    // EKS commands (3)\n    Component {\n        id: \"commands/hu/eks/list\",\n        kind: ComponentKind::Command,\n        description: \"List pods\",\n        path: \"commands/hu/eks/list.md\",\n        content: CMD_EKS_LIST,\n    },\n    Component {\n        id: \"commands/hu/eks/exec\",\n        kind: ComponentKind::Command,\n        description: \"Execute in pod\",\n        path: \"commands/hu/eks/exec.md\",\n        content: CMD_EKS_EXEC,\n    },\n    Component {\n        id: \"commands/hu/eks/logs\",\n        kind: ComponentKind::Command,\n        description: \"Tail pod logs\",\n        path: \"commands/hu/eks/logs.md\",\n        content: CMD_EKS_LOGS,\n    },\n    // Pipeline commands (3)\n    Component {\n        id: \"commands/hu/pipeline/list\",\n        kind: ComponentKind::Command,\n        description: \"List pipelines\",\n        path: \"commands/hu/pipeline/list.md\",\n        content: CMD_PIPELINE_LIST,\n    },\n    Component {\n        id: \"commands/hu/pipeline/status\",\n        kind: ComponentKind::Command,\n        description: \"Show pipeline status\",\n        path: \"commands/hu/pipeline/status.md\",\n        content: CMD_PIPELINE_STATUS,\n    },\n    Component {\n        id: \"commands/hu/pipeline/history\",\n        kind: ComponentKind::Command,\n        description: \"Show execution history\",\n        path: \"commands/hu/pipeline/history.md\",\n        content: CMD_PIPELINE_HISTORY,\n    },\n    // Utils commands (6)\n    Component {\n        id: \"commands/hu/utils/fetch-html\",\n        kind: ComponentKind::Command,\n        description: \"Fetch URL as markdown\",\n        path: \"commands/hu/utils/fetch-html.md\",\n        content: CMD_UTILS_FETCH_HTML,\n    },\n    Component {\n        id: \"commands/hu/utils/grep\",\n        kind: ComponentKind::Command,\n        description: \"Smart grep\",\n        path: \"commands/hu/utils/grep.md\",\n        content: CMD_UTILS_GREP,\n    },\n    Component {\n        id: \"commands/hu/utils/web-search\",\n        kind: ComponentKind::Command,\n        description: \"Web search\",\n        path: \"commands/hu/utils/web-search.md\",\n        content: CMD_UTILS_WEB_SEARCH,\n    },\n    Component {\n        id: \"commands/hu/utils/docs-index\",\n        kind: ComponentKind::Command,\n        description: \"Build docs index\",\n        path: \"commands/hu/utils/docs-index.md\",\n        content: CMD_UTILS_DOCS_INDEX,\n    },\n    Component {\n        id: \"commands/hu/utils/docs-search\",\n        kind: ComponentKind::Command,\n        description: \"Search docs index\",\n        path: \"commands/hu/utils/docs-search.md\",\n        content: CMD_UTILS_DOCS_SEARCH,\n    },\n    Component {\n        id: \"commands/hu/utils/docs-section\",\n        kind: ComponentKind::Command,\n        description: \"Extract doc section\",\n        path: \"commands/hu/utils/docs-section.md\",\n        content: CMD_UTILS_DOCS_SECTION,\n    },\n    // Data commands (10)\n    Component {\n        id: \"commands/hu/data/sync\",\n        kind: ComponentKind::Command,\n        description: \"Sync Claude data\",\n        path: \"commands/hu/data/sync.md\",\n        content: CMD_DATA_SYNC,\n    },\n    Component {\n        id: \"commands/hu/data/config\",\n        kind: ComponentKind::Command,\n        description: \"Show data config\",\n        path: \"commands/hu/data/config.md\",\n        content: CMD_DATA_CONFIG,\n    },\n    Component {\n        id: \"commands/hu/data/stats\",\n        kind: ComponentKind::Command,\n        description: \"Usage statistics\",\n        path: \"commands/hu/data/stats.md\",\n        content: CMD_DATA_STATS,\n    },\n    Component {\n        id: \"commands/hu/data/search\",\n        kind: ComponentKind::Command,\n        description: \"Search messages\",\n        path: \"commands/hu/data/search.md\",\n        content: CMD_DATA_SEARCH,\n    },\n    Component {\n        id: \"commands/hu/data/todos\",\n        kind: ComponentKind::Command,\n        description: \"Todo operations\",\n        path: \"commands/hu/data/todos.md\",\n        content: CMD_DATA_TODOS,\n    },\n    Component {\n        id: \"commands/hu/data/tools\",\n        kind: ComponentKind::Command,\n        description: \"Tool usage stats\",\n        path: \"commands/hu/data/tools.md\",\n        content: CMD_DATA_TOOLS,\n    },\n    Component {\n        id: \"commands/hu/data/errors\",\n        kind: ComponentKind::Command,\n        description: \"Extract errors\",\n        path: \"commands/hu/data/errors.md\",\n        content: CMD_DATA_ERRORS,\n    },\n    Component {\n        id: \"commands/hu/data/pricing\",\n        kind: ComponentKind::Command,\n        description: \"Pricing analysis\",\n        path: \"commands/hu/data/pricing.md\",\n        content: CMD_DATA_PRICING,\n    },\n    Component {\n        id: \"commands/hu/data/session\",\n        kind: ComponentKind::Command,\n        description: \"Session operations\",\n        path: \"commands/hu/data/session.md\",\n        content: CMD_DATA_SESSION,\n    },\n    Component {\n        id: \"commands/hu/data/branches\",\n        kind: ComponentKind::Command,\n        description: \"Branch statistics\",\n        path: \"commands/hu/data/branches.md\",\n        content: CMD_DATA_BRANCHES,\n    },\n    // Install commands (3)\n    Component {\n        id: \"commands/hu/install/list\",\n        kind: ComponentKind::Command,\n        description: \"List components\",\n        path: \"commands/hu/install/list.md\",\n        content: CMD_INSTALL_LIST,\n    },\n    Component {\n        id: \"commands/hu/install/preview\",\n        kind: ComponentKind::Command,\n        description: \"Preview install\",\n        path: \"commands/hu/install/preview.md\",\n        content: CMD_INSTALL_PREVIEW,\n    },\n    Component {\n        id: \"commands/hu/install/run\",\n        kind: ComponentKind::Command,\n        description: \"Run install\",\n        path: \"commands/hu/install/run.md\",\n        content: CMD_INSTALL_RUN,\n    },\n];\n\n/// Get components filtered by kind\npub fn get_components(include_hooks: bool, include_commands: bool) -\u003e Vec\u003c\u0026'static Component\u003e {\n    COMPONENTS\n        .iter()\n        .filter(|c| match c.kind {\n            ComponentKind::Hook =\u003e include_hooks,\n            ComponentKind::Command =\u003e include_commands,\n        })\n        .collect()\n}\n\n/// Get hooks only\npub fn get_hooks() -\u003e Vec\u003c\u0026'static Component\u003e {\n    get_components(true, false)\n}\n\n/// Get commands only\npub fn get_commands() -\u003e Vec\u003c\u0026'static Component\u003e {\n    get_components(false, true)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn components_count() {\n        assert_eq!(COMPONENTS.len(), 74); // 6 hooks + 68 commands\n    }\n\n    #[test]\n    fn hooks_count() {\n        assert_eq!(get_hooks().len(), 6);\n    }\n\n    #[test]\n    fn commands_count() {\n        assert_eq!(get_commands().len(), 68);\n    }\n\n    #[test]\n    fn all_hooks_have_sh_extension() {\n        for c in get_hooks() {\n            assert!(c.path.ends_with(\".sh\"), \"Hook {} should end with .sh\", c.id);\n        }\n    }\n\n    #[test]\n    fn all_commands_have_md_extension() {\n        for c in get_commands() {\n            assert!(\n                c.path.ends_with(\".md\"),\n                \"Command {} should end with .md\",\n                c.id\n            );\n        }\n    }\n\n    #[test]\n    fn all_hooks_have_shebang() {\n        for c in get_hooks() {\n            assert!(\n                c.content.starts_with(\"#!/bin/bash\"),\n                \"Hook {} should start with shebang\",\n                c.id\n            );\n        }\n    }\n\n    #[test]\n    fn unique_component_ids() {\n        let mut ids: Vec\u003c_\u003e = COMPONENTS.iter().map(|c| c.id).collect();\n        ids.sort();\n        let original_len = ids.len();\n        ids.dedup();\n        assert_eq!(ids.len(), original_len, \"Component IDs must be unique\");\n    }\n\n    #[test]\n    fn unique_component_paths() {\n        let mut paths: Vec\u003c_\u003e = COMPONENTS.iter().map(|c| c.path).collect();\n        paths.sort();\n        let original_len = paths.len();\n        paths.dedup();\n        assert_eq!(paths.len(), original_len, \"Component paths must be unique\");\n    }\n}\n","traces":[{"line":1313,"address":[],"length":0,"stats":{"Line":9}},{"line":1314,"address":[],"length":0,"stats":{"Line":9}},{"line":1316,"address":[],"length":0,"stats":{"Line":675}},{"line":1317,"address":[],"length":0,"stats":{"Line":54}},{"line":1318,"address":[],"length":0,"stats":{"Line":612}},{"line":1324,"address":[],"length":0,"stats":{"Line":4}},{"line":1325,"address":[],"length":0,"stats":{"Line":4}},{"line":1329,"address":[],"length":0,"stats":{"Line":2}},{"line":1330,"address":[],"length":0,"stats":{"Line":2}}],"covered":9,"coverable":9},{"path":["/","Users","chi","Projects","hu","src","install","types.rs"],"content":"use std::path::{Path, PathBuf};\n\n/// A component that can be installed\n#[derive(Debug, Clone)]\npub struct Component {\n    pub id: \u0026'static str,\n    pub kind: ComponentKind,\n    pub description: \u0026'static str,\n    pub path: \u0026'static str,\n    pub content: \u0026'static str,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum ComponentKind {\n    Hook,\n    Command,\n}\n\nimpl ComponentKind {\n    pub fn label(\u0026self) -\u003e \u0026'static str {\n        match self {\n            ComponentKind::Hook =\u003e \"hook\",\n            ComponentKind::Command =\u003e \"command\",\n        }\n    }\n}\n\nimpl Component {\n    pub fn target_path(\u0026self, base_dir: \u0026Path) -\u003e PathBuf {\n        base_dir.join(self.path)\n    }\n}\n\n/// Result of checking a component's install status\n#[derive(Debug, Clone)]\npub struct ComponentStatus {\n    pub component: \u0026'static Component,\n    pub status: InstallStatus,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum InstallStatus {\n    /// Not installed\n    Missing,\n    /// Installed and matches\n    Current,\n    /// Installed but content differs\n    Modified,\n}\n\nimpl InstallStatus {\n    pub fn symbol(\u0026self) -\u003e \u0026'static str {\n        match self {\n            InstallStatus::Missing =\u003e \"\",\n            InstallStatus::Current =\u003e \"\",\n            InstallStatus::Modified =\u003e \"\",\n        }\n    }\n\n    pub fn label(\u0026self) -\u003e \u0026'static str {\n        match self {\n            InstallStatus::Missing =\u003e \"missing\",\n            InstallStatus::Current =\u003e \"current\",\n            InstallStatus::Modified =\u003e \"modified\",\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn component_kind_labels() {\n        assert_eq!(ComponentKind::Hook.label(), \"hook\");\n        assert_eq!(ComponentKind::Command.label(), \"command\");\n    }\n\n    #[test]\n    fn install_status_symbols() {\n        assert_eq!(InstallStatus::Missing.symbol(), \"\");\n        assert_eq!(InstallStatus::Current.symbol(), \"\");\n        assert_eq!(InstallStatus::Modified.symbol(), \"\");\n    }\n\n    #[test]\n    fn target_path_combines_base_and_component_path() {\n        let component = Component {\n            id: \"test\",\n            kind: ComponentKind::Hook,\n            description: \"Test hook\",\n            path: \"hooks/test.sh\",\n            content: \"#!/bin/bash\\necho test\",\n        };\n        let base = PathBuf::from(\"/home/user/.claude\");\n        assert_eq!(\n            component.target_path(\u0026base),\n            PathBuf::from(\"/home/user/.claude/hooks/test.sh\")\n        );\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":2}},{"line":21,"address":[],"length":0,"stats":{"Line":2}},{"line":22,"address":[],"length":0,"stats":{"Line":1}},{"line":23,"address":[],"length":0,"stats":{"Line":1}},{"line":29,"address":[],"length":0,"stats":{"Line":6}},{"line":30,"address":[],"length":0,"stats":{"Line":18}},{"line":52,"address":[],"length":0,"stats":{"Line":3}},{"line":53,"address":[],"length":0,"stats":{"Line":3}},{"line":54,"address":[],"length":0,"stats":{"Line":1}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}}],"covered":11,"coverable":16},{"path":["/","Users","chi","Projects","hu","src","jira","auth","callback.rs"],"content":"use axum::{\n    extract::{Query, State},\n    response::Html,\n    routing::get,\n    Router,\n};\nuse std::collections::HashMap;\nuse std::net::SocketAddr;\nuse std::sync::Arc;\nuse tokio::sync::Mutex;\n\nuse anyhow::{Context, Result};\n\n/// OAuth callback state\n#[derive(Debug, Clone)]\npub(super) struct CallbackState {\n    pub(super) expected_state: String,\n    pub(super) code: Option\u003cString\u003e,\n    pub(super) error: Option\u003cString\u003e,\n}\n\n/// Start the local callback server\npub(super) async fn start_callback_server(state: Arc\u003cMutex\u003cCallbackState\u003e\u003e) -\u003e Result\u003c()\u003e {\n    let app = Router::new()\n        .route(\"/callback\", get(handle_callback))\n        .with_state(state.clone());\n\n    let addr = SocketAddr::from(([127, 0, 0, 1], super::CALLBACK_PORT));\n    let listener = tokio::net::TcpListener::bind(addr)\n        .await\n        .context(\"Failed to bind callback server\")?;\n\n    axum::serve(listener, app)\n        .with_graceful_shutdown(async move {\n            // Wait until we have a code or error\n            loop {\n                tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;\n                let state_lock = state.lock().await;\n                if state_lock.code.is_some() || state_lock.error.is_some() {\n                    break;\n                }\n            }\n            // Give a moment for the response to be sent\n            tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;\n        })\n        .await\n        .context(\"Callback server failed\")?;\n\n    Ok(())\n}\n\n/// Handle the OAuth callback\nasync fn handle_callback(\n    State(state): State\u003cArc\u003cMutex\u003cCallbackState\u003e\u003e\u003e,\n    Query(params): Query\u003cHashMap\u003cString, String\u003e\u003e,\n) -\u003e Html\u003c\u0026'static str\u003e {\n    let mut state_lock = state.lock().await;\n\n    // Check for error\n    if let Some(error) = params.get(\"error\") {\n        state_lock.error = Some(error.clone());\n        return Html(\n            \"\u003chtml\u003e\u003cbody\u003e\u003ch1\u003eAuthorization Failed\u003c/h1\u003e\u003cp\u003eYou can close this window.\u003c/p\u003e\u003c/body\u003e\u003c/html\u003e\",\n        );\n    }\n\n    // Verify state parameter\n    if let Some(received_state) = params.get(\"state\") {\n        if received_state != \u0026state_lock.expected_state {\n            state_lock.error = Some(\"State mismatch - possible CSRF attack\".to_string());\n            return Html(\n                \"\u003chtml\u003e\u003cbody\u003e\u003ch1\u003eError\u003c/h1\u003e\u003cp\u003eState verification failed.\u003c/p\u003e\u003c/body\u003e\u003c/html\u003e\",\n            );\n        }\n    } else {\n        state_lock.error = Some(\"Missing state parameter\".to_string());\n        return Html(\"\u003chtml\u003e\u003cbody\u003e\u003ch1\u003eError\u003c/h1\u003e\u003cp\u003eMissing state parameter.\u003c/p\u003e\u003c/body\u003e\u003c/html\u003e\");\n    }\n\n    // Get authorization code\n    if let Some(code) = params.get(\"code\") {\n        state_lock.code = Some(code.clone());\n        Html(\"\u003chtml\u003e\u003cbody\u003e\u003ch1\u003eSuccess!\u003c/h1\u003e\u003cp\u003eYou can close this window and return to the terminal.\u003c/p\u003e\u003c/body\u003e\u003c/html\u003e\")\n    } else {\n        state_lock.error = Some(\"Missing authorization code\".to_string());\n        Html(\"\u003chtml\u003e\u003cbody\u003e\u003ch1\u003eError\u003c/h1\u003e\u003cp\u003eMissing authorization code.\u003c/p\u003e\u003c/body\u003e\u003c/html\u003e\")\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":34},{"path":["/","Users","chi","Projects","hu","src","jira","auth","mod.rs"],"content":"use anyhow::{bail, Context, Result};\nuse base64::{engine::general_purpose::URL_SAFE_NO_PAD, Engine};\nuse rand::Rng;\nuse std::sync::Arc;\nuse tokio::sync::Mutex;\n\nuse crate::util::{load_credentials, save_credentials, JiraCredentials};\n\nuse super::types::OAuthConfig;\n\nmod callback;\n\nuse callback::{start_callback_server, CallbackState};\n\n#[cfg(test)]\nmod tests;\n\nconst AUTH_URL: \u0026str = \"https://auth.atlassian.com/authorize\";\nconst TOKEN_URL: \u0026str = \"https://auth.atlassian.com/oauth/token\";\nconst RESOURCES_URL: \u0026str = \"https://api.atlassian.com/oauth/token/accessible-resources\";\nconst CALLBACK_PORT: u16 = 9876;\nconst SCOPES: \u0026str = \"read:jira-work write:jira-work read:jira-user offline_access\";\n\n/// Load OAuth config from environment or config file\npub fn load_oauth_config() -\u003e Result\u003cOAuthConfig\u003e {\n    // Try environment variables first\n    if let (Ok(client_id), Ok(client_secret)) = (\n        std::env::var(\"JIRA_CLIENT_ID\"),\n        std::env::var(\"JIRA_CLIENT_SECRET\"),\n    ) {\n        return Ok(OAuthConfig {\n            client_id,\n            client_secret,\n        });\n    }\n\n    // Try config file\n    let config_path = crate::util::config_dir()?.join(\"jira-oauth.toml\");\n    if config_path.exists() {\n        let contents = std::fs::read_to_string(\u0026config_path)\n            .with_context(|| format!(\"Failed to read {}\", config_path.display()))?;\n        let config: OAuthConfig = toml::from_str(\u0026contents)\n            .with_context(|| format!(\"Failed to parse {}\", config_path.display()))?;\n        return Ok(config);\n    }\n\n    bail!(\n        \"Jira OAuth not configured. Set JIRA_CLIENT_ID and JIRA_CLIENT_SECRET environment variables, \\\n        or create {} with client_id and client_secret fields.\",\n        crate::util::config_dir()?.join(\"jira-oauth.toml\").display()\n    )\n}\n\n/// Generate a random state string for CSRF protection\npub fn generate_state() -\u003e String {\n    let mut rng = rand::thread_rng();\n    let bytes: [u8; 32] = rng.gen();\n    URL_SAFE_NO_PAD.encode(bytes)\n}\n\n/// Build the authorization URL\npub fn build_auth_url(client_id: \u0026str, state: \u0026str) -\u003e String {\n    let redirect_uri = format!(\"http://localhost:{}/callback\", CALLBACK_PORT);\n    format!(\n        \"{}?audience=api.atlassian.com\u0026client_id={}\u0026scope={}\u0026redirect_uri={}\u0026state={}\u0026response_type=code\u0026prompt=consent\",\n        AUTH_URL,\n        client_id,\n        urlencoded(SCOPES),\n        urlencoded(\u0026redirect_uri),\n        state\n    )\n}\n\n/// URL encode a string\nfn urlencoded(s: \u0026str) -\u003e String {\n    s.chars()\n        .map(|c| match c {\n            ' ' =\u003e \"%20\".to_string(),\n            ':' =\u003e \"%3A\".to_string(),\n            '/' =\u003e \"%2F\".to_string(),\n            _ =\u003e c.to_string(),\n        })\n        .collect()\n}\n\n/// Start OAuth flow and return user display name\npub async fn login() -\u003e Result\u003cString\u003e {\n    let config = load_oauth_config()?;\n    let state = generate_state();\n\n    // Start local server to receive callback\n    let callback_state = Arc::new(Mutex::new(CallbackState {\n        expected_state: state.clone(),\n        code: None,\n        error: None,\n    }));\n\n    let server_state = callback_state.clone();\n    let server = tokio::spawn(async move { start_callback_server(server_state).await });\n\n    // Open browser for authorization\n    let auth_url = build_auth_url(\u0026config.client_id, \u0026state);\n    open::that(\u0026auth_url).context(\"Failed to open browser\")?;\n\n    // Wait for callback\n    server.await??;\n\n    // Get the authorization code\n    let state_lock = callback_state.lock().await;\n    if let Some(error) = \u0026state_lock.error {\n        bail!(\"Authorization failed: {}\", error);\n    }\n    let code = state_lock\n        .code\n        .clone()\n        .context(\"No authorization code received\")?;\n    drop(state_lock);\n\n    // Exchange code for tokens\n    let tokens = exchange_code(\u0026config, \u0026code).await?;\n\n    // Get accessible resources to find cloud ID\n    let resources = get_accessible_resources(\u0026tokens.access_token).await?;\n    let resource = resources\n        .first()\n        .context(\"No accessible Jira sites found\")?;\n\n    // Get user info\n    let user = get_current_user(\u0026tokens.access_token, \u0026resource.id).await?;\n\n    // Save credentials\n    let creds = JiraCredentials {\n        access_token: tokens.access_token,\n        refresh_token: tokens.refresh_token,\n        expires_at: tokens.expires_at,\n        cloud_id: resource.id.clone(),\n        site_url: resource.url.clone(),\n    };\n    save_jira_credentials(creds)?;\n\n    Ok(user)\n}\n\n/// Token response from Atlassian\n#[derive(Debug)]\nstruct TokenResponse {\n    access_token: String,\n    refresh_token: String,\n    expires_at: i64,\n}\n\n/// Exchange authorization code for tokens\nasync fn exchange_code(config: \u0026OAuthConfig, code: \u0026str) -\u003e Result\u003cTokenResponse\u003e {\n    let client = reqwest::Client::new();\n    let redirect_uri = format!(\"http://localhost:{}/callback\", CALLBACK_PORT);\n\n    let response = client\n        .post(TOKEN_URL)\n        .json(\u0026serde_json::json!({\n            \"grant_type\": \"authorization_code\",\n            \"client_id\": config.client_id,\n            \"client_secret\": config.client_secret,\n            \"code\": code,\n            \"redirect_uri\": redirect_uri\n        }))\n        .send()\n        .await\n        .context(\"Failed to exchange code for tokens\")?;\n\n    if !response.status().is_success() {\n        let error_text = response.text().await.unwrap_or_default();\n        bail!(\"Token exchange failed: {}\", error_text);\n    }\n\n    let json: serde_json::Value = response\n        .json()\n        .await\n        .context(\"Failed to parse token response\")?;\n\n    let access_token = json[\"access_token\"]\n        .as_str()\n        .context(\"Missing access_token\")?\n        .to_string();\n    let refresh_token = json[\"refresh_token\"]\n        .as_str()\n        .context(\"Missing refresh_token\")?\n        .to_string();\n    let expires_in = json[\"expires_in\"].as_i64().unwrap_or(3600);\n    let expires_at = chrono::Utc::now().timestamp() + expires_in;\n\n    Ok(TokenResponse {\n        access_token,\n        refresh_token,\n        expires_at,\n    })\n}\n\n/// Get accessible Jira cloud resources\nasync fn get_accessible_resources(\n    access_token: \u0026str,\n) -\u003e Result\u003cVec\u003csuper::types::AccessibleResource\u003e\u003e {\n    let client = reqwest::Client::new();\n\n    let response = client\n        .get(RESOURCES_URL)\n        .bearer_auth(access_token)\n        .send()\n        .await\n        .context(\"Failed to get accessible resources\")?;\n\n    if !response.status().is_success() {\n        let error_text = response.text().await.unwrap_or_default();\n        bail!(\"Failed to get accessible resources: {}\", error_text);\n    }\n\n    let json: serde_json::Value = response.json().await?;\n    let resources: Vec\u003csuper::types::AccessibleResource\u003e = json\n        .as_array()\n        .context(\"Expected array of resources\")?\n        .iter()\n        .filter_map(|r| {\n            Some(super::types::AccessibleResource {\n                id: r[\"id\"].as_str()?.to_string(),\n                url: r[\"url\"].as_str()?.to_string(),\n                name: r[\"name\"].as_str()?.to_string(),\n            })\n        })\n        .collect();\n\n    Ok(resources)\n}\n\n/// Get current user display name\nasync fn get_current_user(access_token: \u0026str, cloud_id: \u0026str) -\u003e Result\u003cString\u003e {\n    let client = reqwest::Client::new();\n    let url = format!(\n        \"https://api.atlassian.com/ex/jira/{}/rest/api/3/myself\",\n        cloud_id\n    );\n\n    let response = client\n        .get(\u0026url)\n        .bearer_auth(access_token)\n        .send()\n        .await\n        .context(\"Failed to get current user\")?;\n\n    if !response.status().is_success() {\n        let error_text = response.text().await.unwrap_or_default();\n        bail!(\"Failed to get current user: {}\", error_text);\n    }\n\n    let json: serde_json::Value = response.json().await?;\n    let display_name = json[\"displayName\"]\n        .as_str()\n        .context(\"Missing displayName\")?\n        .to_string();\n\n    Ok(display_name)\n}\n\n/// Refresh access token if expired or about to expire\npub async fn refresh_token_if_needed() -\u003e Result\u003cString\u003e {\n    let creds = get_credentials().context(\"Not authenticated. Run `hu jira auth` first.\")?;\n\n    // Check if token expires in the next 5 minutes\n    let now = chrono::Utc::now().timestamp();\n    if creds.expires_at \u003e now + 300 {\n        return Ok(creds.access_token);\n    }\n\n    // Need to refresh\n    let config = load_oauth_config()?;\n    let tokens = refresh_token(\u0026config, \u0026creds.refresh_token).await?;\n\n    // Save updated credentials\n    let new_creds = JiraCredentials {\n        access_token: tokens.access_token.clone(),\n        refresh_token: tokens.refresh_token,\n        expires_at: tokens.expires_at,\n        cloud_id: creds.cloud_id,\n        site_url: creds.site_url,\n    };\n    save_jira_credentials(new_creds)?;\n\n    Ok(tokens.access_token)\n}\n\n/// Refresh access token\nasync fn refresh_token(config: \u0026OAuthConfig, refresh_token: \u0026str) -\u003e Result\u003cTokenResponse\u003e {\n    let client = reqwest::Client::new();\n\n    let response = client\n        .post(TOKEN_URL)\n        .json(\u0026serde_json::json!({\n            \"grant_type\": \"refresh_token\",\n            \"client_id\": config.client_id,\n            \"client_secret\": config.client_secret,\n            \"refresh_token\": refresh_token\n        }))\n        .send()\n        .await\n        .context(\"Failed to refresh token\")?;\n\n    if !response.status().is_success() {\n        let error_text = response.text().await.unwrap_or_default();\n        bail!(\"Token refresh failed: {}\", error_text);\n    }\n\n    let json: serde_json::Value = response\n        .json()\n        .await\n        .context(\"Failed to parse token response\")?;\n\n    let access_token = json[\"access_token\"]\n        .as_str()\n        .context(\"Missing access_token\")?\n        .to_string();\n    let new_refresh_token = json[\"refresh_token\"]\n        .as_str()\n        .unwrap_or(refresh_token)\n        .to_string();\n    let expires_in = json[\"expires_in\"].as_i64().unwrap_or(3600);\n    let expires_at = chrono::Utc::now().timestamp() + expires_in;\n\n    Ok(TokenResponse {\n        access_token,\n        refresh_token: new_refresh_token,\n        expires_at,\n    })\n}\n\n/// Get stored Jira credentials\npub fn get_credentials() -\u003e Option\u003cJiraCredentials\u003e {\n    load_credentials().ok().and_then(|c| c.jira)\n}\n\n/// Save Jira credentials\nfn save_jira_credentials(jira: JiraCredentials) -\u003e Result\u003c()\u003e {\n    let mut creds = load_credentials().unwrap_or_default();\n    creds.jira = Some(jira);\n    save_credentials(\u0026creds)\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":4}},{"line":56,"address":[],"length":0,"stats":{"Line":8}},{"line":57,"address":[],"length":0,"stats":{"Line":16}},{"line":58,"address":[],"length":0,"stats":{"Line":12}},{"line":62,"address":[],"length":0,"stats":{"Line":3}},{"line":63,"address":[],"length":0,"stats":{"Line":9}},{"line":64,"address":[],"length":0,"stats":{"Line":3}},{"line":68,"address":[],"length":0,"stats":{"Line":6}},{"line":69,"address":[],"length":0,"stats":{"Line":6}},{"line":75,"address":[],"length":0,"stats":{"Line":10}},{"line":76,"address":[],"length":0,"stats":{"Line":20}},{"line":77,"address":[],"length":0,"stats":{"Line":303}},{"line":78,"address":[],"length":0,"stats":{"Line":20}},{"line":79,"address":[],"length":0,"stats":{"Line":32}},{"line":80,"address":[],"length":0,"stats":{"Line":20}},{"line":81,"address":[],"length":0,"stats":{"Line":514}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":2}},{"line":264,"address":[],"length":0,"stats":{"Line":3}},{"line":267,"address":[],"length":0,"stats":{"Line":3}},{"line":268,"address":[],"length":0,"stats":{"Line":1}},{"line":269,"address":[],"length":0,"stats":{"Line":1}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":3}},{"line":335,"address":[],"length":0,"stats":{"Line":9}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}}],"covered":23,"coverable":159},{"path":["/","Users","chi","Projects","hu","src","jira","auth","tests.rs"],"content":"use super::*;\nuse serde_json::json;\n\n#[test]\nfn generate_state_returns_nonempty_string() {\n    let state = generate_state();\n    assert!(!state.is_empty());\n}\n\n#[test]\nfn generate_state_returns_unique_values() {\n    let state1 = generate_state();\n    let state2 = generate_state();\n    assert_ne!(state1, state2);\n}\n\n#[test]\nfn generate_state_is_url_safe() {\n    let state = generate_state();\n    // URL-safe base64 only uses alphanumeric, dash, underscore\n    assert!(state\n        .chars()\n        .all(|c| c.is_alphanumeric() || c == '-' || c == '_'));\n}\n\n#[test]\nfn build_auth_url_contains_required_params() {\n    let url = build_auth_url(\"test_client_id\", \"test_state\");\n    assert!(url.contains(\"client_id=test_client_id\"));\n    assert!(url.contains(\"state=test_state\"));\n    assert!(url.contains(\"response_type=code\"));\n    assert!(url.contains(\"audience=api.atlassian.com\"));\n    assert!(url.contains(\"prompt=consent\"));\n}\n\n#[test]\nfn build_auth_url_contains_scopes() {\n    let url = build_auth_url(\"id\", \"state\");\n    assert!(url.contains(\"read%3Ajira-work\")); // read:jira-work encoded\n    assert!(url.contains(\"write%3Ajira-work\")); // write:jira-work encoded\n    assert!(url.contains(\"offline_access\"));\n}\n\n#[test]\nfn build_auth_url_contains_redirect_uri() {\n    let url = build_auth_url(\"id\", \"state\");\n    assert!(url.contains(\"redirect_uri=http%3A%2F%2Flocalhost%3A9876%2Fcallback\"));\n}\n\n#[test]\nfn urlencoded_encodes_spaces() {\n    assert_eq!(urlencoded(\"hello world\"), \"hello%20world\");\n}\n\n#[test]\nfn urlencoded_encodes_colons() {\n    assert_eq!(urlencoded(\"a:b\"), \"a%3Ab\");\n}\n\n#[test]\nfn urlencoded_encodes_slashes() {\n    assert_eq!(urlencoded(\"a/b\"), \"a%2Fb\");\n}\n\n#[test]\nfn urlencoded_preserves_alphanumeric() {\n    assert_eq!(urlencoded(\"abc123\"), \"abc123\");\n}\n\n#[test]\nfn parse_token_response_extracts_fields() {\n    let json = json!({\n        \"access_token\": \"access123\",\n        \"refresh_token\": \"refresh456\",\n        \"expires_in\": 7200\n    });\n    let (access, refresh, expires_in) = parse_token_response(\u0026json).unwrap();\n    assert_eq!(access, \"access123\");\n    assert_eq!(refresh, \"refresh456\");\n    assert_eq!(expires_in, 7200);\n}\n\n#[test]\nfn parse_token_response_uses_default_expires() {\n    let json = json!({\n        \"access_token\": \"access\",\n        \"refresh_token\": \"refresh\"\n    });\n    let (_, _, expires_in) = parse_token_response(\u0026json).unwrap();\n    assert_eq!(expires_in, 3600);\n}\n\n#[test]\nfn parse_token_response_fails_missing_access_token() {\n    let json = json!({\n        \"refresh_token\": \"refresh\"\n    });\n    let result = parse_token_response(\u0026json);\n    assert!(result.is_err());\n}\n\n#[test]\nfn parse_token_response_fails_missing_refresh_token() {\n    let json = json!({\n        \"access_token\": \"access\"\n    });\n    let result = parse_token_response(\u0026json);\n    assert!(result.is_err());\n}\n\n#[test]\nfn parse_accessible_resources_extracts_resources() {\n    let json = json!([\n        {\"id\": \"cloud1\", \"url\": \"https://a.atlassian.net\", \"name\": \"Site A\"},\n        {\"id\": \"cloud2\", \"url\": \"https://b.atlassian.net\", \"name\": \"Site B\"}\n    ]);\n    let resources = parse_accessible_resources(\u0026json);\n    assert_eq!(resources.len(), 2);\n    assert_eq!(resources[0].id, \"cloud1\");\n    assert_eq!(resources[0].url, \"https://a.atlassian.net\");\n    assert_eq!(resources[0].name, \"Site A\");\n    assert_eq!(resources[1].id, \"cloud2\");\n}\n\n#[test]\nfn parse_accessible_resources_handles_empty_array() {\n    let json = json!([]);\n    let resources = parse_accessible_resources(\u0026json);\n    assert!(resources.is_empty());\n}\n\n#[test]\nfn parse_accessible_resources_handles_non_array() {\n    let json = json!({\"not\": \"an array\"});\n    let resources = parse_accessible_resources(\u0026json);\n    assert!(resources.is_empty());\n}\n\n#[test]\nfn parse_accessible_resources_skips_incomplete_entries() {\n    let json = json!([\n        {\"id\": \"cloud1\", \"url\": \"https://a.atlassian.net\", \"name\": \"Site A\"},\n        {\"id\": \"cloud2\"}, // missing url and name\n        {\"url\": \"https://c.atlassian.net\", \"name\": \"Site C\"} // missing id\n    ]);\n    let resources = parse_accessible_resources(\u0026json);\n    assert_eq!(resources.len(), 1);\n    assert_eq!(resources[0].id, \"cloud1\");\n}\n\n#[test]\nfn parse_user_response_extracts_display_name() {\n    let json = json!({\n        \"displayName\": \"John Doe\",\n        \"accountId\": \"123\"\n    });\n    let name = parse_user_response(\u0026json);\n    assert_eq!(name, Some(\"John Doe\".to_string()));\n}\n\n#[test]\nfn parse_user_response_returns_none_for_missing_name() {\n    let json = json!({\n        \"accountId\": \"123\"\n    });\n    let name = parse_user_response(\u0026json);\n    assert!(name.is_none());\n}\n\n#[test]\nfn get_credentials_returns_option() {\n    let result = get_credentials();\n    // Result is either Some(creds) or None\n    assert!(result.is_some() || result.is_none());\n}\n\n#[test]\nfn callback_state_debug_format() {\n    let state = CallbackState {\n        expected_state: \"test\".to_string(),\n        code: None,\n        error: None,\n    };\n    let debug_str = format!(\"{:?}\", state);\n    assert!(debug_str.contains(\"CallbackState\"));\n}\n\n#[test]\nfn callback_state_clone() {\n    let state = CallbackState {\n        expected_state: \"state123\".to_string(),\n        code: Some(\"code456\".to_string()),\n        error: None,\n    };\n    let cloned = state.clone();\n    assert_eq!(cloned.expected_state, state.expected_state);\n    assert_eq!(cloned.code, state.code);\n    assert_eq!(cloned.error, state.error);\n}\n\n#[test]\nfn token_response_debug_format() {\n    let response = TokenResponse {\n        access_token: \"access\".to_string(),\n        refresh_token: \"refresh\".to_string(),\n        expires_at: 1234567890,\n    };\n    let debug_str = format!(\"{:?}\", response);\n    assert!(debug_str.contains(\"TokenResponse\"));\n}\n\n#[test]\nfn constants_are_valid() {\n    assert!(AUTH_URL.starts_with(\"https://\"));\n    assert!(TOKEN_URL.starts_with(\"https://\"));\n    assert!(RESOURCES_URL.starts_with(\"https://\"));\n    assert!(CALLBACK_PORT \u003e 0);\n    assert!(!SCOPES.is_empty());\n}\n\n#[test]\nfn scopes_contain_required_permissions() {\n    assert!(SCOPES.contains(\"read:jira-work\"));\n    assert!(SCOPES.contains(\"write:jira-work\"));\n    assert!(SCOPES.contains(\"read:jira-user\"));\n    assert!(SCOPES.contains(\"offline_access\"));\n}\n\n/// Parse token response JSON (pure function, testable)\nfn parse_token_response(json: \u0026serde_json::Value) -\u003e Result\u003c(String, String, i64)\u003e {\n    let access_token = json[\"access_token\"]\n        .as_str()\n        .context(\"Missing access_token\")?\n        .to_string();\n    let refresh_token = json[\"refresh_token\"]\n        .as_str()\n        .context(\"Missing refresh_token\")?\n        .to_string();\n    let expires_in = json[\"expires_in\"].as_i64().unwrap_or(3600);\n\n    Ok((access_token, refresh_token, expires_in))\n}\n\n/// Parse accessible resources JSON (pure function, testable)\nfn parse_accessible_resources(\n    json: \u0026serde_json::Value,\n) -\u003e Vec\u003csuper::super::types::AccessibleResource\u003e {\n    json.as_array()\n        .unwrap_or(\u0026vec![])\n        .iter()\n        .filter_map(|r| {\n            Some(super::super::types::AccessibleResource {\n                id: r[\"id\"].as_str()?.to_string(),\n                url: r[\"url\"].as_str()?.to_string(),\n                name: r[\"name\"].as_str()?.to_string(),\n            })\n        })\n        .collect()\n}\n\n/// Parse user response JSON (pure function, testable)\nfn parse_user_response(json: \u0026serde_json::Value) -\u003e Option\u003cString\u003e {\n    json[\"displayName\"].as_str().map(|s| s.to_string())\n}\n","traces":[{"line":230,"address":[],"length":0,"stats":{"Line":4}},{"line":231,"address":[],"length":0,"stats":{"Line":7}},{"line":235,"address":[],"length":0,"stats":{"Line":5}},{"line":239,"address":[],"length":0,"stats":{"Line":8}},{"line":241,"address":[],"length":0,"stats":{"Line":4}},{"line":245,"address":[],"length":0,"stats":{"Line":4}},{"line":248,"address":[],"length":0,"stats":{"Line":12}},{"line":249,"address":[],"length":0,"stats":{"Line":4}},{"line":251,"address":[],"length":0,"stats":{"Line":9}},{"line":253,"address":[],"length":0,"stats":{"Line":15}},{"line":254,"address":[],"length":0,"stats":{"Line":12}},{"line":255,"address":[],"length":0,"stats":{"Line":9}},{"line":262,"address":[],"length":0,"stats":{"Line":2}},{"line":263,"address":[],"length":0,"stats":{"Line":8}}],"covered":14,"coverable":14},{"path":["/","Users","chi","Projects","hu","src","jira","auth_handler.rs"],"content":"use anyhow::Result;\n\nuse super::auth;\n\n/// Run the jira auth command\npub async fn run() -\u003e Result\u003c()\u003e {\n    println!(\"Opening browser for Jira authorization...\");\n    let name = auth::login().await?;\n    println!(\"\\x1b[32m\\u{2713}\\x1b[0m Logged in as {}\", name);\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    // Auth handler is thin and delegates to auth module\n    // Integration testing would require mocking the browser and OAuth flow\n    // Pure function tests are in auth.rs\n\n    #[test]\n    fn module_compiles() {\n        // Verify the module structure is correct\n        assert!(true);\n    }\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["/","Users","chi","Projects","hu","src","jira","cli.rs"],"content":"use clap::Subcommand;\n\n#[derive(Debug, Subcommand)]\npub enum JiraCommand {\n    /// Authenticate with Jira via OAuth 2.0\n    Auth,\n\n    /// List my tickets in current sprint\n    Tickets,\n\n    /// Show all issues in current sprint\n    Sprint,\n\n    /// Search tickets using JQL\n    Search {\n        /// JQL query (e.g., \"project = PROJ AND status = 'In Progress'\")\n        query: String,\n    },\n\n    /// Show ticket details\n    Show {\n        /// Ticket key (e.g., PROJ-123)\n        key: String,\n    },\n\n    /// Update a ticket\n    Update {\n        /// Ticket key (e.g., PROJ-123)\n        key: String,\n\n        /// New summary/title\n        #[arg(long)]\n        summary: Option\u003cString\u003e,\n\n        /// New status (transition)\n        #[arg(long)]\n        status: Option\u003cString\u003e,\n\n        /// Assign to user (account ID or \"me\")\n        #[arg(long)]\n        assign: Option\u003cString\u003e,\n    },\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use clap::CommandFactory;\n\n    // Helper to build a command for testing\n    fn build_cmd() -\u003e clap::Command {\n        #[derive(clap::Parser)]\n        struct TestCli {\n            #[command(subcommand)]\n            cmd: JiraCommand,\n        }\n        TestCli::command()\n    }\n\n    #[test]\n    fn parses_auth() {\n        let cmd = build_cmd();\n        let matches = cmd.try_get_matches_from([\"test\", \"auth\"]);\n        assert!(matches.is_ok());\n    }\n\n    #[test]\n    fn parses_tickets() {\n        let cmd = build_cmd();\n        let matches = cmd.try_get_matches_from([\"test\", \"tickets\"]);\n        assert!(matches.is_ok());\n    }\n\n    #[test]\n    fn parses_sprint() {\n        let cmd = build_cmd();\n        let matches = cmd.try_get_matches_from([\"test\", \"sprint\"]);\n        assert!(matches.is_ok());\n    }\n\n    #[test]\n    fn parses_search() {\n        let cmd = build_cmd();\n        let matches = cmd.try_get_matches_from([\"test\", \"search\", \"project = TEST\"]);\n        assert!(matches.is_ok());\n    }\n\n    #[test]\n    fn parses_show() {\n        let cmd = build_cmd();\n        let matches = cmd.try_get_matches_from([\"test\", \"show\", \"PROJ-123\"]);\n        assert!(matches.is_ok());\n    }\n\n    #[test]\n    fn parses_update_with_summary() {\n        let cmd = build_cmd();\n        let matches =\n            cmd.try_get_matches_from([\"test\", \"update\", \"PROJ-123\", \"--summary\", \"New title\"]);\n        assert!(matches.is_ok());\n    }\n\n    #[test]\n    fn parses_update_with_status() {\n        let cmd = build_cmd();\n        let matches = cmd.try_get_matches_from([\"test\", \"update\", \"PROJ-123\", \"--status\", \"Done\"]);\n        assert!(matches.is_ok());\n    }\n\n    #[test]\n    fn parses_update_with_assign() {\n        let cmd = build_cmd();\n        let matches = cmd.try_get_matches_from([\"test\", \"update\", \"PROJ-123\", \"--assign\", \"me\"]);\n        assert!(matches.is_ok());\n    }\n\n    #[test]\n    fn parses_update_with_all_options() {\n        let cmd = build_cmd();\n        let matches = cmd.try_get_matches_from([\n            \"test\",\n            \"update\",\n            \"PROJ-123\",\n            \"--summary\",\n            \"New title\",\n            \"--status\",\n            \"In Progress\",\n            \"--assign\",\n            \"user123\",\n        ]);\n        assert!(matches.is_ok());\n    }\n\n    #[test]\n    fn update_requires_key() {\n        let cmd = build_cmd();\n        let matches = cmd.try_get_matches_from([\"test\", \"update\", \"--summary\", \"Title\"]);\n        assert!(matches.is_err());\n    }\n\n    #[test]\n    fn search_requires_query() {\n        let cmd = build_cmd();\n        let matches = cmd.try_get_matches_from([\"test\", \"search\"]);\n        assert!(matches.is_err());\n    }\n\n    #[test]\n    fn show_requires_key() {\n        let cmd = build_cmd();\n        let matches = cmd.try_get_matches_from([\"test\", \"show\"]);\n        assert!(matches.is_err());\n    }\n\n    #[test]\n    fn jira_command_debug() {\n        let cmd = JiraCommand::Auth;\n        let debug_str = format!(\"{:?}\", cmd);\n        assert!(debug_str.contains(\"Auth\"));\n    }\n\n    #[test]\n    fn tickets_command_debug() {\n        let cmd = JiraCommand::Tickets;\n        let debug_str = format!(\"{:?}\", cmd);\n        assert!(debug_str.contains(\"Tickets\"));\n    }\n\n    #[test]\n    fn sprint_command_debug() {\n        let cmd = JiraCommand::Sprint;\n        let debug_str = format!(\"{:?}\", cmd);\n        assert!(debug_str.contains(\"Sprint\"));\n    }\n\n    #[test]\n    fn search_command_debug() {\n        let cmd = JiraCommand::Search {\n            query: \"test\".to_string(),\n        };\n        let debug_str = format!(\"{:?}\", cmd);\n        assert!(debug_str.contains(\"Search\"));\n    }\n\n    #[test]\n    fn show_command_debug() {\n        let cmd = JiraCommand::Show {\n            key: \"X-1\".to_string(),\n        };\n        let debug_str = format!(\"{:?}\", cmd);\n        assert!(debug_str.contains(\"Show\"));\n    }\n\n    #[test]\n    fn update_command_debug() {\n        let cmd = JiraCommand::Update {\n            key: \"X-1\".to_string(),\n            summary: Some(\"S\".to_string()),\n            status: None,\n            assign: None,\n        };\n        let debug_str = format!(\"{:?}\", cmd);\n        assert!(debug_str.contains(\"Update\"));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","jira","client","mod.rs"],"content":"use anyhow::{bail, Context, Result};\nuse std::future::Future;\n\nuse super::auth;\nuse super::types::{Issue, IssueUpdate, Transition, User};\n\n#[cfg(test)]\nmod tests;\n\n/// Trait for Jira API operations (enables mocking in tests)\npub trait JiraApi: Send + Sync {\n    /// Get current authenticated user\n    fn get_current_user(\u0026self) -\u003e impl Future\u003cOutput = Result\u003cUser\u003e\u003e + Send;\n\n    /// Get a single issue by key\n    fn get_issue(\u0026self, key: \u0026str) -\u003e impl Future\u003cOutput = Result\u003cIssue\u003e\u003e + Send;\n\n    /// Search issues using JQL\n    fn search_issues(\u0026self, jql: \u0026str) -\u003e impl Future\u003cOutput = Result\u003cVec\u003cIssue\u003e\u003e\u003e + Send;\n\n    /// Update issue fields\n    fn update_issue(\n        \u0026self,\n        key: \u0026str,\n        update: \u0026IssueUpdate,\n    ) -\u003e impl Future\u003cOutput = Result\u003c()\u003e\u003e + Send;\n\n    /// Get available transitions for an issue\n    fn get_transitions(\u0026self, key: \u0026str) -\u003e impl Future\u003cOutput = Result\u003cVec\u003cTransition\u003e\u003e\u003e + Send;\n\n    /// Transition an issue to a new status\n    fn transition_issue(\n        \u0026self,\n        key: \u0026str,\n        transition_id: \u0026str,\n    ) -\u003e impl Future\u003cOutput = Result\u003c()\u003e\u003e + Send;\n}\n\n/// Jira API client\npub struct JiraClient {\n    client: reqwest::Client,\n    cloud_id: String,\n    access_token: String,\n}\n\nimpl JiraClient {\n    /// Create a new authenticated Jira client\n    pub async fn new() -\u003e Result\u003cSelf\u003e {\n        let access_token = auth::refresh_token_if_needed().await?;\n        let creds =\n            auth::get_credentials().context(\"Not authenticated. Run `hu jira auth` first.\")?;\n\n        Ok(Self {\n            client: reqwest::Client::new(),\n            cloud_id: creds.cloud_id,\n            access_token,\n        })\n    }\n\n    /// Build API URL for Jira REST API v3\n    fn api_url(\u0026self, path: \u0026str) -\u003e String {\n        format!(\n            \"https://api.atlassian.com/ex/jira/{}/rest/api/3{}\",\n            self.cloud_id, path\n        )\n    }\n}\n\nimpl JiraApi for JiraClient {\n    async fn get_current_user(\u0026self) -\u003e Result\u003cUser\u003e {\n        let url = self.api_url(\"/myself\");\n        let response = self\n            .client\n            .get(\u0026url)\n            .bearer_auth(\u0026self.access_token)\n            .send()\n            .await\n            .context(\"Failed to get current user\")?;\n\n        if !response.status().is_success() {\n            let error_text = response.text().await.unwrap_or_default();\n            bail!(\"Failed to get current user: {}\", error_text);\n        }\n\n        let json: serde_json::Value = response.json().await?;\n        parse_user(\u0026json).context(\"Failed to parse user response\")\n    }\n\n    async fn get_issue(\u0026self, key: \u0026str) -\u003e Result\u003cIssue\u003e {\n        let url = self.api_url(\u0026format!(\"/issue/{}\", key));\n        let response = self\n            .client\n            .get(\u0026url)\n            .bearer_auth(\u0026self.access_token)\n            .send()\n            .await\n            .context(\"Failed to get issue\")?;\n\n        if !response.status().is_success() {\n            let error_text = response.text().await.unwrap_or_default();\n            bail!(\"Failed to get issue {}: {}\", key, error_text);\n        }\n\n        let json: serde_json::Value = response.json().await?;\n        parse_single_issue(\u0026json).context(\"Failed to parse issue\")\n    }\n\n    async fn search_issues(\u0026self, jql: \u0026str) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n        // Use the new /search/jql endpoint (the old /search was deprecated)\n        let url = self.api_url(\"/search/jql\");\n        let response = self\n            .client\n            .post(\u0026url)\n            .bearer_auth(\u0026self.access_token)\n            .json(\u0026serde_json::json!({\n                \"jql\": jql,\n                \"fields\": [\"summary\", \"status\", \"issuetype\", \"assignee\", \"description\", \"updated\"]\n            }))\n            .send()\n            .await\n            .context(\"Failed to search issues\")?;\n\n        if !response.status().is_success() {\n            let error_text = response.text().await.unwrap_or_default();\n            bail!(\"Failed to search issues: {}\", error_text);\n        }\n\n        let json: serde_json::Value = response.json().await?;\n        Ok(parse_issues(\u0026json))\n    }\n\n    async fn update_issue(\u0026self, key: \u0026str, update: \u0026IssueUpdate) -\u003e Result\u003c()\u003e {\n        let url = self.api_url(\u0026format!(\"/issue/{}\", key));\n\n        let mut fields = serde_json::Map::new();\n        if let Some(summary) = \u0026update.summary {\n            fields.insert(\"summary\".to_string(), serde_json::json!(summary));\n        }\n        if let Some(description) = \u0026update.description {\n            // Jira uses ADF format for description\n            fields.insert(\n                \"description\".to_string(),\n                serde_json::json!({\n                    \"type\": \"doc\",\n                    \"version\": 1,\n                    \"content\": [{\n                        \"type\": \"paragraph\",\n                        \"content\": [{\n                            \"type\": \"text\",\n                            \"text\": description\n                        }]\n                    }]\n                }),\n            );\n        }\n        if let Some(assignee) = \u0026update.assignee {\n            fields.insert(\n                \"assignee\".to_string(),\n                serde_json::json!({ \"accountId\": assignee }),\n            );\n        }\n\n        let body = serde_json::json!({ \"fields\": fields });\n\n        let response = self\n            .client\n            .put(\u0026url)\n            .bearer_auth(\u0026self.access_token)\n            .json(\u0026body)\n            .send()\n            .await\n            .context(\"Failed to update issue\")?;\n\n        if !response.status().is_success() {\n            let error_text = response.text().await.unwrap_or_default();\n            bail!(\"Failed to update issue {}: {}\", key, error_text);\n        }\n\n        Ok(())\n    }\n\n    async fn get_transitions(\u0026self, key: \u0026str) -\u003e Result\u003cVec\u003cTransition\u003e\u003e {\n        let url = self.api_url(\u0026format!(\"/issue/{}/transitions\", key));\n        let response = self\n            .client\n            .get(\u0026url)\n            .bearer_auth(\u0026self.access_token)\n            .send()\n            .await\n            .context(\"Failed to get transitions\")?;\n\n        if !response.status().is_success() {\n            let error_text = response.text().await.unwrap_or_default();\n            bail!(\"Failed to get transitions for {}: {}\", key, error_text);\n        }\n\n        let json: serde_json::Value = response.json().await?;\n        Ok(parse_transitions(\u0026json))\n    }\n\n    async fn transition_issue(\u0026self, key: \u0026str, transition_id: \u0026str) -\u003e Result\u003c()\u003e {\n        let url = self.api_url(\u0026format!(\"/issue/{}/transitions\", key));\n        let body = serde_json::json!({\n            \"transition\": { \"id\": transition_id }\n        });\n\n        let response = self\n            .client\n            .post(\u0026url)\n            .bearer_auth(\u0026self.access_token)\n            .json(\u0026body)\n            .send()\n            .await\n            .context(\"Failed to transition issue\")?;\n\n        if !response.status().is_success() {\n            let error_text = response.text().await.unwrap_or_default();\n            bail!(\"Failed to transition issue {}: {}\", key, error_text);\n        }\n\n        Ok(())\n    }\n}\n\n/// Parse user from JSON (pure function, testable)\npub fn parse_user(json: \u0026serde_json::Value) -\u003e Option\u003cUser\u003e {\n    Some(User {\n        account_id: json[\"accountId\"].as_str()?.to_string(),\n        display_name: json[\"displayName\"].as_str()?.to_string(),\n        email_address: json[\"emailAddress\"].as_str().map(|s| s.to_string()),\n    })\n}\n\n/// Parse issues from JSON (pure function, testable)\npub fn parse_issues(json: \u0026serde_json::Value) -\u003e Vec\u003cIssue\u003e {\n    json[\"issues\"]\n        .as_array()\n        .unwrap_or(\u0026vec![])\n        .iter()\n        .filter_map(parse_single_issue)\n        .collect()\n}\n\n/// Parse a single issue from JSON (pure function, testable)\npub fn parse_single_issue(json: \u0026serde_json::Value) -\u003e Option\u003cIssue\u003e {\n    let fields = \u0026json[\"fields\"];\n    Some(Issue {\n        key: json[\"key\"].as_str()?.to_string(),\n        summary: fields[\"summary\"].as_str()?.to_string(),\n        status: fields[\"status\"][\"name\"].as_str()?.to_string(),\n        issue_type: fields[\"issuetype\"][\"name\"].as_str()?.to_string(),\n        assignee: fields[\"assignee\"][\"displayName\"]\n            .as_str()\n            .map(|s| s.to_string()),\n        description: extract_description(fields),\n        updated: fields[\"updated\"].as_str()?.to_string(),\n    })\n}\n\n/// Extract description text from ADF format\nfn extract_description(fields: \u0026serde_json::Value) -\u003e Option\u003cString\u003e {\n    // Jira uses Atlassian Document Format (ADF) for rich text\n    // For simplicity, extract text nodes recursively\n    let description = \u0026fields[\"description\"];\n    if description.is_null() {\n        return None;\n    }\n\n    // If it's a simple string, return it\n    if let Some(s) = description.as_str() {\n        return Some(s.to_string());\n    }\n\n    // Extract text from ADF content\n    let content = description[\"content\"].as_array()?;\n    let text: Vec\u003cString\u003e = content\n        .iter()\n        .filter_map(extract_text_from_adf_node)\n        .collect();\n\n    if text.is_empty() {\n        None\n    } else {\n        Some(text.join(\"\\n\"))\n    }\n}\n\n/// Extract text from an ADF node recursively\nfn extract_text_from_adf_node(node: \u0026serde_json::Value) -\u003e Option\u003cString\u003e {\n    // If this node has text, return it\n    if let Some(text) = node[\"text\"].as_str() {\n        return Some(text.to_string());\n    }\n\n    // Otherwise, recursively extract from content\n    let content = node[\"content\"].as_array()?;\n    let texts: Vec\u003cString\u003e = content\n        .iter()\n        .filter_map(extract_text_from_adf_node)\n        .collect();\n\n    if texts.is_empty() {\n        None\n    } else {\n        Some(texts.join(\"\"))\n    }\n}\n\n/// Parse transitions from JSON (pure function, testable)\npub fn parse_transitions(json: \u0026serde_json::Value) -\u003e Vec\u003cTransition\u003e {\n    json[\"transitions\"]\n        .as_array()\n        .unwrap_or(\u0026vec![])\n        .iter()\n        .filter_map(|t| {\n            Some(Transition {\n                id: t[\"id\"].as_str()?.to_string(),\n                name: t[\"name\"].as_str()?.to_string(),\n            })\n        })\n        .collect()\n}\n\n/// Build update request body (pure function, testable)\n#[cfg(test)]\npub fn build_update_body(update: \u0026IssueUpdate) -\u003e serde_json::Value {\n    let mut fields = serde_json::Map::new();\n\n    if let Some(summary) = \u0026update.summary {\n        fields.insert(\"summary\".to_string(), serde_json::json!(summary));\n    }\n    if let Some(description) = \u0026update.description {\n        fields.insert(\n            \"description\".to_string(),\n            serde_json::json!({\n                \"type\": \"doc\",\n                \"version\": 1,\n                \"content\": [{\n                    \"type\": \"paragraph\",\n                    \"content\": [{\n                        \"type\": \"text\",\n                        \"text\": description\n                    }]\n                }]\n            }),\n        );\n    }\n    if let Some(assignee) = \u0026update.assignee {\n        fields.insert(\n            \"assignee\".to_string(),\n            serde_json::json!({ \"accountId\": assignee }),\n        );\n    }\n\n    serde_json::json!({ \"fields\": fields })\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":2}},{"line":50,"address":[],"length":0,"stats":{"Line":1}},{"line":51,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":1}},{"line":54,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":62,"address":[],"length":0,"stats":{"Line":1}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":2}},{"line":110,"address":[],"length":0,"stats":{"Line":4}},{"line":111,"address":[],"length":0,"stats":{"Line":3}},{"line":112,"address":[],"length":0,"stats":{"Line":2}},{"line":113,"address":[],"length":0,"stats":{"Line":3}},{"line":114,"address":[],"length":0,"stats":{"Line":3}},{"line":115,"address":[],"length":0,"stats":{"Line":4}},{"line":116,"address":[],"length":0,"stats":{"Line":2}},{"line":117,"address":[],"length":0,"stats":{"Line":2}},{"line":120,"address":[],"length":0,"stats":{"Line":1}},{"line":123,"address":[],"length":0,"stats":{"Line":1}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":4}},{"line":129,"address":[],"length":0,"stats":{"Line":1}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":3}},{"line":228,"address":[],"length":0,"stats":{"Line":9}},{"line":229,"address":[],"length":0,"stats":{"Line":6}},{"line":230,"address":[],"length":0,"stats":{"Line":8}},{"line":235,"address":[],"length":0,"stats":{"Line":4}},{"line":236,"address":[],"length":0,"stats":{"Line":8}},{"line":238,"address":[],"length":0,"stats":{"Line":4}},{"line":240,"address":[],"length":0,"stats":{"Line":4}},{"line":245,"address":[],"length":0,"stats":{"Line":11}},{"line":246,"address":[],"length":0,"stats":{"Line":22}},{"line":248,"address":[],"length":0,"stats":{"Line":33}},{"line":249,"address":[],"length":0,"stats":{"Line":30}},{"line":250,"address":[],"length":0,"stats":{"Line":30}},{"line":251,"address":[],"length":0,"stats":{"Line":30}},{"line":252,"address":[],"length":0,"stats":{"Line":10}},{"line":253,"address":[],"length":0,"stats":{"Line":10}},{"line":254,"address":[],"length":0,"stats":{"Line":26}},{"line":255,"address":[],"length":0,"stats":{"Line":20}},{"line":256,"address":[],"length":0,"stats":{"Line":30}},{"line":261,"address":[],"length":0,"stats":{"Line":14}},{"line":264,"address":[],"length":0,"stats":{"Line":28}},{"line":265,"address":[],"length":0,"stats":{"Line":28}},{"line":266,"address":[],"length":0,"stats":{"Line":5}},{"line":270,"address":[],"length":0,"stats":{"Line":10}},{"line":271,"address":[],"length":0,"stats":{"Line":1}},{"line":275,"address":[],"length":0,"stats":{"Line":24}},{"line":276,"address":[],"length":0,"stats":{"Line":24}},{"line":278,"address":[],"length":0,"stats":{"Line":8}},{"line":281,"address":[],"length":0,"stats":{"Line":16}},{"line":282,"address":[],"length":0,"stats":{"Line":1}},{"line":284,"address":[],"length":0,"stats":{"Line":14}},{"line":289,"address":[],"length":0,"stats":{"Line":107}},{"line":291,"address":[],"length":0,"stats":{"Line":149}},{"line":292,"address":[],"length":0,"stats":{"Line":42}},{"line":296,"address":[],"length":0,"stats":{"Line":195}},{"line":297,"address":[],"length":0,"stats":{"Line":192}},{"line":299,"address":[],"length":0,"stats":{"Line":64}},{"line":302,"address":[],"length":0,"stats":{"Line":128}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":128}},{"line":310,"address":[],"length":0,"stats":{"Line":3}},{"line":311,"address":[],"length":0,"stats":{"Line":6}},{"line":313,"address":[],"length":0,"stats":{"Line":3}},{"line":315,"address":[],"length":0,"stats":{"Line":6}},{"line":317,"address":[],"length":0,"stats":{"Line":9}},{"line":318,"address":[],"length":0,"stats":{"Line":9}},{"line":326,"address":[],"length":0,"stats":{"Line":5}},{"line":327,"address":[],"length":0,"stats":{"Line":10}},{"line":329,"address":[],"length":0,"stats":{"Line":9}},{"line":330,"address":[],"length":0,"stats":{"Line":8}},{"line":332,"address":[],"length":0,"stats":{"Line":9}},{"line":333,"address":[],"length":0,"stats":{"Line":6}},{"line":334,"address":[],"length":0,"stats":{"Line":6}},{"line":335,"address":[],"length":0,"stats":{"Line":4}},{"line":336,"address":[],"length":0,"stats":{"Line":4}},{"line":337,"address":[],"length":0,"stats":{"Line":4}},{"line":338,"address":[],"length":0,"stats":{"Line":4}},{"line":339,"address":[],"length":0,"stats":{"Line":4}},{"line":340,"address":[],"length":0,"stats":{"Line":4}},{"line":341,"address":[],"length":0,"stats":{"Line":2}},{"line":342,"address":[],"length":0,"stats":{"Line":2}},{"line":348,"address":[],"length":0,"stats":{"Line":9}},{"line":349,"address":[],"length":0,"stats":{"Line":6}},{"line":350,"address":[],"length":0,"stats":{"Line":6}},{"line":351,"address":[],"length":0,"stats":{"Line":2}},{"line":355,"address":[],"length":0,"stats":{"Line":10}}],"covered":88,"coverable":172},{"path":["/","Users","chi","Projects","hu","src","jira","client","tests.rs"],"content":"use super::*;\nuse serde_json::json;\n\n#[test]\nfn parse_user_extracts_fields() {\n    let json = json!({\n        \"accountId\": \"123\",\n        \"displayName\": \"John Doe\",\n        \"emailAddress\": \"john@example.com\"\n    });\n    let user = parse_user(\u0026json).unwrap();\n    assert_eq!(user.account_id, \"123\");\n    assert_eq!(user.display_name, \"John Doe\");\n    assert_eq!(user.email_address, Some(\"john@example.com\".to_string()));\n}\n\n#[test]\nfn parse_user_without_email() {\n    let json = json!({\n        \"accountId\": \"456\",\n        \"displayName\": \"Jane\"\n    });\n    let user = parse_user(\u0026json).unwrap();\n    assert_eq!(user.account_id, \"456\");\n    assert!(user.email_address.is_none());\n}\n\n#[test]\nfn parse_user_returns_none_for_missing_fields() {\n    let json = json!({\n        \"displayName\": \"Missing ID\"\n    });\n    let user = parse_user(\u0026json);\n    assert!(user.is_none());\n}\n\n#[test]\nfn parse_issues_extracts_issues() {\n    let json = json!({\n        \"issues\": [{\n            \"key\": \"PROJ-123\",\n            \"fields\": {\n                \"summary\": \"Fix bug\",\n                \"status\": {\"name\": \"In Progress\"},\n                \"issuetype\": {\"name\": \"Bug\"},\n                \"assignee\": {\"displayName\": \"John\"},\n                \"updated\": \"2024-01-15T10:00:00Z\"\n            }\n        }]\n    });\n    let issues = parse_issues(\u0026json);\n    assert_eq!(issues.len(), 1);\n    assert_eq!(issues[0].key, \"PROJ-123\");\n    assert_eq!(issues[0].summary, \"Fix bug\");\n    assert_eq!(issues[0].status, \"In Progress\");\n    assert_eq!(issues[0].issue_type, \"Bug\");\n    assert_eq!(issues[0].assignee, Some(\"John\".to_string()));\n}\n\n#[test]\nfn parse_issues_handles_unassigned() {\n    let json = json!({\n        \"issues\": [{\n            \"key\": \"PROJ-456\",\n            \"fields\": {\n                \"summary\": \"Task\",\n                \"status\": {\"name\": \"Open\"},\n                \"issuetype\": {\"name\": \"Task\"},\n                \"assignee\": null,\n                \"updated\": \"2024-01-15T12:00:00Z\"\n            }\n        }]\n    });\n    let issues = parse_issues(\u0026json);\n    assert_eq!(issues.len(), 1);\n    assert!(issues[0].assignee.is_none());\n}\n\n#[test]\nfn parse_issues_handles_empty() {\n    let json = json!({\"issues\": []});\n    let issues = parse_issues(\u0026json);\n    assert!(issues.is_empty());\n}\n\n#[test]\nfn parse_single_issue_extracts_fields() {\n    let json = json!({\n        \"key\": \"TEST-1\",\n        \"fields\": {\n            \"summary\": \"Test issue\",\n            \"status\": {\"name\": \"Done\"},\n            \"issuetype\": {\"name\": \"Story\"},\n            \"assignee\": {\"displayName\": \"Tester\"},\n            \"description\": {\n                \"type\": \"doc\",\n                \"content\": [{\n                    \"type\": \"paragraph\",\n                    \"content\": [{\"type\": \"text\", \"text\": \"Description text\"}]\n                }]\n            },\n            \"updated\": \"2024-01-01T00:00:00Z\"\n        }\n    });\n    let issue = parse_single_issue(\u0026json).unwrap();\n    assert_eq!(issue.key, \"TEST-1\");\n    assert_eq!(issue.summary, \"Test issue\");\n    assert_eq!(issue.status, \"Done\");\n    assert_eq!(issue.issue_type, \"Story\");\n    assert_eq!(issue.assignee, Some(\"Tester\".to_string()));\n    assert_eq!(issue.description, Some(\"Description text\".to_string()));\n}\n\n#[test]\nfn parse_single_issue_returns_none_for_missing_key() {\n    let json = json!({\n        \"fields\": {\n            \"summary\": \"No key\",\n            \"status\": {\"name\": \"Open\"},\n            \"issuetype\": {\"name\": \"Task\"},\n            \"updated\": \"2024-01-01T00:00:00Z\"\n        }\n    });\n    let issue = parse_single_issue(\u0026json);\n    assert!(issue.is_none());\n}\n\n#[test]\nfn parse_single_issue_handles_null_description() {\n    let json = json!({\n        \"key\": \"X-1\",\n        \"fields\": {\n            \"summary\": \"S\",\n            \"status\": {\"name\": \"Open\"},\n            \"issuetype\": {\"name\": \"Task\"},\n            \"description\": null,\n            \"updated\": \"2024-01-01T00:00:00Z\"\n        }\n    });\n    let issue = parse_single_issue(\u0026json).unwrap();\n    assert!(issue.description.is_none());\n}\n\n#[test]\nfn extract_description_handles_string() {\n    let fields = json!({\"description\": \"Simple string\"});\n    let desc = extract_description(\u0026fields);\n    assert_eq!(desc, Some(\"Simple string\".to_string()));\n}\n\n#[test]\nfn extract_description_handles_adf() {\n    let fields = json!({\n        \"description\": {\n            \"type\": \"doc\",\n            \"content\": [{\n                \"type\": \"paragraph\",\n                \"content\": [\n                    {\"type\": \"text\", \"text\": \"Hello \"},\n                    {\"type\": \"text\", \"text\": \"world\"}\n                ]\n            }]\n        }\n    });\n    let desc = extract_description(\u0026fields);\n    assert_eq!(desc, Some(\"Hello world\".to_string()));\n}\n\n#[test]\nfn extract_description_handles_null() {\n    let fields = json!({\"description\": null});\n    let desc = extract_description(\u0026fields);\n    assert!(desc.is_none());\n}\n\n#[test]\nfn extract_description_handles_empty_content() {\n    let fields = json!({\n        \"description\": {\n            \"type\": \"doc\",\n            \"content\": []\n        }\n    });\n    let desc = extract_description(\u0026fields);\n    assert!(desc.is_none());\n}\n\n#[test]\nfn extract_text_from_adf_node_gets_text() {\n    let node = json!({\"type\": \"text\", \"text\": \"Hello\"});\n    let text = extract_text_from_adf_node(\u0026node);\n    assert_eq!(text, Some(\"Hello\".to_string()));\n}\n\n#[test]\nfn extract_text_from_adf_node_recurses() {\n    let node = json!({\n        \"type\": \"paragraph\",\n        \"content\": [\n            {\"type\": \"text\", \"text\": \"A\"},\n            {\"type\": \"text\", \"text\": \"B\"}\n        ]\n    });\n    let text = extract_text_from_adf_node(\u0026node);\n    assert_eq!(text, Some(\"AB\".to_string()));\n}\n\n#[test]\nfn extract_text_from_adf_node_handles_no_content() {\n    let node = json!({\"type\": \"hardBreak\"});\n    let text = extract_text_from_adf_node(\u0026node);\n    assert!(text.is_none());\n}\n\n#[test]\nfn parse_transitions_extracts_transitions() {\n    let json = json!({\n        \"transitions\": [\n            {\"id\": \"11\", \"name\": \"To Do\"},\n            {\"id\": \"21\", \"name\": \"In Progress\"},\n            {\"id\": \"31\", \"name\": \"Done\"}\n        ]\n    });\n    let transitions = parse_transitions(\u0026json);\n    assert_eq!(transitions.len(), 3);\n    assert_eq!(transitions[0].id, \"11\");\n    assert_eq!(transitions[0].name, \"To Do\");\n    assert_eq!(transitions[2].id, \"31\");\n    assert_eq!(transitions[2].name, \"Done\");\n}\n\n#[test]\nfn parse_transitions_handles_empty() {\n    let json = json!({\"transitions\": []});\n    let transitions = parse_transitions(\u0026json);\n    assert!(transitions.is_empty());\n}\n\n#[test]\nfn parse_transitions_handles_missing() {\n    let json = json!({});\n    let transitions = parse_transitions(\u0026json);\n    assert!(transitions.is_empty());\n}\n\n#[test]\nfn build_update_body_with_summary() {\n    let update = IssueUpdate {\n        summary: Some(\"New summary\".to_string()),\n        description: None,\n        assignee: None,\n    };\n    let body = build_update_body(\u0026update);\n    assert_eq!(body[\"fields\"][\"summary\"], \"New summary\");\n}\n\n#[test]\nfn build_update_body_with_description() {\n    let update = IssueUpdate {\n        summary: None,\n        description: Some(\"New description\".to_string()),\n        assignee: None,\n    };\n    let body = build_update_body(\u0026update);\n    assert_eq!(body[\"fields\"][\"description\"][\"type\"], \"doc\");\n    assert_eq!(body[\"fields\"][\"description\"][\"version\"], 1);\n}\n\n#[test]\nfn build_update_body_with_assignee() {\n    let update = IssueUpdate {\n        summary: None,\n        description: None,\n        assignee: Some(\"user123\".to_string()),\n    };\n    let body = build_update_body(\u0026update);\n    assert_eq!(body[\"fields\"][\"assignee\"][\"accountId\"], \"user123\");\n}\n\n#[test]\nfn build_update_body_with_all_fields() {\n    let update = IssueUpdate {\n        summary: Some(\"Sum\".to_string()),\n        description: Some(\"Desc\".to_string()),\n        assignee: Some(\"user\".to_string()),\n    };\n    let body = build_update_body(\u0026update);\n    assert_eq!(body[\"fields\"][\"summary\"], \"Sum\");\n    assert!(body[\"fields\"][\"description\"].is_object());\n    assert_eq!(body[\"fields\"][\"assignee\"][\"accountId\"], \"user\");\n}\n\n#[test]\nfn build_update_body_empty() {\n    let update = IssueUpdate::default();\n    let body = build_update_body(\u0026update);\n    assert_eq!(body[\"fields\"], json!({}));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","jira","mod.rs"],"content":"//! Jira integration\n//!\n//! # CLI Usage\n//! Use [`run_command`] for CLI commands that format and print output.\n//!\n//! # Programmatic Usage (MCP/HTTP)\n//! Use the reusable functions that return typed data:\n//! - [`get_issue`] - Get a single issue\n//! - [`search_issues`] - Search with JQL\n//! - [`get_current_user`] - Get authenticated user\n//! - [`update_issue`] - Update issue fields\n//! - [`get_transitions`] - Get available transitions\n//! - [`transition_issue`] - Change issue status\n\nmod auth;\nmod auth_handler;\nmod cli;\nmod client;\nmod search;\nmod service;\nmod show;\nmod sprint;\nmod tickets;\nmod types;\nmod update;\n\nuse anyhow::Result;\n\npub use cli::JiraCommand;\npub use types::{Issue, IssueUpdate, Transition, User};\n\nuse update::UpdateArgs;\n\n/// Run a Jira command (CLI entry point - formats and prints)\n#[cfg(not(tarpaulin_include))]\npub async fn run_command(cmd: JiraCommand) -\u003e anyhow::Result\u003c()\u003e {\n    match cmd {\n        JiraCommand::Auth =\u003e auth_handler::run().await,\n        JiraCommand::Tickets =\u003e tickets::run().await,\n        JiraCommand::Sprint =\u003e sprint::run(sprint::SprintArgs::default()).await,\n        JiraCommand::Search { query } =\u003e search::run(\u0026query).await,\n        JiraCommand::Show { key } =\u003e show::run(\u0026key).await,\n        JiraCommand::Update {\n            key,\n            summary,\n            status,\n            assign,\n        } =\u003e {\n            update::run(UpdateArgs {\n                key,\n                summary,\n                status,\n                assign,\n            })\n            .await\n        }\n    }\n}\n\n// ============================================================================\n// Reusable functions for MCP/HTTP - return typed data, never print\n// ============================================================================\n\n/// Get a single issue by key (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn get_issue(key: \u0026str) -\u003e Result\u003cIssue\u003e {\n    let client = service::create_client().await?;\n    service::get_issue(\u0026client, key).await\n}\n\n/// Search issues using JQL (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn search_issues(jql: \u0026str) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n    let client = service::create_client().await?;\n    service::search_issues(\u0026client, jql).await\n}\n\n/// Get current authenticated user (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn get_current_user() -\u003e Result\u003cUser\u003e {\n    let client = service::create_client().await?;\n    service::get_current_user(\u0026client).await\n}\n\n/// Update issue fields (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn update_issue(key: \u0026str, update: \u0026IssueUpdate) -\u003e Result\u003c()\u003e {\n    let client = service::create_client().await?;\n    service::update_issue(\u0026client, key, update).await\n}\n\n/// Get available transitions for an issue (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn get_transitions(key: \u0026str) -\u003e Result\u003cVec\u003cTransition\u003e\u003e {\n    let client = service::create_client().await?;\n    service::get_transitions(\u0026client, key).await\n}\n\n/// Transition an issue to a new status (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn transition_issue(key: \u0026str, transition_id: \u0026str) -\u003e Result\u003c()\u003e {\n    let client = service::create_client().await?;\n    service::transition_issue(\u0026client, key, transition_id).await\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn jira_command_exported() {\n        // Verify JiraCommand is re-exported\n        let _cmd = JiraCommand::Auth;\n    }\n\n    #[test]\n    fn update_args_created() {\n        let args = UpdateArgs {\n            key: \"X-1\".to_string(),\n            summary: None,\n            status: None,\n            assign: None,\n        };\n        assert_eq!(args.key, \"X-1\");\n    }\n}\n","traces":[{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["/","Users","chi","Projects","hu","src","jira","search.rs"],"content":"use anyhow::Result;\n\nuse super::client::{JiraApi, JiraClient};\nuse super::types::Issue;\n\n/// Run the jira search command\npub async fn run(query: \u0026str) -\u003e Result\u003c()\u003e {\n    let client = JiraClient::new().await?;\n    let output = process_search(\u0026client, query).await?;\n    print!(\"{}\", output);\n    Ok(())\n}\n\n/// Process search command (business logic, testable)\npub async fn process_search(client: \u0026impl JiraApi, query: \u0026str) -\u003e Result\u003cString\u003e {\n    let issues = client.search_issues(query).await?;\n    Ok(format_search_results(\u0026issues, query))\n}\n\n/// Format search results\nfn format_search_results(issues: \u0026[Issue], query: \u0026str) -\u003e String {\n    let mut output = String::new();\n\n    if issues.is_empty() {\n        output.push_str(\u0026format!(\"No issues found for: {}\\n\", query));\n        return output;\n    }\n\n    output.push_str(\u0026format!(\n        \"Found {} issue{} for: {}\\n\\n\",\n        issues.len(),\n        if issues.len() == 1 { \"\" } else { \"s\" },\n        query\n    ));\n\n    // Calculate column widths\n    let key_width = issues.iter().map(|i| i.key.len()).max().unwrap_or(0).max(4);\n    let status_width = issues\n        .iter()\n        .map(|i| i.status.len())\n        .max()\n        .unwrap_or(0)\n        .max(6);\n\n    for issue in issues {\n        let assignee = issue.assignee.as_deref().unwrap_or(\"-\");\n        let status_color = match issue.status.as_str() {\n            \"Done\" =\u003e \"\\x1b[32m\",        // green\n            \"In Progress\" =\u003e \"\\x1b[33m\", // yellow\n            _ =\u003e \"\\x1b[34m\",             // blue\n        };\n\n        output.push_str(\u0026format!(\n            \"{:\u003ckey_w$}  {}{:\u003cstatus_w$}\\x1b[0m  {}\\n\",\n            issue.key,\n            status_color,\n            issue.status,\n            truncate(\u0026issue.summary, 50),\n            key_w = key_width,\n            status_w = status_width,\n        ));\n        output.push_str(\u0026format!(\n            \"{:\u003ckey_w$}  \\x1b[90m{} | {}\\x1b[0m\\n\",\n            \"\",\n            issue.issue_type,\n            assignee,\n            key_w = key_width,\n        ));\n    }\n\n    output\n}\n\n/// Truncate string to max length with ellipsis\nfn truncate(s: \u0026str, max_len: usize) -\u003e String {\n    if s.len() \u003c= max_len {\n        s.to_string()\n    } else {\n        format!(\"{}...\", \u0026s[..max_len.saturating_sub(3)])\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::super::types::{IssueUpdate, Transition, User};\n    use super::*;\n\n    #[test]\n    fn truncate_short_string_unchanged() {\n        assert_eq!(truncate(\"hello\", 10), \"hello\");\n    }\n\n    #[test]\n    fn truncate_exact_length_unchanged() {\n        assert_eq!(truncate(\"hello\", 5), \"hello\");\n    }\n\n    #[test]\n    fn truncate_long_string_adds_ellipsis() {\n        assert_eq!(truncate(\"hello world\", 8), \"hello...\");\n    }\n\n    #[test]\n    fn truncate_very_short_max() {\n        assert_eq!(truncate(\"hello\", 3), \"...\");\n    }\n\n    #[test]\n    fn truncate_zero_max() {\n        assert_eq!(truncate(\"hello\", 0), \"...\");\n    }\n\n    #[test]\n    fn format_search_results_empty() {\n        let issues: Vec\u003cIssue\u003e = vec![];\n        let output = format_search_results(\u0026issues, \"project = TEST\");\n        assert!(output.contains(\"No issues found\"));\n        assert!(output.contains(\"project = TEST\"));\n    }\n\n    #[test]\n    fn format_search_results_single() {\n        let issues = vec![Issue {\n            key: \"TEST-1\".to_string(),\n            summary: \"Test issue\".to_string(),\n            status: \"Open\".to_string(),\n            issue_type: \"Bug\".to_string(),\n            assignee: Some(\"Alice\".to_string()),\n            description: None,\n            updated: \"2024-01-01T00:00:00Z\".to_string(),\n        }];\n        let output = format_search_results(\u0026issues, \"jql\");\n        assert!(output.contains(\"Found 1 issue for\"));\n        assert!(output.contains(\"TEST-1\"));\n        assert!(output.contains(\"Test issue\"));\n        assert!(output.contains(\"Bug\"));\n        assert!(output.contains(\"Alice\"));\n    }\n\n    #[test]\n    fn format_search_results_multiple() {\n        let issues = vec![\n            Issue {\n                key: \"A-1\".to_string(),\n                summary: \"First\".to_string(),\n                status: \"Done\".to_string(),\n                issue_type: \"Task\".to_string(),\n                assignee: None,\n                description: None,\n                updated: \"U\".to_string(),\n            },\n            Issue {\n                key: \"A-2\".to_string(),\n                summary: \"Second\".to_string(),\n                status: \"In Progress\".to_string(),\n                issue_type: \"Story\".to_string(),\n                assignee: Some(\"Bob\".to_string()),\n                description: None,\n                updated: \"U\".to_string(),\n            },\n        ];\n        let output = format_search_results(\u0026issues, \"q\");\n        assert!(output.contains(\"Found 2 issues\"));\n        assert!(output.contains(\"A-1\"));\n        assert!(output.contains(\"A-2\"));\n        assert!(output.contains(\"-\")); // unassigned\n        assert!(output.contains(\"Bob\"));\n    }\n\n    #[test]\n    fn format_search_results_truncates_long_summary() {\n        let issues = vec![Issue {\n            key: \"X-1\".to_string(),\n            summary: \"This is a very long summary that should be truncated to fit on screen\"\n                .to_string(),\n            status: \"Open\".to_string(),\n            issue_type: \"Task\".to_string(),\n            assignee: None,\n            description: None,\n            updated: \"U\".to_string(),\n        }];\n        let output = format_search_results(\u0026issues, \"q\");\n        assert!(output.contains(\"...\"));\n    }\n\n    #[test]\n    fn format_search_results_colors_status() {\n        let issues = vec![\n            Issue {\n                key: \"A-1\".to_string(),\n                summary: \"Done\".to_string(),\n                status: \"Done\".to_string(),\n                issue_type: \"T\".to_string(),\n                assignee: None,\n                description: None,\n                updated: \"U\".to_string(),\n            },\n            Issue {\n                key: \"A-2\".to_string(),\n                summary: \"In Progress\".to_string(),\n                status: \"In Progress\".to_string(),\n                issue_type: \"T\".to_string(),\n                assignee: None,\n                description: None,\n                updated: \"U\".to_string(),\n            },\n            Issue {\n                key: \"A-3\".to_string(),\n                summary: \"Other\".to_string(),\n                status: \"Other\".to_string(),\n                issue_type: \"T\".to_string(),\n                assignee: None,\n                description: None,\n                updated: \"U\".to_string(),\n            },\n        ];\n        let output = format_search_results(\u0026issues, \"q\");\n        assert!(output.contains(\"\\x1b[32m\")); // green for Done\n        assert!(output.contains(\"\\x1b[33m\")); // yellow for In Progress\n        assert!(output.contains(\"\\x1b[34m\")); // blue for other\n    }\n\n    // Mock client for testing process_search\n    struct MockJiraClient {\n        issues: Vec\u003cIssue\u003e,\n    }\n\n    impl JiraApi for MockJiraClient {\n        async fn get_current_user(\u0026self) -\u003e Result\u003cUser\u003e {\n            unimplemented!()\n        }\n\n        async fn get_issue(\u0026self, _key: \u0026str) -\u003e Result\u003cIssue\u003e {\n            unimplemented!()\n        }\n\n        async fn search_issues(\u0026self, _jql: \u0026str) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n            Ok(self.issues.clone())\n        }\n\n        async fn update_issue(\u0026self, _key: \u0026str, _update: \u0026IssueUpdate) -\u003e Result\u003c()\u003e {\n            unimplemented!()\n        }\n\n        async fn get_transitions(\u0026self, _key: \u0026str) -\u003e Result\u003cVec\u003cTransition\u003e\u003e {\n            unimplemented!()\n        }\n\n        async fn transition_issue(\u0026self, _key: \u0026str, _transition_id: \u0026str) -\u003e Result\u003c()\u003e {\n            unimplemented!()\n        }\n    }\n\n    #[tokio::test]\n    async fn process_search_returns_formatted_results() {\n        let client = MockJiraClient {\n            issues: vec![Issue {\n                key: \"TEST-123\".to_string(),\n                summary: \"Test issue\".to_string(),\n                status: \"Open\".to_string(),\n                issue_type: \"Bug\".to_string(),\n                assignee: Some(\"Tester\".to_string()),\n                description: None,\n                updated: \"2024-01-01T00:00:00Z\".to_string(),\n            }],\n        };\n\n        let output = process_search(\u0026client, \"project = TEST\").await.unwrap();\n        assert!(output.contains(\"TEST-123\"));\n        assert!(output.contains(\"Test issue\"));\n    }\n\n    #[tokio::test]\n    async fn process_search_empty_results() {\n        let client = MockJiraClient { issues: vec![] };\n\n        let output = process_search(\u0026client, \"nonexistent\").await.unwrap();\n        assert!(output.contains(\"No issues found\"));\n    }\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":4}},{"line":16,"address":[],"length":0,"stats":{"Line":8}},{"line":17,"address":[],"length":0,"stats":{"Line":4}},{"line":21,"address":[],"length":0,"stats":{"Line":7}},{"line":22,"address":[],"length":0,"stats":{"Line":14}},{"line":24,"address":[],"length":0,"stats":{"Line":14}},{"line":25,"address":[],"length":0,"stats":{"Line":6}},{"line":26,"address":[],"length":0,"stats":{"Line":2}},{"line":29,"address":[],"length":0,"stats":{"Line":15}},{"line":30,"address":[],"length":0,"stats":{"Line":5}},{"line":31,"address":[],"length":0,"stats":{"Line":10}},{"line":32,"address":[],"length":0,"stats":{"Line":10}},{"line":37,"address":[],"length":0,"stats":{"Line":51}},{"line":38,"address":[],"length":0,"stats":{"Line":10}},{"line":40,"address":[],"length":0,"stats":{"Line":21}},{"line":45,"address":[],"length":0,"stats":{"Line":21}},{"line":46,"address":[],"length":0,"stats":{"Line":40}},{"line":47,"address":[],"length":0,"stats":{"Line":16}},{"line":48,"address":[],"length":0,"stats":{"Line":10}},{"line":49,"address":[],"length":0,"stats":{"Line":8}},{"line":50,"address":[],"length":0,"stats":{"Line":4}},{"line":53,"address":[],"length":0,"stats":{"Line":32}},{"line":54,"address":[],"length":0,"stats":{"Line":16}},{"line":55,"address":[],"length":0,"stats":{"Line":8}},{"line":56,"address":[],"length":0,"stats":{"Line":8}},{"line":57,"address":[],"length":0,"stats":{"Line":8}},{"line":58,"address":[],"length":0,"stats":{"Line":8}},{"line":59,"address":[],"length":0,"stats":{"Line":8}},{"line":60,"address":[],"length":0,"stats":{"Line":8}},{"line":62,"address":[],"length":0,"stats":{"Line":24}},{"line":63,"address":[],"length":0,"stats":{"Line":8}},{"line":64,"address":[],"length":0,"stats":{"Line":8}},{"line":65,"address":[],"length":0,"stats":{"Line":8}},{"line":66,"address":[],"length":0,"stats":{"Line":8}},{"line":67,"address":[],"length":0,"stats":{"Line":8}},{"line":71,"address":[],"length":0,"stats":{"Line":5}},{"line":75,"address":[],"length":0,"stats":{"Line":13}},{"line":76,"address":[],"length":0,"stats":{"Line":26}},{"line":77,"address":[],"length":0,"stats":{"Line":18}},{"line":79,"address":[],"length":0,"stats":{"Line":16}}],"covered":40,"coverable":45},{"path":["/","Users","chi","Projects","hu","src","jira","service.rs"],"content":"//! Jira service layer - business logic that returns data\n//!\n//! Functions in this module accept trait objects and return typed data.\n//! They never print - that's the CLI layer's job.\n\nuse anyhow::Result;\n\nuse super::client::{JiraApi, JiraClient};\nuse super::types::{Issue, IssueUpdate, Transition, User};\n\n/// Get a single issue by key\npub async fn get_issue(api: \u0026impl JiraApi, key: \u0026str) -\u003e Result\u003cIssue\u003e {\n    api.get_issue(key).await\n}\n\n/// Search issues using JQL\npub async fn search_issues(api: \u0026impl JiraApi, jql: \u0026str) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n    api.search_issues(jql).await\n}\n\n/// Get current authenticated user\npub async fn get_current_user(api: \u0026impl JiraApi) -\u003e Result\u003cUser\u003e {\n    api.get_current_user().await\n}\n\n/// Update issue fields\npub async fn update_issue(api: \u0026impl JiraApi, key: \u0026str, update: \u0026IssueUpdate) -\u003e Result\u003c()\u003e {\n    api.update_issue(key, update).await\n}\n\n/// Get available transitions for an issue\npub async fn get_transitions(api: \u0026impl JiraApi, key: \u0026str) -\u003e Result\u003cVec\u003cTransition\u003e\u003e {\n    api.get_transitions(key).await\n}\n\n/// Transition an issue to a new status\npub async fn transition_issue(api: \u0026impl JiraApi, key: \u0026str, transition_id: \u0026str) -\u003e Result\u003c()\u003e {\n    api.transition_issue(key, transition_id).await\n}\n\n/// Create a new authenticated client\npub async fn create_client() -\u003e Result\u003cJiraClient\u003e {\n    JiraClient::new().await\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    struct MockApi {\n        issues: Vec\u003cIssue\u003e,\n        user: Option\u003cUser\u003e,\n        transitions: Vec\u003cTransition\u003e,\n    }\n\n    impl MockApi {\n        fn new() -\u003e Self {\n            Self {\n                issues: vec![],\n                user: None,\n                transitions: vec![],\n            }\n        }\n\n        fn with_issues(mut self, issues: Vec\u003cIssue\u003e) -\u003e Self {\n            self.issues = issues;\n            self\n        }\n\n        fn with_user(mut self, user: User) -\u003e Self {\n            self.user = Some(user);\n            self\n        }\n\n        fn with_transitions(mut self, transitions: Vec\u003cTransition\u003e) -\u003e Self {\n            self.transitions = transitions;\n            self\n        }\n    }\n\n    impl JiraApi for MockApi {\n        async fn get_current_user(\u0026self) -\u003e Result\u003cUser\u003e {\n            self.user\n                .clone()\n                .ok_or_else(|| anyhow::anyhow!(\"No user configured\"))\n        }\n\n        async fn get_issue(\u0026self, key: \u0026str) -\u003e Result\u003cIssue\u003e {\n            self.issues\n                .iter()\n                .find(|i| i.key == key)\n                .cloned()\n                .ok_or_else(|| anyhow::anyhow!(\"Issue not found: {}\", key))\n        }\n\n        async fn search_issues(\u0026self, _jql: \u0026str) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n            Ok(self.issues.clone())\n        }\n\n        async fn update_issue(\u0026self, _key: \u0026str, _update: \u0026IssueUpdate) -\u003e Result\u003c()\u003e {\n            Ok(())\n        }\n\n        async fn get_transitions(\u0026self, _key: \u0026str) -\u003e Result\u003cVec\u003cTransition\u003e\u003e {\n            Ok(self.transitions.clone())\n        }\n\n        async fn transition_issue(\u0026self, _key: \u0026str, _transition_id: \u0026str) -\u003e Result\u003c()\u003e {\n            Ok(())\n        }\n    }\n\n    fn make_issue(key: \u0026str, summary: \u0026str, status: \u0026str) -\u003e Issue {\n        Issue {\n            key: key.to_string(),\n            summary: summary.to_string(),\n            status: status.to_string(),\n            issue_type: \"Task\".to_string(),\n            assignee: None,\n            description: None,\n            updated: \"2024-01-01T00:00:00Z\".to_string(),\n        }\n    }\n\n    #[tokio::test]\n    async fn get_issue_returns_matching() {\n        let api = MockApi::new().with_issues(vec![\n            make_issue(\"PROJ-1\", \"First issue\", \"Open\"),\n            make_issue(\"PROJ-2\", \"Second issue\", \"Done\"),\n        ]);\n\n        let result = get_issue(\u0026api, \"PROJ-2\").await.unwrap();\n        assert_eq!(result.key, \"PROJ-2\");\n        assert_eq!(result.summary, \"Second issue\");\n    }\n\n    #[tokio::test]\n    async fn get_issue_not_found() {\n        let api = MockApi::new();\n        let result = get_issue(\u0026api, \"MISSING\").await;\n        assert!(result.is_err());\n    }\n\n    #[tokio::test]\n    async fn search_issues_returns_all() {\n        let api = MockApi::new().with_issues(vec![\n            make_issue(\"PROJ-1\", \"First\", \"Open\"),\n            make_issue(\"PROJ-2\", \"Second\", \"Done\"),\n        ]);\n\n        let result = search_issues(\u0026api, \"project = PROJ\").await.unwrap();\n        assert_eq!(result.len(), 2);\n    }\n\n    #[tokio::test]\n    async fn get_current_user_returns_user() {\n        let api = MockApi::new().with_user(User {\n            account_id: \"123\".to_string(),\n            display_name: \"John Doe\".to_string(),\n            email_address: Some(\"john@test.com\".to_string()),\n        });\n\n        let result = get_current_user(\u0026api).await.unwrap();\n        assert_eq!(result.display_name, \"John Doe\");\n    }\n\n    #[tokio::test]\n    async fn get_transitions_returns_list() {\n        let api = MockApi::new().with_transitions(vec![\n            Transition {\n                id: \"1\".to_string(),\n                name: \"Start Progress\".to_string(),\n            },\n            Transition {\n                id: \"2\".to_string(),\n                name: \"Done\".to_string(),\n            },\n        ]);\n\n        let result = get_transitions(\u0026api, \"PROJ-1\").await.unwrap();\n        assert_eq!(result.len(), 2);\n        assert_eq!(result[0].name, \"Start Progress\");\n    }\n\n    #[tokio::test]\n    async fn update_issue_succeeds() {\n        let api = MockApi::new();\n        let update = IssueUpdate {\n            summary: Some(\"New summary\".to_string()),\n            ..Default::default()\n        };\n\n        let result = update_issue(\u0026api, \"PROJ-1\", \u0026update).await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn transition_issue_succeeds() {\n        let api = MockApi::new();\n        let result = transition_issue(\u0026api, \"PROJ-1\", \"2\").await;\n        assert!(result.is_ok());\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":4}},{"line":13,"address":[],"length":0,"stats":{"Line":6}},{"line":17,"address":[],"length":0,"stats":{"Line":2}},{"line":18,"address":[],"length":0,"stats":{"Line":3}},{"line":22,"address":[],"length":0,"stats":{"Line":2}},{"line":23,"address":[],"length":0,"stats":{"Line":2}},{"line":27,"address":[],"length":0,"stats":{"Line":2}},{"line":28,"address":[],"length":0,"stats":{"Line":4}},{"line":32,"address":[],"length":0,"stats":{"Line":2}},{"line":33,"address":[],"length":0,"stats":{"Line":3}},{"line":37,"address":[],"length":0,"stats":{"Line":2}},{"line":38,"address":[],"length":0,"stats":{"Line":4}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}}],"covered":12,"coverable":14},{"path":["/","Users","chi","Projects","hu","src","jira","show.rs"],"content":"use anyhow::Result;\n\nuse super::client::{JiraApi, JiraClient};\nuse super::types::Issue;\n\n/// Run the jira show command\npub async fn run(key: \u0026str) -\u003e Result\u003c()\u003e {\n    let client = JiraClient::new().await?;\n    let output = process_show(\u0026client, key).await?;\n    print!(\"{}\", output);\n    Ok(())\n}\n\n/// Process show command (business logic, testable)\npub async fn process_show(client: \u0026impl JiraApi, key: \u0026str) -\u003e Result\u003cString\u003e {\n    let issue = client.get_issue(key).await?;\n    Ok(format_issue(\u0026issue))\n}\n\n/// Format issue for display\nfn format_issue(issue: \u0026Issue) -\u003e String {\n    let mut output = String::new();\n\n    // Header\n    output.push_str(\u0026format!(\"\\x1b[1m{}\\x1b[0m {}\\n\", issue.key, issue.summary));\n    output.push('\\n');\n\n    // Metadata\n    output.push_str(\u0026format!(\"Type:     {}\\n\", issue.issue_type));\n    output.push_str(\u0026format!(\"Status:   {}\\n\", format_status(\u0026issue.status)));\n    output.push_str(\u0026format!(\n        \"Assignee: {}\\n\",\n        issue.assignee.as_deref().unwrap_or(\"Unassigned\")\n    ));\n    output.push_str(\u0026format!(\"Updated:  {}\\n\", format_date(\u0026issue.updated)));\n\n    // Description\n    if let Some(desc) = \u0026issue.description {\n        output.push('\\n');\n        output.push_str(\"Description:\\n\");\n        output.push_str(\u0026format_description(desc));\n    }\n\n    output\n}\n\n/// Format status with color\nfn format_status(status: \u0026str) -\u003e String {\n    let color = match status {\n        \"Done\" =\u003e \"\\x1b[32m\",        // green\n        \"In Progress\" =\u003e \"\\x1b[33m\", // yellow\n        \"To Do\" =\u003e \"\\x1b[34m\",       // blue\n        \"In Review\" =\u003e \"\\x1b[35m\",   // magenta\n        _ =\u003e \"\\x1b[36m\",             // cyan\n    };\n    format!(\"{}{}\\x1b[0m\", color, status)\n}\n\n/// Format date for display\nfn format_date(date: \u0026str) -\u003e String {\n    // Parse ISO date and format nicely\n    // Input: \"2024-01-15T10:30:00.000+0000\"\n    if let Some((date_part, time_part)) = date.split_once('T') {\n        if let Some((time, _)) = time_part.split_once('.') {\n            return format!(\"{} {}\", date_part, time);\n        }\n        return format!(\n            \"{} {}\",\n            date_part,\n            time_part.split('+').next().unwrap_or(time_part)\n        );\n    }\n    date.to_string()\n}\n\n/// Format description with indentation\nfn format_description(desc: \u0026str) -\u003e String {\n    desc.lines().map(|line| format!(\"  {}\\n\", line)).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn format_issue_shows_key_and_summary() {\n        let issue = Issue {\n            key: \"PROJ-123\".to_string(),\n            summary: \"Fix the bug\".to_string(),\n            status: \"In Progress\".to_string(),\n            issue_type: \"Bug\".to_string(),\n            assignee: Some(\"John\".to_string()),\n            description: None,\n            updated: \"2024-01-15T10:30:00.000+0000\".to_string(),\n        };\n        let output = format_issue(\u0026issue);\n        assert!(output.contains(\"PROJ-123\"));\n        assert!(output.contains(\"Fix the bug\"));\n        assert!(output.contains(\"Bug\"));\n        assert!(output.contains(\"In Progress\"));\n        assert!(output.contains(\"John\"));\n    }\n\n    #[test]\n    fn format_issue_shows_unassigned() {\n        let issue = Issue {\n            key: \"X-1\".to_string(),\n            summary: \"S\".to_string(),\n            status: \"Open\".to_string(),\n            issue_type: \"Task\".to_string(),\n            assignee: None,\n            description: None,\n            updated: \"2024-01-01T00:00:00Z\".to_string(),\n        };\n        let output = format_issue(\u0026issue);\n        assert!(output.contains(\"Unassigned\"));\n    }\n\n    #[test]\n    fn format_issue_shows_description() {\n        let issue = Issue {\n            key: \"X-1\".to_string(),\n            summary: \"S\".to_string(),\n            status: \"Open\".to_string(),\n            issue_type: \"Task\".to_string(),\n            assignee: None,\n            description: Some(\"This is the description.\\nWith multiple lines.\".to_string()),\n            updated: \"2024-01-01T00:00:00Z\".to_string(),\n        };\n        let output = format_issue(\u0026issue);\n        assert!(output.contains(\"Description:\"));\n        assert!(output.contains(\"This is the description.\"));\n        assert!(output.contains(\"With multiple lines.\"));\n    }\n\n    #[test]\n    fn format_status_colors_done() {\n        let output = format_status(\"Done\");\n        assert!(output.contains(\"\\x1b[32m\")); // green\n        assert!(output.contains(\"Done\"));\n    }\n\n    #[test]\n    fn format_status_colors_in_progress() {\n        let output = format_status(\"In Progress\");\n        assert!(output.contains(\"\\x1b[33m\")); // yellow\n    }\n\n    #[test]\n    fn format_status_colors_to_do() {\n        let output = format_status(\"To Do\");\n        assert!(output.contains(\"\\x1b[34m\")); // blue\n    }\n\n    #[test]\n    fn format_status_colors_in_review() {\n        let output = format_status(\"In Review\");\n        assert!(output.contains(\"\\x1b[35m\")); // magenta\n    }\n\n    #[test]\n    fn format_status_colors_other() {\n        let output = format_status(\"Unknown Status\");\n        assert!(output.contains(\"\\x1b[36m\")); // cyan\n    }\n\n    #[test]\n    fn format_date_parses_full_iso() {\n        let date = \"2024-01-15T10:30:00.000+0000\";\n        let output = format_date(date);\n        assert_eq!(output, \"2024-01-15 10:30:00\");\n    }\n\n    #[test]\n    fn format_date_parses_iso_with_z() {\n        let date = \"2024-01-15T10:30:00Z\";\n        let output = format_date(date);\n        assert_eq!(output, \"2024-01-15 10:30:00Z\");\n    }\n\n    #[test]\n    fn format_date_handles_simple() {\n        let date = \"2024-01-15\";\n        let output = format_date(date);\n        assert_eq!(output, \"2024-01-15\");\n    }\n\n    #[test]\n    fn format_description_indents_lines() {\n        let desc = \"Line 1\\nLine 2\\nLine 3\";\n        let output = format_description(desc);\n        assert!(output.contains(\"  Line 1\\n\"));\n        assert!(output.contains(\"  Line 2\\n\"));\n        assert!(output.contains(\"  Line 3\\n\"));\n    }\n\n    #[test]\n    fn format_description_handles_empty() {\n        let output = format_description(\"\");\n        // Empty string produces empty output (no lines to format)\n        assert_eq!(output, \"\");\n    }\n\n    #[test]\n    fn format_description_handles_single_line() {\n        let output = format_description(\"Only one line\");\n        assert_eq!(output, \"  Only one line\\n\");\n    }\n\n    use super::super::types::{IssueUpdate, Transition, User};\n\n    // Mock client for testing process_show\n    struct MockJiraClient {\n        issue: Issue,\n    }\n\n    impl JiraApi for MockJiraClient {\n        async fn get_current_user(\u0026self) -\u003e Result\u003cUser\u003e {\n            unimplemented!()\n        }\n\n        async fn get_issue(\u0026self, _key: \u0026str) -\u003e Result\u003cIssue\u003e {\n            Ok(self.issue.clone())\n        }\n\n        async fn search_issues(\u0026self, _jql: \u0026str) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n            unimplemented!()\n        }\n\n        async fn update_issue(\u0026self, _key: \u0026str, _update: \u0026IssueUpdate) -\u003e Result\u003c()\u003e {\n            unimplemented!()\n        }\n\n        async fn get_transitions(\u0026self, _key: \u0026str) -\u003e Result\u003cVec\u003cTransition\u003e\u003e {\n            unimplemented!()\n        }\n\n        async fn transition_issue(\u0026self, _key: \u0026str, _transition_id: \u0026str) -\u003e Result\u003c()\u003e {\n            unimplemented!()\n        }\n    }\n\n    #[tokio::test]\n    async fn process_show_returns_formatted_issue() {\n        let client = MockJiraClient {\n            issue: Issue {\n                key: \"TEST-999\".to_string(),\n                summary: \"Test issue\".to_string(),\n                status: \"Done\".to_string(),\n                issue_type: \"Story\".to_string(),\n                assignee: Some(\"Tester\".to_string()),\n                description: Some(\"Test description\".to_string()),\n                updated: \"2024-01-01T00:00:00Z\".to_string(),\n            },\n        };\n\n        let output = process_show(\u0026client, \"TEST-999\").await.unwrap();\n        assert!(output.contains(\"TEST-999\"));\n        assert!(output.contains(\"Test issue\"));\n        assert!(output.contains(\"Done\"));\n        assert!(output.contains(\"Story\"));\n        assert!(output.contains(\"Tester\"));\n        assert!(output.contains(\"Test description\"));\n    }\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":2}},{"line":16,"address":[],"length":0,"stats":{"Line":4}},{"line":17,"address":[],"length":0,"stats":{"Line":1}},{"line":21,"address":[],"length":0,"stats":{"Line":4}},{"line":22,"address":[],"length":0,"stats":{"Line":8}},{"line":25,"address":[],"length":0,"stats":{"Line":12}},{"line":26,"address":[],"length":0,"stats":{"Line":8}},{"line":29,"address":[],"length":0,"stats":{"Line":12}},{"line":30,"address":[],"length":0,"stats":{"Line":20}},{"line":31,"address":[],"length":0,"stats":{"Line":16}},{"line":32,"address":[],"length":0,"stats":{"Line":8}},{"line":33,"address":[],"length":0,"stats":{"Line":12}},{"line":35,"address":[],"length":0,"stats":{"Line":20}},{"line":38,"address":[],"length":0,"stats":{"Line":8}},{"line":39,"address":[],"length":0,"stats":{"Line":6}},{"line":40,"address":[],"length":0,"stats":{"Line":8}},{"line":41,"address":[],"length":0,"stats":{"Line":6}},{"line":44,"address":[],"length":0,"stats":{"Line":4}},{"line":48,"address":[],"length":0,"stats":{"Line":9}},{"line":49,"address":[],"length":0,"stats":{"Line":18}},{"line":50,"address":[],"length":0,"stats":{"Line":11}},{"line":51,"address":[],"length":0,"stats":{"Line":9}},{"line":52,"address":[],"length":0,"stats":{"Line":6}},{"line":53,"address":[],"length":0,"stats":{"Line":5}},{"line":54,"address":[],"length":0,"stats":{"Line":3}},{"line":56,"address":[],"length":0,"stats":{"Line":18}},{"line":60,"address":[],"length":0,"stats":{"Line":7}},{"line":63,"address":[],"length":0,"stats":{"Line":19}},{"line":64,"address":[],"length":0,"stats":{"Line":8}},{"line":65,"address":[],"length":0,"stats":{"Line":4}},{"line":67,"address":[],"length":0,"stats":{"Line":4}},{"line":68,"address":[],"length":0,"stats":{"Line":4}},{"line":70,"address":[],"length":0,"stats":{"Line":16}},{"line":73,"address":[],"length":0,"stats":{"Line":2}},{"line":77,"address":[],"length":0,"stats":{"Line":5}},{"line":78,"address":[],"length":0,"stats":{"Line":34}}],"covered":36,"coverable":41},{"path":["/","Users","chi","Projects","hu","src","jira","sprint.rs"],"content":"use anyhow::Result;\n\nuse super::client::{JiraApi, JiraClient};\nuse super::types::Issue;\n\n/// Arguments for sprint command\n#[derive(Debug, Clone, Default)]\npub struct SprintArgs {\n    // Reserved for future options (e.g., filter by project)\n    pub _placeholder: Option\u003c()\u003e,\n}\n\n/// Run the jira sprint command\npub async fn run(_args: SprintArgs) -\u003e Result\u003c()\u003e {\n    let client = JiraClient::new().await?;\n    let output = process_sprint(\u0026client).await?;\n    print!(\"{}\", output);\n    Ok(())\n}\n\n/// Process sprint command (business logic, testable)\npub async fn process_sprint(client: \u0026impl JiraApi) -\u003e Result\u003cString\u003e {\n    // Use JQL to find all issues in active sprints\n    let jql = \"sprint in openSprints() ORDER BY status ASC, updated DESC\";\n    let issues = client.search_issues(jql).await?;\n\n    Ok(format_sprint_output(\u0026issues))\n}\n\n/// Format sprint output\nfn format_sprint_output(issues: \u0026[Issue]) -\u003e String {\n    let mut output = String::new();\n\n    // Header\n    output.push_str(\u0026format!(\n        \"\\x1b[1mActive Sprint Issues\\x1b[0m ({} total)\\n\\n\",\n        issues.len()\n    ));\n\n    if issues.is_empty() {\n        output.push_str(\"No issues in active sprints\\n\");\n        return output;\n    }\n\n    // Group by status\n    let mut by_status: std::collections::HashMap\u003c\u0026str, Vec\u003c\u0026Issue\u003e\u003e =\n        std::collections::HashMap::new();\n    for issue in issues {\n        by_status.entry(\u0026issue.status).or_default().push(issue);\n    }\n\n    // Status order preference\n    let status_order = [\"To Do\", \"In Progress\", \"In Review\", \"CODE REVIEW\", \"Done\"];\n\n    // Output in order, then any remaining\n    for status in \u0026status_order {\n        if let Some(issues) = by_status.remove(*status) {\n            output.push_str(\u0026format_status_section(status, \u0026issues));\n        }\n    }\n\n    // Remaining statuses\n    let mut remaining: Vec\u003c_\u003e = by_status.into_iter().collect();\n    remaining.sort_by_key(|(status, _)| *status);\n    for (status, issues) in remaining {\n        output.push_str(\u0026format_status_section(status, \u0026issues));\n    }\n\n    output\n}\n\n/// Format a status section\nfn format_status_section(status: \u0026str, issues: \u0026[\u0026Issue]) -\u003e String {\n    let mut output = String::new();\n    let status_color = match status {\n        \"Done\" =\u003e \"\\x1b[32m\",                                      // green\n        \"In Progress\" | \"In Review\" | \"CODE REVIEW\" =\u003e \"\\x1b[33m\", // yellow\n        _ =\u003e \"\\x1b[34m\",                                           // blue\n    };\n    output.push_str(\u0026format!(\n        \"{}{}\\x1b[0m ({})\\n\",\n        status_color,\n        status,\n        issues.len()\n    ));\n\n    for issue in issues {\n        let assignee = issue.assignee.as_deref().unwrap_or(\"Unassigned\");\n        output.push_str(\u0026format!(\n            \"  {} {} \\x1b[90m({})\\x1b[0m\\n\",\n            issue.key, issue.summary, assignee\n        ));\n    }\n    output.push('\\n');\n    output\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn sprint_args_debug() {\n        let args = SprintArgs::default();\n        let debug_str = format!(\"{:?}\", args);\n        assert!(debug_str.contains(\"SprintArgs\"));\n    }\n\n    #[test]\n    fn sprint_args_clone() {\n        let args = SprintArgs::default();\n        let cloned = args.clone();\n        assert_eq!(cloned._placeholder, args._placeholder);\n    }\n\n    #[test]\n    fn format_sprint_output_shows_header() {\n        let issues = vec![];\n        let output = format_sprint_output(\u0026issues);\n        assert!(output.contains(\"Active Sprint Issues\"));\n        assert!(output.contains(\"0 total\"));\n        assert!(output.contains(\"No issues in active sprints\"));\n    }\n\n    #[test]\n    fn format_sprint_output_groups_by_status() {\n        let issues = vec![\n            Issue {\n                key: \"A-1\".to_string(),\n                summary: \"Task 1\".to_string(),\n                status: \"To Do\".to_string(),\n                issue_type: \"Task\".to_string(),\n                assignee: Some(\"Alice\".to_string()),\n                description: None,\n                updated: \"2024-01-01T00:00:00Z\".to_string(),\n            },\n            Issue {\n                key: \"A-2\".to_string(),\n                summary: \"Task 2\".to_string(),\n                status: \"In Progress\".to_string(),\n                issue_type: \"Task\".to_string(),\n                assignee: Some(\"Bob\".to_string()),\n                description: None,\n                updated: \"2024-01-01T00:00:00Z\".to_string(),\n            },\n            Issue {\n                key: \"A-3\".to_string(),\n                summary: \"Task 3\".to_string(),\n                status: \"Done\".to_string(),\n                issue_type: \"Task\".to_string(),\n                assignee: None,\n                description: None,\n                updated: \"2024-01-01T00:00:00Z\".to_string(),\n            },\n        ];\n        let output = format_sprint_output(\u0026issues);\n        assert!(output.contains(\"A-1\"));\n        assert!(output.contains(\"Task 1\"));\n        assert!(output.contains(\"Alice\"));\n        assert!(output.contains(\"A-2\"));\n        assert!(output.contains(\"Bob\"));\n        assert!(output.contains(\"A-3\"));\n        assert!(output.contains(\"Unassigned\"));\n    }\n\n    #[test]\n    fn format_status_section_shows_count() {\n        let issue1 = Issue {\n            key: \"X-1\".to_string(),\n            summary: \"S1\".to_string(),\n            status: \"Open\".to_string(),\n            issue_type: \"T\".to_string(),\n            assignee: None,\n            description: None,\n            updated: \"U\".to_string(),\n        };\n        let issue2 = Issue {\n            key: \"X-2\".to_string(),\n            summary: \"S2\".to_string(),\n            status: \"Open\".to_string(),\n            issue_type: \"T\".to_string(),\n            assignee: Some(\"User\".to_string()),\n            description: None,\n            updated: \"U\".to_string(),\n        };\n        let issues = vec![\u0026issue1, \u0026issue2];\n        let output = format_status_section(\"Open\", \u0026issues);\n        assert!(output.contains(\"Open\"));\n        assert!(output.contains(\"(2)\"));\n        assert!(output.contains(\"X-1\"));\n        assert!(output.contains(\"X-2\"));\n    }\n\n    #[test]\n    fn format_status_section_color_codes() {\n        let empty: Vec\u003c\u0026Issue\u003e = vec![];\n        let done_output = format_status_section(\"Done\", \u0026empty);\n        assert!(done_output.contains(\"\\x1b[32m\")); // green\n\n        let progress_output = format_status_section(\"In Progress\", \u0026empty);\n        assert!(progress_output.contains(\"\\x1b[33m\")); // yellow\n\n        let other_output = format_status_section(\"Other\", \u0026empty);\n        assert!(other_output.contains(\"\\x1b[34m\")); // blue\n    }\n\n    use super::super::types::{IssueUpdate, Transition, User};\n\n    // Mock client for testing process_sprint\n    struct MockJiraClient {\n        issues: Vec\u003cIssue\u003e,\n    }\n\n    impl JiraApi for MockJiraClient {\n        async fn get_current_user(\u0026self) -\u003e Result\u003cUser\u003e {\n            unimplemented!()\n        }\n\n        async fn get_issue(\u0026self, _key: \u0026str) -\u003e Result\u003cIssue\u003e {\n            unimplemented!()\n        }\n\n        async fn search_issues(\u0026self, _jql: \u0026str) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n            Ok(self.issues.clone())\n        }\n\n        async fn update_issue(\u0026self, _key: \u0026str, _update: \u0026IssueUpdate) -\u003e Result\u003c()\u003e {\n            unimplemented!()\n        }\n\n        async fn get_transitions(\u0026self, _key: \u0026str) -\u003e Result\u003cVec\u003cTransition\u003e\u003e {\n            unimplemented!()\n        }\n\n        async fn transition_issue(\u0026self, _key: \u0026str, _transition_id: \u0026str) -\u003e Result\u003c()\u003e {\n            unimplemented!()\n        }\n    }\n\n    #[tokio::test]\n    async fn process_sprint_returns_issues() {\n        let client = MockJiraClient {\n            issues: vec![Issue {\n                key: \"TEST-1\".to_string(),\n                summary: \"Test issue\".to_string(),\n                status: \"In Progress\".to_string(),\n                issue_type: \"Task\".to_string(),\n                assignee: Some(\"Dev\".to_string()),\n                description: None,\n                updated: \"2024-01-01\".to_string(),\n            }],\n        };\n\n        let output = process_sprint(\u0026client).await.unwrap();\n        assert!(output.contains(\"TEST-1\"));\n        assert!(output.contains(\"Test issue\"));\n        assert!(output.contains(\"In Progress\"));\n    }\n\n    #[tokio::test]\n    async fn process_sprint_handles_empty() {\n        let client = MockJiraClient { issues: vec![] };\n\n        let output = process_sprint(\u0026client).await.unwrap();\n        assert!(output.contains(\"No issues in active sprints\"));\n    }\n\n    #[test]\n    fn format_sprint_output_handles_unknown_status() {\n        // Test that unknown statuses (not in status_order) are still displayed\n        let issues = vec![\n            Issue {\n                key: \"A-1\".to_string(),\n                summary: \"Task with custom status\".to_string(),\n                status: \"Custom Status\".to_string(),\n                issue_type: \"Task\".to_string(),\n                assignee: Some(\"Alice\".to_string()),\n                description: None,\n                updated: \"2024-01-01T00:00:00Z\".to_string(),\n            },\n            Issue {\n                key: \"A-2\".to_string(),\n                summary: \"Task with another status\".to_string(),\n                status: \"Another Custom\".to_string(),\n                issue_type: \"Task\".to_string(),\n                assignee: None,\n                description: None,\n                updated: \"2024-01-01T00:00:00Z\".to_string(),\n            },\n        ];\n        let output = format_sprint_output(\u0026issues);\n        assert!(output.contains(\"Custom Status\"));\n        assert!(output.contains(\"A-1\"));\n        assert!(output.contains(\"Another Custom\"));\n        assert!(output.contains(\"A-2\"));\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":4}},{"line":24,"address":[],"length":0,"stats":{"Line":4}},{"line":25,"address":[],"length":0,"stats":{"Line":8}},{"line":27,"address":[],"length":0,"stats":{"Line":2}},{"line":31,"address":[],"length":0,"stats":{"Line":5}},{"line":32,"address":[],"length":0,"stats":{"Line":10}},{"line":35,"address":[],"length":0,"stats":{"Line":20}},{"line":36,"address":[],"length":0,"stats":{"Line":10}},{"line":37,"address":[],"length":0,"stats":{"Line":5}},{"line":40,"address":[],"length":0,"stats":{"Line":10}},{"line":41,"address":[],"length":0,"stats":{"Line":6}},{"line":42,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":6}},{"line":47,"address":[],"length":0,"stats":{"Line":3}},{"line":48,"address":[],"length":0,"stats":{"Line":21}},{"line":49,"address":[],"length":0,"stats":{"Line":24}},{"line":53,"address":[],"length":0,"stats":{"Line":12}},{"line":56,"address":[],"length":0,"stats":{"Line":33}},{"line":57,"address":[],"length":0,"stats":{"Line":38}},{"line":58,"address":[],"length":0,"stats":{"Line":16}},{"line":63,"address":[],"length":0,"stats":{"Line":15}},{"line":64,"address":[],"length":0,"stats":{"Line":6}},{"line":65,"address":[],"length":0,"stats":{"Line":11}},{"line":66,"address":[],"length":0,"stats":{"Line":8}},{"line":69,"address":[],"length":0,"stats":{"Line":3}},{"line":73,"address":[],"length":0,"stats":{"Line":10}},{"line":74,"address":[],"length":0,"stats":{"Line":20}},{"line":75,"address":[],"length":0,"stats":{"Line":20}},{"line":76,"address":[],"length":0,"stats":{"Line":12}},{"line":77,"address":[],"length":0,"stats":{"Line":21}},{"line":78,"address":[],"length":0,"stats":{"Line":5}},{"line":80,"address":[],"length":0,"stats":{"Line":40}},{"line":81,"address":[],"length":0,"stats":{"Line":20}},{"line":82,"address":[],"length":0,"stats":{"Line":10}},{"line":83,"address":[],"length":0,"stats":{"Line":10}},{"line":84,"address":[],"length":0,"stats":{"Line":10}},{"line":87,"address":[],"length":0,"stats":{"Line":34}},{"line":88,"address":[],"length":0,"stats":{"Line":48}},{"line":89,"address":[],"length":0,"stats":{"Line":24}},{"line":90,"address":[],"length":0,"stats":{"Line":8}},{"line":91,"address":[],"length":0,"stats":{"Line":8}},{"line":94,"address":[],"length":0,"stats":{"Line":20}},{"line":95,"address":[],"length":0,"stats":{"Line":10}}],"covered":43,"coverable":48},{"path":["/","Users","chi","Projects","hu","src","jira","tickets.rs"],"content":"use anyhow::Result;\n\nuse super::client::{JiraApi, JiraClient};\nuse super::types::Issue;\n\n// ANSI color codes\nconst GREEN: \u0026str = \"\\x1b[32m\";\nconst YELLOW: \u0026str = \"\\x1b[33m\";\nconst BLUE: \u0026str = \"\\x1b[34m\";\nconst GRAY: \u0026str = \"\\x1b[90m\";\nconst BOLD: \u0026str = \"\\x1b[1m\";\nconst RESET: \u0026str = \"\\x1b[0m\";\n\n/// Run the jira tickets command (list current sprint tickets assigned to me)\npub async fn run() -\u003e Result\u003c()\u003e {\n    let client = JiraClient::new().await?;\n    let output = process_tickets(\u0026client).await?;\n    print!(\"{}\", output);\n    Ok(())\n}\n\n/// Process tickets command (business logic, testable)\npub async fn process_tickets(client: \u0026impl JiraApi) -\u003e Result\u003cString\u003e {\n    // Use JQL to find issues in active sprints assigned to current user\n    let jql =\n        \"sprint in openSprints() AND assignee = currentUser() ORDER BY status ASC, updated DESC\";\n    let issues = client.search_issues(jql).await?;\n\n    Ok(format_tickets(\u0026issues))\n}\n\nfn get_terminal_width() -\u003e usize {\n    terminal_size::terminal_size()\n        .map(|(w, _)| w.0 as usize)\n        .unwrap_or(120)\n}\n\n/// Format tickets as a table\nfn format_tickets(issues: \u0026[Issue]) -\u003e String {\n    let mut output = String::new();\n    let term_width = get_terminal_width();\n\n    // Header\n    output.push_str(\u0026format!(\n        \"{}My Sprint Tickets{} ({} issues)\\n\\n\",\n        BOLD,\n        RESET,\n        issues.len()\n    ));\n\n    if issues.is_empty() {\n        output.push_str(\"No tickets assigned to you in active sprints\\n\");\n        return output;\n    }\n\n    // Calculate column widths based on content\n    let key_width = issues\n        .iter()\n        .map(|i| i.key.chars().count())\n        .max()\n        .unwrap_or(4)\n        .max(4);\n    let status_width = issues\n        .iter()\n        .map(|i| i.status.chars().count())\n        .max()\n        .unwrap_or(6)\n        .max(6);\n    let type_width = issues\n        .iter()\n        .map(|i| i.issue_type.chars().count())\n        .max()\n        .unwrap_or(4)\n        .max(4);\n\n    // Layout:  Key  Status  Type  Summary \n    // Borders take: 5 separators  3 chars = 15 chars\n    let border_overhead = 15;\n    let fixed_cols = key_width + status_width + type_width;\n    let available_for_summary = term_width\n        .saturating_sub(border_overhead + fixed_cols)\n        .max(20);\n\n    // Top border\n    output.push_str(\u0026format!(\n        \"{}{}{}{}\\n\",\n        \"\".repeat(key_width + 2),\n        \"\".repeat(status_width + 2),\n        \"\".repeat(type_width + 2),\n        \"\".repeat(available_for_summary + 2)\n    ));\n\n    // Header row\n    output.push_str(\u0026format!(\n        \" {}{:\u003ckey_w$}{}  {}{:\u003cstatus_w$}{}  {}{:\u003ctype_w$}{}  {}{:\u003csum_w$}{} \\n\",\n        BOLD,\n        \"Key\",\n        RESET,\n        BOLD,\n        \"Status\",\n        RESET,\n        BOLD,\n        \"Type\",\n        RESET,\n        BOLD,\n        \"Summary\",\n        RESET,\n        key_w = key_width,\n        status_w = status_width,\n        type_w = type_width,\n        sum_w = available_for_summary,\n    ));\n\n    // Header separator\n    output.push_str(\u0026format!(\n        \"{}{}{}{}\\n\",\n        \"\".repeat(key_width + 2),\n        \"\".repeat(status_width + 2),\n        \"\".repeat(type_width + 2),\n        \"\".repeat(available_for_summary + 2)\n    ));\n\n    // Data rows\n    for issue in issues {\n        let status_color = match issue.status.as_str() {\n            \"Done\" =\u003e GREEN,\n            \"In Progress\" | \"In Review\" | \"CODE REVIEW\" =\u003e YELLOW,\n            _ =\u003e BLUE,\n        };\n\n        let summary_display = truncate(\u0026issue.summary, available_for_summary);\n\n        output.push_str(\u0026format!(\n            \" {:\u003ckey_w$}  {}{:\u003cstatus_w$}{}  {}{:\u003ctype_w$}{}  {:\u003csum_w$} \\n\",\n            issue.key,\n            status_color,\n            truncate(\u0026issue.status, status_width),\n            RESET,\n            GRAY,\n            truncate(\u0026issue.issue_type, type_width),\n            RESET,\n            summary_display,\n            key_w = key_width,\n            status_w = status_width,\n            type_w = type_width,\n            sum_w = available_for_summary,\n        ));\n    }\n\n    // Bottom border\n    output.push_str(\u0026format!(\n        \"{}{}{}{}\\n\",\n        \"\".repeat(key_width + 2),\n        \"\".repeat(status_width + 2),\n        \"\".repeat(type_width + 2),\n        \"\".repeat(available_for_summary + 2)\n    ));\n\n    output\n}\n\n/// Truncate string to max length with ellipsis\nfn truncate(s: \u0026str, max_len: usize) -\u003e String {\n    if s.chars().count() \u003c= max_len {\n        s.to_string()\n    } else {\n        let truncated: String = s.chars().take(max_len.saturating_sub(1)).collect();\n        format!(\"{}\", truncated)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::super::types::{IssueUpdate, Transition, User};\n    use super::*;\n\n    #[test]\n    fn truncate_short_unchanged() {\n        assert_eq!(truncate(\"hello\", 10), \"hello\");\n    }\n\n    #[test]\n    fn truncate_long_adds_ellipsis() {\n        assert_eq!(truncate(\"hello world\", 8), \"hello w\");\n    }\n\n    #[test]\n    fn truncate_unicode() {\n        assert_eq!(truncate(\"hllo\", 5), \"hllo\");\n        assert_eq!(truncate(\"hllo world\", 6), \"hllo\");\n    }\n\n    #[test]\n    fn truncate_exact_length() {\n        assert_eq!(truncate(\"hello\", 5), \"hello\");\n    }\n\n    #[test]\n    fn get_terminal_width_returns_reasonable_value() {\n        let width = get_terminal_width();\n        assert!(width \u003e= 20);\n    }\n\n    #[test]\n    fn format_tickets_empty() {\n        let issues: Vec\u003cIssue\u003e = vec![];\n        let output = format_tickets(\u0026issues);\n        assert!(output.contains(\"My Sprint Tickets\"));\n        assert!(output.contains(\"0 issues\"));\n        assert!(output.contains(\"No tickets assigned\"));\n    }\n\n    #[test]\n    fn format_tickets_with_issues() {\n        let issues = vec![\n            Issue {\n                key: \"A-1\".to_string(),\n                summary: \"First task\".to_string(),\n                status: \"Done\".to_string(),\n                issue_type: \"Task\".to_string(),\n                assignee: Some(\"Alice\".to_string()),\n                description: None,\n                updated: \"U\".to_string(),\n            },\n            Issue {\n                key: \"A-2\".to_string(),\n                summary: \"Second task\".to_string(),\n                status: \"In Progress\".to_string(),\n                issue_type: \"Bug\".to_string(),\n                assignee: None,\n                description: None,\n                updated: \"U\".to_string(),\n            },\n        ];\n        let output = format_tickets(\u0026issues);\n        assert!(output.contains(\"My Sprint Tickets\"));\n        assert!(output.contains(\"2 issues\"));\n        assert!(output.contains(\"A-1\"));\n        assert!(output.contains(\"A-2\"));\n        assert!(output.contains(\"First task\"));\n        assert!(output.contains(\"Second task\"));\n        assert!(output.contains(\"Task\"));\n        assert!(output.contains(\"Bug\"));\n        // Box-drawing characters\n        assert!(output.contains(\"\"));\n        assert!(output.contains(\"\"));\n        assert!(output.contains(\"\"));\n        assert!(output.contains(\"\"));\n        assert!(output.contains(\"\"));\n        assert!(output.contains(\"\"));\n    }\n\n    #[test]\n    fn format_tickets_colors_status() {\n        let issues = vec![\n            Issue {\n                key: \"X-1\".to_string(),\n                summary: \"S\".to_string(),\n                status: \"Done\".to_string(),\n                issue_type: \"T\".to_string(),\n                assignee: None,\n                description: None,\n                updated: \"U\".to_string(),\n            },\n            Issue {\n                key: \"X-2\".to_string(),\n                summary: \"S\".to_string(),\n                status: \"In Progress\".to_string(),\n                issue_type: \"T\".to_string(),\n                assignee: None,\n                description: None,\n                updated: \"U\".to_string(),\n            },\n            Issue {\n                key: \"X-3\".to_string(),\n                summary: \"S\".to_string(),\n                status: \"To Do\".to_string(),\n                issue_type: \"T\".to_string(),\n                assignee: None,\n                description: None,\n                updated: \"U\".to_string(),\n            },\n        ];\n        let output = format_tickets(\u0026issues);\n        assert!(output.contains(GREEN)); // Done\n        assert!(output.contains(YELLOW)); // In Progress\n        assert!(output.contains(BLUE)); // To Do\n    }\n\n    #[test]\n    fn format_tickets_handles_long_summary() {\n        // Summary must be \u003e200 chars to ensure truncation even on wide terminals\n        let issues = vec![Issue {\n            key: \"LONG-123\".to_string(),\n            summary: \"A\".repeat(250),\n            status: \"Open\".to_string(),\n            issue_type: \"Story\".to_string(),\n            assignee: Some(\"A Very Long Username\".to_string()),\n            description: None,\n            updated: \"U\".to_string(),\n        }];\n        let output = format_tickets(\u0026issues);\n        // Should contain truncation indicator\n        assert!(output.contains(\"\"));\n    }\n\n    // Mock client for testing\n    struct MockJiraClient {\n        issues: Vec\u003cIssue\u003e,\n    }\n\n    impl JiraApi for MockJiraClient {\n        async fn get_current_user(\u0026self) -\u003e Result\u003cUser\u003e {\n            unimplemented!()\n        }\n\n        async fn get_issue(\u0026self, _key: \u0026str) -\u003e Result\u003cIssue\u003e {\n            unimplemented!()\n        }\n\n        async fn search_issues(\u0026self, _jql: \u0026str) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n            Ok(self.issues.clone())\n        }\n\n        async fn update_issue(\u0026self, _key: \u0026str, _update: \u0026IssueUpdate) -\u003e Result\u003c()\u003e {\n            unimplemented!()\n        }\n\n        async fn get_transitions(\u0026self, _key: \u0026str) -\u003e Result\u003cVec\u003cTransition\u003e\u003e {\n            unimplemented!()\n        }\n\n        async fn transition_issue(\u0026self, _key: \u0026str, _transition_id: \u0026str) -\u003e Result\u003c()\u003e {\n            unimplemented!()\n        }\n    }\n\n    #[tokio::test]\n    async fn process_tickets_returns_issues() {\n        let client = MockJiraClient {\n            issues: vec![Issue {\n                key: \"TEST-1\".to_string(),\n                summary: \"Test issue\".to_string(),\n                status: \"Open\".to_string(),\n                issue_type: \"Task\".to_string(),\n                assignee: Some(\"Me\".to_string()),\n                description: None,\n                updated: \"2024-01-01\".to_string(),\n            }],\n        };\n\n        let output = process_tickets(\u0026client).await.unwrap();\n        assert!(output.contains(\"TEST-1\"));\n        assert!(output.contains(\"Test issue\"));\n    }\n\n    #[tokio::test]\n    async fn process_tickets_handles_empty() {\n        let client = MockJiraClient { issues: vec![] };\n\n        let output = process_tickets(\u0026client).await.unwrap();\n        assert!(output.contains(\"No tickets assigned\"));\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":2}},{"line":16,"address":[],"length":0,"stats":{"Line":2}},{"line":17,"address":[],"length":0,"stats":{"Line":3}},{"line":18,"address":[],"length":0,"stats":{"Line":2}},{"line":19,"address":[],"length":0,"stats":{"Line":1}},{"line":23,"address":[],"length":0,"stats":{"Line":6}},{"line":25,"address":[],"length":0,"stats":{"Line":3}},{"line":26,"address":[],"length":0,"stats":{"Line":3}},{"line":27,"address":[],"length":0,"stats":{"Line":12}},{"line":29,"address":[],"length":0,"stats":{"Line":3}},{"line":32,"address":[],"length":0,"stats":{"Line":8}},{"line":33,"address":[],"length":0,"stats":{"Line":8}},{"line":34,"address":[],"length":0,"stats":{"Line":15}},{"line":39,"address":[],"length":0,"stats":{"Line":7}},{"line":40,"address":[],"length":0,"stats":{"Line":14}},{"line":41,"address":[],"length":0,"stats":{"Line":14}},{"line":44,"address":[],"length":0,"stats":{"Line":28}},{"line":45,"address":[],"length":0,"stats":{"Line":14}},{"line":46,"address":[],"length":0,"stats":{"Line":7}},{"line":47,"address":[],"length":0,"stats":{"Line":7}},{"line":48,"address":[],"length":0,"stats":{"Line":7}},{"line":51,"address":[],"length":0,"stats":{"Line":14}},{"line":52,"address":[],"length":0,"stats":{"Line":6}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":57,"address":[],"length":0,"stats":{"Line":10}},{"line":59,"address":[],"length":0,"stats":{"Line":31}},{"line":63,"address":[],"length":0,"stats":{"Line":10}},{"line":65,"address":[],"length":0,"stats":{"Line":31}},{"line":69,"address":[],"length":0,"stats":{"Line":10}},{"line":71,"address":[],"length":0,"stats":{"Line":31}},{"line":78,"address":[],"length":0,"stats":{"Line":10}},{"line":79,"address":[],"length":0,"stats":{"Line":10}},{"line":80,"address":[],"length":0,"stats":{"Line":10}},{"line":81,"address":[],"length":0,"stats":{"Line":10}},{"line":85,"address":[],"length":0,"stats":{"Line":20}},{"line":86,"address":[],"length":0,"stats":{"Line":10}},{"line":87,"address":[],"length":0,"stats":{"Line":20}},{"line":88,"address":[],"length":0,"stats":{"Line":20}},{"line":89,"address":[],"length":0,"stats":{"Line":20}},{"line":90,"address":[],"length":0,"stats":{"Line":10}},{"line":94,"address":[],"length":0,"stats":{"Line":15}},{"line":95,"address":[],"length":0,"stats":{"Line":5}},{"line":96,"address":[],"length":0,"stats":{"Line":5}},{"line":97,"address":[],"length":0,"stats":{"Line":5}},{"line":98,"address":[],"length":0,"stats":{"Line":5}},{"line":99,"address":[],"length":0,"stats":{"Line":5}},{"line":100,"address":[],"length":0,"stats":{"Line":5}},{"line":101,"address":[],"length":0,"stats":{"Line":5}},{"line":102,"address":[],"length":0,"stats":{"Line":5}},{"line":103,"address":[],"length":0,"stats":{"Line":5}},{"line":104,"address":[],"length":0,"stats":{"Line":5}},{"line":105,"address":[],"length":0,"stats":{"Line":5}},{"line":106,"address":[],"length":0,"stats":{"Line":5}},{"line":107,"address":[],"length":0,"stats":{"Line":5}},{"line":108,"address":[],"length":0,"stats":{"Line":5}},{"line":109,"address":[],"length":0,"stats":{"Line":5}},{"line":110,"address":[],"length":0,"stats":{"Line":5}},{"line":111,"address":[],"length":0,"stats":{"Line":5}},{"line":115,"address":[],"length":0,"stats":{"Line":20}},{"line":116,"address":[],"length":0,"stats":{"Line":10}},{"line":117,"address":[],"length":0,"stats":{"Line":20}},{"line":118,"address":[],"length":0,"stats":{"Line":20}},{"line":119,"address":[],"length":0,"stats":{"Line":20}},{"line":120,"address":[],"length":0,"stats":{"Line":10}},{"line":124,"address":[],"length":0,"stats":{"Line":31}},{"line":125,"address":[],"length":0,"stats":{"Line":26}},{"line":126,"address":[],"length":0,"stats":{"Line":20}},{"line":127,"address":[],"length":0,"stats":{"Line":16}},{"line":128,"address":[],"length":0,"stats":{"Line":4}},{"line":131,"address":[],"length":0,"stats":{"Line":52}},{"line":133,"address":[],"length":0,"stats":{"Line":52}},{"line":134,"address":[],"length":0,"stats":{"Line":26}},{"line":135,"address":[],"length":0,"stats":{"Line":13}},{"line":136,"address":[],"length":0,"stats":{"Line":13}},{"line":137,"address":[],"length":0,"stats":{"Line":52}},{"line":138,"address":[],"length":0,"stats":{"Line":13}},{"line":139,"address":[],"length":0,"stats":{"Line":13}},{"line":140,"address":[],"length":0,"stats":{"Line":26}},{"line":141,"address":[],"length":0,"stats":{"Line":13}},{"line":142,"address":[],"length":0,"stats":{"Line":13}},{"line":143,"address":[],"length":0,"stats":{"Line":13}},{"line":144,"address":[],"length":0,"stats":{"Line":13}},{"line":145,"address":[],"length":0,"stats":{"Line":13}},{"line":146,"address":[],"length":0,"stats":{"Line":13}},{"line":151,"address":[],"length":0,"stats":{"Line":20}},{"line":152,"address":[],"length":0,"stats":{"Line":10}},{"line":153,"address":[],"length":0,"stats":{"Line":20}},{"line":154,"address":[],"length":0,"stats":{"Line":20}},{"line":155,"address":[],"length":0,"stats":{"Line":20}},{"line":156,"address":[],"length":0,"stats":{"Line":10}},{"line":159,"address":[],"length":0,"stats":{"Line":5}},{"line":163,"address":[],"length":0,"stats":{"Line":44}},{"line":164,"address":[],"length":0,"stats":{"Line":132}},{"line":165,"address":[],"length":0,"stats":{"Line":82}},{"line":167,"address":[],"length":0,"stats":{"Line":24}},{"line":168,"address":[],"length":0,"stats":{"Line":6}}],"covered":96,"coverable":96},{"path":["/","Users","chi","Projects","hu","src","jira","types.rs"],"content":"use serde::{Deserialize, Serialize};\n\n/// Jira user\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct User {\n    pub account_id: String,\n    pub display_name: String,\n    pub email_address: Option\u003cString\u003e,\n}\n\n/// Jira issue\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Issue {\n    pub key: String,\n    pub summary: String,\n    pub status: String,\n    pub issue_type: String,\n    pub assignee: Option\u003cString\u003e,\n    pub description: Option\u003cString\u003e,\n    pub updated: String,\n}\n\n/// Fields to update on an issue\n#[derive(Debug, Clone, Default)]\npub struct IssueUpdate {\n    pub summary: Option\u003cString\u003e,\n    pub description: Option\u003cString\u003e,\n    pub assignee: Option\u003cString\u003e,\n}\n\n/// Issue transition (status change)\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Transition {\n    pub id: String,\n    pub name: String,\n}\n\n/// OAuth configuration for Jira\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct OAuthConfig {\n    pub client_id: String,\n    pub client_secret: String,\n}\n\n/// Accessible Jira Cloud resource\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AccessibleResource {\n    pub id: String,\n    pub url: String,\n    pub name: String,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn user_clone() {\n        let user = User {\n            account_id: \"123\".to_string(),\n            display_name: \"John Doe\".to_string(),\n            email_address: Some(\"john@example.com\".to_string()),\n        };\n        let cloned = user.clone();\n        assert_eq!(cloned.account_id, user.account_id);\n        assert_eq!(cloned.display_name, user.display_name);\n        assert_eq!(cloned.email_address, user.email_address);\n    }\n\n    #[test]\n    fn user_without_email() {\n        let user = User {\n            account_id: \"456\".to_string(),\n            display_name: \"Jane\".to_string(),\n            email_address: None,\n        };\n        assert!(user.email_address.is_none());\n    }\n\n    #[test]\n    fn user_debug_format() {\n        let user = User {\n            account_id: \"id\".to_string(),\n            display_name: \"name\".to_string(),\n            email_address: None,\n        };\n        let debug_str = format!(\"{:?}\", user);\n        assert!(debug_str.contains(\"User\"));\n    }\n\n    #[test]\n    fn user_serialize() {\n        let user = User {\n            account_id: \"123\".to_string(),\n            display_name: \"John\".to_string(),\n            email_address: Some(\"john@test.com\".to_string()),\n        };\n        let json = serde_json::to_string(\u0026user).unwrap();\n        assert!(json.contains(\"account_id\"));\n        assert!(json.contains(\"123\"));\n    }\n\n    #[test]\n    fn user_deserialize() {\n        let json = r#\"{\"account_id\":\"abc\",\"display_name\":\"Test\",\"email_address\":null}\"#;\n        let user: User = serde_json::from_str(json).unwrap();\n        assert_eq!(user.account_id, \"abc\");\n        assert_eq!(user.display_name, \"Test\");\n        assert!(user.email_address.is_none());\n    }\n\n    #[test]\n    fn issue_clone() {\n        let issue = Issue {\n            key: \"PROJ-123\".to_string(),\n            summary: \"Fix bug\".to_string(),\n            status: \"In Progress\".to_string(),\n            issue_type: \"Bug\".to_string(),\n            assignee: Some(\"john\".to_string()),\n            description: Some(\"A bug description\".to_string()),\n            updated: \"2024-01-15T10:00:00Z\".to_string(),\n        };\n        let cloned = issue.clone();\n        assert_eq!(cloned.key, issue.key);\n        assert_eq!(cloned.summary, issue.summary);\n        assert_eq!(cloned.status, issue.status);\n    }\n\n    #[test]\n    fn issue_without_optional_fields() {\n        let issue = Issue {\n            key: \"PROJ-456\".to_string(),\n            summary: \"Task\".to_string(),\n            status: \"Open\".to_string(),\n            issue_type: \"Task\".to_string(),\n            assignee: None,\n            description: None,\n            updated: \"2024-01-15T12:00:00Z\".to_string(),\n        };\n        assert!(issue.assignee.is_none());\n        assert!(issue.description.is_none());\n    }\n\n    #[test]\n    fn issue_debug_format() {\n        let issue = Issue {\n            key: \"K\".to_string(),\n            summary: \"S\".to_string(),\n            status: \"St\".to_string(),\n            issue_type: \"T\".to_string(),\n            assignee: None,\n            description: None,\n            updated: \"U\".to_string(),\n        };\n        let debug_str = format!(\"{:?}\", issue);\n        assert!(debug_str.contains(\"Issue\"));\n    }\n\n    #[test]\n    fn issue_serialize() {\n        let issue = Issue {\n            key: \"TEST-1\".to_string(),\n            summary: \"Test issue\".to_string(),\n            status: \"Done\".to_string(),\n            issue_type: \"Story\".to_string(),\n            assignee: Some(\"user\".to_string()),\n            description: Some(\"desc\".to_string()),\n            updated: \"2024-01-01T00:00:00Z\".to_string(),\n        };\n        let json = serde_json::to_string(\u0026issue).unwrap();\n        assert!(json.contains(\"TEST-1\"));\n        assert!(json.contains(\"Test issue\"));\n    }\n\n    #[test]\n    fn issue_deserialize() {\n        let json = r#\"{\n            \"key\": \"X-1\",\n            \"summary\": \"Sum\",\n            \"status\": \"Open\",\n            \"issue_type\": \"Bug\",\n            \"assignee\": null,\n            \"description\": null,\n            \"updated\": \"2024-01-01T00:00:00Z\"\n        }\"#;\n        let issue: Issue = serde_json::from_str(json).unwrap();\n        assert_eq!(issue.key, \"X-1\");\n        assert_eq!(issue.summary, \"Sum\");\n    }\n\n    #[test]\n    fn issue_update_default() {\n        let update = IssueUpdate::default();\n        assert!(update.summary.is_none());\n        assert!(update.description.is_none());\n        assert!(update.assignee.is_none());\n    }\n\n    #[test]\n    fn issue_update_clone() {\n        let update = IssueUpdate {\n            summary: Some(\"New summary\".to_string()),\n            description: Some(\"New desc\".to_string()),\n            assignee: Some(\"user123\".to_string()),\n        };\n        let cloned = update.clone();\n        assert_eq!(cloned.summary, update.summary);\n        assert_eq!(cloned.description, update.description);\n        assert_eq!(cloned.assignee, update.assignee);\n    }\n\n    #[test]\n    fn issue_update_debug_format() {\n        let update = IssueUpdate::default();\n        let debug_str = format!(\"{:?}\", update);\n        assert!(debug_str.contains(\"IssueUpdate\"));\n    }\n\n    #[test]\n    fn issue_update_partial() {\n        let update = IssueUpdate {\n            summary: Some(\"Only summary\".to_string()),\n            description: None,\n            assignee: None,\n        };\n        assert!(update.summary.is_some());\n        assert!(update.description.is_none());\n    }\n\n    #[test]\n    fn transition_clone() {\n        let transition = Transition {\n            id: \"31\".to_string(),\n            name: \"In Progress\".to_string(),\n        };\n        let cloned = transition.clone();\n        assert_eq!(cloned.id, transition.id);\n        assert_eq!(cloned.name, transition.name);\n    }\n\n    #[test]\n    fn transition_debug_format() {\n        let transition = Transition {\n            id: \"1\".to_string(),\n            name: \"T\".to_string(),\n        };\n        let debug_str = format!(\"{:?}\", transition);\n        assert!(debug_str.contains(\"Transition\"));\n    }\n\n    #[test]\n    fn transition_serialize() {\n        let transition = Transition {\n            id: \"21\".to_string(),\n            name: \"Done\".to_string(),\n        };\n        let json = serde_json::to_string(\u0026transition).unwrap();\n        assert!(json.contains(\"21\"));\n        assert!(json.contains(\"Done\"));\n    }\n\n    #[test]\n    fn transition_deserialize() {\n        let json = r#\"{\"id\": \"11\", \"name\": \"To Do\"}\"#;\n        let transition: Transition = serde_json::from_str(json).unwrap();\n        assert_eq!(transition.id, \"11\");\n        assert_eq!(transition.name, \"To Do\");\n    }\n\n    #[test]\n    fn oauth_config_clone() {\n        let config = OAuthConfig {\n            client_id: \"id123\".to_string(),\n            client_secret: \"secret456\".to_string(),\n        };\n        let cloned = config.clone();\n        assert_eq!(cloned.client_id, config.client_id);\n        assert_eq!(cloned.client_secret, config.client_secret);\n    }\n\n    #[test]\n    fn oauth_config_debug_format() {\n        let config = OAuthConfig {\n            client_id: \"id\".to_string(),\n            client_secret: \"secret\".to_string(),\n        };\n        let debug_str = format!(\"{:?}\", config);\n        assert!(debug_str.contains(\"OAuthConfig\"));\n    }\n\n    #[test]\n    fn oauth_config_serialize() {\n        let config = OAuthConfig {\n            client_id: \"test_id\".to_string(),\n            client_secret: \"test_secret\".to_string(),\n        };\n        let json = serde_json::to_string(\u0026config).unwrap();\n        assert!(json.contains(\"test_id\"));\n        assert!(json.contains(\"test_secret\"));\n    }\n\n    #[test]\n    fn oauth_config_deserialize() {\n        let json = r#\"{\"client_id\": \"cid\", \"client_secret\": \"csec\"}\"#;\n        let config: OAuthConfig = serde_json::from_str(json).unwrap();\n        assert_eq!(config.client_id, \"cid\");\n        assert_eq!(config.client_secret, \"csec\");\n    }\n\n    #[test]\n    fn accessible_resource_clone() {\n        let resource = AccessibleResource {\n            id: \"cloud-123\".to_string(),\n            url: \"https://example.atlassian.net\".to_string(),\n            name: \"Example Site\".to_string(),\n        };\n        let cloned = resource.clone();\n        assert_eq!(cloned.id, resource.id);\n        assert_eq!(cloned.url, resource.url);\n        assert_eq!(cloned.name, resource.name);\n    }\n\n    #[test]\n    fn accessible_resource_debug_format() {\n        let resource = AccessibleResource {\n            id: \"id\".to_string(),\n            url: \"url\".to_string(),\n            name: \"name\".to_string(),\n        };\n        let debug_str = format!(\"{:?}\", resource);\n        assert!(debug_str.contains(\"AccessibleResource\"));\n    }\n\n    #[test]\n    fn accessible_resource_serialize() {\n        let resource = AccessibleResource {\n            id: \"res-id\".to_string(),\n            url: \"https://test.atlassian.net\".to_string(),\n            name: \"Test Site\".to_string(),\n        };\n        let json = serde_json::to_string(\u0026resource).unwrap();\n        assert!(json.contains(\"res-id\"));\n        assert!(json.contains(\"https://test.atlassian.net\"));\n    }\n\n    #[test]\n    fn accessible_resource_deserialize() {\n        let json = r#\"{\"id\": \"abc\", \"url\": \"https://x.atlassian.net\", \"name\": \"X\"}\"#;\n        let resource: AccessibleResource = serde_json::from_str(json).unwrap();\n        assert_eq!(resource.id, \"abc\");\n        assert_eq!(resource.url, \"https://x.atlassian.net\");\n        assert_eq!(resource.name, \"X\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","jira","update","mod.rs"],"content":"use anyhow::{bail, Result};\n\nuse super::client::{JiraApi, JiraClient};\nuse super::types::{IssueUpdate, Transition};\n\n#[cfg(test)]\nmod tests;\n\n/// Arguments for update command\n#[derive(Debug, Clone)]\npub struct UpdateArgs {\n    pub key: String,\n    pub summary: Option\u003cString\u003e,\n    pub status: Option\u003cString\u003e,\n    pub assign: Option\u003cString\u003e,\n}\n\n/// Run the jira update command\npub async fn run(args: UpdateArgs) -\u003e Result\u003c()\u003e {\n    let client = JiraClient::new().await?;\n    let output = process_update(\u0026client, \u0026args).await?;\n    print!(\"{}\", output);\n    Ok(())\n}\n\n/// Process update command (business logic, testable)\npub async fn process_update(client: \u0026impl JiraApi, args: \u0026UpdateArgs) -\u003e Result\u003cString\u003e {\n    let mut output = String::new();\n    let mut changes_made = false;\n\n    // Handle field updates\n    let has_field_updates = args.summary.is_some() || args.assign.is_some();\n    if has_field_updates {\n        let assignee = match \u0026args.assign {\n            Some(a) if a == \"me\" =\u003e {\n                let user = client.get_current_user().await?;\n                Some(user.account_id)\n            }\n            Some(a) =\u003e Some(a.clone()),\n            None =\u003e None,\n        };\n\n        let update = IssueUpdate {\n            summary: args.summary.clone(),\n            description: None,\n            assignee,\n        };\n\n        client.update_issue(\u0026args.key, \u0026update).await?;\n        changes_made = true;\n\n        if let Some(summary) = \u0026args.summary {\n            output.push_str(\u0026format!(\n                \"\\x1b[32m\\u{2713}\\x1b[0m Updated summary: \\\"{}\\\"\\n\",\n                summary\n            ));\n        }\n        if args.assign.is_some() {\n            output.push_str(\"\\x1b[32m\\u{2713}\\x1b[0m Updated assignee\\n\");\n        }\n    }\n\n    // Handle status transition\n    if let Some(target_status) = \u0026args.status {\n        let transitions = client.get_transitions(\u0026args.key).await?;\n        let transition = find_transition(\u0026transitions, target_status)?;\n\n        client.transition_issue(\u0026args.key, \u0026transition.id).await?;\n        changes_made = true;\n\n        output.push_str(\u0026format!(\n            \"\\x1b[32m\\u{2713}\\x1b[0m Transitioned to: {}\\n\",\n            transition.name\n        ));\n    }\n\n    if !changes_made {\n        bail!(\"No changes specified. Use --summary, --status, or --assign.\");\n    }\n\n    Ok(output)\n}\n\n/// Find a transition by name (case-insensitive)\nfn find_transition\u003c'a\u003e(transitions: \u0026'a [Transition], target: \u0026str) -\u003e Result\u003c\u0026'a Transition\u003e {\n    let target_lower = target.to_lowercase();\n\n    // Exact match first\n    if let Some(t) = transitions\n        .iter()\n        .find(|t| t.name.to_lowercase() == target_lower)\n    {\n        return Ok(t);\n    }\n\n    // Partial match\n    if let Some(t) = transitions\n        .iter()\n        .find(|t| t.name.to_lowercase().contains(\u0026target_lower))\n    {\n        return Ok(t);\n    }\n\n    // Build error message with available transitions\n    let available: Vec\u003c_\u003e = transitions.iter().map(|t| t.name.as_str()).collect();\n    bail!(\n        \"Status '{}' not found. Available transitions: {}\",\n        target,\n        available.join(\", \")\n    )\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":12}},{"line":28,"address":[],"length":0,"stats":{"Line":12}},{"line":29,"address":[],"length":0,"stats":{"Line":12}},{"line":32,"address":[],"length":0,"stats":{"Line":26}},{"line":33,"address":[],"length":0,"stats":{"Line":6}},{"line":34,"address":[],"length":0,"stats":{"Line":7}},{"line":35,"address":[],"length":0,"stats":{"Line":8}},{"line":36,"address":[],"length":0,"stats":{"Line":6}},{"line":37,"address":[],"length":0,"stats":{"Line":2}},{"line":39,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":1}},{"line":44,"address":[],"length":0,"stats":{"Line":12}},{"line":49,"address":[],"length":0,"stats":{"Line":16}},{"line":50,"address":[],"length":0,"stats":{"Line":4}},{"line":52,"address":[],"length":0,"stats":{"Line":8}},{"line":53,"address":[],"length":0,"stats":{"Line":6}},{"line":54,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":11}},{"line":59,"address":[],"length":0,"stats":{"Line":6}},{"line":64,"address":[],"length":0,"stats":{"Line":8}},{"line":65,"address":[],"length":0,"stats":{"Line":8}},{"line":66,"address":[],"length":0,"stats":{"Line":8}},{"line":68,"address":[],"length":0,"stats":{"Line":8}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":71,"address":[],"length":0,"stats":{"Line":6}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":2}},{"line":77,"address":[],"length":0,"stats":{"Line":6}},{"line":78,"address":[],"length":0,"stats":{"Line":2}},{"line":81,"address":[],"length":0,"stats":{"Line":5}},{"line":85,"address":[],"length":0,"stats":{"Line":8}},{"line":86,"address":[],"length":0,"stats":{"Line":24}},{"line":89,"address":[],"length":0,"stats":{"Line":13}},{"line":91,"address":[],"length":0,"stats":{"Line":34}},{"line":93,"address":[],"length":0,"stats":{"Line":5}},{"line":97,"address":[],"length":0,"stats":{"Line":4}},{"line":99,"address":[],"length":0,"stats":{"Line":12}},{"line":101,"address":[],"length":0,"stats":{"Line":1}},{"line":105,"address":[],"length":0,"stats":{"Line":16}},{"line":106,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":4}}],"covered":42,"coverable":48},{"path":["/","Users","chi","Projects","hu","src","jira","update","tests.rs"],"content":"use super::super::types::User;\nuse super::*;\n\n#[test]\nfn update_args_debug() {\n    let args = UpdateArgs {\n        key: \"X-1\".to_string(),\n        summary: Some(\"New\".to_string()),\n        status: None,\n        assign: None,\n    };\n    let debug_str = format!(\"{:?}\", args);\n    assert!(debug_str.contains(\"UpdateArgs\"));\n}\n\n#[test]\nfn update_args_clone() {\n    let args = UpdateArgs {\n        key: \"X-1\".to_string(),\n        summary: Some(\"S\".to_string()),\n        status: Some(\"Done\".to_string()),\n        assign: Some(\"user\".to_string()),\n    };\n    let cloned = args.clone();\n    assert_eq!(cloned.key, args.key);\n    assert_eq!(cloned.summary, args.summary);\n    assert_eq!(cloned.status, args.status);\n    assert_eq!(cloned.assign, args.assign);\n}\n\n#[test]\nfn find_transition_exact_match() {\n    let transitions = vec![\n        Transition {\n            id: \"11\".to_string(),\n            name: \"To Do\".to_string(),\n        },\n        Transition {\n            id: \"21\".to_string(),\n            name: \"In Progress\".to_string(),\n        },\n        Transition {\n            id: \"31\".to_string(),\n            name: \"Done\".to_string(),\n        },\n    ];\n\n    let t = find_transition(\u0026transitions, \"Done\").unwrap();\n    assert_eq!(t.id, \"31\");\n    assert_eq!(t.name, \"Done\");\n}\n\n#[test]\nfn find_transition_case_insensitive() {\n    let transitions = vec![Transition {\n        id: \"21\".to_string(),\n        name: \"In Progress\".to_string(),\n    }];\n\n    let t = find_transition(\u0026transitions, \"in progress\").unwrap();\n    assert_eq!(t.id, \"21\");\n\n    let t2 = find_transition(\u0026transitions, \"IN PROGRESS\").unwrap();\n    assert_eq!(t2.id, \"21\");\n}\n\n#[test]\nfn find_transition_partial_match() {\n    let transitions = vec![\n        Transition {\n            id: \"11\".to_string(),\n            name: \"Start Progress\".to_string(),\n        },\n        Transition {\n            id: \"21\".to_string(),\n            name: \"In Progress\".to_string(),\n        },\n    ];\n\n    let t = find_transition(\u0026transitions, \"progress\").unwrap();\n    assert!(t.name.contains(\"Progress\"));\n}\n\n#[test]\nfn find_transition_not_found() {\n    let transitions = vec![\n        Transition {\n            id: \"11\".to_string(),\n            name: \"To Do\".to_string(),\n        },\n        Transition {\n            id: \"31\".to_string(),\n            name: \"Done\".to_string(),\n        },\n    ];\n\n    let result = find_transition(\u0026transitions, \"In Progress\");\n    assert!(result.is_err());\n    let err = result.unwrap_err().to_string();\n    assert!(err.contains(\"In Progress\"));\n    assert!(err.contains(\"To Do\"));\n    assert!(err.contains(\"Done\"));\n}\n\n#[test]\nfn find_transition_empty_list() {\n    let transitions: Vec\u003cTransition\u003e = vec![];\n    let result = find_transition(\u0026transitions, \"Done\");\n    assert!(result.is_err());\n}\n\n// Mock client for testing process_update\nstruct MockJiraClient {\n    user: User,\n    transitions: Vec\u003cTransition\u003e,\n    updated_fields: std::sync::Mutex\u003cOption\u003cIssueUpdate\u003e\u003e,\n    transitioned_to: std::sync::Mutex\u003cOption\u003cString\u003e\u003e,\n}\n\nimpl JiraApi for MockJiraClient {\n    async fn get_current_user(\u0026self) -\u003e Result\u003cUser\u003e {\n        Ok(self.user.clone())\n    }\n\n    async fn get_issue(\u0026self, _key: \u0026str) -\u003e Result\u003csuper::super::types::Issue\u003e {\n        unimplemented!()\n    }\n\n    async fn search_issues(\u0026self, _jql: \u0026str) -\u003e Result\u003cVec\u003csuper::super::types::Issue\u003e\u003e {\n        unimplemented!()\n    }\n\n    async fn update_issue(\u0026self, _key: \u0026str, update: \u0026IssueUpdate) -\u003e Result\u003c()\u003e {\n        *self.updated_fields.lock().unwrap() = Some(update.clone());\n        Ok(())\n    }\n\n    async fn get_transitions(\u0026self, _key: \u0026str) -\u003e Result\u003cVec\u003cTransition\u003e\u003e {\n        Ok(self.transitions.clone())\n    }\n\n    async fn transition_issue(\u0026self, _key: \u0026str, transition_id: \u0026str) -\u003e Result\u003c()\u003e {\n        *self.transitioned_to.lock().unwrap() = Some(transition_id.to_string());\n        Ok(())\n    }\n}\n\n#[tokio::test]\nasync fn process_update_changes_summary() {\n    let client = MockJiraClient {\n        user: User {\n            account_id: \"me123\".to_string(),\n            display_name: \"Me\".to_string(),\n            email_address: None,\n        },\n        transitions: vec![],\n        updated_fields: std::sync::Mutex::new(None),\n        transitioned_to: std::sync::Mutex::new(None),\n    };\n\n    let args = UpdateArgs {\n        key: \"X-1\".to_string(),\n        summary: Some(\"New summary\".to_string()),\n        status: None,\n        assign: None,\n    };\n\n    let output = process_update(\u0026client, \u0026args).await.unwrap();\n    assert!(output.contains(\"Updated summary\"));\n    assert!(output.contains(\"New summary\"));\n\n    let updated = client.updated_fields.lock().unwrap();\n    assert!(updated.is_some());\n    assert_eq!(\n        updated.as_ref().unwrap().summary,\n        Some(\"New summary\".to_string())\n    );\n}\n\n#[tokio::test]\nasync fn process_update_assigns_to_me() {\n    let client = MockJiraClient {\n        user: User {\n            account_id: \"my-account-id\".to_string(),\n            display_name: \"Me\".to_string(),\n            email_address: None,\n        },\n        transitions: vec![],\n        updated_fields: std::sync::Mutex::new(None),\n        transitioned_to: std::sync::Mutex::new(None),\n    };\n\n    let args = UpdateArgs {\n        key: \"X-1\".to_string(),\n        summary: None,\n        status: None,\n        assign: Some(\"me\".to_string()),\n    };\n\n    let output = process_update(\u0026client, \u0026args).await.unwrap();\n    assert!(output.contains(\"Updated assignee\"));\n\n    let updated = client.updated_fields.lock().unwrap();\n    assert_eq!(\n        updated.as_ref().unwrap().assignee,\n        Some(\"my-account-id\".to_string())\n    );\n}\n\n#[tokio::test]\nasync fn process_update_assigns_to_user() {\n    let client = MockJiraClient {\n        user: User {\n            account_id: \"me\".to_string(),\n            display_name: \"Me\".to_string(),\n            email_address: None,\n        },\n        transitions: vec![],\n        updated_fields: std::sync::Mutex::new(None),\n        transitioned_to: std::sync::Mutex::new(None),\n    };\n\n    let args = UpdateArgs {\n        key: \"X-1\".to_string(),\n        summary: None,\n        status: None,\n        assign: Some(\"other-user-123\".to_string()),\n    };\n\n    let output = process_update(\u0026client, \u0026args).await.unwrap();\n    assert!(output.contains(\"Updated assignee\"));\n\n    let updated = client.updated_fields.lock().unwrap();\n    assert_eq!(\n        updated.as_ref().unwrap().assignee,\n        Some(\"other-user-123\".to_string())\n    );\n}\n\n#[tokio::test]\nasync fn process_update_transitions_status() {\n    let client = MockJiraClient {\n        user: User {\n            account_id: \"me\".to_string(),\n            display_name: \"Me\".to_string(),\n            email_address: None,\n        },\n        transitions: vec![\n            Transition {\n                id: \"11\".to_string(),\n                name: \"To Do\".to_string(),\n            },\n            Transition {\n                id: \"21\".to_string(),\n                name: \"In Progress\".to_string(),\n            },\n            Transition {\n                id: \"31\".to_string(),\n                name: \"Done\".to_string(),\n            },\n        ],\n        updated_fields: std::sync::Mutex::new(None),\n        transitioned_to: std::sync::Mutex::new(None),\n    };\n\n    let args = UpdateArgs {\n        key: \"X-1\".to_string(),\n        summary: None,\n        status: Some(\"Done\".to_string()),\n        assign: None,\n    };\n\n    let output = process_update(\u0026client, \u0026args).await.unwrap();\n    assert!(output.contains(\"Transitioned to: Done\"));\n\n    let transitioned = client.transitioned_to.lock().unwrap();\n    assert_eq!(transitioned.as_ref().unwrap(), \"31\");\n}\n\n#[tokio::test]\nasync fn process_update_fails_no_changes() {\n    let client = MockJiraClient {\n        user: User {\n            account_id: \"me\".to_string(),\n            display_name: \"Me\".to_string(),\n            email_address: None,\n        },\n        transitions: vec![],\n        updated_fields: std::sync::Mutex::new(None),\n        transitioned_to: std::sync::Mutex::new(None),\n    };\n\n    let args = UpdateArgs {\n        key: \"X-1\".to_string(),\n        summary: None,\n        status: None,\n        assign: None,\n    };\n\n    let result = process_update(\u0026client, \u0026args).await;\n    assert!(result.is_err());\n    assert!(result\n        .unwrap_err()\n        .to_string()\n        .contains(\"No changes specified\"));\n}\n\n#[tokio::test]\nasync fn process_update_multiple_changes() {\n    let client = MockJiraClient {\n        user: User {\n            account_id: \"me123\".to_string(),\n            display_name: \"Me\".to_string(),\n            email_address: None,\n        },\n        transitions: vec![Transition {\n            id: \"31\".to_string(),\n            name: \"Done\".to_string(),\n        }],\n        updated_fields: std::sync::Mutex::new(None),\n        transitioned_to: std::sync::Mutex::new(None),\n    };\n\n    let args = UpdateArgs {\n        key: \"X-1\".to_string(),\n        summary: Some(\"Updated\".to_string()),\n        status: Some(\"Done\".to_string()),\n        assign: Some(\"me\".to_string()),\n    };\n\n    let output = process_update(\u0026client, \u0026args).await.unwrap();\n    assert!(output.contains(\"Updated summary\"));\n    assert!(output.contains(\"Updated assignee\"));\n    assert!(output.contains(\"Transitioned to: Done\"));\n}\n","traces":[{"line":121,"address":[],"length":0,"stats":{"Line":4}},{"line":122,"address":[],"length":0,"stats":{"Line":2}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":8}},{"line":134,"address":[],"length":0,"stats":{"Line":12}},{"line":135,"address":[],"length":0,"stats":{"Line":4}},{"line":138,"address":[],"length":0,"stats":{"Line":4}},{"line":139,"address":[],"length":0,"stats":{"Line":2}},{"line":142,"address":[],"length":0,"stats":{"Line":4}},{"line":143,"address":[],"length":0,"stats":{"Line":6}},{"line":144,"address":[],"length":0,"stats":{"Line":2}}],"covered":10,"coverable":12},{"path":["/","Users","chi","Projects","hu","src","main.rs"],"content":"use clap::{CommandFactory, Parser};\n\nmod cli;\nmod context;\nmod data;\nmod docs;\nmod eks;\nmod gh;\nmod git;\nmod install;\nmod jira;\nmod newrelic;\nmod pagerduty;\nmod pipeline;\nmod read;\nmod sentry;\nmod slack;\nmod util;\nmod utils;\n\nuse cli::{Cli, Command};\n\n#[tokio::main]\nasync fn main() -\u003e anyhow::Result\u003c()\u003e {\n    let cli = Cli::parse();\n\n    match cli.command {\n        Some(cmd) =\u003e run_command(cmd).await,\n        None =\u003e {\n            Cli::command().print_help()?;\n            println!();\n            Ok(())\n        }\n    }\n}\n\nasync fn run_command(cmd: Command) -\u003e anyhow::Result\u003c()\u003e {\n    match cmd {\n        Command::Jira { cmd: Some(cmd) } =\u003e {\n            return jira::run_command(cmd).await;\n        }\n        Command::Jira { cmd: None } =\u003e {\n            print_subcommand_help(\"jira\")?;\n        }\n        Command::Gh { cmd: Some(cmd) } =\u003e {\n            return gh::run_command(cmd).await;\n        }\n        Command::Gh { cmd: None } =\u003e {\n            print_subcommand_help(\"gh\")?;\n        }\n        Command::Slack { cmd: Some(cmd) } =\u003e {\n            return slack::run(cmd).await;\n        }\n        Command::Slack { cmd: None } =\u003e {\n            print_subcommand_help(\"slack\")?;\n        }\n        Command::PagerDuty { cmd: Some(cmd) } =\u003e {\n            return pagerduty::run(cmd).await;\n        }\n        Command::PagerDuty { cmd: None } =\u003e {\n            print_subcommand_help(\"pagerduty\")?;\n        }\n        Command::Sentry { cmd: Some(cmd) } =\u003e {\n            return sentry::run(cmd).await;\n        }\n        Command::Sentry { cmd: None } =\u003e {\n            print_subcommand_help(\"sentry\")?;\n        }\n        Command::NewRelic { cmd: Some(cmd) } =\u003e {\n            return newrelic::run(cmd).await;\n        }\n        Command::NewRelic { cmd: None } =\u003e {\n            print_subcommand_help(\"newrelic\")?;\n        }\n        Command::Eks { cmd: Some(cmd) } =\u003e {\n            return eks::run(cmd).await;\n        }\n        Command::Eks { cmd: None } =\u003e {\n            print_subcommand_help(\"eks\")?;\n        }\n        Command::Pipeline { cmd: Some(cmd) } =\u003e {\n            return pipeline::run(cmd).await;\n        }\n        Command::Pipeline { cmd: None } =\u003e {\n            print_subcommand_help(\"pipeline\")?;\n        }\n        Command::Utils { cmd: Some(cmd) } =\u003e {\n            return utils::run_command(cmd).await;\n        }\n        Command::Utils { cmd: None } =\u003e {\n            print_subcommand_help(\"utils\")?;\n        }\n        Command::Context { cmd: Some(cmd) } =\u003e {\n            return context::run_command(cmd).await;\n        }\n        Command::Context { cmd: None } =\u003e {\n            print_subcommand_help(\"context\")?;\n        }\n        Command::Read(args) =\u003e {\n            return read::run(args);\n        }\n        Command::Data { cmd: Some(cmd) } =\u003e {\n            return data::run_command(cmd).await;\n        }\n        Command::Data { cmd: None } =\u003e {\n            print_subcommand_help(\"data\")?;\n        }\n        Command::Install { cmd: Some(cmd) } =\u003e {\n            return install::run_command(cmd).await;\n        }\n        Command::Install { cmd: None } =\u003e {\n            print_subcommand_help(\"install\")?;\n        }\n        Command::Docs { cmd: Some(cmd) } =\u003e {\n            return docs::run_command(cmd).await;\n        }\n        Command::Docs { cmd: None } =\u003e {\n            print_subcommand_help(\"docs\")?;\n        }\n    }\n    Ok(())\n}\n\nfn print_subcommand_help(name: \u0026str) -\u003e anyhow::Result\u003c()\u003e {\n    let mut cmd = Cli::command();\n    for sub in cmd.get_subcommands_mut() {\n        if sub.get_name() == name {\n            sub.print_help()?;\n            println!();\n            return Ok(());\n        }\n    }\n    unreachable!(\"unknown subcommand: {}\", name)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn parses_no_args() {\n        let cli = Cli::try_parse_from::\u003c[\u0026str; 0], \u0026str\u003e([]).unwrap();\n        assert!(cli.command.is_none());\n    }\n\n    #[test]\n    fn parses_subcommand_without_action() {\n        let cli = Cli::try_parse_from([\"hu\", \"jira\"]).unwrap();\n        assert!(matches!(cli.command, Some(Command::Jira { cmd: None })));\n    }\n\n    #[test]\n    fn parses_command_aliases() {\n        // pd -\u003e pagerduty\n        let cli = Cli::try_parse_from([\"hu\", \"pd\", \"oncall\"]).unwrap();\n        assert!(matches!(cli.command, Some(Command::PagerDuty { .. })));\n\n        // nr -\u003e newrelic\n        let cli = Cli::try_parse_from([\"hu\", \"nr\", \"incidents\"]).unwrap();\n        assert!(matches!(cli.command, Some(Command::NewRelic { .. })));\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":66}},{"line":25,"address":[],"length":0,"stats":{"Line":66}},{"line":27,"address":[],"length":0,"stats":{"Line":66}},{"line":28,"address":[],"length":0,"stats":{"Line":90}},{"line":29,"address":[],"length":0,"stats":{"Line":33}},{"line":30,"address":[],"length":0,"stats":{"Line":61}},{"line":31,"address":[],"length":0,"stats":{"Line":47}},{"line":32,"address":[],"length":0,"stats":{"Line":47}},{"line":37,"address":[],"length":0,"stats":{"Line":38}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":39,"address":[],"length":0,"stats":{"Line":1}},{"line":40,"address":[],"length":0,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":1}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":2}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":4}},{"line":61,"address":[],"length":0,"stats":{"Line":2}},{"line":63,"address":[],"length":0,"stats":{"Line":1}},{"line":64,"address":[],"length":0,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":2}},{"line":69,"address":[],"length":0,"stats":{"Line":1}},{"line":70,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":2}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":2}},{"line":79,"address":[],"length":0,"stats":{"Line":2}},{"line":81,"address":[],"length":0,"stats":{"Line":1}},{"line":82,"address":[],"length":0,"stats":{"Line":2}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":87,"address":[],"length":0,"stats":{"Line":2}},{"line":88,"address":[],"length":0,"stats":{"Line":4}},{"line":91,"address":[],"length":0,"stats":{"Line":2}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":9}},{"line":124,"address":[],"length":0,"stats":{"Line":9}},{"line":125,"address":[],"length":0,"stats":{"Line":18}},{"line":126,"address":[],"length":0,"stats":{"Line":63}},{"line":127,"address":[],"length":0,"stats":{"Line":45}},{"line":128,"address":[],"length":0,"stats":{"Line":18}},{"line":129,"address":[],"length":0,"stats":{"Line":9}},{"line":130,"address":[],"length":0,"stats":{"Line":9}}],"covered":43,"coverable":59},{"path":["/","Users","chi","Projects","hu","src","newrelic","client","mod.rs"],"content":"//! New Relic NerdGraph client\n\nuse anyhow::Result;\nuse reqwest::Client;\nuse serde::{Deserialize, Serialize};\nuse std::future::Future;\nuse std::time::Duration;\nuse tokio::time::sleep;\n\nuse super::config::{load_config, NewRelicConfig};\nuse super::types::{Incident, Issue};\n\n#[cfg(test)]\nmod tests;\n\nconst NERDGRAPH_URL: \u0026str = \"https://api.newrelic.com/graphql\";\n\n/// Trait for New Relic API operations (enables testing with mocks)\npub trait NewRelicApi {\n    /// List recent issues\n    fn list_issues(\u0026self, limit: usize) -\u003e impl Future\u003cOutput = Result\u003cVec\u003cIssue\u003e\u003e\u003e + Send;\n\n    /// List recent incidents\n    fn list_incidents(\u0026self, limit: usize) -\u003e impl Future\u003cOutput = Result\u003cVec\u003cIncident\u003e\u003e\u003e + Send;\n\n    /// Run NRQL query\n    fn run_nrql(\u0026self, nrql: \u0026str) -\u003e impl Future\u003cOutput = Result\u003cVec\u003cserde_json::Value\u003e\u003e\u003e + Send;\n}\nconst MAX_RETRIES: u32 = 3;\nconst DEFAULT_RETRY_SECS: u64 = 5;\n\n/// GraphQL request\n#[derive(Debug, Serialize, Deserialize)]\nstruct GraphQLRequest {\n    query: String,\n    variables: serde_json::Value,\n}\n\n/// GraphQL response\n#[derive(Debug, Deserialize)]\nstruct GraphQLResponse\u003cT\u003e {\n    data: Option\u003cT\u003e,\n    errors: Option\u003cVec\u003cGraphQLError\u003e\u003e,\n}\n\n/// GraphQL error\n#[derive(Debug, Deserialize)]\nstruct GraphQLError {\n    message: String,\n}\n\n/// New Relic client\npub struct NewRelicClient {\n    config: NewRelicConfig,\n    http: Client,\n}\n\nimpl NewRelicClient {\n    /// Create a new client\n    pub fn new() -\u003e Result\u003cSelf\u003e {\n        let config = load_config()?;\n        let http = Client::builder().user_agent(\"hu-cli/0.1.0\").build()?;\n        Ok(Self { config, http })\n    }\n\n    /// Get API key\n    fn api_key(\u0026self) -\u003e Result\u003c\u0026str\u003e {\n        self.config\n            .api_key\n            .as_deref()\n            .ok_or_else(|| anyhow::anyhow!(\"New Relic API key not configured\"))\n    }\n\n    /// Get account ID\n    fn account_id(\u0026self) -\u003e Result\u003ci64\u003e {\n        self.config\n            .account_id\n            .ok_or_else(|| anyhow::anyhow!(\"New Relic account ID not configured\"))\n    }\n\n    /// List recent issues\n    pub async fn list_issues(\u0026self, limit: usize) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n        let account_id = self.account_id()?;\n\n        let query = r#\"\n            query($accountId: Int!, $cursor: String) {\n                actor {\n                    account(id: $accountId) {\n                        aiIssues {\n                            issues(cursor: $cursor) {\n                                issues {\n                                    issueId\n                                    title\n                                    priority\n                                    state\n                                    entityNames\n                                    createdAt\n                                    closedAt\n                                    activatedAt\n                                }\n                                nextCursor\n                            }\n                        }\n                    }\n                }\n            }\n        \"#;\n\n        let variables = serde_json::json!({\n            \"accountId\": account_id,\n            \"cursor\": null\n        });\n\n        #[derive(Deserialize)]\n        struct IssuesResponse {\n            actor: Actor,\n        }\n\n        #[derive(Deserialize)]\n        struct Actor {\n            account: Account,\n        }\n\n        #[derive(Deserialize)]\n        #[serde(rename_all = \"camelCase\")]\n        struct Account {\n            ai_issues: AiIssues,\n        }\n\n        #[derive(Deserialize)]\n        struct AiIssues {\n            issues: IssuesData,\n        }\n\n        #[derive(Deserialize)]\n        #[serde(rename_all = \"camelCase\")]\n        struct IssuesData {\n            issues: Vec\u003cIssue\u003e,\n            #[allow(dead_code)]\n            next_cursor: Option\u003cString\u003e,\n        }\n\n        let response: IssuesResponse = self.execute_graphql(query, variables).await?;\n        let mut issues = response.actor.account.ai_issues.issues.issues;\n        issues.truncate(limit);\n        Ok(issues)\n    }\n\n    /// List recent incidents\n    pub async fn list_incidents(\u0026self, limit: usize) -\u003e Result\u003cVec\u003cIncident\u003e\u003e {\n        let account_id = self.account_id()?;\n\n        let query = r#\"\n            query($accountId: Int!, $cursor: String) {\n                actor {\n                    account(id: $accountId) {\n                        aiIssues {\n                            incidents(cursor: $cursor) {\n                                incidents {\n                                    incidentId\n                                    title\n                                    priority\n                                    state\n                                    accountIds\n                                    createdAt\n                                    closedAt\n                                }\n                                nextCursor\n                            }\n                        }\n                    }\n                }\n            }\n        \"#;\n\n        let variables = serde_json::json!({\n            \"accountId\": account_id,\n            \"cursor\": null\n        });\n\n        #[derive(Deserialize)]\n        struct IncidentsResponse {\n            actor: Actor,\n        }\n\n        #[derive(Deserialize)]\n        struct Actor {\n            account: Account,\n        }\n\n        #[derive(Deserialize)]\n        #[serde(rename_all = \"camelCase\")]\n        struct Account {\n            ai_issues: AiIssues,\n        }\n\n        #[derive(Deserialize)]\n        struct AiIssues {\n            incidents: IncidentsData,\n        }\n\n        #[derive(Deserialize)]\n        #[serde(rename_all = \"camelCase\")]\n        struct IncidentsData {\n            incidents: Vec\u003cIncident\u003e,\n            #[allow(dead_code)]\n            next_cursor: Option\u003cString\u003e,\n        }\n\n        let response: IncidentsResponse = self.execute_graphql(query, variables).await?;\n        let mut incidents = response.actor.account.ai_issues.incidents.incidents;\n        incidents.truncate(limit);\n        Ok(incidents)\n    }\n\n    /// Run NRQL query\n    pub async fn run_nrql(\u0026self, nrql: \u0026str) -\u003e Result\u003cVec\u003cserde_json::Value\u003e\u003e {\n        let account_id = self.account_id()?;\n\n        let query = r#\"\n            query($accountId: Int!, $nrql: Nrql!) {\n                actor {\n                    account(id: $accountId) {\n                        nrql(query: $nrql) {\n                            results\n                        }\n                    }\n                }\n            }\n        \"#;\n\n        let variables = serde_json::json!({\n            \"accountId\": account_id,\n            \"nrql\": nrql\n        });\n\n        #[derive(Deserialize)]\n        struct NrqlResponse {\n            actor: Actor,\n        }\n\n        #[derive(Deserialize)]\n        struct Actor {\n            account: Account,\n        }\n\n        #[derive(Deserialize)]\n        struct Account {\n            nrql: NrqlData,\n        }\n\n        #[derive(Deserialize)]\n        struct NrqlData {\n            results: Vec\u003cserde_json::Value\u003e,\n        }\n\n        let response: NrqlResponse = self.execute_graphql(query, variables).await?;\n        Ok(response.actor.account.nrql.results)\n    }\n\n    /// Execute GraphQL query\n    async fn execute_graphql\u003cT: for\u003c'de\u003e Deserialize\u003c'de\u003e\u003e(\n        \u0026self,\n        query: \u0026str,\n        variables: serde_json::Value,\n    ) -\u003e Result\u003cT\u003e {\n        let api_key = self.api_key()?.to_string();\n\n        let request = GraphQLRequest {\n            query: query.to_string(),\n            variables,\n        };\n\n        let body = serde_json::to_string(\u0026request)?;\n\n        let mut retries = 0;\n\n        loop {\n            let response = self\n                .http\n                .post(NERDGRAPH_URL)\n                .header(\"Api-Key\", \u0026api_key)\n                .header(\"Content-Type\", \"application/json\")\n                .body(body.clone())\n                .send()\n                .await?;\n\n            let status = response.status();\n\n            if status == reqwest::StatusCode::TOO_MANY_REQUESTS {\n                if retries \u003e= MAX_RETRIES {\n                    return Err(anyhow::anyhow!(\n                        \"Rate limited after {} retries\",\n                        MAX_RETRIES\n                    ));\n                }\n\n                let retry_after = response\n                    .headers()\n                    .get(\"retry-after\")\n                    .and_then(|v| v.to_str().ok())\n                    .and_then(|s| s.parse::\u003cu64\u003e().ok())\n                    .unwrap_or(DEFAULT_RETRY_SECS);\n\n                eprintln!(\n                    \"Rate limited, waiting {} seconds... (retry {}/{})\",\n                    retry_after,\n                    retries + 1,\n                    MAX_RETRIES\n                );\n                sleep(Duration::from_secs(retry_after)).await;\n                retries += 1;\n                continue;\n            }\n\n            if !status.is_success() {\n                let body = response.text().await.unwrap_or_default();\n                return Err(anyhow::anyhow!(\"HTTP {}: {}\", status.as_u16(), body));\n            }\n\n            let text = response.text().await?;\n            let gql_response: GraphQLResponse\u003cT\u003e = serde_json::from_str(\u0026text).map_err(|e| {\n                anyhow::anyhow!(\"Parse error: {}: {}\", e, \u0026text[..text.len().min(200)])\n            })?;\n\n            if let Some(errors) = gql_response.errors {\n                let messages: Vec\u003c_\u003e = errors.iter().map(|e| e.message.as_str()).collect();\n                return Err(anyhow::anyhow!(\"GraphQL errors: {}\", messages.join(\", \")));\n            }\n\n            return gql_response\n                .data\n                .ok_or_else(|| anyhow::anyhow!(\"No data in response\"));\n        }\n    }\n\n    /// Create client from provided config (for testing)\n    #[cfg(test)]\n    pub fn with_config(config: NewRelicConfig) -\u003e Result\u003cSelf\u003e {\n        let http = Client::builder().user_agent(\"hu-cli/0.1.0\").build()?;\n        Ok(Self { config, http })\n    }\n\n    /// Get config reference (for testing)\n    #[cfg(test)]\n    pub fn config(\u0026self) -\u003e \u0026NewRelicConfig {\n        \u0026self.config\n    }\n}\n\nimpl NewRelicApi for NewRelicClient {\n    async fn list_issues(\u0026self, limit: usize) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n        NewRelicClient::list_issues(self, limit).await\n    }\n\n    async fn list_incidents(\u0026self, limit: usize) -\u003e Result\u003cVec\u003cIncident\u003e\u003e {\n        NewRelicClient::list_incidents(self, limit).await\n    }\n\n    async fn run_nrql(\u0026self, nrql: \u0026str) -\u003e Result\u003cVec\u003cserde_json::Value\u003e\u003e {\n        NewRelicClient::run_nrql(self, nrql).await\n    }\n}\n","traces":[{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":3}},{"line":68,"address":[],"length":0,"stats":{"Line":3}},{"line":69,"address":[],"length":0,"stats":{"Line":3}},{"line":71,"address":[],"length":0,"stats":{"Line":5}},{"line":75,"address":[],"length":0,"stats":{"Line":3}},{"line":76,"address":[],"length":0,"stats":{"Line":3}},{"line":77,"address":[],"length":0,"stats":{"Line":3}},{"line":78,"address":[],"length":0,"stats":{"Line":5}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":4}},{"line":340,"address":[],"length":0,"stats":{"Line":16}},{"line":341,"address":[],"length":0,"stats":{"Line":4}},{"line":346,"address":[],"length":0,"stats":{"Line":1}},{"line":347,"address":[],"length":0,"stats":{"Line":1}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}}],"covered":13,"coverable":130},{"path":["/","Users","chi","Projects","hu","src","newrelic","client","tests.rs"],"content":"use super::*;\nuse anyhow::Result;\nuse serde::Deserialize;\n\n/// Parse issues from GraphQL response JSON\nfn parse_issues_response(json: \u0026str) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n    #[derive(Deserialize)]\n    struct IssuesResponse {\n        actor: Actor,\n    }\n\n    #[derive(Deserialize)]\n    struct Actor {\n        account: Account,\n    }\n\n    #[derive(Deserialize)]\n    #[serde(rename_all = \"camelCase\")]\n    struct Account {\n        ai_issues: AiIssues,\n    }\n\n    #[derive(Deserialize)]\n    struct AiIssues {\n        issues: IssuesData,\n    }\n\n    #[derive(Deserialize)]\n    #[serde(rename_all = \"camelCase\")]\n    struct IssuesData {\n        issues: Vec\u003cIssue\u003e,\n        #[allow(dead_code)]\n        next_cursor: Option\u003cString\u003e,\n    }\n\n    let response: IssuesResponse = serde_json::from_str(json)?;\n    Ok(response.actor.account.ai_issues.issues.issues)\n}\n\n/// Parse incidents from GraphQL response JSON\nfn parse_incidents_response(json: \u0026str) -\u003e Result\u003cVec\u003cIncident\u003e\u003e {\n    #[derive(Deserialize)]\n    struct IncidentsResponse {\n        actor: Actor,\n    }\n\n    #[derive(Deserialize)]\n    struct Actor {\n        account: Account,\n    }\n\n    #[derive(Deserialize)]\n    #[serde(rename_all = \"camelCase\")]\n    struct Account {\n        ai_issues: AiIssues,\n    }\n\n    #[derive(Deserialize)]\n    struct AiIssues {\n        incidents: IncidentsData,\n    }\n\n    #[derive(Deserialize)]\n    #[serde(rename_all = \"camelCase\")]\n    struct IncidentsData {\n        incidents: Vec\u003cIncident\u003e,\n        #[allow(dead_code)]\n        next_cursor: Option\u003cString\u003e,\n    }\n\n    let response: IncidentsResponse = serde_json::from_str(json)?;\n    Ok(response.actor.account.ai_issues.incidents.incidents)\n}\n\n/// Parse NRQL results from GraphQL response JSON\nfn parse_nrql_response(json: \u0026str) -\u003e Result\u003cVec\u003cserde_json::Value\u003e\u003e {\n    #[derive(Deserialize)]\n    struct NrqlResponse {\n        actor: Actor,\n    }\n\n    #[derive(Deserialize)]\n    struct Actor {\n        account: Account,\n    }\n\n    #[derive(Deserialize)]\n    struct Account {\n        nrql: NrqlData,\n    }\n\n    #[derive(Deserialize)]\n    struct NrqlData {\n        results: Vec\u003cserde_json::Value\u003e,\n    }\n\n    let response: NrqlResponse = serde_json::from_str(json)?;\n    Ok(response.actor.account.nrql.results)\n}\n\n/// Build GraphQL request body\nfn build_graphql_request(query: \u0026str, variables: serde_json::Value) -\u003e Result\u003cString\u003e {\n    let request = GraphQLRequest {\n        query: query.to_string(),\n        variables,\n    };\n    Ok(serde_json::to_string(\u0026request)?)\n}\n\n/// Parse GraphQL errors from response\nfn parse_graphql_errors(json: \u0026str) -\u003e Option\u003cVec\u003cString\u003e\u003e {\n    #[derive(Deserialize)]\n    struct ErrorResponse {\n        errors: Option\u003cVec\u003cGraphQLError\u003e\u003e,\n    }\n\n    let response: ErrorResponse = serde_json::from_str(json).ok()?;\n    response\n        .errors\n        .map(|errs| errs.into_iter().map(|e| e.message).collect())\n}\n\n#[test]\nfn test_graphql_request_serialize() {\n    let request = GraphQLRequest {\n        query: \"query { test }\".to_string(),\n        variables: serde_json::json!({\"id\": 123}),\n    };\n    let json = serde_json::to_string(\u0026request).unwrap();\n    assert!(json.contains(\"query\"));\n    assert!(json.contains(\"variables\"));\n    assert!(json.contains(\"test\"));\n    assert!(json.contains(\"123\"));\n}\n\n#[test]\nfn test_graphql_request_deserialize() {\n    let json = r#\"{\"query\":\"query { test }\",\"variables\":{\"id\":456}}\"#;\n    let request: GraphQLRequest = serde_json::from_str(json).unwrap();\n    assert_eq!(request.query, \"query { test }\");\n    assert_eq!(request.variables[\"id\"], 456);\n}\n\n#[test]\nfn test_graphql_request_debug() {\n    let request = GraphQLRequest {\n        query: \"test\".to_string(),\n        variables: serde_json::json!({}),\n    };\n    let debug = format!(\"{:?}\", request);\n    assert!(debug.contains(\"GraphQLRequest\"));\n}\n\n#[test]\nfn test_graphql_response_with_data() {\n    let json = r#\"{\"data\":{\"value\":42},\"errors\":null}\"#;\n    let response: GraphQLResponse\u003cserde_json::Value\u003e = serde_json::from_str(json).unwrap();\n    assert!(response.data.is_some());\n    assert!(response.errors.is_none());\n    assert_eq!(response.data.unwrap()[\"value\"], 42);\n}\n\n#[test]\nfn test_graphql_response_with_errors() {\n    let json = r#\"{\"data\":null,\"errors\":[{\"message\":\"Something went wrong\"}]}\"#;\n    let response: GraphQLResponse\u003cserde_json::Value\u003e = serde_json::from_str(json).unwrap();\n    assert!(response.data.is_none());\n    assert!(response.errors.is_some());\n    let errors = response.errors.unwrap();\n    assert_eq!(errors.len(), 1);\n    assert_eq!(errors[0].message, \"Something went wrong\");\n}\n\n#[test]\nfn test_graphql_response_debug() {\n    let json = r#\"{\"data\":null,\"errors\":null}\"#;\n    let response: GraphQLResponse\u003cserde_json::Value\u003e = serde_json::from_str(json).unwrap();\n    let debug = format!(\"{:?}\", response);\n    assert!(debug.contains(\"GraphQLResponse\"));\n}\n\n#[test]\nfn test_graphql_error_debug() {\n    let json = r#\"{\"message\":\"Error!\"}\"#;\n    let error: GraphQLError = serde_json::from_str(json).unwrap();\n    let debug = format!(\"{:?}\", error);\n    assert!(debug.contains(\"GraphQLError\"));\n    assert!(debug.contains(\"Error!\"));\n}\n\n#[test]\nfn test_parse_issues_response() {\n    let json = r#\"{\n        \"actor\": {\n            \"account\": {\n                \"aiIssues\": {\n                    \"issues\": {\n                        \"issues\": [\n                            {\n                                \"issueId\": \"ISS-001\",\n                                \"title\": [\"Issue Title\"],\n                                \"priority\": \"HIGH\",\n                                \"state\": \"ACTIVATED\",\n                                \"entityNames\": [\"svc-a\"],\n                                \"createdAt\": 1700000000000,\n                                \"closedAt\": null,\n                                \"activatedAt\": 1700000100000\n                            }\n                        ],\n                        \"nextCursor\": null\n                    }\n                }\n            }\n        }\n    }\"#;\n    let issues = parse_issues_response(json).unwrap();\n    assert_eq!(issues.len(), 1);\n    assert_eq!(issues[0].issue_id, \"ISS-001\");\n    assert_eq!(issues[0].priority, \"HIGH\");\n}\n\n#[test]\nfn test_parse_issues_response_empty() {\n    let json = r#\"{\n        \"actor\": {\n            \"account\": {\n                \"aiIssues\": {\n                    \"issues\": {\n                        \"issues\": [],\n                        \"nextCursor\": null\n                    }\n                }\n            }\n        }\n    }\"#;\n    let issues = parse_issues_response(json).unwrap();\n    assert!(issues.is_empty());\n}\n\n#[test]\nfn test_parse_issues_response_with_cursor() {\n    let json = r#\"{\n        \"actor\": {\n            \"account\": {\n                \"aiIssues\": {\n                    \"issues\": {\n                        \"issues\": [],\n                        \"nextCursor\": \"abc123\"\n                    }\n                }\n            }\n        }\n    }\"#;\n    let issues = parse_issues_response(json).unwrap();\n    assert!(issues.is_empty());\n}\n\n#[test]\nfn test_parse_issues_response_invalid() {\n    let json = r#\"{\"invalid\":\"json\"}\"#;\n    let result = parse_issues_response(json);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_parse_incidents_response() {\n    let json = r#\"{\n        \"actor\": {\n            \"account\": {\n                \"aiIssues\": {\n                    \"incidents\": {\n                        \"incidents\": [\n                            {\n                                \"incidentId\": \"INC-001\",\n                                \"title\": \"Incident Title\",\n                                \"priority\": \"CRITICAL\",\n                                \"state\": \"CLOSED\",\n                                \"accountIds\": [12345],\n                                \"createdAt\": 1700000000000,\n                                \"closedAt\": 1700001000000\n                            }\n                        ],\n                        \"nextCursor\": null\n                    }\n                }\n            }\n        }\n    }\"#;\n    let incidents = parse_incidents_response(json).unwrap();\n    assert_eq!(incidents.len(), 1);\n    assert_eq!(incidents[0].incident_id, \"INC-001\");\n    assert_eq!(incidents[0].priority, \"CRITICAL\");\n}\n\n#[test]\nfn test_parse_incidents_response_empty() {\n    let json = r#\"{\n        \"actor\": {\n            \"account\": {\n                \"aiIssues\": {\n                    \"incidents\": {\n                        \"incidents\": [],\n                        \"nextCursor\": null\n                    }\n                }\n            }\n        }\n    }\"#;\n    let incidents = parse_incidents_response(json).unwrap();\n    assert!(incidents.is_empty());\n}\n\n#[test]\nfn test_parse_incidents_response_invalid() {\n    let json = r#\"{\"malformed\":\"response\"}\"#;\n    let result = parse_incidents_response(json);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_parse_nrql_response() {\n    let json = r#\"{\n        \"actor\": {\n            \"account\": {\n                \"nrql\": {\n                    \"results\": [\n                        {\"count\": 42, \"name\": \"test1\"},\n                        {\"count\": 100, \"name\": \"test2\"}\n                    ]\n                }\n            }\n        }\n    }\"#;\n    let results = parse_nrql_response(json).unwrap();\n    assert_eq!(results.len(), 2);\n    assert_eq!(results[0][\"count\"], 42);\n    assert_eq!(results[1][\"name\"], \"test2\");\n}\n\n#[test]\nfn test_parse_nrql_response_empty() {\n    let json = r#\"{\n        \"actor\": {\n            \"account\": {\n                \"nrql\": {\n                    \"results\": []\n                }\n            }\n        }\n    }\"#;\n    let results = parse_nrql_response(json).unwrap();\n    assert!(results.is_empty());\n}\n\n#[test]\nfn test_parse_nrql_response_invalid() {\n    let json = r#\"{\"not\":\"valid\"}\"#;\n    let result = parse_nrql_response(json);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_build_graphql_request() {\n    let query = \"query { test }\";\n    let variables = serde_json::json!({\"accountId\": 12345});\n    let body = build_graphql_request(query, variables).unwrap();\n\n    let parsed: serde_json::Value = serde_json::from_str(\u0026body).unwrap();\n    assert_eq!(parsed[\"query\"], \"query { test }\");\n    assert_eq!(parsed[\"variables\"][\"accountId\"], 12345);\n}\n\n#[test]\nfn test_build_graphql_request_complex_variables() {\n    let query = \"mutation { create }\";\n    let variables = serde_json::json!({\n        \"input\": {\n            \"name\": \"Test\",\n            \"values\": [1, 2, 3]\n        }\n    });\n    let body = build_graphql_request(query, variables).unwrap();\n    let parsed: serde_json::Value = serde_json::from_str(\u0026body).unwrap();\n    assert_eq!(parsed[\"variables\"][\"input\"][\"name\"], \"Test\");\n}\n\n#[test]\nfn test_parse_graphql_errors_present() {\n    let json = r#\"{\"errors\":[{\"message\":\"Error 1\"},{\"message\":\"Error 2\"}]}\"#;\n    let errors = parse_graphql_errors(json).unwrap();\n    assert_eq!(errors.len(), 2);\n    assert_eq!(errors[0], \"Error 1\");\n    assert_eq!(errors[1], \"Error 2\");\n}\n\n#[test]\nfn test_parse_graphql_errors_none() {\n    let json = r#\"{\"data\":{\"result\":\"ok\"}}\"#;\n    let errors = parse_graphql_errors(json);\n    assert!(errors.is_none());\n}\n\n#[test]\nfn test_parse_graphql_errors_null() {\n    let json = r#\"{\"errors\":null}\"#;\n    let errors = parse_graphql_errors(json);\n    assert!(errors.is_none());\n}\n\n#[test]\nfn test_parse_graphql_errors_invalid_json() {\n    let json = \"not valid json\";\n    let errors = parse_graphql_errors(json);\n    assert!(errors.is_none());\n}\n\n#[test]\nfn test_client_with_config_no_api_key() {\n    let config = NewRelicConfig {\n        api_key: None,\n        account_id: Some(12345),\n    };\n    let client = NewRelicClient::with_config(config).unwrap();\n    assert!(client.api_key().is_err());\n    assert!(client.account_id().is_ok());\n}\n\n#[test]\nfn test_client_with_config_no_account_id() {\n    let config = NewRelicConfig {\n        api_key: Some(\"NRAK-test\".to_string()),\n        account_id: None,\n    };\n    let client = NewRelicClient::with_config(config).unwrap();\n    assert!(client.api_key().is_ok());\n    assert!(client.account_id().is_err());\n}\n\n#[test]\nfn test_client_with_config_both() {\n    let config = NewRelicConfig {\n        api_key: Some(\"NRAK-both\".to_string()),\n        account_id: Some(99999),\n    };\n    let client = NewRelicClient::with_config(config).unwrap();\n    assert_eq!(client.api_key().unwrap(), \"NRAK-both\");\n    assert_eq!(client.account_id().unwrap(), 99999);\n}\n\n#[test]\nfn test_client_config_ref() {\n    let config = NewRelicConfig {\n        api_key: Some(\"NRAK-ref\".to_string()),\n        account_id: Some(11111),\n    };\n    let client = NewRelicClient::with_config(config).unwrap();\n    let config_ref = client.config();\n    assert_eq!(config_ref.api_key, Some(\"NRAK-ref\".to_string()));\n    assert_eq!(config_ref.account_id, Some(11111));\n}\n\n#[test]\nfn test_constants() {\n    assert_eq!(NERDGRAPH_URL, \"https://api.newrelic.com/graphql\");\n    assert_eq!(MAX_RETRIES, 3);\n    assert_eq!(DEFAULT_RETRY_SECS, 5);\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":4}},{"line":36,"address":[],"length":0,"stats":{"Line":15}},{"line":37,"address":[],"length":0,"stats":{"Line":3}},{"line":41,"address":[],"length":0,"stats":{"Line":3}},{"line":71,"address":[],"length":0,"stats":{"Line":11}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":76,"address":[],"length":0,"stats":{"Line":3}},{"line":97,"address":[],"length":0,"stats":{"Line":11}},{"line":98,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":2}},{"line":104,"address":[],"length":0,"stats":{"Line":4}},{"line":107,"address":[],"length":0,"stats":{"Line":4}},{"line":111,"address":[],"length":0,"stats":{"Line":4}},{"line":117,"address":[],"length":0,"stats":{"Line":19}},{"line":118,"address":[],"length":0,"stats":{"Line":3}},{"line":119,"address":[],"length":0,"stats":{"Line":3}},{"line":120,"address":[],"length":0,"stats":{"Line":7}}],"covered":17,"coverable":17},{"path":["/","Users","chi","Projects","hu","src","newrelic","config.rs"],"content":"//! New Relic configuration\n\nuse anyhow::Result;\nuse serde::{Deserialize, Serialize};\nuse std::fs;\nuse std::path::PathBuf;\n\n/// New Relic configuration\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct NewRelicConfig {\n    /// API key (NRAK-...)\n    pub api_key: Option\u003cString\u003e,\n    /// Account ID\n    pub account_id: Option\u003ci64\u003e,\n}\n\nimpl NewRelicConfig {\n    /// Check if configured\n    #[must_use]\n    pub fn is_configured(\u0026self) -\u003e bool {\n        self.api_key.is_some() \u0026\u0026 self.account_id.is_some()\n    }\n}\n\n/// Settings file structure\n#[derive(Debug, Default, Deserialize)]\nstruct SettingsFile {\n    newrelic: Option\u003cNewRelicConfig\u003e,\n}\n\n/// Get path to config file\npub fn config_path() -\u003e Option\u003cPathBuf\u003e {\n    dirs::home_dir().map(|p| p.join(\".config\").join(\"hu\").join(\"settings.toml\"))\n}\n\n/// Load config from settings file and environment\npub fn load_config() -\u003e Result\u003cNewRelicConfig\u003e {\n    let mut config = NewRelicConfig::default();\n\n    // Load from settings file\n    if let Some(path) = config_path() {\n        if path.exists() {\n            let contents = fs::read_to_string(\u0026path)?;\n            let settings: SettingsFile = toml::from_str(\u0026contents)?;\n            if let Some(nr) = settings.newrelic {\n                config = nr;\n            }\n        }\n    }\n\n    // Override with environment variables\n    if let Ok(key) = std::env::var(\"NEW_RELIC_API_KEY\") {\n        config.api_key = Some(key);\n    }\n    if let Ok(id) = std::env::var(\"NEW_RELIC_ACCOUNT_ID\") {\n        if let Ok(parsed) = id.parse() {\n            config.account_id = Some(parsed);\n        }\n    }\n\n    Ok(config)\n}\n\n/// Save config to file\npub fn save_config(api_key: \u0026str, account_id: i64) -\u003e Result\u003c()\u003e {\n    let path = config_path().ok_or_else(|| anyhow::anyhow!(\"Cannot determine config directory\"))?;\n\n    let contents = if path.exists() {\n        fs::read_to_string(\u0026path)?\n    } else {\n        String::new()\n    };\n\n    let mut doc: toml::Value =\n        toml::from_str(\u0026contents).unwrap_or_else(|_| toml::Value::Table(toml::map::Map::new()));\n\n    let table = doc\n        .as_table_mut()\n        .ok_or_else(|| anyhow::anyhow!(\"Config is not a table\"))?;\n\n    if !table.contains_key(\"newrelic\") {\n        table.insert(\n            \"newrelic\".to_string(),\n            toml::Value::Table(toml::map::Map::new()),\n        );\n    }\n\n    let nr = table\n        .get_mut(\"newrelic\")\n        .and_then(|v| v.as_table_mut())\n        .ok_or_else(|| anyhow::anyhow!(\"newrelic section is not a table\"))?;\n\n    nr.insert(\n        \"api_key\".to_string(),\n        toml::Value::String(api_key.to_string()),\n    );\n    nr.insert(\"account_id\".to_string(), toml::Value::Integer(account_id));\n\n    let output = toml::to_string_pretty(\u0026doc)?;\n\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent)?;\n    }\n\n    fs::write(\u0026path, output)?;\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_newrelic_config_is_configured_both_set() {\n        let config = NewRelicConfig {\n            api_key: Some(\"NRAK-12345\".to_string()),\n            account_id: Some(12345),\n        };\n        assert!(config.is_configured());\n    }\n\n    #[test]\n    fn test_newrelic_config_is_configured_only_api_key() {\n        let config = NewRelicConfig {\n            api_key: Some(\"NRAK-12345\".to_string()),\n            account_id: None,\n        };\n        assert!(!config.is_configured());\n    }\n\n    #[test]\n    fn test_newrelic_config_is_configured_only_account_id() {\n        let config = NewRelicConfig {\n            api_key: None,\n            account_id: Some(12345),\n        };\n        assert!(!config.is_configured());\n    }\n\n    #[test]\n    fn test_newrelic_config_is_configured_neither() {\n        let config = NewRelicConfig {\n            api_key: None,\n            account_id: None,\n        };\n        assert!(!config.is_configured());\n    }\n\n    #[test]\n    fn test_newrelic_config_default() {\n        let config = NewRelicConfig::default();\n        assert!(config.api_key.is_none());\n        assert!(config.account_id.is_none());\n        assert!(!config.is_configured());\n    }\n\n    #[test]\n    fn test_config_path_returns_some() {\n        let path = config_path();\n        if let Some(p) = path {\n            assert!(p.to_string_lossy().contains(\"settings.toml\"));\n        }\n    }\n\n    #[test]\n    fn test_newrelic_config_serialization() {\n        let config = NewRelicConfig {\n            api_key: Some(\"NRAK-test123\".to_string()),\n            account_id: Some(99999),\n        };\n\n        let serialized = serde_json::to_string(\u0026config).unwrap();\n        assert!(serialized.contains(\"api_key\"));\n        assert!(serialized.contains(\"NRAK-test123\"));\n        assert!(serialized.contains(\"account_id\"));\n        assert!(serialized.contains(\"99999\"));\n    }\n\n    #[test]\n    fn test_newrelic_config_deserialization() {\n        let json = r#\"{\"api_key\":\"NRAK-abc\",\"account_id\":12345}\"#;\n        let config: NewRelicConfig = serde_json::from_str(json).unwrap();\n        assert_eq!(config.api_key, Some(\"NRAK-abc\".to_string()));\n        assert_eq!(config.account_id, Some(12345));\n    }\n\n    #[test]\n    fn test_newrelic_config_deserialization_null_fields() {\n        let json = r#\"{\"api_key\":null,\"account_id\":null}\"#;\n        let config: NewRelicConfig = serde_json::from_str(json).unwrap();\n        assert!(config.api_key.is_none());\n        assert!(config.account_id.is_none());\n        assert!(!config.is_configured());\n    }\n\n    #[test]\n    fn test_newrelic_config_deserialization_empty_object() {\n        let json = r#\"{}\"#;\n        let config: NewRelicConfig = serde_json::from_str(json).unwrap();\n        assert!(config.api_key.is_none());\n        assert!(config.account_id.is_none());\n    }\n\n    #[test]\n    fn test_newrelic_config_clone() {\n        let config = NewRelicConfig {\n            api_key: Some(\"NRAK-xyz\".to_string()),\n            account_id: Some(54321),\n        };\n        let cloned = config.clone();\n        assert_eq!(cloned.api_key, config.api_key);\n        assert_eq!(cloned.account_id, config.account_id);\n    }\n\n    #[test]\n    fn test_newrelic_config_debug() {\n        let config = NewRelicConfig {\n            api_key: Some(\"NRAK-key\".to_string()),\n            account_id: Some(11111),\n        };\n        let debug = format!(\"{:?}\", config);\n        assert!(debug.contains(\"NewRelicConfig\"));\n        assert!(debug.contains(\"api_key\"));\n        assert!(debug.contains(\"account_id\"));\n    }\n\n    #[test]\n    fn test_settings_file_deserialization_with_newrelic() {\n        let toml = r#\"\n[newrelic]\napi_key = \"NRAK-fromfile\"\naccount_id = 777\n\"#;\n        let settings: SettingsFile = toml::from_str(toml).unwrap();\n        assert!(settings.newrelic.is_some());\n        let nr = settings.newrelic.unwrap();\n        assert_eq!(nr.api_key, Some(\"NRAK-fromfile\".to_string()));\n        assert_eq!(nr.account_id, Some(777));\n    }\n\n    #[test]\n    fn test_settings_file_deserialization_empty() {\n        let toml = \"\";\n        let settings: SettingsFile = toml::from_str(toml).unwrap();\n        assert!(settings.newrelic.is_none());\n    }\n\n    #[test]\n    fn test_settings_file_deserialization_without_newrelic() {\n        let toml = r#\"\n[sentry]\nauth_token = \"secret\"\n\"#;\n        let settings: SettingsFile = toml::from_str(toml).unwrap();\n        assert!(settings.newrelic.is_none());\n    }\n\n    #[test]\n    fn test_settings_file_debug() {\n        let settings = SettingsFile { newrelic: None };\n        let debug = format!(\"{:?}\", settings);\n        assert!(debug.contains(\"SettingsFile\"));\n    }\n\n    #[test]\n    fn test_settings_file_default() {\n        let settings = SettingsFile::default();\n        assert!(settings.newrelic.is_none());\n    }\n\n    #[test]\n    fn test_config_path_hu_directory() {\n        if let Some(path) = config_path() {\n            // Should be in ~/.config/hu/settings.toml\n            let path_str = path.to_string_lossy();\n            assert!(path_str.contains(\".config\"));\n            assert!(path_str.contains(\"hu\"));\n            assert!(path_str.ends_with(\"settings.toml\"));\n        }\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":14}},{"line":21,"address":[],"length":0,"stats":{"Line":40}},{"line":32,"address":[],"length":0,"stats":{"Line":3}},{"line":33,"address":[],"length":0,"stats":{"Line":12}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":41,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":1}},{"line":43,"address":[],"length":0,"stats":{"Line":3}},{"line":44,"address":[],"length":0,"stats":{"Line":4}},{"line":45,"address":[],"length":0,"stats":{"Line":1}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":1}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}}],"covered":14,"coverable":43},{"path":["/","Users","chi","Projects","hu","src","newrelic","display","mod.rs"],"content":"//! New Relic output formatting\n\nuse anyhow::{Context, Result};\nuse comfy_table::{presets::UTF8_FULL_CONDENSED, Cell, Color, ContentArrangement, Table};\n\nuse super::types::{Incident, Issue, OutputFormat};\n\n#[cfg(test)]\nmod tests;\n\n/// Format timestamp from epoch millis\nfn format_time(ts: Option\u003ci64\u003e) -\u003e String {\n    let Some(ms) = ts else {\n        return \"-\".to_string();\n    };\n\n    let secs = ms / 1000;\n    let Some(dt) = chrono::DateTime::from_timestamp(secs, 0) else {\n        return \"-\".to_string();\n    };\n\n    let now = chrono::Utc::now();\n    let duration = now.signed_duration_since(dt);\n\n    if duration.num_days() \u003e 0 {\n        format!(\"{}d ago\", duration.num_days())\n    } else if duration.num_hours() \u003e 0 {\n        format!(\"{}h ago\", duration.num_hours())\n    } else if duration.num_minutes() \u003e 0 {\n        format!(\"{}m ago\", duration.num_minutes())\n    } else {\n        \"just now\".to_string()\n    }\n}\n\n/// Truncate string\nfn truncate(s: \u0026str, max_len: usize) -\u003e String {\n    if s.len() \u003c= max_len {\n        s.to_string()\n    } else {\n        format!(\"{}...\", \u0026s[..max_len.saturating_sub(3)])\n    }\n}\n\n/// Color for priority\nfn priority_color(priority: \u0026str) -\u003e Color {\n    match priority.to_uppercase().as_str() {\n        \"CRITICAL\" =\u003e Color::Red,\n        \"HIGH\" =\u003e Color::Yellow,\n        \"MEDIUM\" =\u003e Color::Blue,\n        _ =\u003e Color::White,\n    }\n}\n\n/// Color for state\nfn state_color(state: \u0026str) -\u003e Color {\n    match state.to_uppercase().as_str() {\n        \"CLOSED\" =\u003e Color::Green,\n        \"ACTIVATED\" | \"ACTIVE\" =\u003e Color::Red,\n        _ =\u003e Color::White,\n    }\n}\n\n/// Output issues list\npub fn output_issues(issues: \u0026[Issue], format: OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            if issues.is_empty() {\n                println!(\"No issues found.\");\n                return Ok(());\n            }\n\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_content_arrangement(ContentArrangement::Dynamic);\n            table.set_header(vec![\n                \"ID\", \"Priority\", \"State\", \"Title\", \"Entities\", \"Created\",\n            ]);\n\n            for issue in issues {\n                let title = issue.title.join(\", \");\n                let entities = issue.entity_names.join(\", \");\n\n                table.add_row(vec![\n                    Cell::new(\u0026issue.issue_id[..issue.issue_id.len().min(12)]).fg(Color::Cyan),\n                    Cell::new(\u0026issue.priority).fg(priority_color(\u0026issue.priority)),\n                    Cell::new(\u0026issue.state).fg(state_color(\u0026issue.state)),\n                    Cell::new(truncate(\u0026title, 40)),\n                    Cell::new(truncate(\u0026entities, 20)),\n                    Cell::new(format_time(issue.created_at)),\n                ]);\n            }\n\n            println!(\"{table}\");\n            println!(\"\\n{} issues\", issues.len());\n        }\n        OutputFormat::Json =\u003e {\n            let json = serde_json::to_string_pretty(issues).context(\"Failed to serialize\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n\n/// Output incidents list\npub fn output_incidents(incidents: \u0026[Incident], format: OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            if incidents.is_empty() {\n                println!(\"No incidents found.\");\n                return Ok(());\n            }\n\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_content_arrangement(ContentArrangement::Dynamic);\n            table.set_header(vec![\"ID\", \"Priority\", \"State\", \"Title\", \"Created\"]);\n\n            for incident in incidents {\n                table.add_row(vec![\n                    Cell::new(\u0026incident.incident_id[..incident.incident_id.len().min(12)])\n                        .fg(Color::Cyan),\n                    Cell::new(\u0026incident.priority).fg(priority_color(\u0026incident.priority)),\n                    Cell::new(\u0026incident.state).fg(state_color(\u0026incident.state)),\n                    Cell::new(truncate(\u0026incident.title, 50)),\n                    Cell::new(format_time(incident.created_at)),\n                ]);\n            }\n\n            println!(\"{table}\");\n            println!(\"\\n{} incidents\", incidents.len());\n        }\n        OutputFormat::Json =\u003e {\n            let json = serde_json::to_string_pretty(incidents).context(\"Failed to serialize\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n\n/// Output NRQL results\npub fn output_nrql(results: \u0026[serde_json::Value], format: OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            if results.is_empty() {\n                println!(\"No results.\");\n                return Ok(());\n            }\n\n            // Try to create table from results\n            if let Some(first) = results.first() {\n                if let Some(obj) = first.as_object() {\n                    let mut table = Table::new();\n                    table.load_preset(UTF8_FULL_CONDENSED);\n                    table.set_content_arrangement(ContentArrangement::Dynamic);\n\n                    // Headers from first object\n                    let headers: Vec\u003c_\u003e = obj.keys().collect();\n                    table.set_header(headers.iter().map(|h| h.as_str()).collect::\u003cVec\u003c_\u003e\u003e());\n\n                    // Rows\n                    for result in results {\n                        if let Some(obj) = result.as_object() {\n                            let row: Vec\u003c_\u003e = headers\n                                .iter()\n                                .map(|h| {\n                                    obj.get(*h)\n                                        .map(format_json_value)\n                                        .unwrap_or_else(|| \"-\".to_string())\n                                })\n                                .collect();\n                            table.add_row(row);\n                        }\n                    }\n\n                    println!(\"{table}\");\n                    println!(\"\\n{} results\", results.len());\n                    return Ok(());\n                }\n            }\n\n            // Fallback to JSON\n            let json = serde_json::to_string_pretty(results)?;\n            println!(\"{json}\");\n        }\n        OutputFormat::Json =\u003e {\n            let json = serde_json::to_string_pretty(results).context(\"Failed to serialize\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n\n/// Format JSON value for table display\nfn format_json_value(v: \u0026serde_json::Value) -\u003e String {\n    match v {\n        serde_json::Value::Null =\u003e \"-\".to_string(),\n        serde_json::Value::String(s) =\u003e s.clone(),\n        serde_json::Value::Number(n) =\u003e n.to_string(),\n        serde_json::Value::Bool(b) =\u003e b.to_string(),\n        _ =\u003e v.to_string(),\n    }\n}\n\n/// Output config status\npub fn output_config_status(config: \u0026super::config::NewRelicConfig) {\n    println!(\"New Relic Configuration\");\n    println!(\"{}\", \"-\".repeat(40));\n    println!(\n        \"API key:    {}\",\n        if config.api_key.is_some() {\n            \"Yes\"\n        } else {\n            \"No\"\n        }\n    );\n    println!(\n        \"Account ID: {}\",\n        config\n            .account_id\n            .map(|id| id.to_string())\n            .unwrap_or_else(|| \"Not set\".to_string())\n    );\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":9}},{"line":13,"address":[],"length":0,"stats":{"Line":17}},{"line":14,"address":[],"length":0,"stats":{"Line":2}},{"line":17,"address":[],"length":0,"stats":{"Line":16}},{"line":18,"address":[],"length":0,"stats":{"Line":15}},{"line":19,"address":[],"length":0,"stats":{"Line":2}},{"line":22,"address":[],"length":0,"stats":{"Line":14}},{"line":23,"address":[],"length":0,"stats":{"Line":28}},{"line":25,"address":[],"length":0,"stats":{"Line":7}},{"line":26,"address":[],"length":0,"stats":{"Line":12}},{"line":27,"address":[],"length":0,"stats":{"Line":4}},{"line":28,"address":[],"length":0,"stats":{"Line":4}},{"line":29,"address":[],"length":0,"stats":{"Line":3}},{"line":30,"address":[],"length":0,"stats":{"Line":4}},{"line":32,"address":[],"length":0,"stats":{"Line":4}},{"line":37,"address":[],"length":0,"stats":{"Line":9}},{"line":38,"address":[],"length":0,"stats":{"Line":18}},{"line":39,"address":[],"length":0,"stats":{"Line":6}},{"line":41,"address":[],"length":0,"stats":{"Line":24}},{"line":46,"address":[],"length":0,"stats":{"Line":9}},{"line":47,"address":[],"length":0,"stats":{"Line":9}},{"line":48,"address":[],"length":0,"stats":{"Line":11}},{"line":49,"address":[],"length":0,"stats":{"Line":9}},{"line":50,"address":[],"length":0,"stats":{"Line":7}},{"line":51,"address":[],"length":0,"stats":{"Line":3}},{"line":56,"address":[],"length":0,"stats":{"Line":8}},{"line":57,"address":[],"length":0,"stats":{"Line":8}},{"line":58,"address":[],"length":0,"stats":{"Line":10}},{"line":59,"address":[],"length":0,"stats":{"Line":14}},{"line":60,"address":[],"length":0,"stats":{"Line":3}},{"line":65,"address":[],"length":0,"stats":{"Line":3}},{"line":66,"address":[],"length":0,"stats":{"Line":3}},{"line":68,"address":[],"length":0,"stats":{"Line":4}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":2}},{"line":74,"address":[],"length":0,"stats":{"Line":3}},{"line":75,"address":[],"length":0,"stats":{"Line":3}},{"line":76,"address":[],"length":0,"stats":{"Line":3}},{"line":77,"address":[],"length":0,"stats":{"Line":5}},{"line":80,"address":[],"length":0,"stats":{"Line":4}},{"line":81,"address":[],"length":0,"stats":{"Line":4}},{"line":82,"address":[],"length":0,"stats":{"Line":4}},{"line":84,"address":[],"length":0,"stats":{"Line":4}},{"line":85,"address":[],"length":0,"stats":{"Line":7}},{"line":86,"address":[],"length":0,"stats":{"Line":6}},{"line":87,"address":[],"length":0,"stats":{"Line":6}},{"line":88,"address":[],"length":0,"stats":{"Line":4}},{"line":89,"address":[],"length":0,"stats":{"Line":4}},{"line":90,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":2}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":98,"address":[],"length":0,"stats":{"Line":4}},{"line":99,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":2}},{"line":106,"address":[],"length":0,"stats":{"Line":3}},{"line":107,"address":[],"length":0,"stats":{"Line":3}},{"line":109,"address":[],"length":0,"stats":{"Line":4}},{"line":110,"address":[],"length":0,"stats":{"Line":2}},{"line":111,"address":[],"length":0,"stats":{"Line":1}},{"line":114,"address":[],"length":0,"stats":{"Line":2}},{"line":115,"address":[],"length":0,"stats":{"Line":3}},{"line":116,"address":[],"length":0,"stats":{"Line":3}},{"line":117,"address":[],"length":0,"stats":{"Line":7}},{"line":119,"address":[],"length":0,"stats":{"Line":4}},{"line":120,"address":[],"length":0,"stats":{"Line":4}},{"line":121,"address":[],"length":0,"stats":{"Line":5}},{"line":122,"address":[],"length":0,"stats":{"Line":3}},{"line":123,"address":[],"length":0,"stats":{"Line":6}},{"line":124,"address":[],"length":0,"stats":{"Line":6}},{"line":125,"address":[],"length":0,"stats":{"Line":4}},{"line":126,"address":[],"length":0,"stats":{"Line":2}},{"line":130,"address":[],"length":0,"stats":{"Line":2}},{"line":131,"address":[],"length":0,"stats":{"Line":4}},{"line":134,"address":[],"length":0,"stats":{"Line":4}},{"line":135,"address":[],"length":0,"stats":{"Line":2}},{"line":138,"address":[],"length":0,"stats":{"Line":2}},{"line":142,"address":[],"length":0,"stats":{"Line":5}},{"line":143,"address":[],"length":0,"stats":{"Line":5}},{"line":145,"address":[],"length":0,"stats":{"Line":8}},{"line":146,"address":[],"length":0,"stats":{"Line":2}},{"line":147,"address":[],"length":0,"stats":{"Line":1}},{"line":151,"address":[],"length":0,"stats":{"Line":6}},{"line":152,"address":[],"length":0,"stats":{"Line":5}},{"line":153,"address":[],"length":0,"stats":{"Line":4}},{"line":154,"address":[],"length":0,"stats":{"Line":6}},{"line":155,"address":[],"length":0,"stats":{"Line":6}},{"line":158,"address":[],"length":0,"stats":{"Line":10}},{"line":159,"address":[],"length":0,"stats":{"Line":18}},{"line":162,"address":[],"length":0,"stats":{"Line":10}},{"line":163,"address":[],"length":0,"stats":{"Line":8}},{"line":164,"address":[],"length":0,"stats":{"Line":12}},{"line":166,"address":[],"length":0,"stats":{"Line":12}},{"line":167,"address":[],"length":0,"stats":{"Line":24}},{"line":168,"address":[],"length":0,"stats":{"Line":8}},{"line":169,"address":[],"length":0,"stats":{"Line":10}},{"line":172,"address":[],"length":0,"stats":{"Line":12}},{"line":176,"address":[],"length":0,"stats":{"Line":4}},{"line":177,"address":[],"length":0,"stats":{"Line":8}},{"line":178,"address":[],"length":0,"stats":{"Line":2}},{"line":183,"address":[],"length":0,"stats":{"Line":3}},{"line":184,"address":[],"length":0,"stats":{"Line":2}},{"line":187,"address":[],"length":0,"stats":{"Line":4}},{"line":188,"address":[],"length":0,"stats":{"Line":2}},{"line":191,"address":[],"length":0,"stats":{"Line":2}},{"line":195,"address":[],"length":0,"stats":{"Line":15}},{"line":196,"address":[],"length":0,"stats":{"Line":15}},{"line":197,"address":[],"length":0,"stats":{"Line":2}},{"line":198,"address":[],"length":0,"stats":{"Line":9}},{"line":199,"address":[],"length":0,"stats":{"Line":21}},{"line":200,"address":[],"length":0,"stats":{"Line":6}},{"line":201,"address":[],"length":0,"stats":{"Line":4}},{"line":206,"address":[],"length":0,"stats":{"Line":3}},{"line":207,"address":[],"length":0,"stats":{"Line":6}},{"line":208,"address":[],"length":0,"stats":{"Line":12}},{"line":209,"address":[],"length":0,"stats":{"Line":3}},{"line":210,"address":[],"length":0,"stats":{"Line":3}},{"line":211,"address":[],"length":0,"stats":{"Line":6}},{"line":212,"address":[],"length":0,"stats":{"Line":2}},{"line":214,"address":[],"length":0,"stats":{"Line":1}},{"line":217,"address":[],"length":0,"stats":{"Line":3}},{"line":218,"address":[],"length":0,"stats":{"Line":3}},{"line":219,"address":[],"length":0,"stats":{"Line":3}},{"line":220,"address":[],"length":0,"stats":{"Line":3}},{"line":221,"address":[],"length":0,"stats":{"Line":5}},{"line":222,"address":[],"length":0,"stats":{"Line":7}}],"covered":126,"coverable":126},{"path":["/","Users","chi","Projects","hu","src","newrelic","display","tests.rs"],"content":"use super::*;\n\n#[test]\nfn test_format_time_none() {\n    assert_eq!(format_time(None), \"-\");\n}\n\n#[test]\nfn test_format_time_days_ago() {\n    let now = chrono::Utc::now();\n    let two_days_ago = now - chrono::Duration::days(2);\n    let ms = two_days_ago.timestamp() * 1000;\n    assert_eq!(format_time(Some(ms)), \"2d ago\");\n}\n\n#[test]\nfn test_format_time_hours_ago() {\n    let now = chrono::Utc::now();\n    let two_hours_ago = now - chrono::Duration::hours(2);\n    let ms = two_hours_ago.timestamp() * 1000;\n    assert_eq!(format_time(Some(ms)), \"2h ago\");\n}\n\n#[test]\nfn test_format_time_minutes_ago() {\n    let now = chrono::Utc::now();\n    let five_mins_ago = now - chrono::Duration::minutes(5);\n    let ms = five_mins_ago.timestamp() * 1000;\n    assert_eq!(format_time(Some(ms)), \"5m ago\");\n}\n\n#[test]\nfn test_format_time_just_now() {\n    let now = chrono::Utc::now();\n    let ms = now.timestamp() * 1000;\n    assert_eq!(format_time(Some(ms)), \"just now\");\n}\n\n#[test]\nfn test_truncate_short() {\n    assert_eq!(truncate(\"hello\", 10), \"hello\");\n}\n\n#[test]\nfn test_truncate_exact() {\n    assert_eq!(truncate(\"hello\", 5), \"hello\");\n}\n\n#[test]\nfn test_truncate_long() {\n    assert_eq!(truncate(\"hello world\", 8), \"hello...\");\n}\n\n#[test]\nfn test_priority_color_critical() {\n    assert_eq!(priority_color(\"CRITICAL\"), Color::Red);\n    assert_eq!(priority_color(\"critical\"), Color::Red);\n}\n\n#[test]\nfn test_priority_color_high() {\n    assert_eq!(priority_color(\"HIGH\"), Color::Yellow);\n    assert_eq!(priority_color(\"high\"), Color::Yellow);\n}\n\n#[test]\nfn test_priority_color_medium() {\n    assert_eq!(priority_color(\"MEDIUM\"), Color::Blue);\n}\n\n#[test]\nfn test_priority_color_other() {\n    assert_eq!(priority_color(\"LOW\"), Color::White);\n    assert_eq!(priority_color(\"unknown\"), Color::White);\n}\n\n#[test]\nfn test_state_color_closed() {\n    assert_eq!(state_color(\"CLOSED\"), Color::Green);\n    assert_eq!(state_color(\"closed\"), Color::Green);\n}\n\n#[test]\nfn test_state_color_active() {\n    assert_eq!(state_color(\"ACTIVATED\"), Color::Red);\n    assert_eq!(state_color(\"ACTIVE\"), Color::Red);\n    assert_eq!(state_color(\"active\"), Color::Red);\n}\n\n#[test]\nfn test_state_color_other() {\n    assert_eq!(state_color(\"PENDING\"), Color::White);\n}\n\n#[test]\nfn test_format_json_value_null() {\n    assert_eq!(format_json_value(\u0026serde_json::Value::Null), \"-\");\n}\n\n#[test]\nfn test_format_json_value_string() {\n    assert_eq!(\n        format_json_value(\u0026serde_json::Value::String(\"hello\".to_string())),\n        \"hello\"\n    );\n}\n\n#[test]\nfn test_format_json_value_number() {\n    assert_eq!(format_json_value(\u0026serde_json::json!(42)), \"42\");\n    assert_eq!(format_json_value(\u0026serde_json::json!(3.14)), \"3.14\");\n}\n\n#[test]\nfn test_format_json_value_bool() {\n    assert_eq!(format_json_value(\u0026serde_json::json!(true)), \"true\");\n    assert_eq!(format_json_value(\u0026serde_json::json!(false)), \"false\");\n}\n\n#[test]\nfn test_format_json_value_array() {\n    let arr = serde_json::json!([1, 2, 3]);\n    assert_eq!(format_json_value(\u0026arr), \"[1,2,3]\");\n}\n\n#[test]\nfn test_output_issues_empty() {\n    let issues: Vec\u003cIssue\u003e = vec![];\n    let result = output_issues(\u0026issues, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_issues_json() {\n    let issues = vec![Issue {\n        issue_id: \"12345678901234567890\".to_string(),\n        priority: \"HIGH\".to_string(),\n        state: \"ACTIVATED\".to_string(),\n        title: vec![\"Test Issue\".to_string()],\n        entity_names: vec![\"my-service\".to_string()],\n        created_at: Some(chrono::Utc::now().timestamp() * 1000),\n        closed_at: None,\n        activated_at: Some(chrono::Utc::now().timestamp() * 1000),\n    }];\n    let result = output_issues(\u0026issues, OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_incidents_empty() {\n    let incidents: Vec\u003cIncident\u003e = vec![];\n    let result = output_incidents(\u0026incidents, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_incidents_json() {\n    let incidents = vec![Incident {\n        incident_id: \"12345678901234567890\".to_string(),\n        priority: \"CRITICAL\".to_string(),\n        state: \"CLOSED\".to_string(),\n        title: \"Test Incident\".to_string(),\n        account_ids: vec![12345],\n        created_at: Some(chrono::Utc::now().timestamp() * 1000),\n        closed_at: None,\n    }];\n    let result = output_incidents(\u0026incidents, OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_nrql_empty() {\n    let results: Vec\u003cserde_json::Value\u003e = vec![];\n    let result = output_nrql(\u0026results, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_nrql_json() {\n    let results = vec![serde_json::json!({\"count\": 42, \"name\": \"test\"})];\n    let result = output_nrql(\u0026results, OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_nrql_table() {\n    let results = vec![\n        serde_json::json!({\"count\": 42, \"name\": \"test1\"}),\n        serde_json::json!({\"count\": 10, \"name\": \"test2\"}),\n    ];\n    let result = output_nrql(\u0026results, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_nrql_table_non_object() {\n    // Test fallback to JSON when results are not objects\n    let results = vec![serde_json::json!(\"string value\"), serde_json::json!(123)];\n    let result = output_nrql(\u0026results, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_nrql_table_missing_keys() {\n    // Test when second object is missing keys from first\n    let results = vec![\n        serde_json::json!({\"a\": 1, \"b\": 2}),\n        serde_json::json!({\"a\": 3}), // missing \"b\"\n    ];\n    let result = output_nrql(\u0026results, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_issues_table_with_data() {\n    let issues = vec![Issue {\n        issue_id: \"123456789012345678901234567890\".to_string(), // long ID\n        priority: \"MEDIUM\".to_string(),\n        state: \"CREATED\".to_string(),\n        title: vec![\n            \"This is a very long title that should be truncated for display purposes\".to_string(),\n        ],\n        entity_names: vec![\"service-one\".to_string(), \"service-two\".to_string()],\n        created_at: Some(chrono::Utc::now().timestamp() * 1000 - 86400000), // 1 day ago\n        closed_at: None,\n        activated_at: None,\n    }];\n    let result = output_issues(\u0026issues, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_incidents_table_with_data() {\n    let incidents = vec![Incident {\n        incident_id: \"INC-VERYLONGIDTHATWILLBETRUNCATED\".to_string(),\n        priority: \"LOW\".to_string(),\n        state: \"PENDING\".to_string(),\n        title: \"This incident title is also quite long and needs truncation\".to_string(),\n        account_ids: vec![1, 2, 3],\n        created_at: Some(chrono::Utc::now().timestamp() * 1000),\n        closed_at: Some(chrono::Utc::now().timestamp() * 1000),\n    }];\n    let result = output_incidents(\u0026incidents, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_format_time_invalid_timestamp() {\n    // Very old timestamp that might be invalid\n    let result = format_time(Some(-1000000000000000));\n    // Should still return something, not crash\n    assert!(!result.is_empty());\n}\n\n#[test]\nfn test_format_time_out_of_range() {\n    // Timestamp so large that DateTime::from_timestamp returns None\n    // i64::MAX / 1000 = ~292 billion years, way beyond chrono's range\n    let result = format_time(Some(i64::MAX));\n    assert_eq!(result, \"-\");\n}\n\n#[test]\nfn test_format_json_value_object() {\n    let obj = serde_json::json!({\"key\": \"value\"});\n    let formatted = format_json_value(\u0026obj);\n    assert!(formatted.contains(\"key\"));\n    assert!(formatted.contains(\"value\"));\n}\n\n#[test]\nfn test_truncate_empty() {\n    assert_eq!(truncate(\"\", 10), \"\");\n}\n\n#[test]\nfn test_truncate_very_short_max() {\n    // Test edge case where max_len is very small\n    assert_eq!(truncate(\"hello\", 3), \"...\");\n}\n\n#[test]\nfn test_truncate_zero() {\n    // Test edge case where max_len is 0\n    let result = truncate(\"hello\", 0);\n    // Should handle gracefully\n    assert!(result.len() \u003c= 3); // \"...\" or empty\n}\n\n#[test]\nfn test_output_config_status_configured() {\n    let config = super::super::config::NewRelicConfig {\n        api_key: Some(\"NRAK-test\".to_string()),\n        account_id: Some(12345),\n    };\n    // Just verify it doesn't panic\n    output_config_status(\u0026config);\n}\n\n#[test]\nfn test_output_config_status_not_configured() {\n    let config = super::super::config::NewRelicConfig {\n        api_key: None,\n        account_id: None,\n    };\n    output_config_status(\u0026config);\n}\n\n#[test]\nfn test_output_config_status_partial() {\n    let config = super::super::config::NewRelicConfig {\n        api_key: Some(\"NRAK-partial\".to_string()),\n        account_id: None,\n    };\n    output_config_status(\u0026config);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","newrelic","mod.rs"],"content":"//! New Relic integration\n//!\n//! Query incidents and run NRQL queries via NerdGraph.\n//!\n//! # CLI Usage\n//! Use [`run`] for CLI commands that format and print output.\n//!\n//! # Programmatic Usage (MCP/HTTP)\n//! Use the reusable functions that return typed data:\n//! - [`get_config`] - Get configuration status\n//! - [`list_issues`] - List recent issues\n//! - [`list_incidents`] - List recent incidents\n//! - [`run_nrql`] - Run NRQL query\n\nmod client;\nmod config;\nmod display;\nmod service;\npub mod types;\n\nuse anyhow::Result;\nuse clap::Subcommand;\n\nuse client::NewRelicClient;\npub use config::NewRelicConfig;\nuse types::OutputFormat;\npub use types::{Incident, Issue};\n\n/// New Relic subcommands\n#[derive(Debug, Subcommand)]\npub enum NewRelicCommand {\n    /// Show configuration status\n    Config,\n\n    /// Set API key and account ID\n    Auth {\n        /// API key (NRAK-...)\n        key: String,\n\n        /// Account ID\n        #[arg(short, long)]\n        account: i64,\n    },\n\n    /// List recent issues\n    Issues {\n        /// Maximum number of issues\n        #[arg(short, long, default_value = \"25\")]\n        limit: usize,\n\n        /// Output as JSON\n        #[arg(long)]\n        json: bool,\n    },\n\n    /// List recent incidents\n    Incidents {\n        /// Maximum number of incidents\n        #[arg(short, long, default_value = \"25\")]\n        limit: usize,\n\n        /// Output as JSON\n        #[arg(long)]\n        json: bool,\n    },\n\n    /// Run NRQL query\n    Query {\n        /// NRQL query string\n        nrql: String,\n\n        /// Output as JSON\n        #[arg(long)]\n        json: bool,\n    },\n}\n\n/// Run a New Relic command (CLI entry point - formats and prints)\n#[cfg(not(tarpaulin_include))]\npub async fn run(cmd: NewRelicCommand) -\u003e Result\u003c()\u003e {\n    match cmd {\n        NewRelicCommand::Config =\u003e cmd_config(),\n        NewRelicCommand::Auth { key, account } =\u003e cmd_auth(\u0026key, account),\n        NewRelicCommand::Issues { limit, json } =\u003e cmd_issues(limit, json).await,\n        NewRelicCommand::Incidents { limit, json } =\u003e cmd_incidents(limit, json).await,\n        NewRelicCommand::Query { nrql, json } =\u003e cmd_query(\u0026nrql, json).await,\n    }\n}\n\n// ============================================================================\n// Reusable functions for MCP/HTTP - return typed data, never print\n// ============================================================================\n\n/// Get New Relic configuration status (for MCP/HTTP)\n#[allow(dead_code)]\npub fn get_config() -\u003e Result\u003cNewRelicConfig\u003e {\n    service::get_config()\n}\n\n/// List recent issues (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn list_issues(limit: usize) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n    let client = NewRelicClient::new()?;\n    service::list_issues(\u0026client, limit).await\n}\n\n/// List recent incidents (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn list_incidents(limit: usize) -\u003e Result\u003cVec\u003cIncident\u003e\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n    let client = NewRelicClient::new()?;\n    service::list_incidents(\u0026client, limit).await\n}\n\n/// Run NRQL query (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn run_nrql(nrql: \u0026str) -\u003e Result\u003cVec\u003cserde_json::Value\u003e\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n    let client = NewRelicClient::new()?;\n    service::run_nrql(\u0026client, nrql).await\n}\n\n// ============================================================================\n// CLI command handlers - create client, call service, format and print\n// ============================================================================\n\n/// Show config status\nfn cmd_config() -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    display::output_config_status(\u0026config);\n    Ok(())\n}\n\n/// Set auth\nfn cmd_auth(key: \u0026str, account_id: i64) -\u003e Result\u003c()\u003e {\n    service::save_auth(key, account_id)?;\n    println!(\"New Relic API key saved for account: {}\", account_id);\n    Ok(())\n}\n\n/// List issues\nasync fn cmd_issues(limit: usize, json: bool) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n\n    let client = NewRelicClient::new()?;\n    let issues = service::list_issues(\u0026client, limit).await?;\n\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n\n    display::output_issues(\u0026issues, format)?;\n    Ok(())\n}\n\n/// List incidents\nasync fn cmd_incidents(limit: usize, json: bool) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n\n    let client = NewRelicClient::new()?;\n    let incidents = service::list_incidents(\u0026client, limit).await?;\n\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n\n    display::output_incidents(\u0026incidents, format)?;\n    Ok(())\n}\n\n/// Run NRQL query\nasync fn cmd_query(nrql: \u0026str, json: bool) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n\n    let client = NewRelicClient::new()?;\n    let results = service::run_nrql(\u0026client, nrql).await?;\n\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n\n    display::output_nrql(\u0026results, format)?;\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_newrelic_command_config_variant() {\n        let cmd = NewRelicCommand::Config;\n        let debug = format!(\"{:?}\", cmd);\n        assert!(debug.contains(\"Config\"));\n    }\n\n    #[test]\n    fn test_newrelic_command_auth_variant() {\n        let cmd = NewRelicCommand::Auth {\n            key: \"NRAK-test\".to_string(),\n            account: 12345,\n        };\n        let debug = format!(\"{:?}\", cmd);\n        assert!(debug.contains(\"Auth\"));\n        assert!(debug.contains(\"NRAK-test\"));\n        assert!(debug.contains(\"12345\"));\n    }\n\n    #[test]\n    fn test_newrelic_command_issues_variant() {\n        let cmd = NewRelicCommand::Issues {\n            limit: 50,\n            json: true,\n        };\n        let debug = format!(\"{:?}\", cmd);\n        assert!(debug.contains(\"Issues\"));\n        assert!(debug.contains(\"50\"));\n        assert!(debug.contains(\"true\"));\n    }\n\n    #[test]\n    fn test_newrelic_command_incidents_variant() {\n        let cmd = NewRelicCommand::Incidents {\n            limit: 10,\n            json: false,\n        };\n        let debug = format!(\"{:?}\", cmd);\n        assert!(debug.contains(\"Incidents\"));\n        assert!(debug.contains(\"10\"));\n        assert!(debug.contains(\"false\"));\n    }\n\n    #[test]\n    fn test_newrelic_command_query_variant() {\n        let cmd = NewRelicCommand::Query {\n            nrql: \"SELECT count(*) FROM Transaction\".to_string(),\n            json: true,\n        };\n        let debug = format!(\"{:?}\", cmd);\n        assert!(debug.contains(\"Query\"));\n        assert!(debug.contains(\"SELECT\"));\n        assert!(debug.contains(\"Transaction\"));\n    }\n\n    #[test]\n    fn test_ensure_configured_with_configured() {\n        let config = config::NewRelicConfig {\n            api_key: Some(\"NRAK-configured\".to_string()),\n            account_id: Some(99999),\n        };\n        let result = service::ensure_configured(\u0026config);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_ensure_configured_with_unconfigured() {\n        let config = config::NewRelicConfig {\n            api_key: None,\n            account_id: None,\n        };\n        let result = service::ensure_configured(\u0026config);\n        assert!(result.is_err());\n        let err_msg = result.unwrap_err().to_string();\n        assert!(err_msg.contains(\"not configured\"));\n    }\n\n    #[test]\n    fn test_ensure_configured_partial_api_key_only() {\n        let config = config::NewRelicConfig {\n            api_key: Some(\"NRAK-partial\".to_string()),\n            account_id: None,\n        };\n        let result = service::ensure_configured(\u0026config);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_ensure_configured_partial_account_only() {\n        let config = config::NewRelicConfig {\n            api_key: None,\n            account_id: Some(12345),\n        };\n        let result = service::ensure_configured(\u0026config);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_output_format_from_json_flag_true() {\n        let json = true;\n        let format = if json {\n            OutputFormat::Json\n        } else {\n            OutputFormat::Table\n        };\n        assert!(matches!(format, OutputFormat::Json));\n    }\n\n    #[test]\n    fn test_output_format_from_json_flag_false() {\n        let json = false;\n        let format = if json {\n            OutputFormat::Json\n        } else {\n            OutputFormat::Table\n        };\n        assert!(matches!(format, OutputFormat::Table));\n    }\n}\n","traces":[{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":2}},{"line":165,"address":[],"length":0,"stats":{"Line":2}},{"line":166,"address":[],"length":0,"stats":{"Line":3}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}}],"covered":3,"coverable":55},{"path":["/","Users","chi","Projects","hu","src","newrelic","service.rs"],"content":"//! New Relic service layer - business logic that returns data\n//!\n//! Functions in this module accept trait objects and return typed data.\n//! They never print - that's the CLI layer's job.\n\nuse anyhow::{bail, Result};\n\nuse super::client::NewRelicApi;\nuse super::config::{self, NewRelicConfig};\nuse super::types::{Incident, Issue};\n\n/// Get current configuration\npub fn get_config() -\u003e Result\u003cNewRelicConfig\u003e {\n    config::load_config()\n}\n\n/// Save API key and account ID\npub fn save_auth(key: \u0026str, account_id: i64) -\u003e Result\u003c()\u003e {\n    config::save_config(key, account_id)\n}\n\n/// Check if API is configured, return error if not\npub fn ensure_configured(config: \u0026NewRelicConfig) -\u003e Result\u003c()\u003e {\n    if !config.is_configured() {\n        bail!(\n            \"New Relic not configured. Run: hu newrelic auth \u003ckey\u003e --account \u003cid\u003e\\n\\\n             Or set NEW_RELIC_API_KEY and NEW_RELIC_ACCOUNT_ID environment variables.\"\n        );\n    }\n    Ok(())\n}\n\n/// List recent issues\npub async fn list_issues(api: \u0026impl NewRelicApi, limit: usize) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n    api.list_issues(limit).await\n}\n\n/// List recent incidents\npub async fn list_incidents(api: \u0026impl NewRelicApi, limit: usize) -\u003e Result\u003cVec\u003cIncident\u003e\u003e {\n    api.list_incidents(limit).await\n}\n\n/// Run NRQL query\npub async fn run_nrql(api: \u0026impl NewRelicApi, nrql: \u0026str) -\u003e Result\u003cVec\u003cserde_json::Value\u003e\u003e {\n    api.run_nrql(nrql).await\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    /// Mock New Relic API for testing\n    struct MockApi {\n        issues: Vec\u003cIssue\u003e,\n        incidents: Vec\u003cIncident\u003e,\n        nrql_results: Vec\u003cserde_json::Value\u003e,\n    }\n\n    impl MockApi {\n        fn new() -\u003e Self {\n            Self {\n                issues: vec![],\n                incidents: vec![],\n                nrql_results: vec![],\n            }\n        }\n\n        fn with_issues(mut self, issues: Vec\u003cIssue\u003e) -\u003e Self {\n            self.issues = issues;\n            self\n        }\n\n        fn with_incidents(mut self, incidents: Vec\u003cIncident\u003e) -\u003e Self {\n            self.incidents = incidents;\n            self\n        }\n\n        fn with_nrql_results(mut self, results: Vec\u003cserde_json::Value\u003e) -\u003e Self {\n            self.nrql_results = results;\n            self\n        }\n    }\n\n    impl NewRelicApi for MockApi {\n        async fn list_issues(\u0026self, limit: usize) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n            Ok(self.issues.iter().take(limit).cloned().collect())\n        }\n\n        async fn list_incidents(\u0026self, limit: usize) -\u003e Result\u003cVec\u003cIncident\u003e\u003e {\n            Ok(self.incidents.iter().take(limit).cloned().collect())\n        }\n\n        async fn run_nrql(\u0026self, _nrql: \u0026str) -\u003e Result\u003cVec\u003cserde_json::Value\u003e\u003e {\n            Ok(self.nrql_results.clone())\n        }\n    }\n\n    fn make_issue(id: \u0026str, title: \u0026str, priority: \u0026str, state: \u0026str) -\u003e Issue {\n        Issue {\n            issue_id: id.to_string(),\n            title: vec![title.to_string()],\n            priority: priority.to_string(),\n            state: state.to_string(),\n            entity_names: vec![\"test-entity\".to_string()],\n            created_at: Some(1704067200000),\n            closed_at: None,\n            activated_at: Some(1704067200000),\n        }\n    }\n\n    fn make_incident(id: \u0026str, title: \u0026str, priority: \u0026str, state: \u0026str) -\u003e Incident {\n        Incident {\n            incident_id: id.to_string(),\n            title: title.to_string(),\n            priority: priority.to_string(),\n            state: state.to_string(),\n            account_ids: vec![12345],\n            created_at: Some(1704067200000),\n            closed_at: None,\n        }\n    }\n\n    #[tokio::test]\n    async fn list_issues_returns_all() {\n        let api = MockApi::new().with_issues(vec![\n            make_issue(\"1\", \"Issue 1\", \"CRITICAL\", \"ACTIVATED\"),\n            make_issue(\"2\", \"Issue 2\", \"HIGH\", \"CREATED\"),\n        ]);\n\n        let result = list_issues(\u0026api, 10).await.unwrap();\n        assert_eq!(result.len(), 2);\n    }\n\n    #[tokio::test]\n    async fn list_issues_respects_limit() {\n        let api = MockApi::new().with_issues(vec![\n            make_issue(\"1\", \"Issue 1\", \"CRITICAL\", \"ACTIVATED\"),\n            make_issue(\"2\", \"Issue 2\", \"HIGH\", \"CREATED\"),\n            make_issue(\"3\", \"Issue 3\", \"MEDIUM\", \"CLOSED\"),\n        ]);\n\n        let result = list_issues(\u0026api, 2).await.unwrap();\n        assert_eq!(result.len(), 2);\n    }\n\n    #[tokio::test]\n    async fn list_incidents_returns_all() {\n        let api = MockApi::new().with_incidents(vec![\n            make_incident(\"INC1\", \"Incident 1\", \"CRITICAL\", \"ACTIVATED\"),\n            make_incident(\"INC2\", \"Incident 2\", \"HIGH\", \"CREATED\"),\n        ]);\n\n        let result = list_incidents(\u0026api, 10).await.unwrap();\n        assert_eq!(result.len(), 2);\n    }\n\n    #[tokio::test]\n    async fn list_incidents_respects_limit() {\n        let api = MockApi::new().with_incidents(vec![\n            make_incident(\"INC1\", \"Incident 1\", \"CRITICAL\", \"ACTIVATED\"),\n            make_incident(\"INC2\", \"Incident 2\", \"HIGH\", \"CREATED\"),\n            make_incident(\"INC3\", \"Incident 3\", \"MEDIUM\", \"CLOSED\"),\n        ]);\n\n        let result = list_incidents(\u0026api, 2).await.unwrap();\n        assert_eq!(result.len(), 2);\n    }\n\n    #[tokio::test]\n    async fn run_nrql_returns_results() {\n        let api = MockApi::new().with_nrql_results(vec![\n            serde_json::json!({\"count\": 100}),\n            serde_json::json!({\"count\": 200}),\n        ]);\n\n        let result = run_nrql(\u0026api, \"SELECT count(*) FROM Transaction\")\n            .await\n            .unwrap();\n        assert_eq!(result.len(), 2);\n        assert_eq!(result[0][\"count\"], 100);\n    }\n\n    #[tokio::test]\n    async fn run_nrql_returns_empty() {\n        let api = MockApi::new();\n        let result = run_nrql(\u0026api, \"SELECT count(*) FROM Nothing\")\n            .await\n            .unwrap();\n        assert!(result.is_empty());\n    }\n\n    #[test]\n    fn ensure_configured_fails_without_key() {\n        let config = NewRelicConfig::default();\n        let result = ensure_configured(\u0026config);\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"not configured\"));\n    }\n\n    #[test]\n    fn ensure_configured_fails_without_account() {\n        let config = NewRelicConfig {\n            api_key: Some(\"NRAK-test\".to_string()),\n            account_id: None,\n        };\n        let result = ensure_configured(\u0026config);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn ensure_configured_succeeds_with_both() {\n        let config = NewRelicConfig {\n            api_key: Some(\"NRAK-test\".to_string()),\n            account_id: Some(12345),\n        };\n        let result = ensure_configured(\u0026config);\n        assert!(result.is_ok());\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":1}},{"line":14,"address":[],"length":0,"stats":{"Line":1}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":8}},{"line":24,"address":[],"length":0,"stats":{"Line":8}},{"line":25,"address":[],"length":0,"stats":{"Line":6}},{"line":26,"address":[],"length":0,"stats":{"Line":6}},{"line":27,"address":[],"length":0,"stats":{"Line":6}},{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":34,"address":[],"length":0,"stats":{"Line":4}},{"line":35,"address":[],"length":0,"stats":{"Line":6}},{"line":39,"address":[],"length":0,"stats":{"Line":4}},{"line":40,"address":[],"length":0,"stats":{"Line":6}},{"line":44,"address":[],"length":0,"stats":{"Line":4}},{"line":45,"address":[],"length":0,"stats":{"Line":6}}],"covered":14,"coverable":16},{"path":["/","Users","chi","Projects","hu","src","newrelic","types.rs"],"content":"//! New Relic data types\n\nuse serde::{Deserialize, Serialize};\n\n/// New Relic incident\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Incident {\n    /// Incident ID\n    pub incident_id: String,\n    /// Title\n    pub title: String,\n    /// Priority (CRITICAL, HIGH, MEDIUM, LOW)\n    #[serde(default)]\n    pub priority: String,\n    /// State (CREATED, ACTIVATED, CLOSED)\n    #[serde(default)]\n    pub state: String,\n    /// Account ID\n    pub account_ids: Vec\u003ci64\u003e,\n    /// Created at timestamp\n    #[serde(default)]\n    pub created_at: Option\u003ci64\u003e,\n    /// Closed at timestamp\n    #[serde(default)]\n    pub closed_at: Option\u003ci64\u003e,\n}\n\n/// New Relic issue (groups incidents)\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Issue {\n    /// Issue ID\n    pub issue_id: String,\n    /// Title\n    pub title: Vec\u003cString\u003e,\n    /// Priority\n    #[serde(default)]\n    pub priority: String,\n    /// State\n    #[serde(default)]\n    pub state: String,\n    /// Entity names\n    #[serde(default)]\n    pub entity_names: Vec\u003cString\u003e,\n    /// Created at\n    pub created_at: Option\u003ci64\u003e,\n    /// Closed at\n    pub closed_at: Option\u003ci64\u003e,\n    /// Activated at\n    pub activated_at: Option\u003ci64\u003e,\n}\n\n/// Output format\n#[derive(Debug, Clone, Copy, Default)]\npub enum OutputFormat {\n    #[default]\n    Table,\n    Json,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_incident_debug() {\n        let incident = Incident {\n            incident_id: \"INC123\".to_string(),\n            title: \"Test Incident\".to_string(),\n            priority: \"CRITICAL\".to_string(),\n            state: \"CLOSED\".to_string(),\n            account_ids: vec![12345],\n            created_at: Some(1704067200000),\n            closed_at: None,\n        };\n        let debug = format!(\"{:?}\", incident);\n        assert!(debug.contains(\"Incident\"));\n        assert!(debug.contains(\"INC123\"));\n    }\n\n    #[test]\n    fn test_incident_clone() {\n        let incident = Incident {\n            incident_id: \"INC123\".to_string(),\n            title: \"Test\".to_string(),\n            priority: \"HIGH\".to_string(),\n            state: \"ACTIVATED\".to_string(),\n            account_ids: vec![1, 2, 3],\n            created_at: None,\n            closed_at: None,\n        };\n        let cloned = incident.clone();\n        assert_eq!(cloned.incident_id, incident.incident_id);\n        assert_eq!(cloned.account_ids, incident.account_ids);\n    }\n\n    #[test]\n    fn test_issue_debug() {\n        let issue = Issue {\n            issue_id: \"ISS123\".to_string(),\n            title: vec![\"Test Issue\".to_string()],\n            priority: \"MEDIUM\".to_string(),\n            state: \"CREATED\".to_string(),\n            entity_names: vec![\"service-a\".to_string()],\n            created_at: Some(1704067200000),\n            closed_at: None,\n            activated_at: None,\n        };\n        let debug = format!(\"{:?}\", issue);\n        assert!(debug.contains(\"Issue\"));\n        assert!(debug.contains(\"ISS123\"));\n    }\n\n    #[test]\n    fn test_issue_clone() {\n        let issue = Issue {\n            issue_id: \"ISS123\".to_string(),\n            title: vec![\"Title 1\".to_string(), \"Title 2\".to_string()],\n            priority: \"LOW\".to_string(),\n            state: \"CLOSED\".to_string(),\n            entity_names: vec![],\n            created_at: None,\n            closed_at: Some(1704067200000),\n            activated_at: Some(1704067100000),\n        };\n        let cloned = issue.clone();\n        assert_eq!(cloned.issue_id, issue.issue_id);\n        assert_eq!(cloned.title, issue.title);\n    }\n\n    #[test]\n    fn test_output_format_default() {\n        let format = OutputFormat::default();\n        assert!(matches!(format, OutputFormat::Table));\n    }\n\n    #[test]\n    fn test_output_format_clone() {\n        let format = OutputFormat::Json;\n        let cloned = format.clone();\n        assert!(matches!(cloned, OutputFormat::Json));\n    }\n\n    #[test]\n    fn test_output_format_debug() {\n        let format = OutputFormat::Table;\n        let debug = format!(\"{:?}\", format);\n        assert_eq!(debug, \"Table\");\n    }\n\n    #[test]\n    fn test_incident_serde_default() {\n        // Test that serde default works for optional fields\n        let json = r#\"{\"incidentId\":\"INC1\",\"title\":\"Test\",\"accountIds\":[1]}\"#;\n        let incident: Incident = serde_json::from_str(json).unwrap();\n        assert_eq!(incident.priority, \"\");\n        assert_eq!(incident.state, \"\");\n        assert!(incident.created_at.is_none());\n    }\n\n    #[test]\n    fn test_issue_serde_default() {\n        let json = r#\"{\"issueId\":\"ISS1\",\"title\":[\"Test\"]}\"#;\n        let issue: Issue = serde_json::from_str(json).unwrap();\n        assert_eq!(issue.priority, \"\");\n        assert_eq!(issue.state, \"\");\n        assert!(issue.entity_names.is_empty());\n    }\n\n    #[test]\n    fn test_incident_serialize() {\n        let incident = Incident {\n            incident_id: \"INC-001\".to_string(),\n            title: \"Test\".to_string(),\n            priority: \"HIGH\".to_string(),\n            state: \"ACTIVE\".to_string(),\n            account_ids: vec![111, 222],\n            created_at: Some(1704067200000),\n            closed_at: None,\n        };\n        let json = serde_json::to_string(\u0026incident).unwrap();\n        // Should use camelCase\n        assert!(json.contains(\"incidentId\"));\n        assert!(json.contains(\"accountIds\"));\n        assert!(json.contains(\"createdAt\"));\n        assert!(!json.contains(\"incident_id\")); // Not snake_case\n    }\n\n    #[test]\n    fn test_issue_serialize() {\n        let issue = Issue {\n            issue_id: \"ISS-001\".to_string(),\n            title: vec![\"Title 1\".to_string()],\n            priority: \"CRITICAL\".to_string(),\n            state: \"CLOSED\".to_string(),\n            entity_names: vec![\"entity\".to_string()],\n            created_at: Some(1704067200000),\n            closed_at: Some(1704067300000),\n            activated_at: Some(1704067100000),\n        };\n        let json = serde_json::to_string(\u0026issue).unwrap();\n        // Should use camelCase\n        assert!(json.contains(\"issueId\"));\n        assert!(json.contains(\"entityNames\"));\n        assert!(json.contains(\"activatedAt\"));\n    }\n\n    #[test]\n    fn test_incident_full_deserialize() {\n        let json = r#\"{\n            \"incidentId\": \"INC-FULL\",\n            \"title\": \"Full incident\",\n            \"priority\": \"CRITICAL\",\n            \"state\": \"CLOSED\",\n            \"accountIds\": [1, 2, 3],\n            \"createdAt\": 1704067200000,\n            \"closedAt\": 1704067300000\n        }\"#;\n        let incident: Incident = serde_json::from_str(json).unwrap();\n        assert_eq!(incident.incident_id, \"INC-FULL\");\n        assert_eq!(incident.title, \"Full incident\");\n        assert_eq!(incident.priority, \"CRITICAL\");\n        assert_eq!(incident.state, \"CLOSED\");\n        assert_eq!(incident.account_ids, vec![1, 2, 3]);\n        assert_eq!(incident.created_at, Some(1704067200000));\n        assert_eq!(incident.closed_at, Some(1704067300000));\n    }\n\n    #[test]\n    fn test_issue_full_deserialize() {\n        let json = r#\"{\n            \"issueId\": \"ISS-FULL\",\n            \"title\": [\"Title A\", \"Title B\"],\n            \"priority\": \"HIGH\",\n            \"state\": \"ACTIVATED\",\n            \"entityNames\": [\"svc-a\", \"svc-b\"],\n            \"createdAt\": 1704067200000,\n            \"closedAt\": null,\n            \"activatedAt\": 1704067150000\n        }\"#;\n        let issue: Issue = serde_json::from_str(json).unwrap();\n        assert_eq!(issue.issue_id, \"ISS-FULL\");\n        assert_eq!(issue.title, vec![\"Title A\", \"Title B\"]);\n        assert_eq!(issue.priority, \"HIGH\");\n        assert_eq!(issue.state, \"ACTIVATED\");\n        assert_eq!(issue.entity_names, vec![\"svc-a\", \"svc-b\"]);\n        assert_eq!(issue.created_at, Some(1704067200000));\n        assert!(issue.closed_at.is_none());\n        assert_eq!(issue.activated_at, Some(1704067150000));\n    }\n\n    #[test]\n    fn test_incident_empty_account_ids() {\n        let json = r#\"{\"incidentId\":\"INC\",\"title\":\"T\",\"accountIds\":[]}\"#;\n        let incident: Incident = serde_json::from_str(json).unwrap();\n        assert!(incident.account_ids.is_empty());\n    }\n\n    #[test]\n    fn test_issue_empty_titles() {\n        let json = r#\"{\"issueId\":\"ISS\",\"title\":[]}\"#;\n        let issue: Issue = serde_json::from_str(json).unwrap();\n        assert!(issue.title.is_empty());\n    }\n\n    #[test]\n    fn test_output_format_copy() {\n        let format = OutputFormat::Json;\n        let copied = format;\n        assert!(matches!(copied, OutputFormat::Json));\n    }\n\n    #[test]\n    fn test_incident_roundtrip() {\n        let original = Incident {\n            incident_id: \"RT-001\".to_string(),\n            title: \"Roundtrip test\".to_string(),\n            priority: \"MEDIUM\".to_string(),\n            state: \"CREATED\".to_string(),\n            account_ids: vec![42],\n            created_at: Some(1700000000000),\n            closed_at: None,\n        };\n        let json = serde_json::to_string(\u0026original).unwrap();\n        let deserialized: Incident = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(deserialized.incident_id, original.incident_id);\n        assert_eq!(deserialized.title, original.title);\n        assert_eq!(deserialized.priority, original.priority);\n        assert_eq!(deserialized.state, original.state);\n        assert_eq!(deserialized.account_ids, original.account_ids);\n        assert_eq!(deserialized.created_at, original.created_at);\n        assert_eq!(deserialized.closed_at, original.closed_at);\n    }\n\n    #[test]\n    fn test_issue_roundtrip() {\n        let original = Issue {\n            issue_id: \"RT-ISS\".to_string(),\n            title: vec![\"Round\".to_string(), \"Trip\".to_string()],\n            priority: \"LOW\".to_string(),\n            state: \"PENDING\".to_string(),\n            entity_names: vec![\"e1\".to_string()],\n            created_at: Some(1600000000000),\n            closed_at: Some(1600001000000),\n            activated_at: None,\n        };\n        let json = serde_json::to_string(\u0026original).unwrap();\n        let deserialized: Issue = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(deserialized.issue_id, original.issue_id);\n        assert_eq!(deserialized.title, original.title);\n        assert_eq!(deserialized.priority, original.priority);\n        assert_eq!(deserialized.entity_names, original.entity_names);\n        assert_eq!(deserialized.created_at, original.created_at);\n        assert_eq!(deserialized.closed_at, original.closed_at);\n        assert_eq!(deserialized.activated_at, original.activated_at);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","pagerduty","cli.rs"],"content":"//! PagerDuty CLI commands\n\nuse clap::{Subcommand, ValueEnum};\n\n/// Incident status filter\n#[derive(Debug, Clone, Copy, ValueEnum)]\npub enum StatusFilter {\n    /// Only triggered incidents\n    Triggered,\n    /// Only acknowledged incidents\n    Acknowledged,\n    /// Only resolved incidents\n    Resolved,\n    /// Triggered and acknowledged (active)\n    Active,\n}\n\n#[derive(Debug, Subcommand)]\npub enum PagerDutyCommand {\n    /// Show configuration status\n    Config,\n\n    /// Set API token\n    Auth {\n        /// PagerDuty API token\n        token: String,\n    },\n\n    /// Show who's currently on call\n    Oncall {\n        /// Filter by escalation policy ID\n        #[arg(short = 'p', long)]\n        policy: Option\u003cString\u003e,\n\n        /// Filter by schedule ID\n        #[arg(short, long)]\n        schedule: Option\u003cString\u003e,\n\n        /// Output as JSON\n        #[arg(long)]\n        json: bool,\n    },\n\n    /// List active alerts (triggered + acknowledged incidents)\n    Alerts {\n        /// Maximum number to show\n        #[arg(short, long, default_value = \"25\")]\n        limit: usize,\n\n        /// Output as JSON\n        #[arg(long)]\n        json: bool,\n    },\n\n    /// List incidents with filters\n    Incidents {\n        /// Filter by status\n        #[arg(short, long, value_enum)]\n        status: Option\u003cStatusFilter\u003e,\n\n        /// Maximum number to show\n        #[arg(short, long, default_value = \"25\")]\n        limit: usize,\n\n        /// Output as JSON\n        #[arg(long)]\n        json: bool,\n    },\n\n    /// Show incident details\n    Show {\n        /// Incident ID\n        id: String,\n\n        /// Output as JSON\n        #[arg(long)]\n        json: bool,\n    },\n\n    /// Show current user info\n    Whoami {\n        /// Output as JSON\n        #[arg(long)]\n        json: bool,\n    },\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use clap::{CommandFactory, Parser};\n\n    #[derive(Parser)]\n    struct TestCli {\n        #[command(subcommand)]\n        cmd: PagerDutyCommand,\n    }\n\n    #[test]\n    fn parses_config() {\n        let cli = TestCli::try_parse_from([\"test\", \"config\"]).unwrap();\n        assert!(matches!(cli.cmd, PagerDutyCommand::Config));\n    }\n\n    #[test]\n    fn parses_auth() {\n        let cli = TestCli::try_parse_from([\"test\", \"auth\", \"my-token\"]).unwrap();\n        match cli.cmd {\n            PagerDutyCommand::Auth { token } =\u003e assert_eq!(token, \"my-token\"),\n            _ =\u003e panic!(\"Expected Auth command\"),\n        }\n    }\n\n    #[test]\n    fn parses_oncall_no_args() {\n        let cli = TestCli::try_parse_from([\"test\", \"oncall\"]).unwrap();\n        match cli.cmd {\n            PagerDutyCommand::Oncall {\n                policy,\n                schedule,\n                json,\n            } =\u003e {\n                assert!(policy.is_none());\n                assert!(schedule.is_none());\n                assert!(!json);\n            }\n            _ =\u003e panic!(\"Expected Oncall command\"),\n        }\n    }\n\n    #[test]\n    fn parses_oncall_with_policy() {\n        let cli = TestCli::try_parse_from([\"test\", \"oncall\", \"-p\", \"EP123\"]).unwrap();\n        match cli.cmd {\n            PagerDutyCommand::Oncall { policy, .. } =\u003e {\n                assert_eq!(policy, Some(\"EP123\".to_string()));\n            }\n            _ =\u003e panic!(\"Expected Oncall command\"),\n        }\n    }\n\n    #[test]\n    fn parses_oncall_with_schedule() {\n        let cli = TestCli::try_parse_from([\"test\", \"oncall\", \"--schedule\", \"S456\"]).unwrap();\n        match cli.cmd {\n            PagerDutyCommand::Oncall { schedule, .. } =\u003e {\n                assert_eq!(schedule, Some(\"S456\".to_string()));\n            }\n            _ =\u003e panic!(\"Expected Oncall command\"),\n        }\n    }\n\n    #[test]\n    fn parses_oncall_json() {\n        let cli = TestCli::try_parse_from([\"test\", \"oncall\", \"--json\"]).unwrap();\n        match cli.cmd {\n            PagerDutyCommand::Oncall { json, .. } =\u003e assert!(json),\n            _ =\u003e panic!(\"Expected Oncall command\"),\n        }\n    }\n\n    #[test]\n    fn parses_alerts_default_limit() {\n        let cli = TestCli::try_parse_from([\"test\", \"alerts\"]).unwrap();\n        match cli.cmd {\n            PagerDutyCommand::Alerts { limit, json } =\u003e {\n                assert_eq!(limit, 25);\n                assert!(!json);\n            }\n            _ =\u003e panic!(\"Expected Alerts command\"),\n        }\n    }\n\n    #[test]\n    fn parses_alerts_custom_limit() {\n        let cli = TestCli::try_parse_from([\"test\", \"alerts\", \"-l\", \"50\"]).unwrap();\n        match cli.cmd {\n            PagerDutyCommand::Alerts { limit, .. } =\u003e assert_eq!(limit, 50),\n            _ =\u003e panic!(\"Expected Alerts command\"),\n        }\n    }\n\n    #[test]\n    fn parses_incidents_no_filter() {\n        let cli = TestCli::try_parse_from([\"test\", \"incidents\"]).unwrap();\n        match cli.cmd {\n            PagerDutyCommand::Incidents {\n                status,\n                limit,\n                json,\n            } =\u003e {\n                assert!(status.is_none());\n                assert_eq!(limit, 25);\n                assert!(!json);\n            }\n            _ =\u003e panic!(\"Expected Incidents command\"),\n        }\n    }\n\n    #[test]\n    fn parses_incidents_status_triggered() {\n        let cli = TestCli::try_parse_from([\"test\", \"incidents\", \"-s\", \"triggered\"]).unwrap();\n        match cli.cmd {\n            PagerDutyCommand::Incidents { status, .. } =\u003e {\n                assert!(matches!(status, Some(StatusFilter::Triggered)));\n            }\n            _ =\u003e panic!(\"Expected Incidents command\"),\n        }\n    }\n\n    #[test]\n    fn parses_incidents_status_acknowledged() {\n        let cli =\n            TestCli::try_parse_from([\"test\", \"incidents\", \"--status\", \"acknowledged\"]).unwrap();\n        match cli.cmd {\n            PagerDutyCommand::Incidents { status, .. } =\u003e {\n                assert!(matches!(status, Some(StatusFilter::Acknowledged)));\n            }\n            _ =\u003e panic!(\"Expected Incidents command\"),\n        }\n    }\n\n    #[test]\n    fn parses_incidents_status_resolved() {\n        let cli = TestCli::try_parse_from([\"test\", \"incidents\", \"-s\", \"resolved\"]).unwrap();\n        match cli.cmd {\n            PagerDutyCommand::Incidents { status, .. } =\u003e {\n                assert!(matches!(status, Some(StatusFilter::Resolved)));\n            }\n            _ =\u003e panic!(\"Expected Incidents command\"),\n        }\n    }\n\n    #[test]\n    fn parses_incidents_status_active() {\n        let cli = TestCli::try_parse_from([\"test\", \"incidents\", \"-s\", \"active\"]).unwrap();\n        match cli.cmd {\n            PagerDutyCommand::Incidents { status, .. } =\u003e {\n                assert!(matches!(status, Some(StatusFilter::Active)));\n            }\n            _ =\u003e panic!(\"Expected Incidents command\"),\n        }\n    }\n\n    #[test]\n    fn parses_show() {\n        let cli = TestCli::try_parse_from([\"test\", \"show\", \"INC123\"]).unwrap();\n        match cli.cmd {\n            PagerDutyCommand::Show { id, json } =\u003e {\n                assert_eq!(id, \"INC123\");\n                assert!(!json);\n            }\n            _ =\u003e panic!(\"Expected Show command\"),\n        }\n    }\n\n    #[test]\n    fn parses_show_json() {\n        let cli = TestCli::try_parse_from([\"test\", \"show\", \"INC123\", \"--json\"]).unwrap();\n        match cli.cmd {\n            PagerDutyCommand::Show { id, json } =\u003e {\n                assert_eq!(id, \"INC123\");\n                assert!(json);\n            }\n            _ =\u003e panic!(\"Expected Show command\"),\n        }\n    }\n\n    #[test]\n    fn status_filter_debug() {\n        let filter = StatusFilter::Triggered;\n        let debug = format!(\"{:?}\", filter);\n        assert!(debug.contains(\"Triggered\"));\n    }\n\n    #[test]\n    fn status_filter_clone() {\n        let filter = StatusFilter::Active;\n        let cloned = filter;\n        assert!(matches!(cloned, StatusFilter::Active));\n    }\n\n    #[test]\n    fn command_debug() {\n        let cmd = PagerDutyCommand::Config;\n        let debug = format!(\"{:?}\", cmd);\n        assert!(debug.contains(\"Config\"));\n    }\n\n    #[test]\n    fn command_has_help() {\n        // Verify help text is generated without panic\n        let mut cmd = TestCli::command();\n        let help = cmd.render_help();\n        assert!(!help.to_string().is_empty());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","pagerduty","client","mod.rs"],"content":"//! PagerDuty API client\n\nuse anyhow::Result;\nuse reqwest::Client;\nuse serde::de::DeserializeOwned;\nuse std::future::Future;\nuse std::time::Duration;\nuse tokio::time::sleep;\n\nuse super::config::{load_config, PagerDutyConfig};\nuse super::types::{\n    CurrentUserResponse, Incident, IncidentResponse, IncidentStatus, IncidentsResponse, Oncall,\n    OncallsResponse, Service, ServicesResponse, User,\n};\n\n#[cfg(test)]\nmod tests;\n\nconst PAGERDUTY_API_URL: \u0026str = \"https://api.pagerduty.com\";\nconst MAX_RETRIES: u32 = 3;\nconst DEFAULT_RETRY_SECS: u64 = 5;\n\n/// PagerDuty API trait for testability\n#[allow(dead_code)]\npub trait PagerDutyApi: Send + Sync {\n    /// Get current user\n    fn get_current_user(\u0026self) -\u003e impl Future\u003cOutput = Result\u003cUser\u003e\u003e + Send;\n\n    /// List who's on call\n    fn list_oncalls(\n        \u0026self,\n        schedule_ids: Option\u003c\u0026[String]\u003e,\n        escalation_policy_ids: Option\u003c\u0026[String]\u003e,\n    ) -\u003e impl Future\u003cOutput = Result\u003cVec\u003cOncall\u003e\u003e\u003e + Send;\n\n    /// List incidents\n    fn list_incidents(\n        \u0026self,\n        statuses: \u0026[IncidentStatus],\n        limit: usize,\n    ) -\u003e impl Future\u003cOutput = Result\u003cVec\u003cIncident\u003e\u003e\u003e + Send;\n\n    /// Get single incident\n    fn get_incident(\u0026self, id: \u0026str) -\u003e impl Future\u003cOutput = Result\u003cIncident\u003e\u003e + Send;\n\n    /// List services\n    fn list_services(\u0026self) -\u003e impl Future\u003cOutput = Result\u003cVec\u003cService\u003e\u003e\u003e + Send;\n}\n\n/// PagerDuty HTTP client\npub struct PagerDutyClient {\n    config: PagerDutyConfig,\n    http: Client,\n}\n\nimpl PagerDutyClient {\n    /// Create a new client\n    pub fn new() -\u003e Result\u003cSelf\u003e {\n        let config = load_config()?;\n        let http = Client::builder().user_agent(\"hu-cli/0.1.0\").build()?;\n        Ok(Self { config, http })\n    }\n\n    /// Get API token\n    fn api_token(\u0026self) -\u003e Result\u003c\u0026str\u003e {\n        self.config\n            .api_token\n            .as_deref()\n            .ok_or_else(|| anyhow::anyhow!(\"PagerDuty API token not configured\"))\n    }\n\n    /// Make authenticated GET request\n    async fn get\u003cT: DeserializeOwned\u003e(\u0026self, path: \u0026str) -\u003e Result\u003cT\u003e {\n        self.get_with_params(path, \u0026[]).await\n    }\n\n    /// Make authenticated GET request with query parameters\n    async fn get_with_params\u003cT: DeserializeOwned\u003e(\n        \u0026self,\n        path: \u0026str,\n        params: \u0026[(\u0026str, String)],\n    ) -\u003e Result\u003cT\u003e {\n        let token = self.api_token()?.to_string();\n        let url = format!(\"{}{}\", PAGERDUTY_API_URL, path);\n        let params: Vec\u003c(String, String)\u003e = params\n            .iter()\n            .map(|(k, v)| (k.to_string(), v.clone()))\n            .collect();\n\n        self.execute_with_retry(|| {\n            self.http\n                .get(\u0026url)\n                .header(\"Authorization\", format!(\"Token token={}\", token))\n                .header(\"Content-Type\", \"application/json\")\n                .query(\u0026params)\n                .send()\n        })\n        .await\n    }\n\n    /// Execute request with retry on rate limit\n    async fn execute_with_retry\u003cF, Fut, T\u003e(\u0026self, request_fn: F) -\u003e Result\u003cT\u003e\n    where\n        F: Fn() -\u003e Fut,\n        Fut: std::future::Future\u003cOutput = Result\u003creqwest::Response, reqwest::Error\u003e\u003e,\n        T: DeserializeOwned,\n    {\n        let mut retries = 0;\n\n        loop {\n            let response = request_fn().await?;\n            let status = response.status();\n\n            if status == reqwest::StatusCode::TOO_MANY_REQUESTS {\n                if retries \u003e= MAX_RETRIES {\n                    return Err(anyhow::anyhow!(\n                        \"Rate limited after {} retries\",\n                        MAX_RETRIES\n                    ));\n                }\n\n                let retry_after = response\n                    .headers()\n                    .get(\"retry-after\")\n                    .and_then(|v| v.to_str().ok())\n                    .and_then(|s| s.parse::\u003cu64\u003e().ok())\n                    .unwrap_or(DEFAULT_RETRY_SECS);\n\n                eprintln!(\n                    \"Rate limited, waiting {} seconds... (retry {}/{})\",\n                    retry_after,\n                    retries + 1,\n                    MAX_RETRIES\n                );\n                sleep(Duration::from_secs(retry_after)).await;\n                retries += 1;\n                continue;\n            }\n\n            if !status.is_success() {\n                let body = response.text().await.unwrap_or_default();\n                return Err(anyhow::anyhow!(\"HTTP {}: {}\", status.as_u16(), body));\n            }\n\n            let text = response.text().await?;\n            return serde_json::from_str(\u0026text).map_err(|e| {\n                anyhow::anyhow!(\"Parse error: {}: {}\", e, \u0026text[..text.len().min(200)])\n            });\n        }\n    }\n}\n\nimpl PagerDutyApi for PagerDutyClient {\n    async fn get_current_user(\u0026self) -\u003e Result\u003cUser\u003e {\n        let resp: CurrentUserResponse = self.get(\"/users/me\").await?;\n        Ok(resp.user)\n    }\n\n    async fn list_oncalls(\n        \u0026self,\n        schedule_ids: Option\u003c\u0026[String]\u003e,\n        escalation_policy_ids: Option\u003c\u0026[String]\u003e,\n    ) -\u003e Result\u003cVec\u003cOncall\u003e\u003e {\n        let params = build_oncall_params(schedule_ids, escalation_policy_ids);\n        let resp: OncallsResponse = self.get_with_params(\"/oncalls\", \u0026params).await?;\n        Ok(resp.oncalls)\n    }\n\n    async fn list_incidents(\n        \u0026self,\n        statuses: \u0026[IncidentStatus],\n        limit: usize,\n    ) -\u003e Result\u003cVec\u003cIncident\u003e\u003e {\n        let params = build_incidents_params(statuses, limit);\n        let resp: IncidentsResponse = self.get_with_params(\"/incidents\", \u0026params).await?;\n        Ok(resp.incidents)\n    }\n\n    async fn get_incident(\u0026self, id: \u0026str) -\u003e Result\u003cIncident\u003e {\n        let path = format!(\"/incidents/{}\", id);\n        let resp: IncidentResponse = self.get(\u0026path).await?;\n        Ok(resp.incident)\n    }\n\n    async fn list_services(\u0026self) -\u003e Result\u003cVec\u003cService\u003e\u003e {\n        let resp: ServicesResponse = self.get(\"/services\").await?;\n        Ok(resp.services)\n    }\n}\n\n/// Build query parameters for oncalls endpoint\nfn build_oncall_params(\n    schedule_ids: Option\u003c\u0026[String]\u003e,\n    escalation_policy_ids: Option\u003c\u0026[String]\u003e,\n) -\u003e Vec\u003c(\u0026'static str, String)\u003e {\n    let mut params = Vec::new();\n\n    if let Some(ids) = schedule_ids {\n        for id in ids {\n            params.push((\"schedule_ids[]\", id.clone()));\n        }\n    }\n\n    if let Some(ids) = escalation_policy_ids {\n        for id in ids {\n            params.push((\"escalation_policy_ids[]\", id.clone()));\n        }\n    }\n\n    params\n}\n\n/// Build query parameters for incidents endpoint\nfn build_incidents_params(\n    statuses: \u0026[IncidentStatus],\n    limit: usize,\n) -\u003e Vec\u003c(\u0026'static str, String)\u003e {\n    let mut params = vec![(\"limit\", limit.to_string())];\n\n    for status in statuses {\n        params.push((\"statuses[]\", status.as_str().to_string()));\n    }\n\n    params\n}\n","traces":[{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":59,"address":[],"length":0,"stats":{"Line":4}},{"line":60,"address":[],"length":0,"stats":{"Line":8}},{"line":61,"address":[],"length":0,"stats":{"Line":2}},{"line":65,"address":[],"length":0,"stats":{"Line":1}},{"line":66,"address":[],"length":0,"stats":{"Line":1}},{"line":67,"address":[],"length":0,"stats":{"Line":1}},{"line":69,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":4}},{"line":196,"address":[],"length":0,"stats":{"Line":8}},{"line":198,"address":[],"length":0,"stats":{"Line":6}},{"line":199,"address":[],"length":0,"stats":{"Line":11}},{"line":200,"address":[],"length":0,"stats":{"Line":9}},{"line":204,"address":[],"length":0,"stats":{"Line":6}},{"line":205,"address":[],"length":0,"stats":{"Line":8}},{"line":206,"address":[],"length":0,"stats":{"Line":8}},{"line":210,"address":[],"length":0,"stats":{"Line":4}},{"line":214,"address":[],"length":0,"stats":{"Line":3}},{"line":218,"address":[],"length":0,"stats":{"Line":9}},{"line":220,"address":[],"length":0,"stats":{"Line":12}},{"line":221,"address":[],"length":0,"stats":{"Line":12}},{"line":224,"address":[],"length":0,"stats":{"Line":3}}],"covered":22,"coverable":83},{"path":["/","Users","chi","Projects","hu","src","pagerduty","client","tests.rs"],"content":"use super::*;\n\n#[test]\nfn build_oncall_params_empty() {\n    let params = build_oncall_params(None, None);\n    assert!(params.is_empty());\n}\n\n#[test]\nfn build_oncall_params_with_schedule() {\n    let schedules = vec![\"S1\".to_string(), \"S2\".to_string()];\n    let params = build_oncall_params(Some(\u0026schedules), None);\n    assert_eq!(params.len(), 2);\n    assert_eq!(params[0], (\"schedule_ids[]\", \"S1\".to_string()));\n    assert_eq!(params[1], (\"schedule_ids[]\", \"S2\".to_string()));\n}\n\n#[test]\nfn build_oncall_params_with_policy() {\n    let policies = vec![\"EP1\".to_string()];\n    let params = build_oncall_params(None, Some(\u0026policies));\n    assert_eq!(params.len(), 1);\n    assert_eq!(params[0], (\"escalation_policy_ids[]\", \"EP1\".to_string()));\n}\n\n#[test]\nfn build_oncall_params_with_both() {\n    let schedules = vec![\"S1\".to_string()];\n    let policies = vec![\"EP1\".to_string()];\n    let params = build_oncall_params(Some(\u0026schedules), Some(\u0026policies));\n    assert_eq!(params.len(), 2);\n}\n\n#[test]\nfn build_incidents_params_basic() {\n    let statuses = vec![IncidentStatus::Triggered];\n    let params = build_incidents_params(\u0026statuses, 25);\n    assert_eq!(params.len(), 2);\n    assert_eq!(params[0], (\"limit\", \"25\".to_string()));\n    assert_eq!(params[1], (\"statuses[]\", \"triggered\".to_string()));\n}\n\n#[test]\nfn build_incidents_params_multiple_statuses() {\n    let statuses = vec![IncidentStatus::Triggered, IncidentStatus::Acknowledged];\n    let params = build_incidents_params(\u0026statuses, 10);\n    assert_eq!(params.len(), 3);\n    assert_eq!(params[0], (\"limit\", \"10\".to_string()));\n    assert_eq!(params[1], (\"statuses[]\", \"triggered\".to_string()));\n    assert_eq!(params[2], (\"statuses[]\", \"acknowledged\".to_string()));\n}\n\n#[test]\nfn build_incidents_params_empty_statuses() {\n    let statuses: Vec\u003cIncidentStatus\u003e = vec![];\n    let params = build_incidents_params(\u0026statuses, 50);\n    assert_eq!(params.len(), 1);\n    assert_eq!(params[0], (\"limit\", \"50\".to_string()));\n}\n\n// Mock implementation for testing handlers\npub struct MockPagerDutyApi {\n    pub oncalls: Vec\u003cOncall\u003e,\n    pub incidents: Vec\u003cIncident\u003e,\n    pub services: Vec\u003cService\u003e,\n    pub current_user: Option\u003cUser\u003e,\n}\n\nimpl MockPagerDutyApi {\n    pub fn new() -\u003e Self {\n        Self {\n            oncalls: vec![],\n            incidents: vec![],\n            services: vec![],\n            current_user: None,\n        }\n    }\n\n    pub fn with_oncalls(mut self, oncalls: Vec\u003cOncall\u003e) -\u003e Self {\n        self.oncalls = oncalls;\n        self\n    }\n\n    pub fn with_incidents(mut self, incidents: Vec\u003cIncident\u003e) -\u003e Self {\n        self.incidents = incidents;\n        self\n    }\n\n    pub fn with_services(mut self, services: Vec\u003cService\u003e) -\u003e Self {\n        self.services = services;\n        self\n    }\n\n    pub fn with_user(mut self, user: User) -\u003e Self {\n        self.current_user = Some(user);\n        self\n    }\n}\n\nimpl PagerDutyApi for MockPagerDutyApi {\n    async fn get_current_user(\u0026self) -\u003e Result\u003cUser\u003e {\n        self.current_user\n            .clone()\n            .ok_or_else(|| anyhow::anyhow!(\"No user configured\"))\n    }\n\n    async fn list_oncalls(\n        \u0026self,\n        _schedule_ids: Option\u003c\u0026[String]\u003e,\n        _escalation_policy_ids: Option\u003c\u0026[String]\u003e,\n    ) -\u003e Result\u003cVec\u003cOncall\u003e\u003e {\n        Ok(self.oncalls.clone())\n    }\n\n    async fn list_incidents(\n        \u0026self,\n        _statuses: \u0026[IncidentStatus],\n        limit: usize,\n    ) -\u003e Result\u003cVec\u003cIncident\u003e\u003e {\n        Ok(self.incidents.iter().take(limit).cloned().collect())\n    }\n\n    async fn get_incident(\u0026self, id: \u0026str) -\u003e Result\u003cIncident\u003e {\n        self.incidents\n            .iter()\n            .find(|i| i.id == id)\n            .cloned()\n            .ok_or_else(|| anyhow::anyhow!(\"Incident not found: {}\", id))\n    }\n\n    async fn list_services(\u0026self) -\u003e Result\u003cVec\u003cService\u003e\u003e {\n        Ok(self.services.clone())\n    }\n}\n\n#[tokio::test]\nasync fn mock_list_oncalls() {\n    let oncall = make_test_oncall(\"U1\", \"Alice\");\n    let mock = MockPagerDutyApi::new().with_oncalls(vec![oncall]);\n\n    let result = mock.list_oncalls(None, None).await.unwrap();\n    assert_eq!(result.len(), 1);\n    assert_eq!(result[0].user.display_name(), \"Alice\");\n}\n\n#[tokio::test]\nasync fn mock_list_incidents_respects_limit() {\n    let incidents = vec![\n        make_test_incident(\"1\"),\n        make_test_incident(\"2\"),\n        make_test_incident(\"3\"),\n    ];\n    let mock = MockPagerDutyApi::new().with_incidents(incidents);\n\n    let result = mock\n        .list_incidents(\u0026[IncidentStatus::Triggered], 2)\n        .await\n        .unwrap();\n    assert_eq!(result.len(), 2);\n}\n\n#[tokio::test]\nasync fn mock_get_incident() {\n    let incidents = vec![make_test_incident(\"INC1\"), make_test_incident(\"INC2\")];\n    let mock = MockPagerDutyApi::new().with_incidents(incidents);\n\n    let result = mock.get_incident(\"INC1\").await.unwrap();\n    assert_eq!(result.id, \"INC1\");\n}\n\n#[tokio::test]\nasync fn mock_get_incident_not_found() {\n    let mock = MockPagerDutyApi::new();\n    let result = mock.get_incident(\"MISSING\").await;\n    assert!(result.is_err());\n}\n\n#[tokio::test]\nasync fn mock_get_current_user() {\n    let user = make_test_user(\"U1\", \"Alice\");\n    let mock = MockPagerDutyApi::new().with_user(user);\n\n    let result = mock.get_current_user().await.unwrap();\n    assert_eq!(result.display_name(), \"Alice\");\n}\n\n#[tokio::test]\nasync fn mock_get_current_user_not_configured() {\n    let mock = MockPagerDutyApi::new();\n    let result = mock.get_current_user().await;\n    assert!(result.is_err());\n}\n\n#[tokio::test]\nasync fn mock_list_services() {\n    let services = vec![make_test_service(\"S1\", \"Production\")];\n    let mock = MockPagerDutyApi::new().with_services(services);\n\n    let result = mock.list_services().await.unwrap();\n    assert_eq!(result.len(), 1);\n    assert_eq!(result[0].name, \"Production\");\n}\n\n#[test]\nfn client_new_creates_instance() {\n    // This tests the happy path of client creation\n    let result = PagerDutyClient::new();\n    assert!(result.is_ok());\n}\n\n#[test]\nfn api_token_returns_error_when_not_set() {\n    let client = PagerDutyClient::new().unwrap();\n    // If no token is configured, api_token() should return error\n    // This depends on whether PAGERDUTY_API_TOKEN env var is set\n    let result = client.api_token();\n    // Just exercise the code path\n    let _ = result;\n}\n\n#[test]\nfn mock_builder_pattern() {\n    // Test that all builder methods work correctly\n    let user = make_test_user(\"U1\", \"Alice\");\n    let oncalls = vec![make_test_oncall(\"U1\", \"Alice\")];\n    let incidents = vec![make_test_incident(\"INC1\")];\n    let services = vec![make_test_service(\"S1\", \"Production\")];\n\n    let mock = MockPagerDutyApi::new()\n        .with_user(user.clone())\n        .with_oncalls(oncalls.clone())\n        .with_incidents(incidents.clone())\n        .with_services(services.clone());\n\n    assert_eq!(mock.current_user.as_ref().unwrap().id, \"U1\");\n    assert_eq!(mock.oncalls.len(), 1);\n    assert_eq!(mock.incidents.len(), 1);\n    assert_eq!(mock.services.len(), 1);\n}\n\n// Test data helpers\nfn make_test_user(id: \u0026str, name: \u0026str) -\u003e User {\n    User {\n        id: id.to_string(),\n        name: Some(name.to_string()),\n        summary: None,\n        email: format!(\"{}@example.com\", name.to_lowercase()),\n        html_url: String::new(),\n    }\n}\n\nfn make_test_oncall(user_id: \u0026str, user_name: \u0026str) -\u003e Oncall {\n    use super::super::types::{EscalationPolicy, Schedule};\n\n    Oncall {\n        user: make_test_user(user_id, user_name),\n        schedule: Some(Schedule {\n            id: \"S1\".to_string(),\n            name: \"Weekly Rotation\".to_string(),\n            html_url: String::new(),\n        }),\n        escalation_policy: EscalationPolicy {\n            id: \"EP1\".to_string(),\n            name: \"Primary\".to_string(),\n            html_url: String::new(),\n        },\n        escalation_level: 1,\n        start: Some(\"2026-01-01T00:00:00Z\".to_string()),\n        end: Some(\"2026-01-08T00:00:00Z\".to_string()),\n    }\n}\n\nfn make_test_incident(id: \u0026str) -\u003e Incident {\n    use super::super::types::Urgency;\n\n    Incident {\n        id: id.to_string(),\n        incident_number: id.parse().unwrap_or(1),\n        title: format!(\"Test incident {}\", id),\n        status: IncidentStatus::Triggered,\n        urgency: Urgency::High,\n        created_at: \"2026-01-01T12:00:00Z\".to_string(),\n        html_url: String::new(),\n        service: make_test_service(\"S1\", \"Production\"),\n        assignments: vec![],\n    }\n}\n\nfn make_test_service(id: \u0026str, name: \u0026str) -\u003e Service {\n    Service {\n        id: id.to_string(),\n        name: name.to_string(),\n        status: \"active\".to_string(),\n        html_url: String::new(),\n    }\n}\n","traces":[{"line":70,"address":[],"length":0,"stats":{"Line":8}},{"line":72,"address":[],"length":0,"stats":{"Line":16}},{"line":73,"address":[],"length":0,"stats":{"Line":16}},{"line":74,"address":[],"length":0,"stats":{"Line":8}},{"line":79,"address":[],"length":0,"stats":{"Line":2}},{"line":80,"address":[],"length":0,"stats":{"Line":4}},{"line":81,"address":[],"length":0,"stats":{"Line":2}},{"line":84,"address":[],"length":0,"stats":{"Line":3}},{"line":85,"address":[],"length":0,"stats":{"Line":6}},{"line":86,"address":[],"length":0,"stats":{"Line":3}},{"line":89,"address":[],"length":0,"stats":{"Line":2}},{"line":90,"address":[],"length":0,"stats":{"Line":4}},{"line":91,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":2}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":96,"address":[],"length":0,"stats":{"Line":2}},{"line":101,"address":[],"length":0,"stats":{"Line":4}},{"line":102,"address":[],"length":0,"stats":{"Line":2}},{"line":104,"address":[],"length":0,"stats":{"Line":4}},{"line":107,"address":[],"length":0,"stats":{"Line":1}},{"line":112,"address":[],"length":0,"stats":{"Line":1}},{"line":115,"address":[],"length":0,"stats":{"Line":1}},{"line":120,"address":[],"length":0,"stats":{"Line":4}},{"line":123,"address":[],"length":0,"stats":{"Line":4}},{"line":124,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":4}},{"line":128,"address":[],"length":0,"stats":{"Line":4}},{"line":131,"address":[],"length":0,"stats":{"Line":2}},{"line":132,"address":[],"length":0,"stats":{"Line":1}},{"line":242,"address":[],"length":0,"stats":{"Line":4}},{"line":244,"address":[],"length":0,"stats":{"Line":12}},{"line":245,"address":[],"length":0,"stats":{"Line":8}},{"line":247,"address":[],"length":0,"stats":{"Line":16}},{"line":248,"address":[],"length":0,"stats":{"Line":4}},{"line":252,"address":[],"length":0,"stats":{"Line":2}},{"line":256,"address":[],"length":0,"stats":{"Line":8}},{"line":257,"address":[],"length":0,"stats":{"Line":4}},{"line":262,"address":[],"length":0,"stats":{"Line":4}},{"line":268,"address":[],"length":0,"stats":{"Line":4}},{"line":269,"address":[],"length":0,"stats":{"Line":2}},{"line":273,"address":[],"length":0,"stats":{"Line":6}},{"line":277,"address":[],"length":0,"stats":{"Line":18}},{"line":278,"address":[],"length":0,"stats":{"Line":24}},{"line":279,"address":[],"length":0,"stats":{"Line":18}},{"line":282,"address":[],"length":0,"stats":{"Line":18}},{"line":283,"address":[],"length":0,"stats":{"Line":12}},{"line":284,"address":[],"length":0,"stats":{"Line":18}},{"line":285,"address":[],"length":0,"stats":{"Line":6}},{"line":289,"address":[],"length":0,"stats":{"Line":8}},{"line":291,"address":[],"length":0,"stats":{"Line":24}},{"line":292,"address":[],"length":0,"stats":{"Line":24}},{"line":293,"address":[],"length":0,"stats":{"Line":16}},{"line":294,"address":[],"length":0,"stats":{"Line":8}}],"covered":53,"coverable":53},{"path":["/","Users","chi","Projects","hu","src","pagerduty","config.rs"],"content":"//! PagerDuty configuration\n//!\n//! Loads configuration from `~/.config/hu/settings.toml`\n\nuse anyhow::Result;\nuse serde::{Deserialize, Serialize};\nuse std::fs;\nuse std::path::PathBuf;\n\n/// PagerDuty configuration\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct PagerDutyConfig {\n    /// API token\n    pub api_token: Option\u003cString\u003e,\n    /// Default escalation policy IDs (for filtering oncall)\n    #[serde(default)]\n    pub escalation_policy_ids: Vec\u003cString\u003e,\n    /// Default schedule IDs (for filtering oncall)\n    #[serde(default)]\n    pub schedule_ids: Vec\u003cString\u003e,\n}\n\nimpl PagerDutyConfig {\n    /// Check if configured with API token\n    #[must_use]\n    pub fn is_configured(\u0026self) -\u003e bool {\n        self.api_token.is_some()\n    }\n}\n\n/// Settings file structure\n#[derive(Debug, Default, Deserialize)]\nstruct SettingsFile {\n    pagerduty: Option\u003cPagerDutyConfig\u003e,\n}\n\n/// Get path to config file\npub fn config_path() -\u003e Option\u003cPathBuf\u003e {\n    dirs::home_dir().map(|p| p.join(\".config\").join(\"hu\").join(\"settings.toml\"))\n}\n\n/// Load PagerDuty config from settings file and environment\npub fn load_config() -\u003e Result\u003cPagerDutyConfig\u003e {\n    let mut config = PagerDutyConfig::default();\n\n    // Load from settings file\n    if let Some(path) = config_path() {\n        if path.exists() {\n            let contents = fs::read_to_string(\u0026path)?;\n            config = parse_config(\u0026contents)?;\n        }\n    }\n\n    // Override with environment variables\n    if let Ok(token) = std::env::var(\"PAGERDUTY_API_TOKEN\") {\n        config.api_token = Some(token);\n    }\n\n    Ok(config)\n}\n\n/// Parse config from TOML string\nfn parse_config(contents: \u0026str) -\u003e Result\u003cPagerDutyConfig\u003e {\n    let settings: SettingsFile = toml::from_str(contents)?;\n    Ok(settings.pagerduty.unwrap_or_default())\n}\n\n/// Save API token to config file\npub fn save_config(api_token: \u0026str) -\u003e Result\u003c()\u003e {\n    let path = config_path().ok_or_else(|| anyhow::anyhow!(\"Cannot determine config directory\"))?;\n\n    // Read existing or create new\n    let contents = if path.exists() {\n        fs::read_to_string(\u0026path)?\n    } else {\n        String::new()\n    };\n\n    let output = update_config_toml(\u0026contents, api_token)?;\n\n    // Ensure parent directory exists\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent)?;\n    }\n\n    fs::write(\u0026path, output)?;\n    Ok(())\n}\n\n/// Update TOML config with new API token\nfn update_config_toml(contents: \u0026str, api_token: \u0026str) -\u003e Result\u003cString\u003e {\n    // Parse as TOML value\n    let mut doc: toml::Value =\n        toml::from_str(contents).unwrap_or_else(|_| toml::Value::Table(toml::map::Map::new()));\n\n    // Ensure pagerduty section exists\n    let table = doc\n        .as_table_mut()\n        .ok_or_else(|| anyhow::anyhow!(\"Config is not a table\"))?;\n\n    if !table.contains_key(\"pagerduty\") {\n        table.insert(\n            \"pagerduty\".to_string(),\n            toml::Value::Table(toml::map::Map::new()),\n        );\n    }\n\n    let pagerduty = table\n        .get_mut(\"pagerduty\")\n        .and_then(|v| v.as_table_mut())\n        .ok_or_else(|| anyhow::anyhow!(\"pagerduty section is not a table\"))?;\n\n    pagerduty.insert(\n        \"api_token\".to_string(),\n        toml::Value::String(api_token.to_string()),\n    );\n\n    toml::to_string_pretty(\u0026doc).map_err(Into::into)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn config_is_configured_with_token() {\n        let config = PagerDutyConfig {\n            api_token: Some(\"token\".to_string()),\n            ..Default::default()\n        };\n        assert!(config.is_configured());\n    }\n\n    #[test]\n    fn config_is_not_configured_without_token() {\n        let config = PagerDutyConfig::default();\n        assert!(!config.is_configured());\n    }\n\n    #[test]\n    fn config_default_has_empty_vectors() {\n        let config = PagerDutyConfig::default();\n        assert!(config.escalation_policy_ids.is_empty());\n        assert!(config.schedule_ids.is_empty());\n    }\n\n    #[test]\n    fn config_path_returns_some() {\n        // May return None in CI without home dir, just verify no panic\n        let _ = config_path();\n    }\n\n    #[test]\n    fn parse_config_empty() {\n        let config = parse_config(\"\").unwrap();\n        assert!(!config.is_configured());\n    }\n\n    #[test]\n    fn parse_config_with_pagerduty_section() {\n        let toml = r#\"\n[pagerduty]\napi_token = \"test-token\"\n\"#;\n        let config = parse_config(toml).unwrap();\n        assert!(config.is_configured());\n        assert_eq!(config.api_token.as_deref(), Some(\"test-token\"));\n    }\n\n    #[test]\n    fn parse_config_with_policy_ids() {\n        let toml = r#\"\n[pagerduty]\napi_token = \"test-token\"\nescalation_policy_ids = [\"EP1\", \"EP2\"]\nschedule_ids = [\"S1\"]\n\"#;\n        let config = parse_config(toml).unwrap();\n        assert_eq!(config.escalation_policy_ids, vec![\"EP1\", \"EP2\"]);\n        assert_eq!(config.schedule_ids, vec![\"S1\"]);\n    }\n\n    #[test]\n    fn parse_config_other_sections_ignored() {\n        let toml = r#\"\n[sentry]\nauth_token = \"sentry-token\"\n\n[pagerduty]\napi_token = \"pd-token\"\n\"#;\n        let config = parse_config(toml).unwrap();\n        assert_eq!(config.api_token.as_deref(), Some(\"pd-token\"));\n    }\n\n    #[test]\n    fn update_config_toml_empty() {\n        let result = update_config_toml(\"\", \"new-token\").unwrap();\n        assert!(result.contains(\"api_token = \\\"new-token\\\"\"));\n        assert!(result.contains(\"[pagerduty]\"));\n    }\n\n    #[test]\n    fn update_config_toml_existing_section() {\n        let existing = r#\"\n[pagerduty]\napi_token = \"old-token\"\n\"#;\n        let result = update_config_toml(existing, \"new-token\").unwrap();\n        assert!(result.contains(\"api_token = \\\"new-token\\\"\"));\n        assert!(!result.contains(\"old-token\"));\n    }\n\n    #[test]\n    fn update_config_toml_preserves_other_sections() {\n        let existing = r#\"\n[sentry]\nauth_token = \"sentry-token\"\n\"#;\n        let result = update_config_toml(existing, \"pd-token\").unwrap();\n        assert!(result.contains(\"sentry-token\"));\n        assert!(result.contains(\"pd-token\"));\n    }\n\n    #[test]\n    fn update_config_toml_preserves_other_pagerduty_fields() {\n        let existing = r#\"\n[pagerduty]\napi_token = \"old-token\"\nescalation_policy_ids = [\"EP1\"]\n\"#;\n        let result = update_config_toml(existing, \"new-token\").unwrap();\n        assert!(result.contains(\"api_token = \\\"new-token\\\"\"));\n        assert!(result.contains(\"EP1\"));\n    }\n\n    #[test]\n    fn config_debug() {\n        let config = PagerDutyConfig::default();\n        let debug = format!(\"{:?}\", config);\n        assert!(debug.contains(\"PagerDutyConfig\"));\n    }\n\n    #[test]\n    fn config_clone() {\n        let config = PagerDutyConfig {\n            api_token: Some(\"token\".to_string()),\n            escalation_policy_ids: vec![\"EP1\".to_string()],\n            schedule_ids: vec![\"S1\".to_string()],\n        };\n        let cloned = config.clone();\n        assert_eq!(cloned.api_token, config.api_token);\n        assert_eq!(cloned.escalation_policy_ids, config.escalation_policy_ids);\n    }\n\n    #[test]\n    fn load_config_returns_default_when_no_file() {\n        // load_config should work even when config file doesn't exist\n        // It will return default config (possibly with env var override)\n        let result = load_config();\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn load_config_env_override() {\n        // Test that environment variable overrides config file\n        // Save current value and restore after test\n        let original = std::env::var(\"PAGERDUTY_API_TOKEN\").ok();\n\n        std::env::set_var(\"PAGERDUTY_API_TOKEN\", \"env-token-test-12345\");\n        let result = load_config();\n        assert!(result.is_ok());\n        let config = result.unwrap();\n        assert_eq!(config.api_token.as_deref(), Some(\"env-token-test-12345\"));\n\n        // Restore original value\n        match original {\n            Some(val) =\u003e std::env::set_var(\"PAGERDUTY_API_TOKEN\", val),\n            None =\u003e std::env::remove_var(\"PAGERDUTY_API_TOKEN\"),\n        }\n    }\n\n    #[test]\n    fn parse_config_invalid_toml() {\n        let invalid = \"this is not valid [[[toml\";\n        let result = parse_config(invalid);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn parse_config_wrong_type_for_pagerduty() {\n        // pagerduty is a string instead of a table\n        let toml = r#\"pagerduty = \"not a table\"\"#;\n        let result = parse_config(toml);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn update_config_toml_invalid_existing() {\n        // Invalid TOML should still work - it creates a new table\n        let invalid = \"this is not valid [[[toml\";\n        let result = update_config_toml(invalid, \"new-token\");\n        // Should succeed by creating fresh config\n        assert!(result.is_ok());\n        assert!(result.unwrap().contains(\"api_token\"));\n    }\n\n    #[test]\n    fn settings_file_default() {\n        let settings = SettingsFile::default();\n        assert!(settings.pagerduty.is_none());\n    }\n\n    #[test]\n    fn settings_file_debug() {\n        let settings = SettingsFile::default();\n        let debug = format!(\"{:?}\", settings);\n        assert!(debug.contains(\"SettingsFile\"));\n    }\n\n    #[test]\n    fn config_serialize() {\n        let config = PagerDutyConfig {\n            api_token: Some(\"token\".to_string()),\n            escalation_policy_ids: vec![\"EP1\".to_string()],\n            schedule_ids: vec![],\n        };\n        let json = serde_json::to_string(\u0026config).unwrap();\n        assert!(json.contains(\"token\"));\n        assert!(json.contains(\"EP1\"));\n    }\n\n    #[test]\n    fn config_deserialize() {\n        let json = r#\"{\n            \"api_token\": \"test-token\",\n            \"escalation_policy_ids\": [\"EP1\"],\n            \"schedule_ids\": []\n        }\"#;\n        let config: PagerDutyConfig = serde_json::from_str(json).unwrap();\n        assert_eq!(config.api_token.as_deref(), Some(\"test-token\"));\n        assert_eq!(config.escalation_policy_ids, vec![\"EP1\"]);\n    }\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":8}},{"line":27,"address":[],"length":0,"stats":{"Line":16}},{"line":38,"address":[],"length":0,"stats":{"Line":9}},{"line":39,"address":[],"length":0,"stats":{"Line":36}},{"line":43,"address":[],"length":0,"stats":{"Line":7}},{"line":44,"address":[],"length":0,"stats":{"Line":14}},{"line":47,"address":[],"length":0,"stats":{"Line":14}},{"line":48,"address":[],"length":0,"stats":{"Line":7}},{"line":49,"address":[],"length":0,"stats":{"Line":21}},{"line":50,"address":[],"length":0,"stats":{"Line":21}},{"line":55,"address":[],"length":0,"stats":{"Line":9}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":59,"address":[],"length":0,"stats":{"Line":7}},{"line":63,"address":[],"length":0,"stats":{"Line":13}},{"line":64,"address":[],"length":0,"stats":{"Line":50}},{"line":65,"address":[],"length":0,"stats":{"Line":11}},{"line":69,"address":[],"length":0,"stats":{"Line":1}},{"line":70,"address":[],"length":0,"stats":{"Line":3}},{"line":73,"address":[],"length":0,"stats":{"Line":2}},{"line":74,"address":[],"length":0,"stats":{"Line":2}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":4}},{"line":82,"address":[],"length":0,"stats":{"Line":2}},{"line":83,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":3}},{"line":87,"address":[],"length":0,"stats":{"Line":1}},{"line":91,"address":[],"length":0,"stats":{"Line":6}},{"line":93,"address":[],"length":0,"stats":{"Line":12}},{"line":94,"address":[],"length":0,"stats":{"Line":19}},{"line":97,"address":[],"length":0,"stats":{"Line":12}},{"line":99,"address":[],"length":0,"stats":{"Line":6}},{"line":101,"address":[],"length":0,"stats":{"Line":15}},{"line":102,"address":[],"length":0,"stats":{"Line":9}},{"line":103,"address":[],"length":0,"stats":{"Line":6}},{"line":104,"address":[],"length":0,"stats":{"Line":3}},{"line":108,"address":[],"length":0,"stats":{"Line":12}},{"line":110,"address":[],"length":0,"stats":{"Line":18}},{"line":111,"address":[],"length":0,"stats":{"Line":6}},{"line":113,"address":[],"length":0,"stats":{"Line":12}},{"line":114,"address":[],"length":0,"stats":{"Line":12}},{"line":115,"address":[],"length":0,"stats":{"Line":6}},{"line":118,"address":[],"length":0,"stats":{"Line":18}}],"covered":41,"coverable":42},{"path":["/","Users","chi","Projects","hu","src","pagerduty","display","mod.rs"],"content":"//! PagerDuty output formatting\n\nuse anyhow::{Context, Result};\nuse comfy_table::{presets::UTF8_FULL_CONDENSED, Cell, Color, ContentArrangement, Table};\n\nuse super::config::PagerDutyConfig;\nuse super::types::{Incident, IncidentStatus, Oncall, OutputFormat};\n\n#[cfg(test)]\nmod tests;\n\n/// Color for incident status\nfn status_color(status: IncidentStatus) -\u003e Color {\n    match status {\n        IncidentStatus::Triggered =\u003e Color::Red,\n        IncidentStatus::Acknowledged =\u003e Color::Yellow,\n        IncidentStatus::Resolved =\u003e Color::Green,\n    }\n}\n\n/// Status icon\nfn status_icon(status: IncidentStatus) -\u003e \u0026'static str {\n    match status {\n        IncidentStatus::Triggered =\u003e \"!\",\n        IncidentStatus::Acknowledged =\u003e \"~\",\n        IncidentStatus::Resolved =\u003e \"\",\n    }\n}\n\n/// Format relative time from ISO8601 timestamp\nfn time_ago(timestamp: \u0026str) -\u003e String {\n    let Ok(dt) = chrono::DateTime::parse_from_rfc3339(timestamp) else {\n        return timestamp.to_string();\n    };\n\n    let now = chrono::Utc::now();\n    let duration = now.signed_duration_since(dt);\n\n    if duration.num_days() \u003e 0 {\n        format!(\"{}d ago\", duration.num_days())\n    } else if duration.num_hours() \u003e 0 {\n        format!(\"{}h ago\", duration.num_hours())\n    } else if duration.num_minutes() \u003e 0 {\n        format!(\"{}m ago\", duration.num_minutes())\n    } else {\n        \"just now\".to_string()\n    }\n}\n\n/// Truncate string to max length\nfn truncate(s: \u0026str, max_len: usize) -\u003e String {\n    if s.len() \u003c= max_len {\n        s.to_string()\n    } else {\n        format!(\"{}...\", \u0026s[..max_len.saturating_sub(3)])\n    }\n}\n\n/// Output oncalls list\npub fn output_oncalls(oncalls: \u0026[Oncall], format: OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            if oncalls.is_empty() {\n                println!(\"No one is currently on call.\");\n                return Ok(());\n            }\n\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_content_arrangement(ContentArrangement::Dynamic);\n            table.set_header(vec![\"User\", \"Email\", \"Policy\", \"Level\", \"Schedule\"]);\n\n            for oncall in oncalls {\n                let schedule_name = oncall\n                    .schedule\n                    .as_ref()\n                    .map(|s| s.name.as_str())\n                    .unwrap_or(\"-\");\n\n                table.add_row(vec![\n                    Cell::new(oncall.user.display_name()).fg(Color::Cyan),\n                    Cell::new(\u0026oncall.user.email),\n                    Cell::new(truncate(\u0026oncall.escalation_policy.name, 25)),\n                    Cell::new(oncall.escalation_level.to_string()),\n                    Cell::new(truncate(schedule_name, 20)),\n                ]);\n            }\n\n            println!(\"{table}\");\n            println!(\"\\n{} on-call\", oncalls.len());\n        }\n        OutputFormat::Json =\u003e {\n            let json =\n                serde_json::to_string_pretty(oncalls).context(\"Failed to serialize oncalls\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n\n/// Output incidents list\npub fn output_incidents(incidents: \u0026[Incident], format: OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            if incidents.is_empty() {\n                println!(\"No incidents found.\");\n                return Ok(());\n            }\n\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_content_arrangement(ContentArrangement::Dynamic);\n            table.set_header(vec![\n                \"#\", \"Status\", \"Urgency\", \"Service\", \"Title\", \"Created\",\n            ]);\n\n            for incident in incidents {\n                let status_text = format!(\"{} {:?}\", status_icon(incident.status), incident.status);\n\n                table.add_row(vec![\n                    Cell::new(incident.incident_number.to_string()).fg(Color::Cyan),\n                    Cell::new(\u0026status_text).fg(status_color(incident.status)),\n                    Cell::new(format!(\"{:?}\", incident.urgency)),\n                    Cell::new(truncate(\u0026incident.service.name, 20)),\n                    Cell::new(truncate(\u0026incident.title, 40)),\n                    Cell::new(time_ago(\u0026incident.created_at)),\n                ]);\n            }\n\n            println!(\"{table}\");\n            println!(\"\\n{} incidents\", incidents.len());\n        }\n        OutputFormat::Json =\u003e {\n            let json =\n                serde_json::to_string_pretty(incidents).context(\"Failed to serialize incidents\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n\n/// Output single incident detail\npub fn output_incident_detail(incident: \u0026Incident, format: OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            println!(\"{}\", \"-\".repeat(60));\n            println!(\n                \"#{} - {}\",\n                incident.incident_number,\n                truncate(\u0026incident.title, 50)\n            );\n            println!(\"{}\", \"-\".repeat(60));\n            println!(\n                \"Status:   {} {:?}\",\n                status_icon(incident.status),\n                incident.status\n            );\n            println!(\"Urgency:  {:?}\", incident.urgency);\n            println!(\"Service:  {}\", incident.service.name);\n            println!(\"Created:  {}\", time_ago(\u0026incident.created_at));\n\n            if !incident.assignments.is_empty() {\n                println!(\"\\nAssigned to:\");\n                for assignment in \u0026incident.assignments {\n                    println!(\n                        \"  - {} ({})\",\n                        assignment.assignee.display_name(),\n                        assignment.assignee.email\n                    );\n                }\n            }\n\n            if !incident.html_url.is_empty() {\n                println!(\"\\nLink: {}\", incident.html_url);\n            }\n        }\n        OutputFormat::Json =\u003e {\n            let json =\n                serde_json::to_string_pretty(incident).context(\"Failed to serialize incident\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n\n/// Output config status\npub fn output_config_status(config: \u0026PagerDutyConfig) {\n    println!(\"PagerDuty Configuration\");\n    println!(\"{}\", \"-\".repeat(40));\n    println!(\n        \"API token:  {}\",\n        if config.api_token.is_some() {\n            \"Configured\"\n        } else {\n            \"Not set\"\n        }\n    );\n\n    if !config.escalation_policy_ids.is_empty() {\n        println!(\n            \"Default escalation policies: {}\",\n            config.escalation_policy_ids.join(\", \")\n        );\n    }\n\n    if !config.schedule_ids.is_empty() {\n        println!(\"Default schedules: {}\", config.schedule_ids.join(\", \"));\n    }\n}\n\n/// Output current user info\npub fn output_user(user: \u0026super::types::User, format: OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            println!(\"{}\", user.display_name());\n            if !user.email.is_empty() {\n                println!(\"{}\", user.email);\n            }\n            if !user.html_url.is_empty() {\n                println!(\"{}\", user.html_url);\n            }\n        }\n        OutputFormat::Json =\u003e {\n            let json = serde_json::to_string_pretty(user).context(\"Failed to serialize user\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":4}},{"line":14,"address":[],"length":0,"stats":{"Line":4}},{"line":15,"address":[],"length":0,"stats":{"Line":2}},{"line":16,"address":[],"length":0,"stats":{"Line":1}},{"line":17,"address":[],"length":0,"stats":{"Line":1}},{"line":22,"address":[],"length":0,"stats":{"Line":6}},{"line":23,"address":[],"length":0,"stats":{"Line":6}},{"line":24,"address":[],"length":0,"stats":{"Line":2}},{"line":25,"address":[],"length":0,"stats":{"Line":2}},{"line":26,"address":[],"length":0,"stats":{"Line":2}},{"line":31,"address":[],"length":0,"stats":{"Line":11}},{"line":32,"address":[],"length":0,"stats":{"Line":21}},{"line":33,"address":[],"length":0,"stats":{"Line":2}},{"line":36,"address":[],"length":0,"stats":{"Line":20}},{"line":37,"address":[],"length":0,"stats":{"Line":40}},{"line":39,"address":[],"length":0,"stats":{"Line":10}},{"line":40,"address":[],"length":0,"stats":{"Line":8}},{"line":41,"address":[],"length":0,"stats":{"Line":8}},{"line":42,"address":[],"length":0,"stats":{"Line":8}},{"line":43,"address":[],"length":0,"stats":{"Line":6}},{"line":44,"address":[],"length":0,"stats":{"Line":8}},{"line":46,"address":[],"length":0,"stats":{"Line":8}},{"line":51,"address":[],"length":0,"stats":{"Line":13}},{"line":52,"address":[],"length":0,"stats":{"Line":26}},{"line":53,"address":[],"length":0,"stats":{"Line":20}},{"line":55,"address":[],"length":0,"stats":{"Line":12}},{"line":60,"address":[],"length":0,"stats":{"Line":5}},{"line":61,"address":[],"length":0,"stats":{"Line":5}},{"line":63,"address":[],"length":0,"stats":{"Line":6}},{"line":64,"address":[],"length":0,"stats":{"Line":2}},{"line":65,"address":[],"length":0,"stats":{"Line":1}},{"line":68,"address":[],"length":0,"stats":{"Line":4}},{"line":69,"address":[],"length":0,"stats":{"Line":6}},{"line":70,"address":[],"length":0,"stats":{"Line":6}},{"line":71,"address":[],"length":0,"stats":{"Line":14}},{"line":73,"address":[],"length":0,"stats":{"Line":6}},{"line":74,"address":[],"length":0,"stats":{"Line":4}},{"line":75,"address":[],"length":0,"stats":{"Line":2}},{"line":77,"address":[],"length":0,"stats":{"Line":4}},{"line":80,"address":[],"length":0,"stats":{"Line":6}},{"line":81,"address":[],"length":0,"stats":{"Line":10}},{"line":82,"address":[],"length":0,"stats":{"Line":4}},{"line":83,"address":[],"length":0,"stats":{"Line":6}},{"line":84,"address":[],"length":0,"stats":{"Line":6}},{"line":85,"address":[],"length":0,"stats":{"Line":6}},{"line":89,"address":[],"length":0,"stats":{"Line":4}},{"line":90,"address":[],"length":0,"stats":{"Line":8}},{"line":93,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":6}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":98,"address":[],"length":0,"stats":{"Line":4}},{"line":102,"address":[],"length":0,"stats":{"Line":4}},{"line":103,"address":[],"length":0,"stats":{"Line":4}},{"line":105,"address":[],"length":0,"stats":{"Line":4}},{"line":106,"address":[],"length":0,"stats":{"Line":2}},{"line":107,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":2}},{"line":111,"address":[],"length":0,"stats":{"Line":3}},{"line":112,"address":[],"length":0,"stats":{"Line":3}},{"line":113,"address":[],"length":0,"stats":{"Line":3}},{"line":114,"address":[],"length":0,"stats":{"Line":5}},{"line":117,"address":[],"length":0,"stats":{"Line":4}},{"line":118,"address":[],"length":0,"stats":{"Line":6}},{"line":120,"address":[],"length":0,"stats":{"Line":4}},{"line":121,"address":[],"length":0,"stats":{"Line":6}},{"line":122,"address":[],"length":0,"stats":{"Line":6}},{"line":123,"address":[],"length":0,"stats":{"Line":4}},{"line":124,"address":[],"length":0,"stats":{"Line":4}},{"line":125,"address":[],"length":0,"stats":{"Line":4}},{"line":126,"address":[],"length":0,"stats":{"Line":2}},{"line":130,"address":[],"length":0,"stats":{"Line":2}},{"line":131,"address":[],"length":0,"stats":{"Line":4}},{"line":134,"address":[],"length":0,"stats":{"Line":2}},{"line":135,"address":[],"length":0,"stats":{"Line":6}},{"line":136,"address":[],"length":0,"stats":{"Line":4}},{"line":139,"address":[],"length":0,"stats":{"Line":3}},{"line":143,"address":[],"length":0,"stats":{"Line":3}},{"line":144,"address":[],"length":0,"stats":{"Line":3}},{"line":146,"address":[],"length":0,"stats":{"Line":8}},{"line":147,"address":[],"length":0,"stats":{"Line":2}},{"line":148,"address":[],"length":0,"stats":{"Line":2}},{"line":150,"address":[],"length":0,"stats":{"Line":4}},{"line":152,"address":[],"length":0,"stats":{"Line":8}},{"line":153,"address":[],"length":0,"stats":{"Line":2}},{"line":154,"address":[],"length":0,"stats":{"Line":2}},{"line":155,"address":[],"length":0,"stats":{"Line":4}},{"line":158,"address":[],"length":0,"stats":{"Line":4}},{"line":159,"address":[],"length":0,"stats":{"Line":4}},{"line":160,"address":[],"length":0,"stats":{"Line":8}},{"line":162,"address":[],"length":0,"stats":{"Line":2}},{"line":163,"address":[],"length":0,"stats":{"Line":2}},{"line":164,"address":[],"length":0,"stats":{"Line":4}},{"line":165,"address":[],"length":0,"stats":{"Line":2}},{"line":166,"address":[],"length":0,"stats":{"Line":2}},{"line":167,"address":[],"length":0,"stats":{"Line":1}},{"line":168,"address":[],"length":0,"stats":{"Line":1}},{"line":173,"address":[],"length":0,"stats":{"Line":3}},{"line":174,"address":[],"length":0,"stats":{"Line":1}},{"line":178,"address":[],"length":0,"stats":{"Line":1}},{"line":179,"address":[],"length":0,"stats":{"Line":3}},{"line":180,"address":[],"length":0,"stats":{"Line":2}},{"line":183,"address":[],"length":0,"stats":{"Line":3}},{"line":187,"address":[],"length":0,"stats":{"Line":5}},{"line":188,"address":[],"length":0,"stats":{"Line":10}},{"line":189,"address":[],"length":0,"stats":{"Line":20}},{"line":190,"address":[],"length":0,"stats":{"Line":5}},{"line":191,"address":[],"length":0,"stats":{"Line":5}},{"line":192,"address":[],"length":0,"stats":{"Line":10}},{"line":193,"address":[],"length":0,"stats":{"Line":4}},{"line":195,"address":[],"length":0,"stats":{"Line":1}},{"line":199,"address":[],"length":0,"stats":{"Line":6}},{"line":200,"address":[],"length":0,"stats":{"Line":2}},{"line":201,"address":[],"length":0,"stats":{"Line":2}},{"line":202,"address":[],"length":0,"stats":{"Line":2}},{"line":206,"address":[],"length":0,"stats":{"Line":6}},{"line":207,"address":[],"length":0,"stats":{"Line":4}},{"line":212,"address":[],"length":0,"stats":{"Line":3}},{"line":213,"address":[],"length":0,"stats":{"Line":3}},{"line":215,"address":[],"length":0,"stats":{"Line":8}},{"line":216,"address":[],"length":0,"stats":{"Line":3}},{"line":217,"address":[],"length":0,"stats":{"Line":1}},{"line":219,"address":[],"length":0,"stats":{"Line":3}},{"line":220,"address":[],"length":0,"stats":{"Line":1}},{"line":224,"address":[],"length":0,"stats":{"Line":4}},{"line":225,"address":[],"length":0,"stats":{"Line":2}},{"line":228,"address":[],"length":0,"stats":{"Line":3}}],"covered":126,"coverable":126},{"path":["/","Users","chi","Projects","hu","src","pagerduty","display","tests.rs"],"content":"use super::*;\n\n#[test]\nfn status_color_triggered_is_red() {\n    assert_eq!(status_color(IncidentStatus::Triggered), Color::Red);\n}\n\n#[test]\nfn status_color_acknowledged_is_yellow() {\n    assert_eq!(status_color(IncidentStatus::Acknowledged), Color::Yellow);\n}\n\n#[test]\nfn status_color_resolved_is_green() {\n    assert_eq!(status_color(IncidentStatus::Resolved), Color::Green);\n}\n\n#[test]\nfn status_icon_triggered() {\n    assert_eq!(status_icon(IncidentStatus::Triggered), \"!\");\n}\n\n#[test]\nfn status_icon_acknowledged() {\n    assert_eq!(status_icon(IncidentStatus::Acknowledged), \"~\");\n}\n\n#[test]\nfn status_icon_resolved() {\n    assert_eq!(status_icon(IncidentStatus::Resolved), \"\");\n}\n\n#[test]\nfn truncate_short_string() {\n    assert_eq!(truncate(\"hello\", 10), \"hello\");\n}\n\n#[test]\nfn truncate_exact_length() {\n    assert_eq!(truncate(\"hello\", 5), \"hello\");\n}\n\n#[test]\nfn truncate_long_string() {\n    assert_eq!(truncate(\"hello world\", 8), \"hello...\");\n}\n\n#[test]\nfn truncate_very_short_max() {\n    // Edge case: max_len less than 3\n    assert_eq!(truncate(\"hello\", 2), \"...\");\n}\n\n#[test]\nfn time_ago_invalid_timestamp() {\n    assert_eq!(time_ago(\"invalid\"), \"invalid\");\n}\n\n#[test]\nfn time_ago_days() {\n    // 5 days ago\n    let dt = chrono::Utc::now() - chrono::Duration::days(5);\n    let timestamp = dt.to_rfc3339();\n    assert_eq!(time_ago(\u0026timestamp), \"5d ago\");\n}\n\n#[test]\nfn time_ago_hours() {\n    // 3 hours ago\n    let dt = chrono::Utc::now() - chrono::Duration::hours(3);\n    let timestamp = dt.to_rfc3339();\n    assert_eq!(time_ago(\u0026timestamp), \"3h ago\");\n}\n\n#[test]\nfn time_ago_minutes() {\n    // 15 minutes ago\n    let dt = chrono::Utc::now() - chrono::Duration::minutes(15);\n    let timestamp = dt.to_rfc3339();\n    assert_eq!(time_ago(\u0026timestamp), \"15m ago\");\n}\n\n#[test]\nfn time_ago_just_now() {\n    // 30 seconds ago\n    let dt = chrono::Utc::now() - chrono::Duration::seconds(30);\n    let timestamp = dt.to_rfc3339();\n    assert_eq!(time_ago(\u0026timestamp), \"just now\");\n}\n\n#[test]\nfn output_config_status_not_configured() {\n    let config = PagerDutyConfig::default();\n    // Just verify it doesn't panic\n    output_config_status(\u0026config);\n}\n\n#[test]\nfn output_config_status_configured() {\n    let config = PagerDutyConfig {\n        api_token: Some(\"token\".to_string()),\n        escalation_policy_ids: vec![\"EP1\".to_string()],\n        schedule_ids: vec![\"S1\".to_string(), \"S2\".to_string()],\n    };\n    // Just verify it doesn't panic\n    output_config_status(\u0026config);\n}\n\n#[test]\nfn output_oncalls_empty() {\n    let result = output_oncalls(\u0026[], OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_incidents_empty() {\n    let result = output_incidents(\u0026[], OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_oncalls_json_empty() {\n    let result = output_oncalls(\u0026[], OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_incidents_json_empty() {\n    let result = output_incidents(\u0026[], OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_oncalls_with_data() {\n    use super::super::types::{EscalationPolicy, Schedule, User};\n\n    let oncalls = vec![Oncall {\n        user: User {\n            id: \"U1\".to_string(),\n            name: Some(\"Alice\".to_string()),\n            summary: None,\n            email: \"alice@example.com\".to_string(),\n            html_url: String::new(),\n        },\n        schedule: Some(Schedule {\n            id: \"S1\".to_string(),\n            name: \"Weekly\".to_string(),\n            html_url: String::new(),\n        }),\n        escalation_policy: EscalationPolicy {\n            id: \"EP1\".to_string(),\n            name: \"Primary\".to_string(),\n            html_url: String::new(),\n        },\n        escalation_level: 1,\n        start: None,\n        end: None,\n    }];\n\n    let result = output_oncalls(\u0026oncalls, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_incidents_with_data() {\n    use super::super::types::{Service, Urgency};\n\n    let incidents = vec![Incident {\n        id: \"INC1\".to_string(),\n        incident_number: 42,\n        title: \"Test incident\".to_string(),\n        status: IncidentStatus::Triggered,\n        urgency: Urgency::High,\n        created_at: chrono::Utc::now().to_rfc3339(),\n        html_url: String::new(),\n        service: Service {\n            id: \"S1\".to_string(),\n            name: \"Production\".to_string(),\n            status: \"active\".to_string(),\n            html_url: String::new(),\n        },\n        assignments: vec![],\n    }];\n\n    let result = output_incidents(\u0026incidents, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_incident_detail_table() {\n    use super::super::types::{Assignment, Service, Urgency, User};\n\n    let incident = Incident {\n        id: \"INC1\".to_string(),\n        incident_number: 42,\n        title: \"Server down\".to_string(),\n        status: IncidentStatus::Acknowledged,\n        urgency: Urgency::High,\n        created_at: chrono::Utc::now().to_rfc3339(),\n        html_url: \"https://pagerduty.com/incidents/INC1\".to_string(),\n        service: Service {\n            id: \"S1\".to_string(),\n            name: \"Production\".to_string(),\n            status: \"active\".to_string(),\n            html_url: String::new(),\n        },\n        assignments: vec![Assignment {\n            assignee: User {\n                id: \"U1\".to_string(),\n                name: Some(\"Alice\".to_string()),\n                summary: None,\n                email: \"alice@example.com\".to_string(),\n                html_url: String::new(),\n            },\n        }],\n    };\n\n    let result = output_incident_detail(\u0026incident, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_incident_detail_json() {\n    use super::super::types::{Service, Urgency};\n\n    let incident = Incident {\n        id: \"INC1\".to_string(),\n        incident_number: 42,\n        title: \"Server down\".to_string(),\n        status: IncidentStatus::Triggered,\n        urgency: Urgency::Low,\n        created_at: \"2026-01-01T12:00:00Z\".to_string(),\n        html_url: String::new(),\n        service: Service {\n            id: \"S1\".to_string(),\n            name: \"Production\".to_string(),\n            status: \"active\".to_string(),\n            html_url: String::new(),\n        },\n        assignments: vec![],\n    };\n\n    let result = output_incident_detail(\u0026incident, OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_user_table_format() {\n    use super::super::types::User;\n\n    let user = User {\n        id: \"U1\".to_string(),\n        name: Some(\"Alice Smith\".to_string()),\n        summary: None,\n        email: \"alice@example.com\".to_string(),\n        html_url: \"https://pagerduty.com/users/U1\".to_string(),\n    };\n\n    let result = output_user(\u0026user, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_user_json_format() {\n    use super::super::types::User;\n\n    let user = User {\n        id: \"U1\".to_string(),\n        name: Some(\"Alice Smith\".to_string()),\n        summary: None,\n        email: \"alice@example.com\".to_string(),\n        html_url: \"https://pagerduty.com/users/U1\".to_string(),\n    };\n\n    let result = output_user(\u0026user, OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_user_empty_email() {\n    use super::super::types::User;\n\n    let user = User {\n        id: \"U1\".to_string(),\n        name: Some(\"Alice\".to_string()),\n        summary: None,\n        email: String::new(),\n        html_url: String::new(),\n    };\n\n    let result = output_user(\u0026user, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_oncalls_without_schedule() {\n    use super::super::types::{EscalationPolicy, User};\n\n    let oncalls = vec![Oncall {\n        user: User {\n            id: \"U1\".to_string(),\n            name: Some(\"Alice\".to_string()),\n            summary: None,\n            email: \"alice@example.com\".to_string(),\n            html_url: String::new(),\n        },\n        schedule: None,\n        escalation_policy: EscalationPolicy {\n            id: \"EP1\".to_string(),\n            name: \"Primary\".to_string(),\n            html_url: String::new(),\n        },\n        escalation_level: 1,\n        start: None,\n        end: None,\n    }];\n\n    let result = output_oncalls(\u0026oncalls, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_oncalls_json_with_data() {\n    use super::super::types::{EscalationPolicy, Schedule, User};\n\n    let oncalls = vec![Oncall {\n        user: User {\n            id: \"U1\".to_string(),\n            name: Some(\"Alice\".to_string()),\n            summary: None,\n            email: \"alice@example.com\".to_string(),\n            html_url: String::new(),\n        },\n        schedule: Some(Schedule {\n            id: \"S1\".to_string(),\n            name: \"Weekly\".to_string(),\n            html_url: String::new(),\n        }),\n        escalation_policy: EscalationPolicy {\n            id: \"EP1\".to_string(),\n            name: \"Primary\".to_string(),\n            html_url: String::new(),\n        },\n        escalation_level: 1,\n        start: None,\n        end: None,\n    }];\n\n    let result = output_oncalls(\u0026oncalls, OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_incidents_json_with_data() {\n    use super::super::types::{Service, Urgency};\n\n    let incidents = vec![Incident {\n        id: \"INC1\".to_string(),\n        incident_number: 42,\n        title: \"Test incident\".to_string(),\n        status: IncidentStatus::Acknowledged,\n        urgency: Urgency::Low,\n        created_at: chrono::Utc::now().to_rfc3339(),\n        html_url: String::new(),\n        service: Service {\n            id: \"S1\".to_string(),\n            name: \"Production\".to_string(),\n            status: \"active\".to_string(),\n            html_url: String::new(),\n        },\n        assignments: vec![],\n    }];\n\n    let result = output_incidents(\u0026incidents, OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_incident_detail_no_url() {\n    use super::super::types::{Service, Urgency};\n\n    let incident = Incident {\n        id: \"INC1\".to_string(),\n        incident_number: 42,\n        title: \"Server down\".to_string(),\n        status: IncidentStatus::Resolved,\n        urgency: Urgency::High,\n        created_at: chrono::Utc::now().to_rfc3339(),\n        html_url: String::new(),\n        service: Service {\n            id: \"S1\".to_string(),\n            name: \"Production\".to_string(),\n            status: \"active\".to_string(),\n            html_url: String::new(),\n        },\n        assignments: vec![],\n    };\n\n    let result = output_incident_detail(\u0026incident, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn truncate_zero_max() {\n    // Edge case: max_len = 0\n    assert_eq!(truncate(\"hello\", 0), \"...\");\n}\n\n#[test]\nfn time_ago_boundary_cases() {\n    // Exactly 1 day ago\n    let dt = chrono::Utc::now() - chrono::Duration::days(1);\n    let timestamp = dt.to_rfc3339();\n    assert_eq!(time_ago(\u0026timestamp), \"1d ago\");\n\n    // Exactly 1 hour ago\n    let dt = chrono::Utc::now() - chrono::Duration::hours(1);\n    let timestamp = dt.to_rfc3339();\n    assert_eq!(time_ago(\u0026timestamp), \"1h ago\");\n\n    // Exactly 1 minute ago\n    let dt = chrono::Utc::now() - chrono::Duration::minutes(1);\n    let timestamp = dt.to_rfc3339();\n    assert_eq!(time_ago(\u0026timestamp), \"1m ago\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","pagerduty","mod.rs"],"content":"//! PagerDuty integration\n//!\n//! View on-call schedules and incidents.\n//!\n//! # CLI Usage\n//! Use [`run`] for CLI commands that format and print output.\n//!\n//! # Programmatic Usage (MCP/HTTP)\n//! Use the reusable functions that return typed data:\n//! - [`get_config`] - Get configuration status\n//! - [`list_oncalls`] - List on-call users\n//! - [`list_alerts`] - List active alerts (triggered + acknowledged)\n//! - [`list_incidents`] - List incidents with filters\n//! - [`get_incident`] - Get incident details\n//! - [`get_current_user`] - Get current user info\n\nmod cli;\nmod client;\nmod config;\nmod display;\nmod service;\npub mod types;\n\nuse anyhow::Result;\n\npub use cli::PagerDutyCommand;\nuse cli::StatusFilter;\nuse client::PagerDutyClient;\npub use config::PagerDutyConfig;\npub use service::{IncidentOptions, OncallOptions};\npub use types::{Incident, Oncall, User};\nuse types::{IncidentStatus, OutputFormat};\n\n/// Run a PagerDuty command (CLI entry point - formats and prints)\n#[cfg(not(tarpaulin_include))]\npub async fn run(cmd: PagerDutyCommand) -\u003e Result\u003c()\u003e {\n    match cmd {\n        PagerDutyCommand::Config =\u003e cmd_config(),\n        PagerDutyCommand::Auth { token } =\u003e cmd_auth(\u0026token),\n        PagerDutyCommand::Oncall {\n            policy,\n            schedule,\n            json,\n        } =\u003e cmd_oncall(policy.as_deref(), schedule.as_deref(), json).await,\n        PagerDutyCommand::Alerts { limit, json } =\u003e cmd_alerts(limit, json).await,\n        PagerDutyCommand::Incidents {\n            status,\n            limit,\n            json,\n        } =\u003e cmd_incidents(status, limit, json).await,\n        PagerDutyCommand::Show { id, json } =\u003e cmd_show(\u0026id, json).await,\n        PagerDutyCommand::Whoami { json } =\u003e cmd_whoami(json).await,\n    }\n}\n\n// ============================================================================\n// Reusable functions for MCP/HTTP - return typed data, never print\n// ============================================================================\n\n/// Get PagerDuty configuration status (for MCP/HTTP)\n#[allow(dead_code)]\npub fn get_config() -\u003e Result\u003cPagerDutyConfig\u003e {\n    service::get_config()\n}\n\n/// List on-call users (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn list_oncalls(opts: \u0026OncallOptions) -\u003e Result\u003cVec\u003cOncall\u003e\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n    let client = PagerDutyClient::new()?;\n    service::list_oncalls(\u0026client, opts).await\n}\n\n/// List active alerts - triggered + acknowledged only (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn list_alerts(limit: usize) -\u003e Result\u003cVec\u003cIncident\u003e\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n    let client = PagerDutyClient::new()?;\n    service::list_alerts(\u0026client, limit).await\n}\n\n/// List incidents with filters (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn list_incidents(opts: \u0026IncidentOptions) -\u003e Result\u003cVec\u003cIncident\u003e\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n    let client = PagerDutyClient::new()?;\n    service::list_incidents(\u0026client, opts).await\n}\n\n/// Get incident details by ID (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn get_incident(id: \u0026str) -\u003e Result\u003cIncident\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n    let client = PagerDutyClient::new()?;\n    service::get_incident(\u0026client, id).await\n}\n\n/// Get current user info (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn get_current_user() -\u003e Result\u003cUser\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n    let client = PagerDutyClient::new()?;\n    service::get_current_user(\u0026client).await\n}\n\n// ============================================================================\n// CLI command handlers - create client, call service, format and print\n// ============================================================================\n\n/// Show config status\nfn cmd_config() -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    display::output_config_status(\u0026config);\n    Ok(())\n}\n\n/// Save API token\nfn cmd_auth(token: \u0026str) -\u003e Result\u003c()\u003e {\n    service::save_auth(token)?;\n    println!(\"PagerDuty API token saved.\");\n    Ok(())\n}\n\n/// Show who's on call\nasync fn cmd_oncall(policy: Option\u003c\u0026str\u003e, schedule: Option\u003c\u0026str\u003e, json: bool) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n\n    let client = PagerDutyClient::new()?;\n    let opts = OncallOptions {\n        policy_id: policy.map(|p| p.to_string()),\n        schedule_id: schedule.map(|s| s.to_string()),\n    };\n\n    let oncalls = service::list_oncalls(\u0026client, \u0026opts).await?;\n\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n    display::output_oncalls(\u0026oncalls, format)?;\n    Ok(())\n}\n\n/// List active alerts (triggered + acknowledged)\nasync fn cmd_alerts(limit: usize, json: bool) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n\n    let client = PagerDutyClient::new()?;\n    let incidents = service::list_alerts(\u0026client, limit).await?;\n\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n    display::output_incidents(\u0026incidents, format)?;\n    Ok(())\n}\n\n/// List incidents with optional status filter\nasync fn cmd_incidents(status: Option\u003cStatusFilter\u003e, limit: usize, json: bool) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n\n    let client = PagerDutyClient::new()?;\n    let opts = IncidentOptions {\n        statuses: status_filter_to_statuses(status),\n        limit,\n    };\n    let incidents = service::list_incidents(\u0026client, \u0026opts).await?;\n\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n    display::output_incidents(\u0026incidents, format)?;\n    Ok(())\n}\n\n/// Show incident details\nasync fn cmd_show(id: \u0026str, json: bool) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n\n    let client = PagerDutyClient::new()?;\n    let incident = service::get_incident(\u0026client, id).await?;\n\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n    display::output_incident_detail(\u0026incident, format)?;\n    Ok(())\n}\n\n/// Show current user info\nasync fn cmd_whoami(json: bool) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n\n    let client = PagerDutyClient::new()?;\n    let user = service::get_current_user(\u0026client).await?;\n\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n    display::output_user(\u0026user, format)?;\n    Ok(())\n}\n\n/// Convert CLI status filter to API statuses\nfn status_filter_to_statuses(filter: Option\u003cStatusFilter\u003e) -\u003e Vec\u003cIncidentStatus\u003e {\n    match filter {\n        Some(StatusFilter::Triggered) =\u003e vec![IncidentStatus::Triggered],\n        Some(StatusFilter::Acknowledged) =\u003e vec![IncidentStatus::Acknowledged],\n        Some(StatusFilter::Resolved) =\u003e vec![IncidentStatus::Resolved],\n        Some(StatusFilter::Active) | None =\u003e {\n            vec![IncidentStatus::Triggered, IncidentStatus::Acknowledged]\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use config::PagerDutyConfig;\n\n    #[test]\n    fn status_filter_to_statuses_none() {\n        let statuses = status_filter_to_statuses(None);\n        assert_eq!(statuses.len(), 2);\n        assert!(statuses.contains(\u0026IncidentStatus::Triggered));\n        assert!(statuses.contains(\u0026IncidentStatus::Acknowledged));\n    }\n\n    #[test]\n    fn status_filter_to_statuses_triggered() {\n        let statuses = status_filter_to_statuses(Some(StatusFilter::Triggered));\n        assert_eq!(statuses, vec![IncidentStatus::Triggered]);\n    }\n\n    #[test]\n    fn status_filter_to_statuses_acknowledged() {\n        let statuses = status_filter_to_statuses(Some(StatusFilter::Acknowledged));\n        assert_eq!(statuses, vec![IncidentStatus::Acknowledged]);\n    }\n\n    #[test]\n    fn status_filter_to_statuses_resolved() {\n        let statuses = status_filter_to_statuses(Some(StatusFilter::Resolved));\n        assert_eq!(statuses, vec![IncidentStatus::Resolved]);\n    }\n\n    #[test]\n    fn status_filter_to_statuses_active() {\n        let statuses = status_filter_to_statuses(Some(StatusFilter::Active));\n        assert_eq!(statuses.len(), 2);\n        assert!(statuses.contains(\u0026IncidentStatus::Triggered));\n        assert!(statuses.contains(\u0026IncidentStatus::Acknowledged));\n    }\n\n    #[test]\n    fn cmd_config_runs() {\n        // Just verify it doesn't panic\n        let result = cmd_config();\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn ensure_configured_with_token_succeeds() {\n        let config = PagerDutyConfig {\n            api_token: Some(\"test-token\".to_string()),\n            ..Default::default()\n        };\n        let result = service::ensure_configured(\u0026config);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn ensure_configured_without_token_fails() {\n        let config = PagerDutyConfig::default();\n        let result = service::ensure_configured(\u0026config);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn cmd_auth_saves_token() {\n        // This test writes to config, which is I/O - just verify it runs\n        // Note: This may modify the actual config file, but we're testing the logic\n        // In a real scenario, we'd mock the file system\n        let result = cmd_auth(\"test-token-12345\");\n        // Either succeeds or fails due to file system permissions\n        let _ = result;\n    }\n}\n","traces":[{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":3}},{"line":117,"address":[],"length":0,"stats":{"Line":6}},{"line":118,"address":[],"length":0,"stats":{"Line":6}},{"line":119,"address":[],"length":0,"stats":{"Line":3}},{"line":123,"address":[],"length":0,"stats":{"Line":1}},{"line":124,"address":[],"length":0,"stats":{"Line":2}},{"line":125,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":1}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":5}},{"line":225,"address":[],"length":0,"stats":{"Line":4}},{"line":226,"address":[],"length":0,"stats":{"Line":2}},{"line":227,"address":[],"length":0,"stats":{"Line":2}},{"line":228,"address":[],"length":0,"stats":{"Line":2}},{"line":230,"address":[],"length":0,"stats":{"Line":6}}],"covered":14,"coverable":94},{"path":["/","Users","chi","Projects","hu","src","pagerduty","service.rs"],"content":"//! PagerDuty service layer - business logic that returns data\n//!\n//! Functions in this module accept trait objects and return typed data.\n//! They never print - that's the CLI layer's job.\n\nuse anyhow::{bail, Result};\n\nuse super::client::PagerDutyApi;\nuse super::config::{self, PagerDutyConfig};\nuse super::types::{Incident, IncidentStatus, Oncall, User};\n\n/// Options for listing on-calls\n#[derive(Debug, Default)]\npub struct OncallOptions {\n    /// Filter by escalation policy ID\n    pub policy_id: Option\u003cString\u003e,\n    /// Filter by schedule ID\n    pub schedule_id: Option\u003cString\u003e,\n}\n\n/// Options for listing incidents\n#[derive(Debug)]\npub struct IncidentOptions {\n    /// Filter by statuses\n    pub statuses: Vec\u003cIncidentStatus\u003e,\n    /// Maximum number of results\n    pub limit: usize,\n}\n\nimpl Default for IncidentOptions {\n    fn default() -\u003e Self {\n        Self {\n            statuses: vec![IncidentStatus::Triggered, IncidentStatus::Acknowledged],\n            limit: 25,\n        }\n    }\n}\n\n/// Get current configuration\npub fn get_config() -\u003e Result\u003cPagerDutyConfig\u003e {\n    config::load_config()\n}\n\n/// Save API token\npub fn save_auth(token: \u0026str) -\u003e Result\u003c()\u003e {\n    config::save_config(token)\n}\n\n/// Check if API is configured, return error if not\npub fn ensure_configured(config: \u0026PagerDutyConfig) -\u003e Result\u003c()\u003e {\n    if !config.is_configured() {\n        bail!(\n            \"PagerDuty not configured. Run: hu pagerduty auth \u003ctoken\u003e\\n\\\n             Or set PAGERDUTY_API_TOKEN environment variable.\"\n        );\n    }\n    Ok(())\n}\n\n/// List on-call users\npub async fn list_oncalls(api: \u0026impl PagerDutyApi, opts: \u0026OncallOptions) -\u003e Result\u003cVec\u003cOncall\u003e\u003e {\n    let policy_ids = opts.policy_id.as_ref().map(|p| vec![p.clone()]);\n    let schedule_ids = opts.schedule_id.as_ref().map(|s| vec![s.clone()]);\n\n    api.list_oncalls(schedule_ids.as_deref(), policy_ids.as_deref())\n        .await\n}\n\n/// List incidents (alerts = triggered + acknowledged only)\npub async fn list_alerts(api: \u0026impl PagerDutyApi, limit: usize) -\u003e Result\u003cVec\u003cIncident\u003e\u003e {\n    let statuses = vec![IncidentStatus::Triggered, IncidentStatus::Acknowledged];\n    api.list_incidents(\u0026statuses, limit).await\n}\n\n/// List incidents with options\npub async fn list_incidents(\n    api: \u0026impl PagerDutyApi,\n    opts: \u0026IncidentOptions,\n) -\u003e Result\u003cVec\u003cIncident\u003e\u003e {\n    api.list_incidents(\u0026opts.statuses, opts.limit).await\n}\n\n/// Get a single incident by ID\npub async fn get_incident(api: \u0026impl PagerDutyApi, id: \u0026str) -\u003e Result\u003cIncident\u003e {\n    api.get_incident(id).await\n}\n\n/// Get current user info\npub async fn get_current_user(api: \u0026impl PagerDutyApi) -\u003e Result\u003cUser\u003e {\n    api.get_current_user().await\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::pagerduty::types::{EscalationPolicy, Schedule, Service, Urgency};\n\n    /// Mock PagerDuty API for testing\n    struct MockApi {\n        oncalls: Vec\u003cOncall\u003e,\n        incidents: Vec\u003cIncident\u003e,\n        user: User,\n    }\n\n    impl MockApi {\n        fn new() -\u003e Self {\n            Self {\n                oncalls: vec![],\n                incidents: vec![],\n                user: User {\n                    id: \"USER123\".to_string(),\n                    name: Some(\"Test User\".to_string()),\n                    summary: None,\n                    email: \"test@example.com\".to_string(),\n                    html_url: \"https://pagerduty.com/users/USER123\".to_string(),\n                },\n            }\n        }\n\n        fn with_oncalls(mut self, oncalls: Vec\u003cOncall\u003e) -\u003e Self {\n            self.oncalls = oncalls;\n            self\n        }\n\n        fn with_incidents(mut self, incidents: Vec\u003cIncident\u003e) -\u003e Self {\n            self.incidents = incidents;\n            self\n        }\n    }\n\n    impl PagerDutyApi for MockApi {\n        async fn get_current_user(\u0026self) -\u003e Result\u003cUser\u003e {\n            Ok(self.user.clone())\n        }\n\n        async fn list_oncalls(\n            \u0026self,\n            _schedule_ids: Option\u003c\u0026[String]\u003e,\n            _escalation_policy_ids: Option\u003c\u0026[String]\u003e,\n        ) -\u003e Result\u003cVec\u003cOncall\u003e\u003e {\n            Ok(self.oncalls.clone())\n        }\n\n        async fn list_incidents(\n            \u0026self,\n            statuses: \u0026[IncidentStatus],\n            limit: usize,\n        ) -\u003e Result\u003cVec\u003cIncident\u003e\u003e {\n            let filtered: Vec\u003cIncident\u003e = self\n                .incidents\n                .iter()\n                .filter(|i| statuses.contains(\u0026i.status))\n                .take(limit)\n                .cloned()\n                .collect();\n            Ok(filtered)\n        }\n\n        async fn get_incident(\u0026self, id: \u0026str) -\u003e Result\u003cIncident\u003e {\n            self.incidents\n                .iter()\n                .find(|i| i.id == id)\n                .cloned()\n                .ok_or_else(|| anyhow::anyhow!(\"Incident not found: {}\", id))\n        }\n\n        async fn list_services(\u0026self) -\u003e Result\u003cVec\u003cService\u003e\u003e {\n            Ok(vec![])\n        }\n    }\n\n    fn make_oncall(user_name: \u0026str, policy_name: \u0026str) -\u003e Oncall {\n        Oncall {\n            user: User {\n                id: format!(\"U{}\", user_name),\n                name: Some(user_name.to_string()),\n                summary: None,\n                email: format!(\"{}@example.com\", user_name.to_lowercase()),\n                html_url: String::new(),\n            },\n            schedule: Some(Schedule {\n                id: \"SCHED1\".to_string(),\n                name: \"Primary\".to_string(),\n                html_url: String::new(),\n            }),\n            escalation_policy: EscalationPolicy {\n                id: \"POL1\".to_string(),\n                name: policy_name.to_string(),\n                html_url: String::new(),\n            },\n            escalation_level: 1,\n            start: None,\n            end: None,\n        }\n    }\n\n    fn make_incident(id: \u0026str, title: \u0026str, status: IncidentStatus) -\u003e Incident {\n        Incident {\n            id: id.to_string(),\n            incident_number: 123,\n            title: title.to_string(),\n            status,\n            urgency: Urgency::High,\n            created_at: \"2024-01-01T00:00:00Z\".to_string(),\n            html_url: String::new(),\n            service: Service {\n                id: \"SVC1\".to_string(),\n                name: \"Test Service\".to_string(),\n                status: \"active\".to_string(),\n                html_url: String::new(),\n            },\n            assignments: vec![],\n        }\n    }\n\n    #[tokio::test]\n    async fn list_oncalls_returns_data() {\n        let api = MockApi::new().with_oncalls(vec![\n            make_oncall(\"Alice\", \"Engineering\"),\n            make_oncall(\"Bob\", \"Platform\"),\n        ]);\n\n        let result = list_oncalls(\u0026api, \u0026OncallOptions::default()).await.unwrap();\n        assert_eq!(result.len(), 2);\n        assert_eq!(result[0].user.display_name(), \"Alice\");\n    }\n\n    #[tokio::test]\n    async fn list_alerts_filters_statuses() {\n        let api = MockApi::new().with_incidents(vec![\n            make_incident(\"INC1\", \"Alert 1\", IncidentStatus::Triggered),\n            make_incident(\"INC2\", \"Alert 2\", IncidentStatus::Resolved),\n            make_incident(\"INC3\", \"Alert 3\", IncidentStatus::Acknowledged),\n        ]);\n\n        let result = list_alerts(\u0026api, 10).await.unwrap();\n        assert_eq!(result.len(), 2); // Only triggered and acknowledged\n        assert!(result.iter().all(|i| i.status != IncidentStatus::Resolved));\n    }\n\n    #[tokio::test]\n    async fn list_incidents_respects_limit() {\n        let api = MockApi::new().with_incidents(vec![\n            make_incident(\"INC1\", \"Alert 1\", IncidentStatus::Triggered),\n            make_incident(\"INC2\", \"Alert 2\", IncidentStatus::Triggered),\n            make_incident(\"INC3\", \"Alert 3\", IncidentStatus::Triggered),\n        ]);\n\n        let opts = IncidentOptions {\n            statuses: vec![IncidentStatus::Triggered],\n            limit: 2,\n        };\n        let result = list_incidents(\u0026api, \u0026opts).await.unwrap();\n        assert_eq!(result.len(), 2);\n    }\n\n    #[tokio::test]\n    async fn get_incident_returns_matching() {\n        let api = MockApi::new().with_incidents(vec![\n            make_incident(\"INC1\", \"Alert 1\", IncidentStatus::Triggered),\n            make_incident(\"INC2\", \"Alert 2\", IncidentStatus::Resolved),\n        ]);\n\n        let result = get_incident(\u0026api, \"INC2\").await.unwrap();\n        assert_eq!(result.id, \"INC2\");\n        assert_eq!(result.title, \"Alert 2\");\n    }\n\n    #[tokio::test]\n    async fn get_incident_not_found() {\n        let api = MockApi::new();\n        let result = get_incident(\u0026api, \"MISSING\").await;\n        assert!(result.is_err());\n    }\n\n    #[tokio::test]\n    async fn get_current_user_returns_data() {\n        let api = MockApi::new();\n        let result = get_current_user(\u0026api).await.unwrap();\n        assert_eq!(result.display_name(), \"Test User\");\n    }\n\n    #[test]\n    fn ensure_configured_fails_without_token() {\n        let config = PagerDutyConfig::default();\n        let result = ensure_configured(\u0026config);\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"not configured\"));\n    }\n\n    #[test]\n    fn ensure_configured_succeeds_with_token() {\n        let config = PagerDutyConfig {\n            api_token: Some(\"test-token\".to_string()),\n            ..Default::default()\n        };\n        let result = ensure_configured(\u0026config);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn oncall_options_default() {\n        let opts = OncallOptions::default();\n        assert!(opts.policy_id.is_none());\n        assert!(opts.schedule_id.is_none());\n    }\n\n    #[test]\n    fn incident_options_default() {\n        let opts = IncidentOptions::default();\n        assert_eq!(opts.limit, 25);\n        assert_eq!(opts.statuses.len(), 2);\n    }\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":1}},{"line":33,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":3}},{"line":41,"address":[],"length":0,"stats":{"Line":3}},{"line":45,"address":[],"length":0,"stats":{"Line":1}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":50,"address":[],"length":0,"stats":{"Line":4}},{"line":51,"address":[],"length":0,"stats":{"Line":4}},{"line":52,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":54,"address":[],"length":0,"stats":{"Line":2}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":61,"address":[],"length":0,"stats":{"Line":2}},{"line":62,"address":[],"length":0,"stats":{"Line":4}},{"line":63,"address":[],"length":0,"stats":{"Line":4}},{"line":65,"address":[],"length":0,"stats":{"Line":6}},{"line":66,"address":[],"length":0,"stats":{"Line":1}},{"line":70,"address":[],"length":0,"stats":{"Line":2}},{"line":71,"address":[],"length":0,"stats":{"Line":4}},{"line":72,"address":[],"length":0,"stats":{"Line":4}},{"line":76,"address":[],"length":0,"stats":{"Line":1}},{"line":80,"address":[],"length":0,"stats":{"Line":4}},{"line":84,"address":[],"length":0,"stats":{"Line":4}},{"line":85,"address":[],"length":0,"stats":{"Line":6}},{"line":89,"address":[],"length":0,"stats":{"Line":2}},{"line":90,"address":[],"length":0,"stats":{"Line":2}}],"covered":26,"coverable":26},{"path":["/","Users","chi","Projects","hu","src","pagerduty","types","mod.rs"],"content":"//! PagerDuty data types\n\nuse serde::{Deserialize, Serialize};\n\n#[cfg(test)]\nmod tests;\n\n/// PagerDuty user\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct User {\n    /// User ID\n    pub id: String,\n    /// User name (full response)\n    #[serde(default)]\n    pub name: Option\u003cString\u003e,\n    /// Summary (reference response)\n    #[serde(default)]\n    pub summary: Option\u003cString\u003e,\n    /// Email address\n    #[serde(default)]\n    pub email: String,\n    /// URL to user in PagerDuty\n    #[serde(default)]\n    pub html_url: String,\n}\n\nimpl User {\n    /// Get display name (prefers name over summary)\n    pub fn display_name(\u0026self) -\u003e \u0026str {\n        self.name\n            .as_deref()\n            .or(self.summary.as_deref())\n            .unwrap_or(\u0026self.id)\n    }\n}\n\n/// Escalation policy\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct EscalationPolicy {\n    /// Policy ID\n    pub id: String,\n    /// Policy name (API returns \"summary\" for references)\n    #[serde(alias = \"summary\")]\n    pub name: String,\n    /// URL to policy in PagerDuty\n    #[serde(default)]\n    pub html_url: String,\n}\n\n/// On-call schedule\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Schedule {\n    /// Schedule ID\n    pub id: String,\n    /// Schedule name (API returns \"summary\" for references)\n    #[serde(alias = \"summary\")]\n    pub name: String,\n    /// URL to schedule in PagerDuty\n    #[serde(default)]\n    pub html_url: String,\n}\n\n/// On-call entry\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Oncall {\n    /// User on call\n    pub user: User,\n    /// Schedule (if any)\n    pub schedule: Option\u003cSchedule\u003e,\n    /// Escalation policy\n    pub escalation_policy: EscalationPolicy,\n    /// Escalation level (1 = primary, 2 = secondary, etc.)\n    pub escalation_level: u32,\n    /// Start time of on-call shift\n    pub start: Option\u003cString\u003e,\n    /// End time of on-call shift\n    pub end: Option\u003cString\u003e,\n}\n\n/// Service\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Service {\n    /// Service ID\n    pub id: String,\n    /// Service name (API returns \"summary\" for references)\n    #[serde(alias = \"summary\")]\n    pub name: String,\n    /// Service status\n    #[serde(default)]\n    pub status: String,\n    /// URL to service in PagerDuty\n    #[serde(default)]\n    pub html_url: String,\n}\n\n/// Incident urgency\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum Urgency {\n    /// High urgency\n    High,\n    /// Low urgency\n    Low,\n}\n\n/// Incident status\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum IncidentStatus {\n    /// Triggered - not yet acknowledged\n    Triggered,\n    /// Acknowledged - someone is working on it\n    Acknowledged,\n    /// Resolved - incident is closed\n    Resolved,\n}\n\nimpl IncidentStatus {\n    /// Convert to API query string value\n    #[must_use]\n    pub fn as_str(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Self::Triggered =\u003e \"triggered\",\n            Self::Acknowledged =\u003e \"acknowledged\",\n            Self::Resolved =\u003e \"resolved\",\n        }\n    }\n}\n\n/// Assignment (user assigned to incident)\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Assignment {\n    /// Assigned user\n    pub assignee: User,\n}\n\n/// Incident\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Incident {\n    /// Incident ID\n    pub id: String,\n    /// Incident number\n    pub incident_number: u64,\n    /// Title/summary\n    pub title: String,\n    /// Current status\n    pub status: IncidentStatus,\n    /// Urgency level\n    pub urgency: Urgency,\n    /// Creation timestamp\n    pub created_at: String,\n    /// URL to incident in PagerDuty\n    #[serde(default)]\n    pub html_url: String,\n    /// Service this incident belongs to\n    pub service: Service,\n    /// Users assigned to this incident\n    #[serde(default)]\n    pub assignments: Vec\u003cAssignment\u003e,\n}\n\n/// Output format\n#[derive(Debug, Clone, Copy, Default, PartialEq, Eq)]\npub enum OutputFormat {\n    /// Table format\n    #[default]\n    Table,\n    /// JSON format\n    Json,\n}\n\n/// API response wrapper for oncalls\n#[derive(Debug, Deserialize)]\npub struct OncallsResponse {\n    /// List of oncalls\n    pub oncalls: Vec\u003cOncall\u003e,\n}\n\n/// API response wrapper for incidents\n#[derive(Debug, Deserialize)]\npub struct IncidentsResponse {\n    /// List of incidents\n    pub incidents: Vec\u003cIncident\u003e,\n}\n\n/// API response wrapper for single incident\n#[derive(Debug, Deserialize)]\npub struct IncidentResponse {\n    /// The incident\n    pub incident: Incident,\n}\n\n/// API response wrapper for services\n#[allow(dead_code)]\n#[derive(Debug, Deserialize)]\npub struct ServicesResponse {\n    /// List of services\n    pub services: Vec\u003cService\u003e,\n}\n\n/// Current user response\n#[allow(dead_code)]\n#[derive(Debug, Deserialize)]\npub struct CurrentUserResponse {\n    /// The user\n    pub user: User,\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":16}},{"line":30,"address":[],"length":0,"stats":{"Line":32}},{"line":32,"address":[],"length":0,"stats":{"Line":64}},{"line":33,"address":[],"length":0,"stats":{"Line":16}},{"line":121,"address":[],"length":0,"stats":{"Line":6}},{"line":122,"address":[],"length":0,"stats":{"Line":6}},{"line":123,"address":[],"length":0,"stats":{"Line":3}},{"line":124,"address":[],"length":0,"stats":{"Line":2}},{"line":125,"address":[],"length":0,"stats":{"Line":1}}],"covered":9,"coverable":9},{"path":["/","Users","chi","Projects","hu","src","pagerduty","types","tests.rs"],"content":"use super::*;\n\n#[test]\nfn incident_status_deserialize() {\n    let json = r#\"\"triggered\"\"#;\n    let status: IncidentStatus = serde_json::from_str(json).unwrap();\n    assert_eq!(status, IncidentStatus::Triggered);\n\n    let json = r#\"\"acknowledged\"\"#;\n    let status: IncidentStatus = serde_json::from_str(json).unwrap();\n    assert_eq!(status, IncidentStatus::Acknowledged);\n\n    let json = r#\"\"resolved\"\"#;\n    let status: IncidentStatus = serde_json::from_str(json).unwrap();\n    assert_eq!(status, IncidentStatus::Resolved);\n}\n\n#[test]\nfn incident_status_serialize() {\n    let json = serde_json::to_string(\u0026IncidentStatus::Triggered).unwrap();\n    assert_eq!(json, r#\"\"triggered\"\"#);\n\n    let json = serde_json::to_string(\u0026IncidentStatus::Acknowledged).unwrap();\n    assert_eq!(json, r#\"\"acknowledged\"\"#);\n\n    let json = serde_json::to_string(\u0026IncidentStatus::Resolved).unwrap();\n    assert_eq!(json, r#\"\"resolved\"\"#);\n}\n\n#[test]\nfn incident_status_as_str() {\n    assert_eq!(IncidentStatus::Triggered.as_str(), \"triggered\");\n    assert_eq!(IncidentStatus::Acknowledged.as_str(), \"acknowledged\");\n    assert_eq!(IncidentStatus::Resolved.as_str(), \"resolved\");\n}\n\n#[test]\nfn urgency_deserialize() {\n    let json = r#\"\"high\"\"#;\n    let urgency: Urgency = serde_json::from_str(json).unwrap();\n    assert_eq!(urgency, Urgency::High);\n\n    let json = r#\"\"low\"\"#;\n    let urgency: Urgency = serde_json::from_str(json).unwrap();\n    assert_eq!(urgency, Urgency::Low);\n}\n\n#[test]\nfn urgency_serialize() {\n    let json = serde_json::to_string(\u0026Urgency::High).unwrap();\n    assert_eq!(json, r#\"\"high\"\"#);\n\n    let json = serde_json::to_string(\u0026Urgency::Low).unwrap();\n    assert_eq!(json, r#\"\"low\"\"#);\n}\n\n#[test]\nfn user_deserialize() {\n    let json = r#\"{\n            \"id\": \"U123\",\n            \"name\": \"Alice Smith\",\n            \"email\": \"alice@example.com\",\n            \"html_url\": \"https://pagerduty.com/users/U123\"\n        }\"#;\n    let user: User = serde_json::from_str(json).unwrap();\n    assert_eq!(user.id, \"U123\");\n    assert_eq!(user.display_name(), \"Alice Smith\");\n    assert_eq!(user.email, \"alice@example.com\");\n    assert_eq!(user.html_url, \"https://pagerduty.com/users/U123\");\n}\n\n#[test]\nfn user_deserialize_without_html_url() {\n    let json = r#\"{\n            \"id\": \"U123\",\n            \"name\": \"Alice Smith\",\n            \"email\": \"alice@example.com\"\n        }\"#;\n    let user: User = serde_json::from_str(json).unwrap();\n    assert_eq!(user.html_url, \"\");\n}\n\n#[test]\nfn oncall_deserialize() {\n    let json = r#\"{\n            \"user\": {\"id\": \"U1\", \"name\": \"Alice\", \"email\": \"alice@example.com\"},\n            \"escalation_policy\": {\"id\": \"EP1\", \"name\": \"Primary\"},\n            \"escalation_level\": 1,\n            \"schedule\": null,\n            \"start\": \"2026-01-01T00:00:00Z\",\n            \"end\": \"2026-01-08T00:00:00Z\"\n        }\"#;\n    let oncall: Oncall = serde_json::from_str(json).unwrap();\n    assert_eq!(oncall.user.display_name(), \"Alice\");\n    assert_eq!(oncall.escalation_level, 1);\n    assert!(oncall.schedule.is_none());\n    assert_eq!(oncall.start, Some(\"2026-01-01T00:00:00Z\".to_string()));\n}\n\n#[test]\nfn oncall_deserialize_with_schedule() {\n    let json = r#\"{\n            \"user\": {\"id\": \"U1\", \"name\": \"Alice\", \"email\": \"alice@example.com\"},\n            \"escalation_policy\": {\"id\": \"EP1\", \"name\": \"Primary\"},\n            \"escalation_level\": 2,\n            \"schedule\": {\"id\": \"S1\", \"name\": \"Weekly Rotation\"},\n            \"start\": null,\n            \"end\": null\n        }\"#;\n    let oncall: Oncall = serde_json::from_str(json).unwrap();\n    assert!(oncall.schedule.is_some());\n    assert_eq!(oncall.schedule.unwrap().name, \"Weekly Rotation\");\n    assert_eq!(oncall.escalation_level, 2);\n}\n\n#[test]\nfn incident_deserialize() {\n    let json = r#\"{\n            \"id\": \"INC123\",\n            \"incident_number\": 42,\n            \"title\": \"Server down\",\n            \"status\": \"triggered\",\n            \"urgency\": \"high\",\n            \"created_at\": \"2026-01-01T12:00:00Z\",\n            \"html_url\": \"https://pagerduty.com/incidents/INC123\",\n            \"service\": {\"id\": \"S1\", \"name\": \"Production\", \"status\": \"active\"},\n            \"assignments\": []\n        }\"#;\n    let incident: Incident = serde_json::from_str(json).unwrap();\n    assert_eq!(incident.id, \"INC123\");\n    assert_eq!(incident.incident_number, 42);\n    assert_eq!(incident.status, IncidentStatus::Triggered);\n    assert_eq!(incident.urgency, Urgency::High);\n    assert_eq!(incident.service.name, \"Production\");\n}\n\n#[test]\nfn incident_deserialize_with_assignments() {\n    let json = r#\"{\n            \"id\": \"INC123\",\n            \"incident_number\": 42,\n            \"title\": \"Server down\",\n            \"status\": \"acknowledged\",\n            \"urgency\": \"low\",\n            \"created_at\": \"2026-01-01T12:00:00Z\",\n            \"service\": {\"id\": \"S1\", \"name\": \"Production\", \"status\": \"active\"},\n            \"assignments\": [\n                {\"assignee\": {\"id\": \"U1\", \"name\": \"Alice\", \"email\": \"alice@example.com\"}}\n            ]\n        }\"#;\n    let incident: Incident = serde_json::from_str(json).unwrap();\n    assert_eq!(incident.assignments.len(), 1);\n    assert_eq!(incident.assignments[0].assignee.display_name(), \"Alice\");\n}\n\n#[test]\nfn oncalls_response_deserialize() {\n    let json = r#\"{\"oncalls\": []}\"#;\n    let resp: OncallsResponse = serde_json::from_str(json).unwrap();\n    assert!(resp.oncalls.is_empty());\n}\n\n#[test]\nfn incidents_response_deserialize() {\n    let json = r#\"{\"incidents\": []}\"#;\n    let resp: IncidentsResponse = serde_json::from_str(json).unwrap();\n    assert!(resp.incidents.is_empty());\n}\n\n#[test]\nfn services_response_deserialize() {\n    let json = r#\"{\"services\": []}\"#;\n    let resp: ServicesResponse = serde_json::from_str(json).unwrap();\n    assert!(resp.services.is_empty());\n}\n\n#[test]\nfn current_user_response_deserialize() {\n    let json = r#\"{\"user\": {\"id\": \"U1\", \"name\": \"Alice\", \"email\": \"alice@example.com\"}}\"#;\n    let resp: CurrentUserResponse = serde_json::from_str(json).unwrap();\n    assert_eq!(resp.user.display_name(), \"Alice\");\n}\n\n#[test]\nfn output_format_default() {\n    let format = OutputFormat::default();\n    assert_eq!(format, OutputFormat::Table);\n}\n\n#[test]\nfn output_format_eq() {\n    assert_eq!(OutputFormat::Table, OutputFormat::Table);\n    assert_eq!(OutputFormat::Json, OutputFormat::Json);\n    assert_ne!(OutputFormat::Table, OutputFormat::Json);\n}\n\n#[test]\nfn types_are_debug() {\n    // Ensure all types implement Debug\n    let user = User {\n        id: \"U1\".to_string(),\n        name: Some(\"Alice\".to_string()),\n        summary: None,\n        email: \"alice@example.com\".to_string(),\n        html_url: String::new(),\n    };\n    let _ = format!(\"{:?}\", user);\n    let _ = format!(\"{:?}\", IncidentStatus::Triggered);\n    let _ = format!(\"{:?}\", Urgency::High);\n    let _ = format!(\"{:?}\", OutputFormat::Table);\n}\n\n#[test]\nfn types_are_clone() {\n    let user = User {\n        id: \"U1\".to_string(),\n        name: Some(\"Alice\".to_string()),\n        summary: None,\n        email: \"alice@example.com\".to_string(),\n        html_url: String::new(),\n    };\n    let cloned = user.clone();\n    assert_eq!(cloned.id, user.id);\n\n    let status = IncidentStatus::Triggered;\n    let cloned = status;\n    assert_eq!(cloned, status);\n}\n\n#[test]\nfn user_display_name_prefers_name() {\n    let user = User {\n        id: \"U1\".to_string(),\n        name: Some(\"Alice\".to_string()),\n        summary: Some(\"Alice Summary\".to_string()),\n        email: String::new(),\n        html_url: String::new(),\n    };\n    assert_eq!(user.display_name(), \"Alice\");\n}\n\n#[test]\nfn user_display_name_falls_back_to_summary() {\n    let user = User {\n        id: \"U1\".to_string(),\n        name: None,\n        summary: Some(\"Alice Summary\".to_string()),\n        email: String::new(),\n        html_url: String::new(),\n    };\n    assert_eq!(user.display_name(), \"Alice Summary\");\n}\n\n#[test]\nfn user_display_name_falls_back_to_id() {\n    let user = User {\n        id: \"U1\".to_string(),\n        name: None,\n        summary: None,\n        email: String::new(),\n        html_url: String::new(),\n    };\n    assert_eq!(user.display_name(), \"U1\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","pipeline","aws.rs"],"content":"//! AWS CLI wrapper functions\n\nuse anyhow::{Context, Result};\nuse std::process::Command;\n\nuse super::types::{\n    AwsConfig, ListExecutionsResponse, ListPipelinesResponse, Pipeline, PipelineExecution,\n    PipelineState,\n};\n\n/// Build AWS CLI base command with region\nfn build_aws_cmd(config: \u0026AwsConfig) -\u003e Command {\n    let mut cmd = Command::new(\"aws\");\n    cmd.arg(\"codepipeline\");\n\n    if let Some(region) = \u0026config.region {\n        cmd.arg(\"--region\").arg(region);\n    }\n\n    cmd\n}\n\n/// List all pipelines\npub fn list_pipelines(config: \u0026AwsConfig) -\u003e Result\u003cVec\u003cPipeline\u003e\u003e {\n    let mut cmd = build_aws_cmd(config);\n    cmd.arg(\"list-pipelines\");\n\n    let output = cmd\n        .output()\n        .context(\"Failed to execute aws cli. Is AWS CLI installed and configured?\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"aws cli failed: {}\", stderr.trim());\n    }\n\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    parse_list_pipelines(\u0026stdout)\n}\n\n/// Parse list-pipelines output\npub fn parse_list_pipelines(json: \u0026str) -\u003e Result\u003cVec\u003cPipeline\u003e\u003e {\n    let resp: ListPipelinesResponse =\n        serde_json::from_str(json).context(\"Failed to parse aws cli output\")?;\n\n    Ok(resp.pipelines.iter().map(|s| s.to_pipeline()).collect())\n}\n\n/// Get pipeline state\npub fn get_pipeline_state(config: \u0026AwsConfig, name: \u0026str) -\u003e Result\u003cPipelineState\u003e {\n    let mut cmd = build_aws_cmd(config);\n    cmd.arg(\"get-pipeline-state\").arg(\"--name\").arg(name);\n\n    let output = cmd.output().context(\"Failed to execute aws cli\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"aws cli failed: {}\", stderr.trim());\n    }\n\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    parse_pipeline_state(\u0026stdout)\n}\n\n/// Parse get-pipeline-state output\npub fn parse_pipeline_state(json: \u0026str) -\u003e Result\u003cPipelineState\u003e {\n    serde_json::from_str(json).context(\"Failed to parse pipeline state\")\n}\n\n/// List pipeline executions\npub fn list_executions(\n    config: \u0026AwsConfig,\n    name: \u0026str,\n    limit: usize,\n) -\u003e Result\u003cVec\u003cPipelineExecution\u003e\u003e {\n    let mut cmd = build_aws_cmd(config);\n    cmd.arg(\"list-pipeline-executions\")\n        .arg(\"--pipeline-name\")\n        .arg(name)\n        .arg(\"--max-results\")\n        .arg(limit.to_string());\n\n    let output = cmd.output().context(\"Failed to execute aws cli\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"aws cli failed: {}\", stderr.trim());\n    }\n\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    parse_list_executions(\u0026stdout)\n}\n\n/// Parse list-pipeline-executions output\npub fn parse_list_executions(json: \u0026str) -\u003e Result\u003cVec\u003cPipelineExecution\u003e\u003e {\n    let resp: ListExecutionsResponse =\n        serde_json::from_str(json).context(\"Failed to parse executions\")?;\n\n    Ok(resp.executions)\n}\n\n/// Build list-pipelines args (for testing)\n#[cfg(test)]\npub fn build_list_args(config: \u0026AwsConfig) -\u003e Vec\u003cString\u003e {\n    let mut args = vec![\"codepipeline\".to_string()];\n\n    if let Some(region) = \u0026config.region {\n        args.push(\"--region\".to_string());\n        args.push(region.clone());\n    }\n\n    args.push(\"list-pipelines\".to_string());\n    args\n}\n\n/// Build get-pipeline-state args (for testing)\n#[cfg(test)]\npub fn build_state_args(config: \u0026AwsConfig, name: \u0026str) -\u003e Vec\u003cString\u003e {\n    let mut args = vec![\"codepipeline\".to_string()];\n\n    if let Some(region) = \u0026config.region {\n        args.push(\"--region\".to_string());\n        args.push(region.clone());\n    }\n\n    args.push(\"get-pipeline-state\".to_string());\n    args.push(\"--name\".to_string());\n    args.push(name.to_string());\n    args\n}\n\n/// Build list-pipeline-executions args (for testing)\n#[cfg(test)]\npub fn build_executions_args(config: \u0026AwsConfig, name: \u0026str, limit: usize) -\u003e Vec\u003cString\u003e {\n    let mut args = vec![\"codepipeline\".to_string()];\n\n    if let Some(region) = \u0026config.region {\n        args.push(\"--region\".to_string());\n        args.push(region.clone());\n    }\n\n    args.push(\"list-pipeline-executions\".to_string());\n    args.push(\"--pipeline-name\".to_string());\n    args.push(name.to_string());\n    args.push(\"--max-results\".to_string());\n    args.push(limit.to_string());\n    args\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn build_list_args_basic() {\n        let config = AwsConfig::default();\n        let args = build_list_args(\u0026config);\n        assert_eq!(args, vec![\"codepipeline\", \"list-pipelines\"]);\n    }\n\n    #[test]\n    fn build_list_args_with_region() {\n        let config = AwsConfig {\n            region: Some(\"us-west-2\".to_string()),\n        };\n        let args = build_list_args(\u0026config);\n        assert_eq!(\n            args,\n            vec![\"codepipeline\", \"--region\", \"us-west-2\", \"list-pipelines\"]\n        );\n    }\n\n    #[test]\n    fn build_state_args_basic() {\n        let config = AwsConfig::default();\n        let args = build_state_args(\u0026config, \"my-pipeline\");\n        assert_eq!(\n            args,\n            vec![\n                \"codepipeline\",\n                \"get-pipeline-state\",\n                \"--name\",\n                \"my-pipeline\"\n            ]\n        );\n    }\n\n    #[test]\n    fn build_state_args_with_region() {\n        let config = AwsConfig {\n            region: Some(\"eu-west-1\".to_string()),\n        };\n        let args = build_state_args(\u0026config, \"my-pipeline\");\n        assert_eq!(\n            args,\n            vec![\n                \"codepipeline\",\n                \"--region\",\n                \"eu-west-1\",\n                \"get-pipeline-state\",\n                \"--name\",\n                \"my-pipeline\"\n            ]\n        );\n    }\n\n    #[test]\n    fn build_executions_args_basic() {\n        let config = AwsConfig::default();\n        let args = build_executions_args(\u0026config, \"my-pipeline\", 10);\n        assert_eq!(\n            args,\n            vec![\n                \"codepipeline\",\n                \"list-pipeline-executions\",\n                \"--pipeline-name\",\n                \"my-pipeline\",\n                \"--max-results\",\n                \"10\"\n            ]\n        );\n    }\n\n    #[test]\n    fn parse_list_pipelines_empty() {\n        let json = r#\"{\"pipelines\": []}\"#;\n        let pipelines = parse_list_pipelines(json).unwrap();\n        assert!(pipelines.is_empty());\n    }\n\n    #[test]\n    fn parse_list_pipelines_single() {\n        let json = r#\"{\"pipelines\": [{\"name\": \"test\"}]}\"#;\n        let pipelines = parse_list_pipelines(json).unwrap();\n        assert_eq!(pipelines.len(), 1);\n        assert_eq!(pipelines[0].name, \"test\");\n    }\n\n    #[test]\n    fn parse_list_pipelines_invalid() {\n        let result = parse_list_pipelines(\"not json\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn parse_pipeline_state_basic() {\n        let json = r#\"{\n            \"pipelineName\": \"test\",\n            \"stageStates\": []\n        }\"#;\n        let state = parse_pipeline_state(json).unwrap();\n        assert_eq!(state.name, \"test\");\n    }\n\n    #[test]\n    fn parse_list_executions_empty() {\n        let json = r#\"{\"pipelineExecutionSummaries\": []}\"#;\n        let executions = parse_list_executions(json).unwrap();\n        assert!(executions.is_empty());\n    }\n\n    #[test]\n    fn parse_list_executions_single() {\n        let json = r#\"{\n            \"pipelineExecutionSummaries\": [\n                {\"pipelineExecutionId\": \"exec-1\", \"status\": \"Succeeded\"}\n            ]\n        }\"#;\n        let executions = parse_list_executions(json).unwrap();\n        assert_eq!(executions.len(), 1);\n        assert_eq!(executions[0].id, \"exec-1\");\n    }\n\n    #[test]\n    fn build_executions_args_with_region() {\n        let config = AwsConfig {\n            region: Some(\"ap-northeast-1\".to_string()),\n        };\n        let args = build_executions_args(\u0026config, \"prod-pipeline\", 5);\n        assert_eq!(\n            args,\n            vec![\n                \"codepipeline\",\n                \"--region\",\n                \"ap-northeast-1\",\n                \"list-pipeline-executions\",\n                \"--pipeline-name\",\n                \"prod-pipeline\",\n                \"--max-results\",\n                \"5\"\n            ]\n        );\n    }\n\n    #[test]\n    fn parse_list_pipelines_multiple() {\n        let json = r#\"{\n            \"pipelines\": [\n                {\"name\": \"pipeline-1\", \"created\": \"2026-01-01\", \"updated\": \"2026-01-02\"},\n                {\"name\": \"pipeline-2\"},\n                {\"name\": \"pipeline-3\", \"created\": \"2026-01-03\"}\n            ]\n        }\"#;\n        let pipelines = parse_list_pipelines(json).unwrap();\n        assert_eq!(pipelines.len(), 3);\n        assert_eq!(pipelines[0].name, \"pipeline-1\");\n        assert_eq!(pipelines[0].created, Some(\"2026-01-01\".to_string()));\n        assert_eq!(pipelines[0].updated, Some(\"2026-01-02\".to_string()));\n        assert_eq!(pipelines[1].name, \"pipeline-2\");\n        assert!(pipelines[1].created.is_none());\n        assert_eq!(pipelines[2].name, \"pipeline-3\");\n    }\n\n    #[test]\n    fn parse_pipeline_state_with_stages() {\n        let json = r#\"{\n            \"pipelineName\": \"complex-pipeline\",\n            \"stageStates\": [\n                {\n                    \"stageName\": \"Source\",\n                    \"latestExecution\": {\"status\": \"Succeeded\"},\n                    \"actionStates\": [\n                        {\"actionName\": \"GitCheckout\", \"latestExecution\": {\"status\": \"Succeeded\"}}\n                    ]\n                },\n                {\n                    \"stageName\": \"Build\",\n                    \"latestExecution\": {\"status\": \"InProgress\"},\n                    \"actionStates\": []\n                }\n            ]\n        }\"#;\n        let state = parse_pipeline_state(json).unwrap();\n        assert_eq!(state.name, \"complex-pipeline\");\n        assert_eq!(state.stages.len(), 2);\n        assert_eq!(state.stages[0].name, \"Source\");\n        assert_eq!(\n            state.stages[0].latest_execution.as_ref().unwrap().status,\n            \"Succeeded\"\n        );\n        assert_eq!(state.stages[0].actions.len(), 1);\n        assert_eq!(state.stages[0].actions[0].name, \"GitCheckout\");\n        assert_eq!(state.stages[1].name, \"Build\");\n    }\n\n    #[test]\n    fn parse_pipeline_state_invalid_json() {\n        let result = parse_pipeline_state(\"invalid json\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn parse_list_executions_invalid() {\n        let result = parse_list_executions(\"not valid json\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn parse_list_executions_multiple() {\n        let json = r#\"{\n            \"pipelineExecutionSummaries\": [\n                {\n                    \"pipelineExecutionId\": \"exec-1\",\n                    \"status\": \"Succeeded\",\n                    \"startTime\": \"2026-01-01T10:00:00Z\",\n                    \"lastUpdateTime\": \"2026-01-01T10:30:00Z\",\n                    \"trigger\": {\"triggerType\": \"Webhook\"}\n                },\n                {\n                    \"pipelineExecutionId\": \"exec-2\",\n                    \"status\": \"Failed\",\n                    \"startTime\": \"2026-01-01T08:00:00Z\"\n                },\n                {\n                    \"pipelineExecutionId\": \"exec-3\",\n                    \"status\": \"InProgress\"\n                }\n            ]\n        }\"#;\n        let executions = parse_list_executions(json).unwrap();\n        assert_eq!(executions.len(), 3);\n        assert_eq!(executions[0].id, \"exec-1\");\n        assert_eq!(executions[0].status, \"Succeeded\");\n        assert!(executions[0].trigger.is_some());\n        assert_eq!(\n            executions[0].trigger.as_ref().unwrap().trigger_type,\n            \"Webhook\"\n        );\n        assert_eq!(executions[1].id, \"exec-2\");\n        assert_eq!(executions[1].status, \"Failed\");\n        assert!(executions[1].trigger.is_none());\n        assert_eq!(executions[2].id, \"exec-3\");\n        assert_eq!(executions[2].status, \"InProgress\");\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":1}},{"line":13,"address":[],"length":0,"stats":{"Line":2}},{"line":14,"address":[],"length":0,"stats":{"Line":2}},{"line":16,"address":[],"length":0,"stats":{"Line":1}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":1}},{"line":24,"address":[],"length":0,"stats":{"Line":1}},{"line":25,"address":[],"length":0,"stats":{"Line":3}},{"line":26,"address":[],"length":0,"stats":{"Line":2}},{"line":28,"address":[],"length":0,"stats":{"Line":2}},{"line":32,"address":[],"length":0,"stats":{"Line":1}},{"line":33,"address":[],"length":0,"stats":{"Line":3}},{"line":34,"address":[],"length":0,"stats":{"Line":3}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":4}},{"line":43,"address":[],"length":0,"stats":{"Line":6}},{"line":44,"address":[],"length":0,"stats":{"Line":13}},{"line":46,"address":[],"length":0,"stats":{"Line":17}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":3}},{"line":67,"address":[],"length":0,"stats":{"Line":9}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":96,"address":[],"length":0,"stats":{"Line":6}},{"line":97,"address":[],"length":0,"stats":{"Line":13}},{"line":99,"address":[],"length":0,"stats":{"Line":3}},{"line":104,"address":[],"length":0,"stats":{"Line":2}},{"line":105,"address":[],"length":0,"stats":{"Line":8}},{"line":107,"address":[],"length":0,"stats":{"Line":4}},{"line":108,"address":[],"length":0,"stats":{"Line":5}},{"line":109,"address":[],"length":0,"stats":{"Line":3}},{"line":112,"address":[],"length":0,"stats":{"Line":8}},{"line":113,"address":[],"length":0,"stats":{"Line":2}},{"line":118,"address":[],"length":0,"stats":{"Line":2}},{"line":119,"address":[],"length":0,"stats":{"Line":8}},{"line":121,"address":[],"length":0,"stats":{"Line":4}},{"line":122,"address":[],"length":0,"stats":{"Line":5}},{"line":123,"address":[],"length":0,"stats":{"Line":3}},{"line":126,"address":[],"length":0,"stats":{"Line":8}},{"line":127,"address":[],"length":0,"stats":{"Line":8}},{"line":128,"address":[],"length":0,"stats":{"Line":8}},{"line":129,"address":[],"length":0,"stats":{"Line":2}},{"line":134,"address":[],"length":0,"stats":{"Line":2}},{"line":135,"address":[],"length":0,"stats":{"Line":8}},{"line":137,"address":[],"length":0,"stats":{"Line":4}},{"line":138,"address":[],"length":0,"stats":{"Line":5}},{"line":139,"address":[],"length":0,"stats":{"Line":3}},{"line":142,"address":[],"length":0,"stats":{"Line":8}},{"line":143,"address":[],"length":0,"stats":{"Line":8}},{"line":144,"address":[],"length":0,"stats":{"Line":8}},{"line":145,"address":[],"length":0,"stats":{"Line":8}},{"line":146,"address":[],"length":0,"stats":{"Line":8}},{"line":147,"address":[],"length":0,"stats":{"Line":2}}],"covered":49,"coverable":72},{"path":["/","Users","chi","Projects","hu","src","pipeline","cli.rs"],"content":"//! Pipeline CLI commands\n\nuse clap::Subcommand;\n\n#[derive(Debug, Subcommand)]\npub enum PipelineCommand {\n    /// List all pipelines\n    List {\n        /// AWS region\n        #[arg(short, long)]\n        region: Option\u003cString\u003e,\n\n        /// Output as JSON\n        #[arg(long)]\n        json: bool,\n    },\n\n    /// Show pipeline status (stages and actions)\n    Status {\n        /// Pipeline name\n        name: String,\n\n        /// AWS region\n        #[arg(short, long)]\n        region: Option\u003cString\u003e,\n\n        /// Output as JSON\n        #[arg(long)]\n        json: bool,\n    },\n\n    /// Show pipeline execution history\n    History {\n        /// Pipeline name\n        name: String,\n\n        /// AWS region\n        #[arg(short, long)]\n        region: Option\u003cString\u003e,\n\n        /// Maximum number of results\n        #[arg(short, long, default_value = \"10\")]\n        limit: usize,\n\n        /// Output as JSON\n        #[arg(long)]\n        json: bool,\n    },\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use clap::{CommandFactory, Parser};\n\n    #[derive(Parser)]\n    struct TestCli {\n        #[command(subcommand)]\n        cmd: PipelineCommand,\n    }\n\n    #[test]\n    fn parses_list_basic() {\n        let cli = TestCli::try_parse_from([\"test\", \"list\"]).unwrap();\n        match cli.cmd {\n            PipelineCommand::List { region, json } =\u003e {\n                assert!(region.is_none());\n                assert!(!json);\n            }\n            _ =\u003e panic!(\"Expected List command\"),\n        }\n    }\n\n    #[test]\n    fn parses_list_with_region() {\n        let cli = TestCli::try_parse_from([\"test\", \"list\", \"-r\", \"us-west-2\"]).unwrap();\n        match cli.cmd {\n            PipelineCommand::List { region, .. } =\u003e {\n                assert_eq!(region, Some(\"us-west-2\".to_string()));\n            }\n            _ =\u003e panic!(\"Expected List command\"),\n        }\n    }\n\n    #[test]\n    fn parses_list_json() {\n        let cli = TestCli::try_parse_from([\"test\", \"list\", \"--json\"]).unwrap();\n        match cli.cmd {\n            PipelineCommand::List { json, .. } =\u003e {\n                assert!(json);\n            }\n            _ =\u003e panic!(\"Expected List command\"),\n        }\n    }\n\n    #[test]\n    fn parses_status_basic() {\n        let cli = TestCli::try_parse_from([\"test\", \"status\", \"my-pipeline\"]).unwrap();\n        match cli.cmd {\n            PipelineCommand::Status { name, region, json } =\u003e {\n                assert_eq!(name, \"my-pipeline\");\n                assert!(region.is_none());\n                assert!(!json);\n            }\n            _ =\u003e panic!(\"Expected Status command\"),\n        }\n    }\n\n    #[test]\n    fn parses_status_with_region() {\n        let cli =\n            TestCli::try_parse_from([\"test\", \"status\", \"my-pipeline\", \"-r\", \"eu-west-1\"]).unwrap();\n        match cli.cmd {\n            PipelineCommand::Status { region, .. } =\u003e {\n                assert_eq!(region, Some(\"eu-west-1\".to_string()));\n            }\n            _ =\u003e panic!(\"Expected Status command\"),\n        }\n    }\n\n    #[test]\n    fn parses_status_json() {\n        let cli = TestCli::try_parse_from([\"test\", \"status\", \"my-pipeline\", \"--json\"]).unwrap();\n        match cli.cmd {\n            PipelineCommand::Status { json, .. } =\u003e {\n                assert!(json);\n            }\n            _ =\u003e panic!(\"Expected Status command\"),\n        }\n    }\n\n    #[test]\n    fn parses_history_basic() {\n        let cli = TestCli::try_parse_from([\"test\", \"history\", \"my-pipeline\"]).unwrap();\n        match cli.cmd {\n            PipelineCommand::History {\n                name, limit, json, ..\n            } =\u003e {\n                assert_eq!(name, \"my-pipeline\");\n                assert_eq!(limit, 10); // default\n                assert!(!json);\n            }\n            _ =\u003e panic!(\"Expected History command\"),\n        }\n    }\n\n    #[test]\n    fn parses_history_with_limit() {\n        let cli = TestCli::try_parse_from([\"test\", \"history\", \"my-pipeline\", \"-l\", \"25\"]).unwrap();\n        match cli.cmd {\n            PipelineCommand::History { limit, .. } =\u003e {\n                assert_eq!(limit, 25);\n            }\n            _ =\u003e panic!(\"Expected History command\"),\n        }\n    }\n\n    #[test]\n    fn parses_history_with_region() {\n        let cli = TestCli::try_parse_from([\"test\", \"history\", \"my-pipeline\", \"-r\", \"ap-south-1\"])\n            .unwrap();\n        match cli.cmd {\n            PipelineCommand::History { region, .. } =\u003e {\n                assert_eq!(region, Some(\"ap-south-1\".to_string()));\n            }\n            _ =\u003e panic!(\"Expected History command\"),\n        }\n    }\n\n    #[test]\n    fn parses_history_json() {\n        let cli = TestCli::try_parse_from([\"test\", \"history\", \"my-pipeline\", \"--json\"]).unwrap();\n        match cli.cmd {\n            PipelineCommand::History { json, .. } =\u003e {\n                assert!(json);\n            }\n            _ =\u003e panic!(\"Expected History command\"),\n        }\n    }\n\n    #[test]\n    fn command_debug() {\n        let cmd = PipelineCommand::List {\n            region: None,\n            json: false,\n        };\n        let debug = format!(\"{:?}\", cmd);\n        assert!(debug.contains(\"List\"));\n    }\n\n    #[test]\n    fn command_has_help() {\n        let mut cmd = TestCli::command();\n        let help = cmd.render_help();\n        assert!(!help.to_string().is_empty());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","pipeline","display","mod.rs"],"content":"//! Pipeline output formatting\n\nuse anyhow::{Context, Result};\nuse comfy_table::{presets::UTF8_FULL_CONDENSED, Cell, Color, ContentArrangement, Table};\n\nuse super::types::{OutputFormat, Pipeline, PipelineExecution, PipelineState, StageStatus};\n\n#[cfg(test)]\nmod tests;\n\n/// Get color for stage/execution status\nfn status_color(status: \u0026str) -\u003e Color {\n    match status {\n        \"Succeeded\" =\u003e Color::Green,\n        \"InProgress\" =\u003e Color::Yellow,\n        \"Failed\" =\u003e Color::Red,\n        \"Stopped\" | \"Cancelled\" | \"Superseded\" =\u003e Color::DarkGrey,\n        _ =\u003e Color::White,\n    }\n}\n\n/// Get icon for status\nfn status_icon(status: \u0026str) -\u003e \u0026'static str {\n    match status {\n        \"Succeeded\" =\u003e \"\",\n        \"InProgress\" =\u003e \"\",\n        \"Failed\" =\u003e \"\",\n        \"Stopped\" | \"Cancelled\" =\u003e \"\",\n        _ =\u003e \" \",\n    }\n}\n\n/// Output pipelines list\npub fn output_pipelines(pipelines: \u0026[Pipeline], format: OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            if pipelines.is_empty() {\n                println!(\"No pipelines found.\");\n                return Ok(());\n            }\n\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_content_arrangement(ContentArrangement::Dynamic);\n            table.set_header(vec![\"NAME\", \"CREATED\", \"UPDATED\"]);\n\n            for pipeline in pipelines {\n                table.add_row(vec![\n                    Cell::new(\u0026pipeline.name).fg(Color::Cyan),\n                    Cell::new(pipeline.created.as_deref().unwrap_or(\"-\")),\n                    Cell::new(pipeline.updated.as_deref().unwrap_or(\"-\")),\n                ]);\n            }\n\n            println!(\"{table}\");\n            println!(\"\\n{} pipelines\", pipelines.len());\n        }\n        OutputFormat::Json =\u003e {\n            let json =\n                serde_json::to_string_pretty(pipelines).context(\"Failed to serialize pipelines\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n\n/// Output pipeline state (stages with status)\npub fn output_pipeline_state(state: \u0026PipelineState, format: OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            println!(\"Pipeline: {}\", state.name);\n            println!();\n\n            if state.stages.is_empty() {\n                println!(\"No stages found.\");\n                return Ok(());\n            }\n\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_content_arrangement(ContentArrangement::Dynamic);\n            table.set_header(vec![\"STAGE\", \"STATUS\", \"ACTIONS\"]);\n\n            for stage in \u0026state.stages {\n                let status = stage\n                    .latest_execution\n                    .as_ref()\n                    .map(|e| e.status.as_str())\n                    .unwrap_or(\"-\");\n\n                let status_enum = StageStatus::from_str(status);\n                let icon = status_icon(status);\n                let display_status = format!(\"{} {}\", icon, status);\n\n                // Show action count\n                let action_count = stage.actions.len();\n                let action_summary = if action_count \u003e 0 {\n                    let succeeded = stage\n                        .actions\n                        .iter()\n                        .filter(|a| {\n                            a.latest_execution\n                                .as_ref()\n                                .map(|e| e.status == \"Succeeded\")\n                                .unwrap_or(false)\n                        })\n                        .count();\n                    format!(\"{}/{} succeeded\", succeeded, action_count)\n                } else {\n                    \"-\".to_string()\n                };\n\n                table.add_row(vec![\n                    Cell::new(\u0026stage.name).fg(Color::Cyan),\n                    Cell::new(\u0026display_status).fg(match status_enum {\n                        StageStatus::Succeeded =\u003e Color::Green,\n                        StageStatus::InProgress =\u003e Color::Yellow,\n                        StageStatus::Failed =\u003e Color::Red,\n                        _ =\u003e Color::White,\n                    }),\n                    Cell::new(\u0026action_summary),\n                ]);\n            }\n\n            println!(\"{table}\");\n        }\n        OutputFormat::Json =\u003e {\n            let json = serde_json::to_string_pretty(state)\n                .context(\"Failed to serialize pipeline state\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n\n/// Output pipeline execution history\npub fn output_executions(executions: \u0026[PipelineExecution], format: OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            if executions.is_empty() {\n                println!(\"No executions found.\");\n                return Ok(());\n            }\n\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_content_arrangement(ContentArrangement::Dynamic);\n            table.set_header(vec![\"ID\", \"STATUS\", \"STARTED\", \"TRIGGER\"]);\n\n            for exec in executions {\n                let icon = status_icon(\u0026exec.status);\n                let display_status = format!(\"{} {}\", icon, exec.status);\n\n                let trigger = exec\n                    .trigger\n                    .as_ref()\n                    .map(|t| t.trigger_type.as_str())\n                    .unwrap_or(\"-\");\n\n                table.add_row(vec![\n                    Cell::new(\u0026exec.id).fg(Color::Cyan),\n                    Cell::new(\u0026display_status).fg(status_color(\u0026exec.status)),\n                    Cell::new(exec.started.as_deref().unwrap_or(\"-\")),\n                    Cell::new(trigger),\n                ]);\n            }\n\n            println!(\"{table}\");\n            println!(\"\\n{} executions\", executions.len());\n        }\n        OutputFormat::Json =\u003e {\n            let json = serde_json::to_string_pretty(executions)\n                .context(\"Failed to serialize executions\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":8}},{"line":13,"address":[],"length":0,"stats":{"Line":8}},{"line":14,"address":[],"length":0,"stats":{"Line":10}},{"line":15,"address":[],"length":0,"stats":{"Line":7}},{"line":16,"address":[],"length":0,"stats":{"Line":6}},{"line":17,"address":[],"length":0,"stats":{"Line":12}},{"line":18,"address":[],"length":0,"stats":{"Line":1}},{"line":23,"address":[],"length":0,"stats":{"Line":12}},{"line":24,"address":[],"length":0,"stats":{"Line":12}},{"line":25,"address":[],"length":0,"stats":{"Line":15}},{"line":26,"address":[],"length":0,"stats":{"Line":11}},{"line":27,"address":[],"length":0,"stats":{"Line":9}},{"line":28,"address":[],"length":0,"stats":{"Line":11}},{"line":29,"address":[],"length":0,"stats":{"Line":2}},{"line":34,"address":[],"length":0,"stats":{"Line":3}},{"line":35,"address":[],"length":0,"stats":{"Line":3}},{"line":37,"address":[],"length":0,"stats":{"Line":4}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":39,"address":[],"length":0,"stats":{"Line":1}},{"line":42,"address":[],"length":0,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":3}},{"line":44,"address":[],"length":0,"stats":{"Line":3}},{"line":45,"address":[],"length":0,"stats":{"Line":5}},{"line":47,"address":[],"length":0,"stats":{"Line":4}},{"line":48,"address":[],"length":0,"stats":{"Line":4}},{"line":49,"address":[],"length":0,"stats":{"Line":5}},{"line":50,"address":[],"length":0,"stats":{"Line":6}},{"line":51,"address":[],"length":0,"stats":{"Line":4}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":56,"address":[],"length":0,"stats":{"Line":4}},{"line":59,"address":[],"length":0,"stats":{"Line":1}},{"line":60,"address":[],"length":0,"stats":{"Line":3}},{"line":61,"address":[],"length":0,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":2}},{"line":68,"address":[],"length":0,"stats":{"Line":7}},{"line":69,"address":[],"length":0,"stats":{"Line":7}},{"line":71,"address":[],"length":0,"stats":{"Line":12}},{"line":72,"address":[],"length":0,"stats":{"Line":6}},{"line":74,"address":[],"length":0,"stats":{"Line":12}},{"line":75,"address":[],"length":0,"stats":{"Line":2}},{"line":76,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":10}},{"line":80,"address":[],"length":0,"stats":{"Line":15}},{"line":81,"address":[],"length":0,"stats":{"Line":15}},{"line":82,"address":[],"length":0,"stats":{"Line":25}},{"line":84,"address":[],"length":0,"stats":{"Line":15}},{"line":85,"address":[],"length":0,"stats":{"Line":10}},{"line":86,"address":[],"length":0,"stats":{"Line":5}},{"line":88,"address":[],"length":0,"stats":{"Line":13}},{"line":91,"address":[],"length":0,"stats":{"Line":15}},{"line":92,"address":[],"length":0,"stats":{"Line":15}},{"line":93,"address":[],"length":0,"stats":{"Line":15}},{"line":96,"address":[],"length":0,"stats":{"Line":15}},{"line":97,"address":[],"length":0,"stats":{"Line":10}},{"line":98,"address":[],"length":0,"stats":{"Line":4}},{"line":99,"address":[],"length":0,"stats":{"Line":2}},{"line":101,"address":[],"length":0,"stats":{"Line":4}},{"line":102,"address":[],"length":0,"stats":{"Line":2}},{"line":103,"address":[],"length":0,"stats":{"Line":2}},{"line":104,"address":[],"length":0,"stats":{"Line":6}},{"line":105,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":4}},{"line":110,"address":[],"length":0,"stats":{"Line":6}},{"line":113,"address":[],"length":0,"stats":{"Line":15}},{"line":114,"address":[],"length":0,"stats":{"Line":20}},{"line":115,"address":[],"length":0,"stats":{"Line":20}},{"line":116,"address":[],"length":0,"stats":{"Line":1}},{"line":117,"address":[],"length":0,"stats":{"Line":1}},{"line":118,"address":[],"length":0,"stats":{"Line":1}},{"line":119,"address":[],"length":0,"stats":{"Line":2}},{"line":121,"address":[],"length":0,"stats":{"Line":10}},{"line":125,"address":[],"length":0,"stats":{"Line":10}},{"line":128,"address":[],"length":0,"stats":{"Line":3}},{"line":130,"address":[],"length":0,"stats":{"Line":2}},{"line":133,"address":[],"length":0,"stats":{"Line":6}},{"line":137,"address":[],"length":0,"stats":{"Line":3}},{"line":138,"address":[],"length":0,"stats":{"Line":3}},{"line":140,"address":[],"length":0,"stats":{"Line":4}},{"line":141,"address":[],"length":0,"stats":{"Line":2}},{"line":142,"address":[],"length":0,"stats":{"Line":1}},{"line":145,"address":[],"length":0,"stats":{"Line":2}},{"line":146,"address":[],"length":0,"stats":{"Line":3}},{"line":147,"address":[],"length":0,"stats":{"Line":3}},{"line":148,"address":[],"length":0,"stats":{"Line":6}},{"line":150,"address":[],"length":0,"stats":{"Line":3}},{"line":151,"address":[],"length":0,"stats":{"Line":3}},{"line":152,"address":[],"length":0,"stats":{"Line":3}},{"line":154,"address":[],"length":0,"stats":{"Line":2}},{"line":155,"address":[],"length":0,"stats":{"Line":1}},{"line":157,"address":[],"length":0,"stats":{"Line":3}},{"line":160,"address":[],"length":0,"stats":{"Line":3}},{"line":161,"address":[],"length":0,"stats":{"Line":4}},{"line":162,"address":[],"length":0,"stats":{"Line":5}},{"line":163,"address":[],"length":0,"stats":{"Line":5}},{"line":164,"address":[],"length":0,"stats":{"Line":2}},{"line":168,"address":[],"length":0,"stats":{"Line":2}},{"line":169,"address":[],"length":0,"stats":{"Line":4}},{"line":172,"address":[],"length":0,"stats":{"Line":3}},{"line":174,"address":[],"length":0,"stats":{"Line":2}},{"line":177,"address":[],"length":0,"stats":{"Line":2}}],"covered":100,"coverable":100},{"path":["/","Users","chi","Projects","hu","src","pipeline","display","tests.rs"],"content":"use super::*;\n\n#[test]\nfn status_color_succeeded() {\n    assert_eq!(status_color(\"Succeeded\"), Color::Green);\n}\n\n#[test]\nfn status_color_in_progress() {\n    assert_eq!(status_color(\"InProgress\"), Color::Yellow);\n}\n\n#[test]\nfn status_color_failed() {\n    assert_eq!(status_color(\"Failed\"), Color::Red);\n}\n\n#[test]\nfn status_color_stopped() {\n    assert_eq!(status_color(\"Stopped\"), Color::DarkGrey);\n}\n\n#[test]\nfn status_color_cancelled() {\n    assert_eq!(status_color(\"Cancelled\"), Color::DarkGrey);\n}\n\n#[test]\nfn status_color_unknown() {\n    assert_eq!(status_color(\"Unknown\"), Color::White);\n}\n\n#[test]\nfn status_icon_succeeded() {\n    assert_eq!(status_icon(\"Succeeded\"), \"\");\n}\n\n#[test]\nfn status_icon_in_progress() {\n    assert_eq!(status_icon(\"InProgress\"), \"\");\n}\n\n#[test]\nfn status_icon_failed() {\n    assert_eq!(status_icon(\"Failed\"), \"\");\n}\n\n#[test]\nfn status_icon_stopped() {\n    assert_eq!(status_icon(\"Stopped\"), \"\");\n}\n\n#[test]\nfn status_icon_unknown() {\n    assert_eq!(status_icon(\"Other\"), \" \");\n}\n\n#[test]\nfn status_icon_cancelled() {\n    assert_eq!(status_icon(\"Cancelled\"), \"\");\n}\n\n#[test]\nfn status_color_superseded() {\n    assert_eq!(status_color(\"Superseded\"), Color::DarkGrey);\n}\n\n#[test]\nfn output_pipelines_empty() {\n    let result = output_pipelines(\u0026[], OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_pipelines_table() {\n    let pipelines = vec![Pipeline {\n        name: \"test-pipeline\".to_string(),\n        created: Some(\"2026-01-01\".to_string()),\n        updated: None,\n    }];\n    let result = output_pipelines(\u0026pipelines, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_pipelines_json() {\n    let pipelines = vec![Pipeline {\n        name: \"test-pipeline\".to_string(),\n        created: None,\n        updated: None,\n    }];\n    let result = output_pipelines(\u0026pipelines, OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_pipeline_state_empty() {\n    let state = PipelineState {\n        name: \"test\".to_string(),\n        stages: vec![],\n    };\n    let result = output_pipeline_state(\u0026state, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_pipeline_state_table() {\n    use super::super::types::{ActionExecution, ActionState, StageExecution, StageState};\n\n    let state = PipelineState {\n        name: \"test-pipeline\".to_string(),\n        stages: vec![StageState {\n            name: \"Source\".to_string(),\n            latest_execution: Some(StageExecution {\n                status: \"Succeeded\".to_string(),\n            }),\n            actions: vec![ActionState {\n                name: \"SourceAction\".to_string(),\n                latest_execution: Some(ActionExecution {\n                    status: \"Succeeded\".to_string(),\n                    last_status_change: None,\n                }),\n            }],\n        }],\n    };\n    let result = output_pipeline_state(\u0026state, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_pipeline_state_with_all_statuses() {\n    use super::super::types::{ActionExecution, ActionState, StageExecution, StageState};\n\n    // Test with InProgress status\n    let state = PipelineState {\n        name: \"in-progress-pipeline\".to_string(),\n        stages: vec![StageState {\n            name: \"Build\".to_string(),\n            latest_execution: Some(StageExecution {\n                status: \"InProgress\".to_string(),\n            }),\n            actions: vec![ActionState {\n                name: \"BuildAction\".to_string(),\n                latest_execution: Some(ActionExecution {\n                    status: \"InProgress\".to_string(),\n                    last_status_change: Some(\"2026-01-01T00:00:00Z\".to_string()),\n                }),\n            }],\n        }],\n    };\n    assert!(output_pipeline_state(\u0026state, OutputFormat::Table).is_ok());\n\n    // Test with Failed status\n    let state = PipelineState {\n        name: \"failed-pipeline\".to_string(),\n        stages: vec![StageState {\n            name: \"Deploy\".to_string(),\n            latest_execution: Some(StageExecution {\n                status: \"Failed\".to_string(),\n            }),\n            actions: vec![],\n        }],\n    };\n    assert!(output_pipeline_state(\u0026state, OutputFormat::Table).is_ok());\n\n    // Test with Stopped status (triggers Unknown branch)\n    let state = PipelineState {\n        name: \"stopped-pipeline\".to_string(),\n        stages: vec![StageState {\n            name: \"Test\".to_string(),\n            latest_execution: Some(StageExecution {\n                status: \"Stopped\".to_string(),\n            }),\n            actions: vec![],\n        }],\n    };\n    assert!(output_pipeline_state(\u0026state, OutputFormat::Table).is_ok());\n\n    // Test stage with no execution\n    let state = PipelineState {\n        name: \"no-execution-pipeline\".to_string(),\n        stages: vec![StageState {\n            name: \"Pending\".to_string(),\n            latest_execution: None,\n            actions: vec![],\n        }],\n    };\n    assert!(output_pipeline_state(\u0026state, OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_pipeline_state_json() {\n    let state = PipelineState {\n        name: \"test\".to_string(),\n        stages: vec![],\n    };\n    let result = output_pipeline_state(\u0026state, OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_executions_empty() {\n    let result = output_executions(\u0026[], OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_executions_table() {\n    use super::super::types::ExecutionTrigger;\n\n    let executions = vec![PipelineExecution {\n        id: \"exec-1\".to_string(),\n        status: \"Succeeded\".to_string(),\n        started: Some(\"2026-01-01T00:00:00Z\".to_string()),\n        updated: None,\n        trigger: Some(ExecutionTrigger {\n            trigger_type: \"Webhook\".to_string(),\n        }),\n    }];\n    let result = output_executions(\u0026executions, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_executions_json() {\n    let executions = vec![PipelineExecution {\n        id: \"exec-1\".to_string(),\n        status: \"Failed\".to_string(),\n        started: None,\n        updated: None,\n        trigger: None,\n    }];\n    let result = output_executions(\u0026executions, OutputFormat::Json);\n    assert!(result.is_ok());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","pipeline","mod.rs"],"content":"//! AWS CodePipeline status (read-only)\n//!\n//! List pipelines, view status, and check execution history.\n\nmod aws;\nmod cli;\nmod display;\nmod types;\n\nuse anyhow::Result;\n\npub use cli::PipelineCommand;\nuse types::{AwsConfig, OutputFormat};\n\n/// Run a pipeline command\npub async fn run(cmd: PipelineCommand) -\u003e Result\u003c()\u003e {\n    match cmd {\n        PipelineCommand::List { region, json } =\u003e cmd_list(region, json),\n        PipelineCommand::Status { name, region, json } =\u003e cmd_status(\u0026name, region, json),\n        PipelineCommand::History {\n            name,\n            region,\n            limit,\n            json,\n        } =\u003e cmd_history(\u0026name, region, limit, json),\n    }\n}\n\n/// List pipelines\nfn cmd_list(region: Option\u003cString\u003e, json: bool) -\u003e Result\u003c()\u003e {\n    let config = AwsConfig { region };\n    let pipelines = aws::list_pipelines(\u0026config)?;\n\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n\n    display::output_pipelines(\u0026pipelines, format)?;\n    Ok(())\n}\n\n/// Show pipeline status\nfn cmd_status(name: \u0026str, region: Option\u003cString\u003e, json: bool) -\u003e Result\u003c()\u003e {\n    let config = AwsConfig { region };\n    let state = aws::get_pipeline_state(\u0026config, name)?;\n\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n\n    display::output_pipeline_state(\u0026state, format)?;\n    Ok(())\n}\n\n/// Show pipeline execution history\nfn cmd_history(name: \u0026str, region: Option\u003cString\u003e, limit: usize, json: bool) -\u003e Result\u003c()\u003e {\n    let config = AwsConfig { region };\n    let executions = aws::list_executions(\u0026config, name, limit)?;\n\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n\n    display::output_executions(\u0026executions, format)?;\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn aws_config_from_region() {\n        let config = AwsConfig {\n            region: Some(\"us-east-1\".to_string()),\n        };\n        assert_eq!(config.region, Some(\"us-east-1\".to_string()));\n    }\n\n    #[test]\n    fn aws_config_default() {\n        let config = AwsConfig { region: None };\n        assert!(config.region.is_none());\n    }\n\n    #[test]\n    fn output_format_from_json_flag_true() {\n        let json = true;\n        let format = if json {\n            OutputFormat::Json\n        } else {\n            OutputFormat::Table\n        };\n        assert_eq!(format, OutputFormat::Json);\n    }\n\n    #[test]\n    fn output_format_from_json_flag_false() {\n        let json = false;\n        let format = if json {\n            OutputFormat::Json\n        } else {\n            OutputFormat::Table\n        };\n        assert_eq!(format, OutputFormat::Table);\n    }\n\n    #[test]\n    fn pipeline_command_list_matches() {\n        let cmd = PipelineCommand::List {\n            region: Some(\"us-west-2\".to_string()),\n            json: true,\n        };\n        match cmd {\n            PipelineCommand::List { region, json } =\u003e {\n                assert_eq!(region, Some(\"us-west-2\".to_string()));\n                assert!(json);\n            }\n            _ =\u003e panic!(\"Expected List command\"),\n        }\n    }\n\n    #[test]\n    fn pipeline_command_status_matches() {\n        let cmd = PipelineCommand::Status {\n            name: \"my-pipeline\".to_string(),\n            region: None,\n            json: false,\n        };\n        match cmd {\n            PipelineCommand::Status { name, region, json } =\u003e {\n                assert_eq!(name, \"my-pipeline\");\n                assert!(region.is_none());\n                assert!(!json);\n            }\n            _ =\u003e panic!(\"Expected Status command\"),\n        }\n    }\n\n    #[test]\n    fn pipeline_command_history_matches() {\n        let cmd = PipelineCommand::History {\n            name: \"prod-pipeline\".to_string(),\n            region: Some(\"eu-central-1\".to_string()),\n            limit: 25,\n            json: true,\n        };\n        match cmd {\n            PipelineCommand::History {\n                name,\n                region,\n                limit,\n                json,\n            } =\u003e {\n                assert_eq!(name, \"prod-pipeline\");\n                assert_eq!(region, Some(\"eu-central-1\".to_string()));\n                assert_eq!(limit, 25);\n                assert!(json);\n            }\n            _ =\u003e panic!(\"Expected History command\"),\n        }\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":2}},{"line":17,"address":[],"length":0,"stats":{"Line":1}},{"line":18,"address":[],"length":0,"stats":{"Line":5}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":1}},{"line":31,"address":[],"length":0,"stats":{"Line":2}},{"line":32,"address":[],"length":0,"stats":{"Line":3}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}}],"covered":6,"coverable":33},{"path":["/","Users","chi","Projects","hu","src","pipeline","types.rs"],"content":"//! CodePipeline data types\n\nuse serde::{Deserialize, Serialize};\n\n/// Pipeline summary\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Pipeline {\n    /// Pipeline name\n    pub name: String,\n    /// Creation time\n    #[serde(default)]\n    pub created: Option\u003cString\u003e,\n    /// Last update time\n    #[serde(default)]\n    pub updated: Option\u003cString\u003e,\n}\n\n/// Pipeline state (current status)\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PipelineState {\n    /// Pipeline name\n    #[serde(rename = \"pipelineName\")]\n    pub name: String,\n    /// Stage states\n    #[serde(rename = \"stageStates\", default)]\n    pub stages: Vec\u003cStageState\u003e,\n}\n\n/// Stage state\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct StageState {\n    /// Stage name\n    #[serde(rename = \"stageName\")]\n    pub name: String,\n    /// Latest execution\n    #[serde(rename = \"latestExecution\", default)]\n    pub latest_execution: Option\u003cStageExecution\u003e,\n    /// Action states\n    #[serde(rename = \"actionStates\", default)]\n    pub actions: Vec\u003cActionState\u003e,\n}\n\n/// Stage execution info\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct StageExecution {\n    /// Status\n    pub status: String,\n}\n\n/// Action state\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ActionState {\n    /// Action name\n    #[serde(rename = \"actionName\")]\n    pub name: String,\n    /// Latest execution\n    #[serde(rename = \"latestExecution\", default)]\n    pub latest_execution: Option\u003cActionExecution\u003e,\n}\n\n/// Action execution info\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ActionExecution {\n    /// Status\n    pub status: String,\n    /// Last status change\n    #[serde(rename = \"lastStatusChange\", default)]\n    pub last_status_change: Option\u003cString\u003e,\n}\n\n/// Pipeline execution summary\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PipelineExecution {\n    /// Execution ID\n    #[serde(rename = \"pipelineExecutionId\")]\n    pub id: String,\n    /// Status\n    pub status: String,\n    /// Start time\n    #[serde(rename = \"startTime\", default)]\n    pub started: Option\u003cString\u003e,\n    /// Last update time\n    #[serde(rename = \"lastUpdateTime\", default)]\n    pub updated: Option\u003cString\u003e,\n    /// Trigger info\n    #[serde(default)]\n    pub trigger: Option\u003cExecutionTrigger\u003e,\n}\n\n/// Execution trigger\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ExecutionTrigger {\n    /// Trigger type\n    #[serde(rename = \"triggerType\")]\n    pub trigger_type: String,\n}\n\n/// Stage status enum\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum StageStatus {\n    /// In progress\n    InProgress,\n    /// Succeeded\n    Succeeded,\n    /// Failed\n    Failed,\n    /// Stopped\n    Stopped,\n    /// Unknown\n    Unknown,\n}\n\nimpl StageStatus {\n    /// Parse from string\n    pub fn from_str(s: \u0026str) -\u003e Self {\n        match s {\n            \"InProgress\" =\u003e Self::InProgress,\n            \"Succeeded\" =\u003e Self::Succeeded,\n            \"Failed\" =\u003e Self::Failed,\n            \"Stopped\" =\u003e Self::Stopped,\n            _ =\u003e Self::Unknown,\n        }\n    }\n}\n\n/// Output format\n#[derive(Debug, Clone, Copy, Default, PartialEq, Eq)]\npub enum OutputFormat {\n    /// Table format\n    #[default]\n    Table,\n    /// JSON format\n    Json,\n}\n\n/// AWS CLI configuration\n#[derive(Debug, Clone, Default)]\npub struct AwsConfig {\n    /// AWS region\n    pub region: Option\u003cString\u003e,\n}\n\n/// List pipelines response\n#[derive(Debug, Deserialize)]\npub struct ListPipelinesResponse {\n    /// Pipelines\n    pub pipelines: Vec\u003cPipelineSummary\u003e,\n}\n\n/// Pipeline summary from list\n#[derive(Debug, Deserialize)]\npub struct PipelineSummary {\n    /// Name\n    pub name: String,\n    /// Created\n    pub created: Option\u003cString\u003e,\n    /// Updated\n    pub updated: Option\u003cString\u003e,\n}\n\nimpl PipelineSummary {\n    /// Convert to Pipeline\n    pub fn to_pipeline(\u0026self) -\u003e Pipeline {\n        Pipeline {\n            name: self.name.clone(),\n            created: self.created.clone(),\n            updated: self.updated.clone(),\n        }\n    }\n}\n\n/// List executions response\n#[derive(Debug, Deserialize)]\npub struct ListExecutionsResponse {\n    /// Executions\n    #[serde(rename = \"pipelineExecutionSummaries\")]\n    pub executions: Vec\u003cPipelineExecution\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn pipeline_debug() {\n        let p = Pipeline {\n            name: \"test\".to_string(),\n            created: None,\n            updated: None,\n        };\n        let debug = format!(\"{:?}\", p);\n        assert!(debug.contains(\"test\"));\n    }\n\n    #[test]\n    fn pipeline_clone() {\n        let p = Pipeline {\n            name: \"test\".to_string(),\n            created: Some(\"2026-01-01\".to_string()),\n            updated: None,\n        };\n        let cloned = p.clone();\n        assert_eq!(cloned.name, p.name);\n    }\n\n    #[test]\n    fn stage_status_from_str() {\n        assert_eq!(StageStatus::from_str(\"InProgress\"), StageStatus::InProgress);\n        assert_eq!(StageStatus::from_str(\"Succeeded\"), StageStatus::Succeeded);\n        assert_eq!(StageStatus::from_str(\"Failed\"), StageStatus::Failed);\n        assert_eq!(StageStatus::from_str(\"Stopped\"), StageStatus::Stopped);\n        assert_eq!(StageStatus::from_str(\"Other\"), StageStatus::Unknown);\n    }\n\n    #[test]\n    fn output_format_default() {\n        let format = OutputFormat::default();\n        assert_eq!(format, OutputFormat::Table);\n    }\n\n    #[test]\n    fn aws_config_default() {\n        let config = AwsConfig::default();\n        assert!(config.region.is_none());\n    }\n\n    #[test]\n    fn parse_list_pipelines_response() {\n        let json = r#\"{\n            \"pipelines\": [\n                {\"name\": \"pipeline-1\", \"created\": \"2026-01-01\", \"updated\": \"2026-01-02\"},\n                {\"name\": \"pipeline-2\"}\n            ]\n        }\"#;\n        let resp: ListPipelinesResponse = serde_json::from_str(json).unwrap();\n        assert_eq!(resp.pipelines.len(), 2);\n        assert_eq!(resp.pipelines[0].name, \"pipeline-1\");\n    }\n\n    #[test]\n    fn parse_pipeline_state() {\n        let json = r#\"{\n            \"pipelineName\": \"my-pipeline\",\n            \"stageStates\": [\n                {\n                    \"stageName\": \"Source\",\n                    \"latestExecution\": {\"status\": \"Succeeded\"},\n                    \"actionStates\": []\n                }\n            ]\n        }\"#;\n        let state: PipelineState = serde_json::from_str(json).unwrap();\n        assert_eq!(state.name, \"my-pipeline\");\n        assert_eq!(state.stages.len(), 1);\n        assert_eq!(state.stages[0].name, \"Source\");\n    }\n\n    #[test]\n    fn parse_list_executions_response() {\n        let json = r#\"{\n            \"pipelineExecutionSummaries\": [\n                {\n                    \"pipelineExecutionId\": \"exec-1\",\n                    \"status\": \"Succeeded\",\n                    \"startTime\": \"2026-01-01T00:00:00Z\",\n                    \"trigger\": {\"triggerType\": \"Webhook\"}\n                }\n            ]\n        }\"#;\n        let resp: ListExecutionsResponse = serde_json::from_str(json).unwrap();\n        assert_eq!(resp.executions.len(), 1);\n        assert_eq!(resp.executions[0].id, \"exec-1\");\n        assert_eq!(resp.executions[0].status, \"Succeeded\");\n    }\n\n    #[test]\n    fn pipeline_summary_to_pipeline() {\n        let summary = PipelineSummary {\n            name: \"test\".to_string(),\n            created: Some(\"2026-01-01\".to_string()),\n            updated: None,\n        };\n        let pipeline = summary.to_pipeline();\n        assert_eq!(pipeline.name, \"test\");\n        assert_eq!(pipeline.created, Some(\"2026-01-01\".to_string()));\n    }\n}\n","traces":[{"line":115,"address":[],"length":0,"stats":{"Line":10}},{"line":116,"address":[],"length":0,"stats":{"Line":10}},{"line":117,"address":[],"length":0,"stats":{"Line":12}},{"line":118,"address":[],"length":0,"stats":{"Line":10}},{"line":119,"address":[],"length":0,"stats":{"Line":8}},{"line":120,"address":[],"length":0,"stats":{"Line":6}},{"line":121,"address":[],"length":0,"stats":{"Line":2}},{"line":163,"address":[],"length":0,"stats":{"Line":5}},{"line":165,"address":[],"length":0,"stats":{"Line":15}},{"line":166,"address":[],"length":0,"stats":{"Line":15}},{"line":167,"address":[],"length":0,"stats":{"Line":5}}],"covered":11,"coverable":11},{"path":["/","Users","chi","Projects","hu","src","read","around.rs"],"content":"/// Extract lines around a center line with context\npub fn extract_lines_around(\n    content: \u0026str,\n    center: usize,\n    context: usize,\n) -\u003e (Vec\u003c(usize, String)\u003e, usize) {\n    let lines: Vec\u003c\u0026str\u003e = content.lines().collect();\n    let total_lines = lines.len();\n\n    if total_lines == 0 || center == 0 {\n        return (vec![], total_lines);\n    }\n\n    // Convert to 0-indexed\n    let center_idx = center.saturating_sub(1);\n\n    // Calculate range with clamping\n    let start = center_idx.saturating_sub(context);\n    let end = (center_idx + context + 1).min(total_lines);\n\n    let result: Vec\u003c(usize, String)\u003e = lines[start..end]\n        .iter()\n        .enumerate()\n        .map(|(i, line)| (start + i + 1, (*line).to_string()))\n        .collect();\n\n    (result, total_lines)\n}\n\n/// Format lines with line numbers and highlight center\npub fn format_lines_around(lines: \u0026[(usize, String)], center: usize, total_lines: usize) -\u003e String {\n    if lines.is_empty() {\n        return \"No content\".to_string();\n    }\n\n    let width = total_lines.to_string().len();\n    let mut output = Vec::new();\n\n    for (num, line) in lines {\n        let marker = if *num == center { \"\u003e\" } else { \" \" };\n        output.push(format!(\n            \"{}{:\u003ewidth$}: {}\",\n            marker,\n            num,\n            line,\n            width = width\n        ));\n    }\n\n    output.join(\"\\n\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn extract_basic() {\n        let content = \"line1\\nline2\\nline3\\nline4\\nline5\";\n        let (lines, total) = extract_lines_around(content, 3, 1);\n        assert_eq!(total, 5);\n        assert_eq!(lines.len(), 3);\n        assert_eq!(lines[0], (2, \"line2\".to_string()));\n        assert_eq!(lines[1], (3, \"line3\".to_string()));\n        assert_eq!(lines[2], (4, \"line4\".to_string()));\n    }\n\n    #[test]\n    fn extract_at_start() {\n        let content = \"line1\\nline2\\nline3\\nline4\\nline5\";\n        let (lines, _) = extract_lines_around(content, 1, 2);\n        assert_eq!(lines.len(), 3);\n        assert_eq!(lines[0], (1, \"line1\".to_string()));\n    }\n\n    #[test]\n    fn extract_at_end() {\n        let content = \"line1\\nline2\\nline3\\nline4\\nline5\";\n        let (lines, _) = extract_lines_around(content, 5, 2);\n        assert_eq!(lines.len(), 3);\n        assert_eq!(lines[2], (5, \"line5\".to_string()));\n    }\n\n    #[test]\n    fn extract_beyond_bounds() {\n        let content = \"line1\\nline2\\nline3\";\n        let (lines, _) = extract_lines_around(content, 2, 10);\n        assert_eq!(lines.len(), 3);\n    }\n\n    #[test]\n    fn extract_empty_content() {\n        let (lines, total) = extract_lines_around(\"\", 1, 5);\n        assert!(lines.is_empty());\n        assert_eq!(total, 0);\n    }\n\n    #[test]\n    fn extract_zero_center() {\n        let content = \"line1\\nline2\";\n        let (lines, _) = extract_lines_around(content, 0, 5);\n        assert!(lines.is_empty());\n    }\n\n    #[test]\n    fn extract_zero_context() {\n        let content = \"line1\\nline2\\nline3\";\n        let (lines, _) = extract_lines_around(content, 2, 0);\n        assert_eq!(lines.len(), 1);\n        assert_eq!(lines[0], (2, \"line2\".to_string()));\n    }\n\n    #[test]\n    fn extract_single_line() {\n        let content = \"only line\";\n        let (lines, total) = extract_lines_around(content, 1, 5);\n        assert_eq!(lines.len(), 1);\n        assert_eq!(total, 1);\n    }\n\n    #[test]\n    fn format_basic() {\n        let lines = vec![\n            (9, \"line9\".to_string()),\n            (10, \"line10\".to_string()),\n            (11, \"line11\".to_string()),\n        ];\n        let output = format_lines_around(\u0026lines, 10, 11);\n        assert!(output.contains(\"\u003e10: line10\"));\n        assert!(output.contains(\" 9: line9\"));\n        assert!(output.contains(\"11: line11\"));\n    }\n\n    #[test]\n    fn format_empty() {\n        let lines: Vec\u003c(usize, String)\u003e = vec![];\n        let output = format_lines_around(\u0026lines, 1, 0);\n        assert_eq!(output, \"No content\");\n    }\n\n    #[test]\n    fn format_line_numbers_aligned() {\n        let lines = vec![\n            (1, \"first\".to_string()),\n            (10, \"tenth\".to_string()),\n            (100, \"hundredth\".to_string()),\n        ];\n        let output = format_lines_around(\u0026lines, 10, 100);\n        // All line numbers should be right-aligned with same width\n        let output_lines: Vec\u003c\u0026str\u003e = output.lines().collect();\n        assert!(output_lines[0].starts_with(\"   1:\"));\n        assert!(output_lines[1].starts_with(\"\u003e 10:\"));\n        assert!(output_lines[2].starts_with(\" 100:\"));\n    }\n\n    #[test]\n    fn format_preserves_content() {\n        let lines = vec![\n            (1, \"  indented content\".to_string()),\n            (2, \"normal\".to_string()),\n        ];\n        let output = format_lines_around(\u0026lines, 1, 10);\n        assert!(output.contains(\"  indented content\"));\n    }\n}\n","traces":[{"line":2,"address":[],"length":0,"stats":{"Line":9}},{"line":7,"address":[],"length":0,"stats":{"Line":45}},{"line":8,"address":[],"length":0,"stats":{"Line":27}},{"line":10,"address":[],"length":0,"stats":{"Line":17}},{"line":11,"address":[],"length":0,"stats":{"Line":2}},{"line":15,"address":[],"length":0,"stats":{"Line":21}},{"line":18,"address":[],"length":0,"stats":{"Line":28}},{"line":19,"address":[],"length":0,"stats":{"Line":28}},{"line":21,"address":[],"length":0,"stats":{"Line":28}},{"line":24,"address":[],"length":0,"stats":{"Line":70}},{"line":27,"address":[],"length":0,"stats":{"Line":7}},{"line":31,"address":[],"length":0,"stats":{"Line":5}},{"line":32,"address":[],"length":0,"stats":{"Line":10}},{"line":33,"address":[],"length":0,"stats":{"Line":2}},{"line":36,"address":[],"length":0,"stats":{"Line":12}},{"line":37,"address":[],"length":0,"stats":{"Line":8}},{"line":39,"address":[],"length":0,"stats":{"Line":37}},{"line":40,"address":[],"length":0,"stats":{"Line":33}},{"line":41,"address":[],"length":0,"stats":{"Line":33}},{"line":42,"address":[],"length":0,"stats":{"Line":11}},{"line":50,"address":[],"length":0,"stats":{"Line":8}}],"covered":21,"coverable":21},{"path":["/","Users","chi","Projects","hu","src","read","cli.rs"],"content":"use clap::Args;\n\n#[derive(Debug, Args)]\npub struct ReadArgs {\n    /// File path to read\n    pub path: String,\n\n    /// Show file outline (functions, structs, classes)\n    #[arg(long, short = 'o')]\n    pub outline: bool,\n\n    /// Show public interface only (pub items in Rust, exports in JS)\n    #[arg(long, short = 'i')]\n    pub interface: bool,\n\n    /// Show lines around a specific line number\n    #[arg(long, short = 'a', value_name = \"LINE\")]\n    pub around: Option\u003cusize\u003e,\n\n    /// Number of context lines for --around (default: 10)\n    #[arg(long, short = 'n', default_value = \"10\")]\n    pub context: usize,\n\n    /// Show git diff\n    #[arg(long, short = 'd')]\n    pub diff: bool,\n\n    /// Commit to diff against (default: HEAD)\n    #[arg(long, default_value = \"HEAD\")]\n    pub commit: String,\n}\n\nimpl ReadArgs {\n    /// Check if any mode is active (outline, interface, around, diff)\n    #[cfg(test)]\n    pub fn has_mode(\u0026self) -\u003e bool {\n        self.outline || self.interface || self.around.is_some() || self.diff\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use clap::Parser;\n\n    #[derive(Parser)]\n    struct TestCli {\n        #[command(flatten)]\n        read: ReadArgs,\n    }\n\n    #[test]\n    fn parse_path_only() {\n        let cli = TestCli::try_parse_from([\"test\", \"file.rs\"]).unwrap();\n        assert_eq!(cli.read.path, \"file.rs\");\n        assert!(!cli.read.outline);\n        assert!(!cli.read.interface);\n        assert!(cli.read.around.is_none());\n        assert!(!cli.read.diff);\n    }\n\n    #[test]\n    fn parse_outline_long() {\n        let cli = TestCli::try_parse_from([\"test\", \"--outline\", \"file.rs\"]).unwrap();\n        assert!(cli.read.outline);\n    }\n\n    #[test]\n    fn parse_outline_short() {\n        let cli = TestCli::try_parse_from([\"test\", \"-o\", \"file.rs\"]).unwrap();\n        assert!(cli.read.outline);\n    }\n\n    #[test]\n    fn parse_interface_long() {\n        let cli = TestCli::try_parse_from([\"test\", \"--interface\", \"file.rs\"]).unwrap();\n        assert!(cli.read.interface);\n    }\n\n    #[test]\n    fn parse_interface_short() {\n        let cli = TestCli::try_parse_from([\"test\", \"-i\", \"file.rs\"]).unwrap();\n        assert!(cli.read.interface);\n    }\n\n    #[test]\n    fn parse_around_long() {\n        let cli = TestCli::try_parse_from([\"test\", \"--around\", \"50\", \"file.rs\"]).unwrap();\n        assert_eq!(cli.read.around, Some(50));\n    }\n\n    #[test]\n    fn parse_around_short() {\n        let cli = TestCli::try_parse_from([\"test\", \"-a\", \"100\", \"file.rs\"]).unwrap();\n        assert_eq!(cli.read.around, Some(100));\n    }\n\n    #[test]\n    fn parse_context_long() {\n        let cli = TestCli::try_parse_from([\"test\", \"-a\", \"50\", \"-n\", \"20\", \"file.rs\"]).unwrap();\n        assert_eq!(cli.read.context, 20);\n    }\n\n    #[test]\n    fn parse_context_default() {\n        let cli = TestCli::try_parse_from([\"test\", \"file.rs\"]).unwrap();\n        assert_eq!(cli.read.context, 10);\n    }\n\n    #[test]\n    fn parse_diff_flag() {\n        let cli = TestCli::try_parse_from([\"test\", \"--diff\", \"file.rs\"]).unwrap();\n        assert!(cli.read.diff);\n        assert_eq!(cli.read.commit, \"HEAD\");\n    }\n\n    #[test]\n    fn parse_diff_with_commit() {\n        let cli =\n            TestCli::try_parse_from([\"test\", \"--diff\", \"--commit\", \"HEAD~1\", \"file.rs\"]).unwrap();\n        assert!(cli.read.diff);\n        assert_eq!(cli.read.commit, \"HEAD~1\");\n    }\n\n    #[test]\n    fn has_mode_none() {\n        let cli = TestCli::try_parse_from([\"test\", \"file.rs\"]).unwrap();\n        assert!(!cli.read.has_mode());\n    }\n\n    #[test]\n    fn has_mode_outline() {\n        let cli = TestCli::try_parse_from([\"test\", \"-o\", \"file.rs\"]).unwrap();\n        assert!(cli.read.has_mode());\n    }\n\n    #[test]\n    fn has_mode_interface() {\n        let cli = TestCli::try_parse_from([\"test\", \"-i\", \"file.rs\"]).unwrap();\n        assert!(cli.read.has_mode());\n    }\n\n    #[test]\n    fn has_mode_around() {\n        let cli = TestCli::try_parse_from([\"test\", \"-a\", \"50\", \"file.rs\"]).unwrap();\n        assert!(cli.read.has_mode());\n    }\n\n    #[test]\n    fn has_mode_diff() {\n        let cli = TestCli::try_parse_from([\"test\", \"-d\", \"file.rs\"]).unwrap();\n        assert!(cli.read.has_mode());\n    }\n\n    #[test]\n    fn read_args_debug() {\n        let cli = TestCli::try_parse_from([\"test\", \"file.rs\"]).unwrap();\n        let debug = format!(\"{:?}\", cli.read);\n        assert!(debug.contains(\"ReadArgs\"));\n    }\n\n    #[test]\n    fn path_required() {\n        let result = TestCli::try_parse_from([\"test\"]);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn combined_flags() {\n        let cli = TestCli::try_parse_from([\"test\", \"-o\", \"-i\", \"-a\", \"50\", \"-n\", \"5\", \"file.rs\"])\n            .unwrap();\n        assert!(cli.read.outline);\n        assert!(cli.read.interface);\n        assert_eq!(cli.read.around, Some(50));\n        assert_eq!(cli.read.context, 5);\n    }\n}\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":5}},{"line":37,"address":[],"length":0,"stats":{"Line":17}}],"covered":2,"coverable":2},{"path":["/","Users","chi","Projects","hu","src","read","diff.rs"],"content":"use anyhow::{Context, Result};\nuse std::path::Path;\nuse std::process::Command;\n\n/// Get git diff for a file against a commit\npub fn git_diff(path: \u0026str, commit: Option\u003c\u0026str\u003e) -\u003e Result\u003cString\u003e {\n    let commit_ref = commit.unwrap_or(\"HEAD\");\n\n    // Verify file exists\n    let path = Path::new(path);\n    if !path.exists() {\n        anyhow::bail!(\"File not found: {}\", path.display());\n    }\n\n    // Run git diff\n    let output = Command::new(\"git\")\n        .args([\"diff\", commit_ref, \"--\", path.to_str().unwrap_or(\"\")])\n        .output()\n        .context(\"Failed to run git diff\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"git diff failed: {}\", stderr);\n    }\n\n    let diff = String::from_utf8_lossy(\u0026output.stdout).to_string();\n\n    if diff.is_empty() {\n        return Ok(\"No changes\".to_string());\n    }\n\n    Ok(diff)\n}\n\n/// Format diff output with colors\npub fn format_diff(diff: \u0026str) -\u003e String {\n    if diff == \"No changes\" {\n        return diff.to_string();\n    }\n\n    let mut output = Vec::new();\n\n    for line in diff.lines() {\n        if line.starts_with('+') \u0026\u0026 !line.starts_with(\"+++\") {\n            // Added line - green\n            output.push(format!(\"\\x1b[32m{}\\x1b[0m\", line));\n        } else if line.starts_with('-') \u0026\u0026 !line.starts_with(\"---\") {\n            // Removed line - red\n            output.push(format!(\"\\x1b[31m{}\\x1b[0m\", line));\n        } else if line.starts_with(\"@@\") {\n            // Hunk header - cyan\n            output.push(format!(\"\\x1b[36m{}\\x1b[0m\", line));\n        } else if line.starts_with(\"diff\") || line.starts_with(\"index\") {\n            // Header - dim\n            output.push(format!(\"\\x1b[2m{}\\x1b[0m\", line));\n        } else {\n            output.push(line.to_string());\n        }\n    }\n\n    output.join(\"\\n\")\n}\n\n/// Parse diff to extract changed line ranges\n#[cfg(test)]\npub fn parse_diff_hunks(diff: \u0026str) -\u003e Vec\u003cDiffHunk\u003e {\n    let mut hunks = Vec::new();\n    let hunk_re = regex::Regex::new(r\"@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@\").unwrap();\n\n    for caps in hunk_re.captures_iter(diff) {\n        let old_start: usize = caps.get(1).unwrap().as_str().parse().unwrap_or(0);\n        let old_count: usize = caps\n            .get(2)\n            .map(|m| m.as_str().parse().unwrap_or(1))\n            .unwrap_or(1);\n        let new_start: usize = caps.get(3).unwrap().as_str().parse().unwrap_or(0);\n        let new_count: usize = caps\n            .get(4)\n            .map(|m| m.as_str().parse().unwrap_or(1))\n            .unwrap_or(1);\n\n        hunks.push(DiffHunk {\n            old_start,\n            old_count,\n            new_start,\n            new_count,\n        });\n    }\n\n    hunks\n}\n\n/// A diff hunk (changed section)\n#[cfg(test)]\n#[derive(Debug, Clone, PartialEq)]\npub struct DiffHunk {\n    pub old_start: usize,\n    pub old_count: usize,\n    pub new_start: usize,\n    pub new_count: usize,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn format_diff_additions() {\n        let diff = \"+added line\";\n        let formatted = format_diff(diff);\n        assert!(formatted.contains(\"\\x1b[32m\"));\n        assert!(formatted.contains(\"+added line\"));\n    }\n\n    #[test]\n    fn format_diff_deletions() {\n        let diff = \"-removed line\";\n        let formatted = format_diff(diff);\n        assert!(formatted.contains(\"\\x1b[31m\"));\n        assert!(formatted.contains(\"-removed line\"));\n    }\n\n    #[test]\n    fn format_diff_hunk_header() {\n        let diff = \"@@ -1,3 +1,4 @@\";\n        let formatted = format_diff(diff);\n        assert!(formatted.contains(\"\\x1b[36m\"));\n    }\n\n    #[test]\n    fn format_diff_file_header() {\n        let diff = \"diff --git a/file.rs b/file.rs\";\n        let formatted = format_diff(diff);\n        assert!(formatted.contains(\"\\x1b[2m\"));\n    }\n\n    #[test]\n    fn format_diff_no_changes() {\n        let formatted = format_diff(\"No changes\");\n        assert_eq!(formatted, \"No changes\");\n    }\n\n    #[test]\n    fn format_diff_preserves_context() {\n        let diff = \" unchanged line\";\n        let formatted = format_diff(diff);\n        assert_eq!(formatted, \" unchanged line\");\n    }\n\n    #[test]\n    fn format_diff_plus_header_not_green() {\n        let diff = \"+++ b/file.rs\";\n        let formatted = format_diff(diff);\n        // Should not have green color code\n        assert!(!formatted.contains(\"\\x1b[32m\"));\n    }\n\n    #[test]\n    fn format_diff_minus_header_not_red() {\n        let diff = \"--- a/file.rs\";\n        let formatted = format_diff(diff);\n        // Should not have red color code\n        assert!(!formatted.contains(\"\\x1b[31m\"));\n    }\n\n    #[test]\n    fn parse_diff_hunks_single() {\n        let diff = \"@@ -1,3 +1,4 @@\";\n        let hunks = parse_diff_hunks(diff);\n        assert_eq!(hunks.len(), 1);\n        assert_eq!(hunks[0].old_start, 1);\n        assert_eq!(hunks[0].old_count, 3);\n        assert_eq!(hunks[0].new_start, 1);\n        assert_eq!(hunks[0].new_count, 4);\n    }\n\n    #[test]\n    fn parse_diff_hunks_multiple() {\n        let diff = \"@@ -1,3 +1,4 @@\\nsome content\\n@@ -10,5 +11,6 @@\";\n        let hunks = parse_diff_hunks(diff);\n        assert_eq!(hunks.len(), 2);\n        assert_eq!(hunks[1].old_start, 10);\n        assert_eq!(hunks[1].new_start, 11);\n    }\n\n    #[test]\n    fn parse_diff_hunks_no_count() {\n        let diff = \"@@ -5 +5 @@\";\n        let hunks = parse_diff_hunks(diff);\n        assert_eq!(hunks.len(), 1);\n        assert_eq!(hunks[0].old_count, 1);\n        assert_eq!(hunks[0].new_count, 1);\n    }\n\n    #[test]\n    fn parse_diff_hunks_empty() {\n        let diff = \"no hunks here\";\n        let hunks = parse_diff_hunks(diff);\n        assert!(hunks.is_empty());\n    }\n\n    #[test]\n    fn diff_hunk_clone() {\n        let hunk = DiffHunk {\n            old_start: 1,\n            old_count: 2,\n            new_start: 3,\n            new_count: 4,\n        };\n        let cloned = hunk.clone();\n        assert_eq!(hunk, cloned);\n    }\n\n    #[test]\n    fn diff_hunk_debug() {\n        let hunk = DiffHunk {\n            old_start: 1,\n            old_count: 2,\n            new_start: 3,\n            new_count: 4,\n        };\n        let debug = format!(\"{:?}\", hunk);\n        assert!(debug.contains(\"DiffHunk\"));\n    }\n\n    // Integration test - requires git repo\n    #[test]\n    fn git_diff_cargo_toml() {\n        // This test uses Cargo.toml which should exist in a git repo\n        let result = git_diff(\n            concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/Cargo.toml\"),\n            Some(\"HEAD\"),\n        );\n        // Either succeeds with diff or \"No changes\"\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn git_diff_nonexistent_file() {\n        let result = git_diff(\"/nonexistent/file.txt\", None);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn git_diff_invalid_commit() {\n        // Using an invalid commit reference should cause git diff to fail\n        let result = git_diff(\n            concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/Cargo.toml\"),\n            Some(\"invalid_commit_ref_that_does_not_exist_xyz123\"),\n        );\n        assert!(result.is_err());\n        let err = result.unwrap_err().to_string();\n        assert!(err.contains(\"git diff failed\"));\n    }\n\n    #[test]\n    fn format_diff_index_header() {\n        let diff = \"index abc123..def456 100644\";\n        let formatted = format_diff(diff);\n        // Should have dim color\n        assert!(formatted.contains(\"\\x1b[2m\"));\n    }\n\n    #[test]\n    fn git_diff_with_actual_changes() {\n        // Compare src/main.rs against an older commit to ensure we get actual diff output\n        // This tests the Ok(diff) return path (line 32) when diff is non-empty\n        let result = git_diff(\n            concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/src/main.rs\"),\n            Some(\"HEAD~20\"), // src/main.rs changes frequently\n        );\n\n        // This test is designed to exercise the non-empty diff return path\n        match result {\n            Ok(diff) =\u003e {\n                // Either \"No changes\" or actual diff content\n                if diff != \"No changes\" {\n                    assert!(\n                        diff.contains(\"diff\") || diff.contains(\"@@\"),\n                        \"Expected diff content but got: {}\",\n                        diff\n                    );\n                }\n            }\n            Err(_) =\u003e {\n                // If not enough history, skip silently - this is CI-friendly\n            }\n        }\n    }\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":6}},{"line":7,"address":[],"length":0,"stats":{"Line":24}},{"line":10,"address":[],"length":0,"stats":{"Line":18}},{"line":11,"address":[],"length":0,"stats":{"Line":6}},{"line":12,"address":[],"length":0,"stats":{"Line":4}},{"line":16,"address":[],"length":0,"stats":{"Line":15}},{"line":17,"address":[],"length":0,"stats":{"Line":30}},{"line":21,"address":[],"length":0,"stats":{"Line":5}},{"line":22,"address":[],"length":0,"stats":{"Line":3}},{"line":23,"address":[],"length":0,"stats":{"Line":2}},{"line":26,"address":[],"length":0,"stats":{"Line":12}},{"line":28,"address":[],"length":0,"stats":{"Line":8}},{"line":29,"address":[],"length":0,"stats":{"Line":4}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":11}},{"line":37,"address":[],"length":0,"stats":{"Line":11}},{"line":38,"address":[],"length":0,"stats":{"Line":4}},{"line":41,"address":[],"length":0,"stats":{"Line":18}},{"line":43,"address":[],"length":0,"stats":{"Line":27}},{"line":44,"address":[],"length":0,"stats":{"Line":23}},{"line":46,"address":[],"length":0,"stats":{"Line":6}},{"line":47,"address":[],"length":0,"stats":{"Line":19}},{"line":49,"address":[],"length":0,"stats":{"Line":3}},{"line":50,"address":[],"length":0,"stats":{"Line":14}},{"line":52,"address":[],"length":0,"stats":{"Line":3}},{"line":53,"address":[],"length":0,"stats":{"Line":21}},{"line":55,"address":[],"length":0,"stats":{"Line":6}},{"line":57,"address":[],"length":0,"stats":{"Line":9}},{"line":61,"address":[],"length":0,"stats":{"Line":18}},{"line":66,"address":[],"length":0,"stats":{"Line":4}},{"line":67,"address":[],"length":0,"stats":{"Line":8}},{"line":68,"address":[],"length":0,"stats":{"Line":16}},{"line":70,"address":[],"length":0,"stats":{"Line":16}},{"line":71,"address":[],"length":0,"stats":{"Line":24}},{"line":72,"address":[],"length":0,"stats":{"Line":12}},{"line":74,"address":[],"length":0,"stats":{"Line":13}},{"line":76,"address":[],"length":0,"stats":{"Line":24}},{"line":77,"address":[],"length":0,"stats":{"Line":12}},{"line":79,"address":[],"length":0,"stats":{"Line":13}},{"line":82,"address":[],"length":0,"stats":{"Line":12}},{"line":83,"address":[],"length":0,"stats":{"Line":8}},{"line":84,"address":[],"length":0,"stats":{"Line":8}},{"line":85,"address":[],"length":0,"stats":{"Line":4}},{"line":86,"address":[],"length":0,"stats":{"Line":4}},{"line":90,"address":[],"length":0,"stats":{"Line":4}}],"covered":44,"coverable":45},{"path":["/","Users","chi","Projects","hu","src","read","display.rs"],"content":"//! Display formatting for read output (CLI-only)\n\nuse super::around::format_lines_around;\nuse super::diff::format_diff;\nuse super::types::{FileOutline, OutlineItem, ReadOutput};\n\n/// Format ReadOutput for CLI display\npub fn format(output: \u0026ReadOutput) -\u003e String {\n    match output {\n        ReadOutput::Full(content) =\u003e content.clone(),\n        ReadOutput::Outline(outline) =\u003e format_outline(outline),\n        ReadOutput::Interface(items) =\u003e format_interface(items),\n        ReadOutput::Around {\n            lines,\n            center,\n            total_lines,\n        } =\u003e format_lines_around(lines, *center, *total_lines),\n        ReadOutput::Diff(diff) =\u003e format_diff(diff),\n    }\n}\n\n/// Format outline for display\nfn format_outline(outline: \u0026FileOutline) -\u003e String {\n    if outline.is_empty() {\n        return \"No outline items found\".to_string();\n    }\n\n    let mut output = Vec::new();\n\n    for item in \u0026outline.items {\n        let indent = \"  \".repeat(item.level);\n        let icon = item.kind.icon();\n        let line_info = format!(\":{}\", item.line);\n        output.push(format!(\"{}{} {}{}\", indent, icon, item.text, line_info));\n    }\n\n    output.join(\"\\n\")\n}\n\n/// Format interface for display\nfn format_interface(items: \u0026[OutlineItem]) -\u003e String {\n    if items.is_empty() {\n        return \"No public interface items found\".to_string();\n    }\n\n    let mut output = Vec::new();\n\n    for item in items {\n        let indent = \"  \".repeat(item.level);\n        let icon = item.kind.icon();\n        output.push(format!(\"{}{} {} :L{}\", indent, icon, item.text, item.line));\n    }\n\n    output.join(\"\\n\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::read::types::ItemKind;\n\n    #[test]\n    fn format_full_content() {\n        let output = ReadOutput::Full(\"hello\\nworld\".to_string());\n        let formatted = format(\u0026output);\n        assert_eq!(formatted, \"hello\\nworld\");\n    }\n\n    #[test]\n    fn format_empty_outline() {\n        let output = ReadOutput::Outline(FileOutline::new());\n        let formatted = format(\u0026output);\n        assert_eq!(formatted, \"No outline items found\");\n    }\n\n    #[test]\n    fn format_outline_with_items() {\n        let mut outline = FileOutline::new();\n        outline.push(OutlineItem::new(\n            10,\n            \"pub fn test()\".to_string(),\n            0,\n            ItemKind::Function,\n        ));\n        let output = ReadOutput::Outline(outline);\n        let formatted = format(\u0026output);\n        assert!(formatted.contains(\"fn pub fn test()\"));\n        assert!(formatted.contains(\":10\"));\n    }\n\n    #[test]\n    fn format_nested_outline() {\n        let mut outline = FileOutline::new();\n        outline.push(OutlineItem::new(\n            1,\n            \"impl Config\".to_string(),\n            0,\n            ItemKind::Impl,\n        ));\n        outline.push(OutlineItem::new(\n            2,\n            \"pub fn new()\".to_string(),\n            1,\n            ItemKind::Function,\n        ));\n        let output = ReadOutput::Outline(outline);\n        let formatted = format(\u0026output);\n        let lines: Vec\u003c\u0026str\u003e = formatted.lines().collect();\n        assert!(lines[0].starts_with(\"impl\"));\n        assert!(lines[1].starts_with(\"  fn\")); // Indented\n    }\n\n    #[test]\n    fn format_empty_interface() {\n        let output = ReadOutput::Interface(vec![]);\n        let formatted = format(\u0026output);\n        assert_eq!(formatted, \"No public interface items found\");\n    }\n\n    #[test]\n    fn format_interface_with_items() {\n        let items = vec![OutlineItem::new(\n            10,\n            \"pub fn test()\".to_string(),\n            0,\n            ItemKind::Function,\n        )];\n        let output = ReadOutput::Interface(items);\n        let formatted = format(\u0026output);\n        assert!(formatted.contains(\"fn pub fn test()\"));\n        assert!(formatted.contains(\":L10\"));\n    }\n\n    #[test]\n    fn format_around_lines() {\n        let output = ReadOutput::Around {\n            lines: vec![\n                (9, \"line9\".to_string()),\n                (10, \"line10\".to_string()),\n                (11, \"line11\".to_string()),\n            ],\n            center: 10,\n            total_lines: 11, // width is 2, so format is \"\u003e10: line10\"\n        };\n        let formatted = format(\u0026output);\n        assert!(formatted.contains(\"\u003e10: line10\"));\n        assert!(formatted.contains(\" 9: line9\"));\n    }\n\n    #[test]\n    fn format_diff_content() {\n        let output = ReadOutput::Diff(\"+added line\".to_string());\n        let formatted = format(\u0026output);\n        assert!(formatted.contains(\"+added line\"));\n        // Should have green color for additions\n        assert!(formatted.contains(\"\\x1b[32m\"));\n    }\n\n    #[test]\n    fn format_diff_no_changes() {\n        let output = ReadOutput::Diff(\"No changes\".to_string());\n        let formatted = format(\u0026output);\n        assert_eq!(formatted, \"No changes\");\n    }\n}\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":9}},{"line":9,"address":[],"length":0,"stats":{"Line":9}},{"line":10,"address":[],"length":0,"stats":{"Line":3}},{"line":11,"address":[],"length":0,"stats":{"Line":9}},{"line":12,"address":[],"length":0,"stats":{"Line":6}},{"line":14,"address":[],"length":0,"stats":{"Line":1}},{"line":15,"address":[],"length":0,"stats":{"Line":1}},{"line":16,"address":[],"length":0,"stats":{"Line":1}},{"line":17,"address":[],"length":0,"stats":{"Line":4}},{"line":18,"address":[],"length":0,"stats":{"Line":6}},{"line":23,"address":[],"length":0,"stats":{"Line":3}},{"line":24,"address":[],"length":0,"stats":{"Line":6}},{"line":25,"address":[],"length":0,"stats":{"Line":2}},{"line":28,"address":[],"length":0,"stats":{"Line":4}},{"line":30,"address":[],"length":0,"stats":{"Line":11}},{"line":31,"address":[],"length":0,"stats":{"Line":15}},{"line":32,"address":[],"length":0,"stats":{"Line":12}},{"line":33,"address":[],"length":0,"stats":{"Line":12}},{"line":34,"address":[],"length":0,"stats":{"Line":9}},{"line":37,"address":[],"length":0,"stats":{"Line":4}},{"line":41,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":4}},{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":48,"address":[],"length":0,"stats":{"Line":4}},{"line":49,"address":[],"length":0,"stats":{"Line":5}},{"line":50,"address":[],"length":0,"stats":{"Line":4}},{"line":51,"address":[],"length":0,"stats":{"Line":3}},{"line":54,"address":[],"length":0,"stats":{"Line":2}}],"covered":29,"coverable":29},{"path":["/","Users","chi","Projects","hu","src","read","interface","mod.rs"],"content":"use regex::Regex;\nuse std::path::Path;\n\nuse super::types::{ItemKind, OutlineItem};\n\n#[cfg(test)]\nmod tests;\n\n/// Extract public interface from file content\npub fn extract_interface(content: \u0026str, path: \u0026str) -\u003e Vec\u003cOutlineItem\u003e {\n    let ext = Path::new(path)\n        .extension()\n        .and_then(|e| e.to_str())\n        .unwrap_or(\"\");\n\n    match ext {\n        \"rs\" =\u003e extract_rust_interface(content),\n        \"py\" =\u003e extract_python_interface(content),\n        \"js\" | \"ts\" | \"jsx\" | \"tsx\" | \"mjs\" =\u003e extract_js_interface(content),\n        \"rb\" =\u003e extract_ruby_interface(content),\n        \"go\" =\u003e extract_go_interface(content),\n        _ =\u003e vec![],\n    }\n}\n\n/// Extract Rust public interface (pub items only)\nfn extract_rust_interface(content: \u0026str) -\u003e Vec\u003cOutlineItem\u003e {\n    let mut items = Vec::new();\n\n    let pub_fn_re =\n        Regex::new(r\"^(\\s*)pub\\s+(async\\s+)?fn\\s+(\\w+)\\s*(\u003c[^\u003e]+\u003e)?\\s*\\([^)]*\\)(\\s*-\u003e\\s*[^{]+)?\")\n            .unwrap();\n    let pub_struct_re = Regex::new(r\"^(\\s*)pub\\s+struct\\s+(\\w+)(\u003c[^\u003e]+\u003e)?\").unwrap();\n    let pub_enum_re = Regex::new(r\"^(\\s*)pub\\s+enum\\s+(\\w+)(\u003c[^\u003e]+\u003e)?\").unwrap();\n    let pub_trait_re = Regex::new(r\"^(\\s*)pub\\s+trait\\s+(\\w+)(\u003c[^\u003e]+\u003e)?\").unwrap();\n    let pub_const_re = Regex::new(r\"^(\\s*)pub\\s+const\\s+(\\w+)\").unwrap();\n    let pub_type_re = Regex::new(r\"^(\\s*)pub\\s+type\\s+(\\w+)\").unwrap();\n    let pub_mod_re = Regex::new(r\"^(\\s*)pub\\s+mod\\s+(\\w+)\").unwrap();\n\n    for (line_num, line) in content.lines().enumerate() {\n        let line_num = line_num + 1;\n\n        if let Some(caps) = pub_fn_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim_end_matches('{').trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 4,\n                ItemKind::Function,\n            ));\n        } else if let Some(caps) = pub_struct_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 4,\n                ItemKind::Struct,\n            ));\n        } else if let Some(caps) = pub_enum_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 4,\n                ItemKind::Enum,\n            ));\n        } else if let Some(caps) = pub_trait_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 4,\n                ItemKind::Trait,\n            ));\n        } else if let Some(caps) = pub_const_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 4,\n                ItemKind::Const,\n            ));\n        } else if let Some(caps) = pub_type_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 4,\n                ItemKind::Type,\n            ));\n        } else if let Some(caps) = pub_mod_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 4,\n                ItemKind::Module,\n            ));\n        }\n    }\n\n    items\n}\n\n/// Extract Python public interface (exclude _private items)\nfn extract_python_interface(content: \u0026str) -\u003e Vec\u003cOutlineItem\u003e {\n    let mut items = Vec::new();\n\n    let def_re = Regex::new(r\"^(\\s*)(async\\s+)?def\\s+(\\w+)\\s*\\([^)]*\\)(\\s*-\u003e\\s*[^:]+)?\").unwrap();\n    let class_re = Regex::new(r\"^(\\s*)class\\s+(\\w+)(\\([^)]*\\))?\").unwrap();\n\n    for (line_num, line) in content.lines().enumerate() {\n        let line_num = line_num + 1;\n\n        if let Some(caps) = def_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let name = caps.get(3).map_or(\"\", |m| m.as_str());\n\n            // Skip private functions (leading underscore) at top level\n            if indent == 0 \u0026\u0026 name.starts_with('_') \u0026\u0026 !name.starts_with(\"__\") {\n                continue;\n            }\n\n            // Skip methods (indented)\n            if indent \u003e 0 {\n                continue;\n            }\n\n            let sig = caps.get(0).unwrap().as_str().trim_end_matches(':').trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                0,\n                ItemKind::Function,\n            ));\n        } else if let Some(caps) = class_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let name = caps.get(2).map_or(\"\", |m| m.as_str());\n\n            // Skip private classes\n            if name.starts_with('_') \u0026\u0026 !name.starts_with(\"__\") {\n                continue;\n            }\n\n            // Skip nested classes\n            if indent \u003e 0 {\n                continue;\n            }\n\n            let sig = caps.get(0).unwrap().as_str().trim_end_matches(':').trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                0,\n                ItemKind::Class,\n            ));\n        }\n    }\n\n    items\n}\n\n/// Extract JavaScript/TypeScript public interface (exports only)\nfn extract_js_interface(content: \u0026str) -\u003e Vec\u003cOutlineItem\u003e {\n    let mut items = Vec::new();\n\n    let export_fn_re =\n        Regex::new(r\"^(\\s*)export\\s+(async\\s+)?function\\s+(\\w+)\\s*(\u003c[^\u003e]+\u003e)?\\s*\\([^)]*\\)\").unwrap();\n    let export_const_re =\n        Regex::new(r\"^(\\s*)export\\s+(const|let|var)\\s+(\\w+)\\s*=\\s*(async\\s+)?\\([^)]*\\)\\s*=\u003e\")\n            .unwrap();\n    let export_class_re = Regex::new(r\"^(\\s*)export\\s+class\\s+(\\w+)(\\s+extends\\s+\\w+)?\").unwrap();\n    let export_default_re =\n        Regex::new(r\"^(\\s*)export\\s+default\\s+(class|function)?\\s*(\\w+)?\").unwrap();\n\n    for (line_num, line) in content.lines().enumerate() {\n        let line_num = line_num + 1;\n\n        if let Some(caps) = export_fn_re.captures(line) {\n            let sig = caps.get(0).unwrap().as_str().trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                0,\n                ItemKind::Function,\n            ));\n        } else if let Some(caps) = export_const_re.captures(line) {\n            let sig = caps.get(0).unwrap().as_str().trim_end_matches(\"=\u003e\").trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                0,\n                ItemKind::Function,\n            ));\n        } else if let Some(caps) = export_class_re.captures(line) {\n            let sig = caps.get(0).unwrap().as_str().trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                0,\n                ItemKind::Class,\n            ));\n        } else if let Some(caps) = export_default_re.captures(line) {\n            let sig = caps.get(0).unwrap().as_str().trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                0,\n                ItemKind::Other,\n            ));\n        }\n    }\n\n    items\n}\n\n/// Extract Ruby public interface (exclude private methods)\nfn extract_ruby_interface(content: \u0026str) -\u003e Vec\u003cOutlineItem\u003e {\n    let mut items = Vec::new();\n    let mut in_private = false;\n\n    let def_re = Regex::new(r\"^(\\s*)def\\s+(\\w+[?!=]?)(\\([^)]*\\))?\").unwrap();\n    let class_re = Regex::new(r\"^(\\s*)class\\s+(\\w+)(\\s*\u003c\\s*\\w+)?\").unwrap();\n    let module_re = Regex::new(r\"^(\\s*)module\\s+(\\w+)\").unwrap();\n    let private_re = Regex::new(r\"^\\s*private\\s*$\").unwrap();\n    let public_re = Regex::new(r\"^\\s*public\\s*$\").unwrap();\n\n    for (line_num, line) in content.lines().enumerate() {\n        let line_num = line_num + 1;\n\n        // Track private/public sections\n        if private_re.is_match(line) {\n            in_private = true;\n            continue;\n        }\n        if public_re.is_match(line) {\n            in_private = false;\n            continue;\n        }\n\n        // Reset private flag on new class/module\n        if class_re.is_match(line) || module_re.is_match(line) {\n            in_private = false;\n        }\n\n        if let Some(caps) = def_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n\n            // Skip private methods\n            if in_private {\n                continue;\n            }\n\n            // Skip nested methods\n            if indent \u003e 2 {\n                continue;\n            }\n\n            let sig = caps.get(0).unwrap().as_str().trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 2,\n                ItemKind::Function,\n            ));\n        } else if let Some(caps) = class_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n\n            // Skip nested classes\n            if indent \u003e 0 {\n                continue;\n            }\n\n            let sig = caps.get(0).unwrap().as_str().trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                0,\n                ItemKind::Class,\n            ));\n        } else if let Some(caps) = module_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n\n            // Skip nested modules\n            if indent \u003e 0 {\n                continue;\n            }\n\n            let sig = caps.get(0).unwrap().as_str().trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                0,\n                ItemKind::Module,\n            ));\n        }\n    }\n\n    items\n}\n\n/// Extract Go public interface (exported items - capitalized)\nfn extract_go_interface(content: \u0026str) -\u003e Vec\u003cOutlineItem\u003e {\n    let mut items = Vec::new();\n\n    let func_re =\n        Regex::new(r\"^func\\s+(\\([^)]+\\)\\s+)?([A-Z]\\w*)\\s*\\([^)]*\\)(\\s*\\([^)]*\\)|\\s*\\w+)?\").unwrap();\n    let type_struct_re = Regex::new(r\"^type\\s+([A-Z]\\w*)\\s+struct\").unwrap();\n    let type_interface_re = Regex::new(r\"^type\\s+([A-Z]\\w*)\\s+interface\").unwrap();\n\n    for (line_num, line) in content.lines().enumerate() {\n        let line_num = line_num + 1;\n\n        if let Some(caps) = func_re.captures(line) {\n            let sig = caps.get(0).unwrap().as_str().trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                0,\n                ItemKind::Function,\n            ));\n        } else if let Some(caps) = type_struct_re.captures(line) {\n            let sig = caps.get(0).unwrap().as_str().trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                0,\n                ItemKind::Struct,\n            ));\n        } else if let Some(caps) = type_interface_re.captures(line) {\n            let sig = caps.get(0).unwrap().as_str().trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                0,\n                ItemKind::Trait,\n            ));\n        }\n    }\n\n    items\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":36}},{"line":11,"address":[],"length":0,"stats":{"Line":72}},{"line":13,"address":[],"length":0,"stats":{"Line":108}},{"line":16,"address":[],"length":0,"stats":{"Line":36}},{"line":17,"address":[],"length":0,"stats":{"Line":56}},{"line":18,"address":[],"length":0,"stats":{"Line":40}},{"line":19,"address":[],"length":0,"stats":{"Line":85}},{"line":20,"address":[],"length":0,"stats":{"Line":30}},{"line":21,"address":[],"length":0,"stats":{"Line":16}},{"line":22,"address":[],"length":0,"stats":{"Line":1}},{"line":27,"address":[],"length":0,"stats":{"Line":10}},{"line":28,"address":[],"length":0,"stats":{"Line":20}},{"line":30,"address":[],"length":0,"stats":{"Line":10}},{"line":31,"address":[],"length":0,"stats":{"Line":20}},{"line":33,"address":[],"length":0,"stats":{"Line":40}},{"line":34,"address":[],"length":0,"stats":{"Line":40}},{"line":35,"address":[],"length":0,"stats":{"Line":40}},{"line":36,"address":[],"length":0,"stats":{"Line":40}},{"line":37,"address":[],"length":0,"stats":{"Line":40}},{"line":38,"address":[],"length":0,"stats":{"Line":40}},{"line":40,"address":[],"length":0,"stats":{"Line":370}},{"line":41,"address":[],"length":0,"stats":{"Line":340}},{"line":43,"address":[],"length":0,"stats":{"Line":341}},{"line":44,"address":[],"length":0,"stats":{"Line":6}},{"line":45,"address":[],"length":0,"stats":{"Line":4}},{"line":46,"address":[],"length":0,"stats":{"Line":3}},{"line":47,"address":[],"length":0,"stats":{"Line":1}},{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":1}},{"line":50,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":339}},{"line":53,"address":[],"length":0,"stats":{"Line":6}},{"line":54,"address":[],"length":0,"stats":{"Line":4}},{"line":55,"address":[],"length":0,"stats":{"Line":3}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":1}},{"line":59,"address":[],"length":0,"stats":{"Line":1}},{"line":61,"address":[],"length":0,"stats":{"Line":337}},{"line":62,"address":[],"length":0,"stats":{"Line":6}},{"line":63,"address":[],"length":0,"stats":{"Line":4}},{"line":64,"address":[],"length":0,"stats":{"Line":3}},{"line":65,"address":[],"length":0,"stats":{"Line":1}},{"line":66,"address":[],"length":0,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":1}},{"line":68,"address":[],"length":0,"stats":{"Line":1}},{"line":70,"address":[],"length":0,"stats":{"Line":335}},{"line":71,"address":[],"length":0,"stats":{"Line":6}},{"line":72,"address":[],"length":0,"stats":{"Line":4}},{"line":73,"address":[],"length":0,"stats":{"Line":3}},{"line":74,"address":[],"length":0,"stats":{"Line":1}},{"line":75,"address":[],"length":0,"stats":{"Line":2}},{"line":76,"address":[],"length":0,"stats":{"Line":1}},{"line":77,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":333}},{"line":80,"address":[],"length":0,"stats":{"Line":6}},{"line":81,"address":[],"length":0,"stats":{"Line":4}},{"line":82,"address":[],"length":0,"stats":{"Line":3}},{"line":83,"address":[],"length":0,"stats":{"Line":1}},{"line":84,"address":[],"length":0,"stats":{"Line":2}},{"line":85,"address":[],"length":0,"stats":{"Line":1}},{"line":86,"address":[],"length":0,"stats":{"Line":1}},{"line":88,"address":[],"length":0,"stats":{"Line":331}},{"line":89,"address":[],"length":0,"stats":{"Line":6}},{"line":90,"address":[],"length":0,"stats":{"Line":4}},{"line":91,"address":[],"length":0,"stats":{"Line":3}},{"line":92,"address":[],"length":0,"stats":{"Line":1}},{"line":93,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":1}},{"line":95,"address":[],"length":0,"stats":{"Line":1}},{"line":97,"address":[],"length":0,"stats":{"Line":329}},{"line":98,"address":[],"length":0,"stats":{"Line":6}},{"line":99,"address":[],"length":0,"stats":{"Line":4}},{"line":100,"address":[],"length":0,"stats":{"Line":3}},{"line":101,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":2}},{"line":103,"address":[],"length":0,"stats":{"Line":1}},{"line":104,"address":[],"length":0,"stats":{"Line":1}},{"line":109,"address":[],"length":0,"stats":{"Line":10}},{"line":113,"address":[],"length":0,"stats":{"Line":7}},{"line":114,"address":[],"length":0,"stats":{"Line":14}},{"line":116,"address":[],"length":0,"stats":{"Line":28}},{"line":117,"address":[],"length":0,"stats":{"Line":28}},{"line":119,"address":[],"length":0,"stats":{"Line":43}},{"line":120,"address":[],"length":0,"stats":{"Line":22}},{"line":122,"address":[],"length":0,"stats":{"Line":26}},{"line":123,"address":[],"length":0,"stats":{"Line":24}},{"line":124,"address":[],"length":0,"stats":{"Line":24}},{"line":127,"address":[],"length":0,"stats":{"Line":12}},{"line":128,"address":[],"length":0,"stats":{"Line":1}},{"line":132,"address":[],"length":0,"stats":{"Line":3}},{"line":133,"address":[],"length":0,"stats":{"Line":1}},{"line":136,"address":[],"length":0,"stats":{"Line":8}},{"line":137,"address":[],"length":0,"stats":{"Line":6}},{"line":138,"address":[],"length":0,"stats":{"Line":2}},{"line":139,"address":[],"length":0,"stats":{"Line":4}},{"line":141,"address":[],"length":0,"stats":{"Line":2}},{"line":143,"address":[],"length":0,"stats":{"Line":19}},{"line":144,"address":[],"length":0,"stats":{"Line":30}},{"line":145,"address":[],"length":0,"stats":{"Line":30}},{"line":148,"address":[],"length":0,"stats":{"Line":11}},{"line":149,"address":[],"length":0,"stats":{"Line":1}},{"line":153,"address":[],"length":0,"stats":{"Line":4}},{"line":154,"address":[],"length":0,"stats":{"Line":1}},{"line":157,"address":[],"length":0,"stats":{"Line":12}},{"line":158,"address":[],"length":0,"stats":{"Line":9}},{"line":159,"address":[],"length":0,"stats":{"Line":3}},{"line":160,"address":[],"length":0,"stats":{"Line":6}},{"line":162,"address":[],"length":0,"stats":{"Line":3}},{"line":167,"address":[],"length":0,"stats":{"Line":7}},{"line":171,"address":[],"length":0,"stats":{"Line":5}},{"line":172,"address":[],"length":0,"stats":{"Line":10}},{"line":174,"address":[],"length":0,"stats":{"Line":5}},{"line":175,"address":[],"length":0,"stats":{"Line":15}},{"line":176,"address":[],"length":0,"stats":{"Line":5}},{"line":177,"address":[],"length":0,"stats":{"Line":10}},{"line":179,"address":[],"length":0,"stats":{"Line":20}},{"line":180,"address":[],"length":0,"stats":{"Line":5}},{"line":181,"address":[],"length":0,"stats":{"Line":15}},{"line":183,"address":[],"length":0,"stats":{"Line":25}},{"line":184,"address":[],"length":0,"stats":{"Line":10}},{"line":186,"address":[],"length":0,"stats":{"Line":12}},{"line":187,"address":[],"length":0,"stats":{"Line":5}},{"line":188,"address":[],"length":0,"stats":{"Line":4}},{"line":189,"address":[],"length":0,"stats":{"Line":2}},{"line":190,"address":[],"length":0,"stats":{"Line":2}},{"line":191,"address":[],"length":0,"stats":{"Line":1}},{"line":192,"address":[],"length":0,"stats":{"Line":1}},{"line":194,"address":[],"length":0,"stats":{"Line":11}},{"line":195,"address":[],"length":0,"stats":{"Line":5}},{"line":196,"address":[],"length":0,"stats":{"Line":4}},{"line":197,"address":[],"length":0,"stats":{"Line":2}},{"line":198,"address":[],"length":0,"stats":{"Line":2}},{"line":199,"address":[],"length":0,"stats":{"Line":1}},{"line":200,"address":[],"length":0,"stats":{"Line":1}},{"line":202,"address":[],"length":0,"stats":{"Line":9}},{"line":203,"address":[],"length":0,"stats":{"Line":5}},{"line":204,"address":[],"length":0,"stats":{"Line":4}},{"line":205,"address":[],"length":0,"stats":{"Line":2}},{"line":206,"address":[],"length":0,"stats":{"Line":2}},{"line":207,"address":[],"length":0,"stats":{"Line":1}},{"line":208,"address":[],"length":0,"stats":{"Line":1}},{"line":210,"address":[],"length":0,"stats":{"Line":7}},{"line":211,"address":[],"length":0,"stats":{"Line":5}},{"line":212,"address":[],"length":0,"stats":{"Line":4}},{"line":213,"address":[],"length":0,"stats":{"Line":2}},{"line":214,"address":[],"length":0,"stats":{"Line":2}},{"line":215,"address":[],"length":0,"stats":{"Line":1}},{"line":216,"address":[],"length":0,"stats":{"Line":1}},{"line":221,"address":[],"length":0,"stats":{"Line":5}},{"line":225,"address":[],"length":0,"stats":{"Line":8}},{"line":226,"address":[],"length":0,"stats":{"Line":16}},{"line":227,"address":[],"length":0,"stats":{"Line":16}},{"line":229,"address":[],"length":0,"stats":{"Line":32}},{"line":230,"address":[],"length":0,"stats":{"Line":32}},{"line":231,"address":[],"length":0,"stats":{"Line":32}},{"line":232,"address":[],"length":0,"stats":{"Line":32}},{"line":233,"address":[],"length":0,"stats":{"Line":32}},{"line":235,"address":[],"length":0,"stats":{"Line":102}},{"line":236,"address":[],"length":0,"stats":{"Line":78}},{"line":239,"address":[],"length":0,"stats":{"Line":117}},{"line":240,"address":[],"length":0,"stats":{"Line":2}},{"line":241,"address":[],"length":0,"stats":{"Line":2}},{"line":243,"address":[],"length":0,"stats":{"Line":111}},{"line":244,"address":[],"length":0,"stats":{"Line":1}},{"line":245,"address":[],"length":0,"stats":{"Line":1}},{"line":249,"address":[],"length":0,"stats":{"Line":207}},{"line":250,"address":[],"length":0,"stats":{"Line":9}},{"line":253,"address":[],"length":0,"stats":{"Line":79}},{"line":254,"address":[],"length":0,"stats":{"Line":42}},{"line":257,"address":[],"length":0,"stats":{"Line":7}},{"line":258,"address":[],"length":0,"stats":{"Line":2}},{"line":262,"address":[],"length":0,"stats":{"Line":5}},{"line":263,"address":[],"length":0,"stats":{"Line":1}},{"line":266,"address":[],"length":0,"stats":{"Line":16}},{"line":267,"address":[],"length":0,"stats":{"Line":12}},{"line":268,"address":[],"length":0,"stats":{"Line":4}},{"line":269,"address":[],"length":0,"stats":{"Line":8}},{"line":270,"address":[],"length":0,"stats":{"Line":4}},{"line":271,"address":[],"length":0,"stats":{"Line":4}},{"line":273,"address":[],"length":0,"stats":{"Line":64}},{"line":274,"address":[],"length":0,"stats":{"Line":36}},{"line":277,"address":[],"length":0,"stats":{"Line":6}},{"line":278,"address":[],"length":0,"stats":{"Line":1}},{"line":281,"address":[],"length":0,"stats":{"Line":20}},{"line":282,"address":[],"length":0,"stats":{"Line":15}},{"line":283,"address":[],"length":0,"stats":{"Line":5}},{"line":284,"address":[],"length":0,"stats":{"Line":10}},{"line":286,"address":[],"length":0,"stats":{"Line":5}},{"line":288,"address":[],"length":0,"stats":{"Line":49}},{"line":289,"address":[],"length":0,"stats":{"Line":18}},{"line":292,"address":[],"length":0,"stats":{"Line":3}},{"line":293,"address":[],"length":0,"stats":{"Line":1}},{"line":296,"address":[],"length":0,"stats":{"Line":8}},{"line":297,"address":[],"length":0,"stats":{"Line":6}},{"line":298,"address":[],"length":0,"stats":{"Line":2}},{"line":299,"address":[],"length":0,"stats":{"Line":4}},{"line":301,"address":[],"length":0,"stats":{"Line":2}},{"line":306,"address":[],"length":0,"stats":{"Line":8}},{"line":310,"address":[],"length":0,"stats":{"Line":5}},{"line":311,"address":[],"length":0,"stats":{"Line":10}},{"line":313,"address":[],"length":0,"stats":{"Line":5}},{"line":314,"address":[],"length":0,"stats":{"Line":15}},{"line":315,"address":[],"length":0,"stats":{"Line":20}},{"line":316,"address":[],"length":0,"stats":{"Line":20}},{"line":318,"address":[],"length":0,"stats":{"Line":25}},{"line":319,"address":[],"length":0,"stats":{"Line":10}},{"line":321,"address":[],"length":0,"stats":{"Line":12}},{"line":322,"address":[],"length":0,"stats":{"Line":5}},{"line":323,"address":[],"length":0,"stats":{"Line":4}},{"line":324,"address":[],"length":0,"stats":{"Line":2}},{"line":325,"address":[],"length":0,"stats":{"Line":2}},{"line":326,"address":[],"length":0,"stats":{"Line":1}},{"line":327,"address":[],"length":0,"stats":{"Line":1}},{"line":329,"address":[],"length":0,"stats":{"Line":11}},{"line":330,"address":[],"length":0,"stats":{"Line":5}},{"line":331,"address":[],"length":0,"stats":{"Line":4}},{"line":332,"address":[],"length":0,"stats":{"Line":2}},{"line":333,"address":[],"length":0,"stats":{"Line":2}},{"line":334,"address":[],"length":0,"stats":{"Line":1}},{"line":335,"address":[],"length":0,"stats":{"Line":1}},{"line":337,"address":[],"length":0,"stats":{"Line":9}},{"line":338,"address":[],"length":0,"stats":{"Line":5}},{"line":339,"address":[],"length":0,"stats":{"Line":4}},{"line":340,"address":[],"length":0,"stats":{"Line":2}},{"line":341,"address":[],"length":0,"stats":{"Line":2}},{"line":342,"address":[],"length":0,"stats":{"Line":1}},{"line":343,"address":[],"length":0,"stats":{"Line":1}},{"line":348,"address":[],"length":0,"stats":{"Line":5}}],"covered":229,"coverable":229},{"path":["/","Users","chi","Projects","hu","src","read","interface","tests.rs"],"content":"use super::*;\n\n#[test]\nfn rust_pub_fn() {\n    let content = \"pub fn test() {}\";\n    let items = extract_interface(content, \"test.rs\");\n    assert_eq!(items.len(), 1);\n    assert!(items[0].text.contains(\"pub fn test\"));\n}\n\n#[test]\nfn rust_private_fn_excluded() {\n    let content = \"fn private_test() {}\";\n    let items = extract_interface(content, \"test.rs\");\n    assert!(items.is_empty());\n}\n\n#[test]\nfn rust_pub_struct() {\n    let content = \"pub struct Config {}\";\n    let items = extract_interface(content, \"test.rs\");\n    assert_eq!(items.len(), 1);\n    assert!(items[0].text.contains(\"pub struct Config\"));\n}\n\n#[test]\nfn rust_pub_enum() {\n    let content = \"pub enum Status { Ok, Err }\";\n    let items = extract_interface(content, \"test.rs\");\n    assert_eq!(items.len(), 1);\n    assert!(items[0].text.contains(\"pub enum Status\"));\n}\n\n#[test]\nfn rust_pub_trait() {\n    let content = \"pub trait Handler {}\";\n    let items = extract_interface(content, \"test.rs\");\n    assert_eq!(items.len(), 1);\n    assert!(items[0].text.contains(\"pub trait Handler\"));\n}\n\n#[test]\nfn rust_pub_const() {\n    let content = \"pub const MAX: u32 = 100;\";\n    let items = extract_interface(content, \"test.rs\");\n    assert_eq!(items.len(), 1);\n    assert!(items[0].text.contains(\"pub const MAX\"));\n}\n\n#[test]\nfn rust_pub_type() {\n    let content = \"pub type Result\u003cT\u003e = std::result::Result\u003cT, Error\u003e;\";\n    let items = extract_interface(content, \"test.rs\");\n    assert_eq!(items.len(), 1);\n    assert!(items[0].text.contains(\"pub type Result\"));\n}\n\n#[test]\nfn rust_pub_mod() {\n    let content = \"pub mod utils;\";\n    let items = extract_interface(content, \"test.rs\");\n    assert_eq!(items.len(), 1);\n    assert!(items[0].text.contains(\"pub mod utils\"));\n}\n\n#[test]\nfn python_public_function() {\n    let content = \"def public_fn():\";\n    let items = extract_interface(content, \"test.py\");\n    assert_eq!(items.len(), 1);\n}\n\n#[test]\nfn python_private_function_excluded() {\n    let content = \"def _private_fn():\";\n    let items = extract_interface(content, \"test.py\");\n    assert!(items.is_empty());\n}\n\n#[test]\nfn python_dunder_included() {\n    let content = \"def __init__(self):\";\n    let items = extract_interface(content, \"test.py\");\n    assert_eq!(items.len(), 1);\n}\n\n#[test]\nfn python_public_class() {\n    let content = \"class Handler:\";\n    let items = extract_interface(content, \"test.py\");\n    assert_eq!(items.len(), 1);\n}\n\n#[test]\nfn python_private_class_excluded() {\n    let content = \"class _Private:\";\n    let items = extract_interface(content, \"test.py\");\n    assert!(items.is_empty());\n}\n\n#[test]\nfn python_method_excluded() {\n    let content = r#\"class Test:\n    def method(self):\n        pass\n\"#;\n    let items = extract_interface(content, \"test.py\");\n    // Only class, not method\n    assert_eq!(items.len(), 1);\n    assert!(items[0].text.contains(\"class Test\"));\n}\n\n#[test]\nfn js_export_function() {\n    let content = \"export function test() {}\";\n    let items = extract_interface(content, \"test.js\");\n    assert_eq!(items.len(), 1);\n    assert!(items[0].text.contains(\"export function test\"));\n}\n\n#[test]\nfn js_non_export_excluded() {\n    let content = \"function internal() {}\";\n    let items = extract_interface(content, \"test.js\");\n    assert!(items.is_empty());\n}\n\n#[test]\nfn js_export_arrow() {\n    let content = \"export const handler = (req) =\u003e\";\n    let items = extract_interface(content, \"test.js\");\n    assert_eq!(items.len(), 1);\n}\n\n#[test]\nfn js_export_class() {\n    let content = \"export class Service {}\";\n    let items = extract_interface(content, \"test.js\");\n    assert_eq!(items.len(), 1);\n    assert!(items[0].text.contains(\"export class Service\"));\n}\n\n#[test]\nfn js_export_default() {\n    let content = \"export default function\";\n    let items = extract_interface(content, \"test.js\");\n    assert_eq!(items.len(), 1);\n}\n\n#[test]\nfn ruby_public_method() {\n    let content = \"def public_method\\nend\";\n    let items = extract_interface(content, \"test.rb\");\n    assert_eq!(items.len(), 1);\n}\n\n#[test]\nfn ruby_private_method_excluded() {\n    let content = r#\"\nclass Test\n  def public\n  end\n\n  private\n\n  def private_method\n  end\nend\n\"#;\n    let items = extract_interface(content, \"test.rb\");\n    // Only class and public method\n    assert_eq!(items.len(), 2);\n}\n\n#[test]\nfn ruby_class() {\n    let content = \"class Handler\";\n    let items = extract_interface(content, \"test.rb\");\n    assert_eq!(items.len(), 1);\n    assert!(items[0].text.contains(\"class Handler\"));\n}\n\n#[test]\nfn ruby_module() {\n    let content = \"module Utils\";\n    let items = extract_interface(content, \"test.rb\");\n    assert_eq!(items.len(), 1);\n    assert!(items[0].text.contains(\"module Utils\"));\n}\n\n#[test]\nfn go_exported_func() {\n    let content = \"func Handler(w http.ResponseWriter) {}\";\n    let items = extract_interface(content, \"test.go\");\n    assert_eq!(items.len(), 1);\n}\n\n#[test]\nfn go_unexported_func_excluded() {\n    let content = \"func internal() {}\";\n    let items = extract_interface(content, \"test.go\");\n    assert!(items.is_empty());\n}\n\n#[test]\nfn go_exported_struct() {\n    let content = \"type Config struct {}\";\n    let items = extract_interface(content, \"test.go\");\n    assert_eq!(items.len(), 1);\n}\n\n#[test]\nfn go_unexported_struct_excluded() {\n    let content = \"type config struct {}\";\n    let items = extract_interface(content, \"test.go\");\n    assert!(items.is_empty());\n}\n\n#[test]\nfn go_exported_interface() {\n    let content = \"type Handler interface {}\";\n    let items = extract_interface(content, \"test.go\");\n    assert_eq!(items.len(), 1);\n}\n\n#[test]\nfn unknown_extension() {\n    let content = \"some content\";\n    let items = extract_interface(content, \"test.xyz\");\n    assert!(items.is_empty());\n}\n\n#[test]\nfn empty_content() {\n    let items = extract_interface(\"\", \"test.rs\");\n    assert!(items.is_empty());\n}\n\n#[test]\nfn python_nested_class_excluded() {\n    // Nested classes (indented) should be excluded\n    let content = r#\"class Outer:\n    class Inner:\n        pass\n\"#;\n    let items = extract_interface(content, \"test.py\");\n    // Only top-level class\n    assert_eq!(items.len(), 1);\n    assert!(items[0].text.contains(\"class Outer\"));\n}\n\n#[test]\nfn ruby_public_after_private() {\n    // public keyword should reset private state\n    let content = r#\"class Test\n  private\n\n  def private_method\n  end\n\n  public\n\n  def public_again\n  end\nend\n\"#;\n    let items = extract_interface(content, \"test.rb\");\n    // class + public_again (private_method is excluded)\n    assert_eq!(items.len(), 2);\n    assert!(items.iter().any(|i| i.text.contains(\"class Test\")));\n    assert!(items.iter().any(|i| i.text.contains(\"def public_again\")));\n    assert!(!items.iter().any(|i| i.text.contains(\"private_method\")));\n}\n\n#[test]\nfn ruby_nested_method_excluded() {\n    // Deeply nested methods (indent \u003e 2) should be excluded\n    let content = r#\"class Test\n  def outer\n      def inner_method\n      end\n  end\nend\n\"#;\n    let items = extract_interface(content, \"test.rb\");\n    // class + outer method, but not inner_method\n    assert_eq!(items.len(), 2);\n    assert!(items.iter().any(|i| i.text.contains(\"class Test\")));\n    assert!(items.iter().any(|i| i.text.contains(\"def outer\")));\n    assert!(!items.iter().any(|i| i.text.contains(\"inner_method\")));\n}\n\n#[test]\nfn ruby_nested_class_excluded() {\n    // Nested classes should be excluded\n    let content = r#\"class Outer\n  class Inner\n  end\nend\n\"#;\n    let items = extract_interface(content, \"test.rb\");\n    // Only top-level class\n    assert_eq!(items.len(), 1);\n    assert!(items[0].text.contains(\"class Outer\"));\n}\n\n#[test]\nfn ruby_nested_module_excluded() {\n    // Nested modules should be excluded\n    let content = r#\"module Outer\n  module Inner\n  end\nend\n\"#;\n    let items = extract_interface(content, \"test.rb\");\n    // Only top-level module\n    assert_eq!(items.len(), 1);\n    assert!(items[0].text.contains(\"module Outer\"));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","read","mod.rs"],"content":"mod around;\nmod cli;\nmod diff;\nmod display;\nmod interface;\nmod outline;\nmod service;\nmod types;\n\npub use cli::ReadArgs;\npub use types::ReadOutput;\n\nuse anyhow::Result;\n\n/// Run the read command (CLI entry point - formats and prints)\n#[cfg(not(tarpaulin_include))]\npub fn run(args: ReadArgs) -\u003e Result\u003c()\u003e {\n    let output = service::run(args)?;\n    let formatted = display::format(\u0026output);\n    print!(\"{}\", formatted);\n    Ok(())\n}\n\n/// Run the read command and return data (for MCP/HTTP)\n#[allow(dead_code)]\npub fn read(args: ReadArgs) -\u003e Result\u003cReadOutput\u003e {\n    service::run(args)\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","Users","chi","Projects","hu","src","read","outline","mod.rs"],"content":"use regex::Regex;\nuse std::path::Path;\n\nuse super::types::{FileOutline, ItemKind, OutlineItem};\n\n#[cfg(test)]\nmod tests;\n\n/// Extract outline from file content based on extension\npub fn extract_outline(content: \u0026str, path: \u0026str) -\u003e FileOutline {\n    let ext = Path::new(path)\n        .extension()\n        .and_then(|e| e.to_str())\n        .unwrap_or(\"\");\n\n    let mut outline = FileOutline::new();\n\n    match ext {\n        \"rs\" =\u003e extract_rust_outline(content, \u0026mut outline),\n        \"py\" =\u003e extract_python_outline(content, \u0026mut outline),\n        \"js\" | \"ts\" | \"jsx\" | \"tsx\" | \"mjs\" =\u003e extract_js_outline(content, \u0026mut outline),\n        \"rb\" =\u003e extract_ruby_outline(content, \u0026mut outline),\n        \"go\" =\u003e extract_go_outline(content, \u0026mut outline),\n        \"md\" | \"markdown\" =\u003e extract_markdown_outline(content, \u0026mut outline),\n        _ =\u003e {}\n    }\n\n    outline\n}\n\n/// Extract Rust outline (functions, structs, enums, traits, impls)\nfn extract_rust_outline(content: \u0026str, outline: \u0026mut FileOutline) {\n    let fn_re = Regex::new(\n        r\"^(\\s*)(pub\\s+)?(async\\s+)?fn\\s+(\\w+)\\s*(\u003c[^\u003e]+\u003e)?\\s*\\([^)]*\\)(\\s*-\u003e\\s*[^{]+)?\",\n    )\n    .unwrap();\n    let struct_re = Regex::new(r\"^(\\s*)(pub\\s+)?struct\\s+(\\w+)(\u003c[^\u003e]+\u003e)?\").unwrap();\n    let enum_re = Regex::new(r\"^(\\s*)(pub\\s+)?enum\\s+(\\w+)(\u003c[^\u003e]+\u003e)?\").unwrap();\n    let trait_re = Regex::new(r\"^(\\s*)(pub\\s+)?trait\\s+(\\w+)(\u003c[^\u003e]+\u003e)?\").unwrap();\n    let impl_re = Regex::new(r\"^(\\s*)impl\\s*(\u003c[^\u003e]+\u003e)?\\s*(\\w+)(\u003c[^\u003e]+\u003e)?(\\s+for\\s+\\w+)?\").unwrap();\n    let mod_re = Regex::new(r\"^(\\s*)(pub\\s+)?mod\\s+(\\w+)\").unwrap();\n    let const_re = Regex::new(r\"^(\\s*)(pub\\s+)?const\\s+(\\w+)\").unwrap();\n    let type_re = Regex::new(r\"^(\\s*)(pub\\s+)?type\\s+(\\w+)\").unwrap();\n\n    for (line_num, line) in content.lines().enumerate() {\n        let line_num = line_num + 1;\n\n        if let Some(caps) = fn_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim_end_matches('{').trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 4,\n                ItemKind::Function,\n            ));\n        } else if let Some(caps) = struct_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 4,\n                ItemKind::Struct,\n            ));\n        } else if let Some(caps) = enum_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 4,\n                ItemKind::Enum,\n            ));\n        } else if let Some(caps) = trait_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 4,\n                ItemKind::Trait,\n            ));\n        } else if let Some(caps) = impl_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 4,\n                ItemKind::Impl,\n            ));\n        } else if let Some(caps) = mod_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 4,\n                ItemKind::Module,\n            ));\n        } else if let Some(caps) = const_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 4,\n                ItemKind::Const,\n            ));\n        } else if let Some(caps) = type_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 4,\n                ItemKind::Type,\n            ));\n        }\n    }\n}\n\n/// Extract Python outline (functions, classes)\nfn extract_python_outline(content: \u0026str, outline: \u0026mut FileOutline) {\n    let def_re = Regex::new(r\"^(\\s*)(async\\s+)?def\\s+(\\w+)\\s*\\([^)]*\\)(\\s*-\u003e\\s*[^:]+)?\").unwrap();\n    let class_re = Regex::new(r\"^(\\s*)class\\s+(\\w+)(\\([^)]*\\))?\").unwrap();\n\n    for (line_num, line) in content.lines().enumerate() {\n        let line_num = line_num + 1;\n\n        if let Some(caps) = def_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim_end_matches(':').trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 4,\n                ItemKind::Function,\n            ));\n        } else if let Some(caps) = class_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim_end_matches(':').trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 4,\n                ItemKind::Class,\n            ));\n        }\n    }\n}\n\n/// Extract JavaScript/TypeScript outline\nfn extract_js_outline(content: \u0026str, outline: \u0026mut FileOutline) {\n    let fn_re =\n        Regex::new(r\"^(\\s*)(export\\s+)?(async\\s+)?function\\s+(\\w+)\\s*(\u003c[^\u003e]+\u003e)?\\s*\\([^)]*\\)\")\n            .unwrap();\n    let arrow_re =\n        Regex::new(r\"^(\\s*)(export\\s+)?(const|let|var)\\s+(\\w+)\\s*=\\s*(async\\s+)?\\([^)]*\\)\\s*=\u003e\")\n            .unwrap();\n    let class_re = Regex::new(r\"^(\\s*)(export\\s+)?class\\s+(\\w+)(\\s+extends\\s+\\w+)?\").unwrap();\n    let method_re = Regex::new(r\"^(\\s*)(async\\s+)?(\\w+)\\s*\\([^)]*\\)\\s*\\{\").unwrap();\n\n    for (line_num, line) in content.lines().enumerate() {\n        let line_num = line_num + 1;\n\n        if let Some(caps) = fn_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 2,\n                ItemKind::Function,\n            ));\n        } else if let Some(caps) = arrow_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim_end_matches(\"=\u003e\").trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 2,\n                ItemKind::Function,\n            ));\n        } else if let Some(caps) = class_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 2,\n                ItemKind::Class,\n            ));\n        } else if let Some(caps) = method_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            // Only include methods with some indent (inside class)\n            if indent \u003e 0 {\n                let sig = caps.get(0).unwrap().as_str().trim_end_matches('{').trim();\n                outline.push(OutlineItem::new(\n                    line_num,\n                    sig.to_string(),\n                    indent / 2,\n                    ItemKind::Function,\n                ));\n            }\n        }\n    }\n}\n\n/// Extract Ruby outline\nfn extract_ruby_outline(content: \u0026str, outline: \u0026mut FileOutline) {\n    let def_re = Regex::new(r\"^(\\s*)def\\s+(\\w+[?!=]?)(\\([^)]*\\))?\").unwrap();\n    let class_re = Regex::new(r\"^(\\s*)class\\s+(\\w+)(\\s*\u003c\\s*\\w+)?\").unwrap();\n    let module_re = Regex::new(r\"^(\\s*)module\\s+(\\w+)\").unwrap();\n\n    for (line_num, line) in content.lines().enumerate() {\n        let line_num = line_num + 1;\n\n        if let Some(caps) = def_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 2,\n                ItemKind::Function,\n            ));\n        } else if let Some(caps) = class_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 2,\n                ItemKind::Class,\n            ));\n        } else if let Some(caps) = module_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 2,\n                ItemKind::Module,\n            ));\n        }\n    }\n}\n\n/// Extract Go outline\nfn extract_go_outline(content: \u0026str, outline: \u0026mut FileOutline) {\n    let func_re =\n        Regex::new(r\"^func\\s+(\\([^)]+\\)\\s+)?(\\w+)\\s*\\([^)]*\\)(\\s*\\([^)]*\\)|\\s*\\w+)?\").unwrap();\n    let type_struct_re = Regex::new(r\"^type\\s+(\\w+)\\s+struct\").unwrap();\n    let type_interface_re = Regex::new(r\"^type\\s+(\\w+)\\s+interface\").unwrap();\n\n    for (line_num, line) in content.lines().enumerate() {\n        let line_num = line_num + 1;\n\n        if let Some(caps) = func_re.captures(line) {\n            let sig = caps.get(0).unwrap().as_str().trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                0,\n                ItemKind::Function,\n            ));\n        } else if let Some(caps) = type_struct_re.captures(line) {\n            let sig = caps.get(0).unwrap().as_str().trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                0,\n                ItemKind::Struct,\n            ));\n        } else if let Some(caps) = type_interface_re.captures(line) {\n            let sig = caps.get(0).unwrap().as_str().trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                0,\n                ItemKind::Trait,\n            ));\n        }\n    }\n}\n\n/// Extract Markdown outline (headings)\nfn extract_markdown_outline(content: \u0026str, outline: \u0026mut FileOutline) {\n    let heading_re = Regex::new(r\"^(#{1,6})\\s+(.+)$\").unwrap();\n\n    for (line_num, line) in content.lines().enumerate() {\n        let line_num = line_num + 1;\n\n        if let Some(caps) = heading_re.captures(line) {\n            let level = caps.get(1).unwrap().as_str().len() as u8;\n            let text = caps.get(2).unwrap().as_str().to_string();\n            outline.push(OutlineItem::new(\n                line_num,\n                text,\n                (level - 1) as usize,\n                ItemKind::Heading(level),\n            ));\n        }\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":33}},{"line":11,"address":[],"length":0,"stats":{"Line":66}},{"line":13,"address":[],"length":0,"stats":{"Line":99}},{"line":16,"address":[],"length":0,"stats":{"Line":66}},{"line":18,"address":[],"length":0,"stats":{"Line":33}},{"line":19,"address":[],"length":0,"stats":{"Line":72}},{"line":20,"address":[],"length":0,"stats":{"Line":32}},{"line":21,"address":[],"length":0,"stats":{"Line":75}},{"line":22,"address":[],"length":0,"stats":{"Line":22}},{"line":23,"address":[],"length":0,"stats":{"Line":15}},{"line":24,"address":[],"length":0,"stats":{"Line":8}},{"line":25,"address":[],"length":0,"stats":{"Line":2}},{"line":28,"address":[],"length":0,"stats":{"Line":33}},{"line":32,"address":[],"length":0,"stats":{"Line":13}},{"line":37,"address":[],"length":0,"stats":{"Line":52}},{"line":38,"address":[],"length":0,"stats":{"Line":52}},{"line":39,"address":[],"length":0,"stats":{"Line":52}},{"line":40,"address":[],"length":0,"stats":{"Line":52}},{"line":41,"address":[],"length":0,"stats":{"Line":52}},{"line":42,"address":[],"length":0,"stats":{"Line":52}},{"line":43,"address":[],"length":0,"stats":{"Line":52}},{"line":45,"address":[],"length":0,"stats":{"Line":75}},{"line":46,"address":[],"length":0,"stats":{"Line":36}},{"line":48,"address":[],"length":0,"stats":{"Line":41}},{"line":49,"address":[],"length":0,"stats":{"Line":30}},{"line":50,"address":[],"length":0,"stats":{"Line":20}},{"line":51,"address":[],"length":0,"stats":{"Line":15}},{"line":52,"address":[],"length":0,"stats":{"Line":5}},{"line":53,"address":[],"length":0,"stats":{"Line":10}},{"line":54,"address":[],"length":0,"stats":{"Line":5}},{"line":55,"address":[],"length":0,"stats":{"Line":5}},{"line":57,"address":[],"length":0,"stats":{"Line":27}},{"line":58,"address":[],"length":0,"stats":{"Line":6}},{"line":59,"address":[],"length":0,"stats":{"Line":4}},{"line":60,"address":[],"length":0,"stats":{"Line":3}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":62,"address":[],"length":0,"stats":{"Line":2}},{"line":63,"address":[],"length":0,"stats":{"Line":1}},{"line":64,"address":[],"length":0,"stats":{"Line":1}},{"line":66,"address":[],"length":0,"stats":{"Line":25}},{"line":67,"address":[],"length":0,"stats":{"Line":6}},{"line":68,"address":[],"length":0,"stats":{"Line":4}},{"line":69,"address":[],"length":0,"stats":{"Line":3}},{"line":70,"address":[],"length":0,"stats":{"Line":1}},{"line":71,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":1}},{"line":75,"address":[],"length":0,"stats":{"Line":23}},{"line":76,"address":[],"length":0,"stats":{"Line":6}},{"line":77,"address":[],"length":0,"stats":{"Line":4}},{"line":78,"address":[],"length":0,"stats":{"Line":3}},{"line":79,"address":[],"length":0,"stats":{"Line":1}},{"line":80,"address":[],"length":0,"stats":{"Line":2}},{"line":81,"address":[],"length":0,"stats":{"Line":1}},{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":84,"address":[],"length":0,"stats":{"Line":23}},{"line":85,"address":[],"length":0,"stats":{"Line":18}},{"line":86,"address":[],"length":0,"stats":{"Line":12}},{"line":87,"address":[],"length":0,"stats":{"Line":9}},{"line":88,"address":[],"length":0,"stats":{"Line":3}},{"line":89,"address":[],"length":0,"stats":{"Line":6}},{"line":90,"address":[],"length":0,"stats":{"Line":3}},{"line":91,"address":[],"length":0,"stats":{"Line":3}},{"line":93,"address":[],"length":0,"stats":{"Line":15}},{"line":94,"address":[],"length":0,"stats":{"Line":6}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":96,"address":[],"length":0,"stats":{"Line":3}},{"line":97,"address":[],"length":0,"stats":{"Line":1}},{"line":98,"address":[],"length":0,"stats":{"Line":2}},{"line":99,"address":[],"length":0,"stats":{"Line":1}},{"line":100,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":13}},{"line":103,"address":[],"length":0,"stats":{"Line":6}},{"line":104,"address":[],"length":0,"stats":{"Line":4}},{"line":105,"address":[],"length":0,"stats":{"Line":3}},{"line":106,"address":[],"length":0,"stats":{"Line":1}},{"line":107,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":1}},{"line":109,"address":[],"length":0,"stats":{"Line":1}},{"line":111,"address":[],"length":0,"stats":{"Line":11}},{"line":112,"address":[],"length":0,"stats":{"Line":6}},{"line":113,"address":[],"length":0,"stats":{"Line":4}},{"line":114,"address":[],"length":0,"stats":{"Line":3}},{"line":115,"address":[],"length":0,"stats":{"Line":1}},{"line":116,"address":[],"length":0,"stats":{"Line":2}},{"line":117,"address":[],"length":0,"stats":{"Line":1}},{"line":118,"address":[],"length":0,"stats":{"Line":1}},{"line":125,"address":[],"length":0,"stats":{"Line":4}},{"line":126,"address":[],"length":0,"stats":{"Line":16}},{"line":127,"address":[],"length":0,"stats":{"Line":16}},{"line":129,"address":[],"length":0,"stats":{"Line":26}},{"line":130,"address":[],"length":0,"stats":{"Line":14}},{"line":132,"address":[],"length":0,"stats":{"Line":17}},{"line":133,"address":[],"length":0,"stats":{"Line":18}},{"line":134,"address":[],"length":0,"stats":{"Line":12}},{"line":135,"address":[],"length":0,"stats":{"Line":9}},{"line":136,"address":[],"length":0,"stats":{"Line":3}},{"line":137,"address":[],"length":0,"stats":{"Line":6}},{"line":138,"address":[],"length":0,"stats":{"Line":3}},{"line":139,"address":[],"length":0,"stats":{"Line":3}},{"line":141,"address":[],"length":0,"stats":{"Line":10}},{"line":142,"address":[],"length":0,"stats":{"Line":12}},{"line":143,"address":[],"length":0,"stats":{"Line":8}},{"line":144,"address":[],"length":0,"stats":{"Line":6}},{"line":145,"address":[],"length":0,"stats":{"Line":2}},{"line":146,"address":[],"length":0,"stats":{"Line":4}},{"line":147,"address":[],"length":0,"stats":{"Line":2}},{"line":148,"address":[],"length":0,"stats":{"Line":2}},{"line":155,"address":[],"length":0,"stats":{"Line":6}},{"line":156,"address":[],"length":0,"stats":{"Line":6}},{"line":157,"address":[],"length":0,"stats":{"Line":12}},{"line":159,"address":[],"length":0,"stats":{"Line":6}},{"line":160,"address":[],"length":0,"stats":{"Line":12}},{"line":162,"address":[],"length":0,"stats":{"Line":24}},{"line":163,"address":[],"length":0,"stats":{"Line":24}},{"line":165,"address":[],"length":0,"stats":{"Line":58}},{"line":166,"address":[],"length":0,"stats":{"Line":40}},{"line":168,"address":[],"length":0,"stats":{"Line":42}},{"line":169,"address":[],"length":0,"stats":{"Line":12}},{"line":170,"address":[],"length":0,"stats":{"Line":8}},{"line":171,"address":[],"length":0,"stats":{"Line":6}},{"line":172,"address":[],"length":0,"stats":{"Line":2}},{"line":173,"address":[],"length":0,"stats":{"Line":4}},{"line":174,"address":[],"length":0,"stats":{"Line":2}},{"line":175,"address":[],"length":0,"stats":{"Line":2}},{"line":177,"address":[],"length":0,"stats":{"Line":37}},{"line":178,"address":[],"length":0,"stats":{"Line":6}},{"line":179,"address":[],"length":0,"stats":{"Line":4}},{"line":180,"address":[],"length":0,"stats":{"Line":3}},{"line":181,"address":[],"length":0,"stats":{"Line":1}},{"line":182,"address":[],"length":0,"stats":{"Line":2}},{"line":183,"address":[],"length":0,"stats":{"Line":1}},{"line":184,"address":[],"length":0,"stats":{"Line":1}},{"line":186,"address":[],"length":0,"stats":{"Line":37}},{"line":187,"address":[],"length":0,"stats":{"Line":18}},{"line":188,"address":[],"length":0,"stats":{"Line":12}},{"line":189,"address":[],"length":0,"stats":{"Line":9}},{"line":190,"address":[],"length":0,"stats":{"Line":3}},{"line":191,"address":[],"length":0,"stats":{"Line":6}},{"line":192,"address":[],"length":0,"stats":{"Line":3}},{"line":193,"address":[],"length":0,"stats":{"Line":3}},{"line":195,"address":[],"length":0,"stats":{"Line":32}},{"line":196,"address":[],"length":0,"stats":{"Line":24}},{"line":198,"address":[],"length":0,"stats":{"Line":8}},{"line":199,"address":[],"length":0,"stats":{"Line":20}},{"line":200,"address":[],"length":0,"stats":{"Line":16}},{"line":201,"address":[],"length":0,"stats":{"Line":8}},{"line":202,"address":[],"length":0,"stats":{"Line":12}},{"line":203,"address":[],"length":0,"stats":{"Line":4}},{"line":204,"address":[],"length":0,"stats":{"Line":4}},{"line":212,"address":[],"length":0,"stats":{"Line":4}},{"line":213,"address":[],"length":0,"stats":{"Line":16}},{"line":214,"address":[],"length":0,"stats":{"Line":16}},{"line":215,"address":[],"length":0,"stats":{"Line":16}},{"line":217,"address":[],"length":0,"stats":{"Line":20}},{"line":218,"address":[],"length":0,"stats":{"Line":8}},{"line":220,"address":[],"length":0,"stats":{"Line":10}},{"line":221,"address":[],"length":0,"stats":{"Line":12}},{"line":222,"address":[],"length":0,"stats":{"Line":8}},{"line":223,"address":[],"length":0,"stats":{"Line":6}},{"line":224,"address":[],"length":0,"stats":{"Line":2}},{"line":225,"address":[],"length":0,"stats":{"Line":4}},{"line":226,"address":[],"length":0,"stats":{"Line":2}},{"line":227,"address":[],"length":0,"stats":{"Line":2}},{"line":229,"address":[],"length":0,"stats":{"Line":5}},{"line":230,"address":[],"length":0,"stats":{"Line":6}},{"line":231,"address":[],"length":0,"stats":{"Line":4}},{"line":232,"address":[],"length":0,"stats":{"Line":3}},{"line":233,"address":[],"length":0,"stats":{"Line":1}},{"line":234,"address":[],"length":0,"stats":{"Line":2}},{"line":235,"address":[],"length":0,"stats":{"Line":1}},{"line":236,"address":[],"length":0,"stats":{"Line":1}},{"line":238,"address":[],"length":0,"stats":{"Line":3}},{"line":239,"address":[],"length":0,"stats":{"Line":6}},{"line":240,"address":[],"length":0,"stats":{"Line":4}},{"line":241,"address":[],"length":0,"stats":{"Line":3}},{"line":242,"address":[],"length":0,"stats":{"Line":1}},{"line":243,"address":[],"length":0,"stats":{"Line":2}},{"line":244,"address":[],"length":0,"stats":{"Line":1}},{"line":245,"address":[],"length":0,"stats":{"Line":1}},{"line":252,"address":[],"length":0,"stats":{"Line":3}},{"line":253,"address":[],"length":0,"stats":{"Line":3}},{"line":254,"address":[],"length":0,"stats":{"Line":9}},{"line":255,"address":[],"length":0,"stats":{"Line":12}},{"line":256,"address":[],"length":0,"stats":{"Line":12}},{"line":258,"address":[],"length":0,"stats":{"Line":15}},{"line":259,"address":[],"length":0,"stats":{"Line":6}},{"line":261,"address":[],"length":0,"stats":{"Line":8}},{"line":262,"address":[],"length":0,"stats":{"Line":5}},{"line":263,"address":[],"length":0,"stats":{"Line":4}},{"line":264,"address":[],"length":0,"stats":{"Line":2}},{"line":265,"address":[],"length":0,"stats":{"Line":2}},{"line":266,"address":[],"length":0,"stats":{"Line":1}},{"line":267,"address":[],"length":0,"stats":{"Line":1}},{"line":269,"address":[],"length":0,"stats":{"Line":7}},{"line":270,"address":[],"length":0,"stats":{"Line":5}},{"line":271,"address":[],"length":0,"stats":{"Line":4}},{"line":272,"address":[],"length":0,"stats":{"Line":2}},{"line":273,"address":[],"length":0,"stats":{"Line":2}},{"line":274,"address":[],"length":0,"stats":{"Line":1}},{"line":275,"address":[],"length":0,"stats":{"Line":1}},{"line":277,"address":[],"length":0,"stats":{"Line":5}},{"line":278,"address":[],"length":0,"stats":{"Line":5}},{"line":279,"address":[],"length":0,"stats":{"Line":4}},{"line":280,"address":[],"length":0,"stats":{"Line":2}},{"line":281,"address":[],"length":0,"stats":{"Line":2}},{"line":282,"address":[],"length":0,"stats":{"Line":1}},{"line":283,"address":[],"length":0,"stats":{"Line":1}},{"line":290,"address":[],"length":0,"stats":{"Line":1}},{"line":291,"address":[],"length":0,"stats":{"Line":4}},{"line":293,"address":[],"length":0,"stats":{"Line":13}},{"line":294,"address":[],"length":0,"stats":{"Line":10}},{"line":296,"address":[],"length":0,"stats":{"Line":18}},{"line":297,"address":[],"length":0,"stats":{"Line":16}},{"line":298,"address":[],"length":0,"stats":{"Line":20}},{"line":299,"address":[],"length":0,"stats":{"Line":16}},{"line":300,"address":[],"length":0,"stats":{"Line":8}},{"line":301,"address":[],"length":0,"stats":{"Line":8}},{"line":302,"address":[],"length":0,"stats":{"Line":4}},{"line":303,"address":[],"length":0,"stats":{"Line":4}}],"covered":220,"coverable":220},{"path":["/","Users","chi","Projects","hu","src","read","outline","tests.rs"],"content":"use super::*;\n\n#[test]\nfn rust_function() {\n    let content = \"pub fn test(x: i32) -\u003e String {\";\n    let outline = extract_outline(content, \"test.rs\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"pub fn test\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Function);\n}\n\n#[test]\nfn rust_async_function() {\n    let content = \"pub async fn fetch() -\u003e Result\u003c()\u003e {\";\n    let outline = extract_outline(content, \"test.rs\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"async fn fetch\"));\n}\n\n#[test]\nfn rust_struct() {\n    let content = \"pub struct Config\u003cT\u003e {\";\n    let outline = extract_outline(content, \"test.rs\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"struct Config\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Struct);\n}\n\n#[test]\nfn rust_enum() {\n    let content = \"pub enum Status {\";\n    let outline = extract_outline(content, \"test.rs\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"enum Status\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Enum);\n}\n\n#[test]\nfn rust_trait() {\n    let content = \"pub trait Handler {\";\n    let outline = extract_outline(content, \"test.rs\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"trait Handler\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Trait);\n}\n\n#[test]\nfn rust_impl() {\n    let content = \"impl Config {\";\n    let outline = extract_outline(content, \"test.rs\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"impl Config\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Impl);\n}\n\n#[test]\nfn rust_impl_for() {\n    let content = \"impl Handler for Config {\";\n    let outline = extract_outline(content, \"test.rs\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"impl Handler for Config\"));\n}\n\n#[test]\nfn rust_mod() {\n    let content = \"pub mod utils;\";\n    let outline = extract_outline(content, \"test.rs\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"mod utils\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Module);\n}\n\n#[test]\nfn rust_const() {\n    let content = \"pub const MAX_SIZE: usize = 1024;\";\n    let outline = extract_outline(content, \"test.rs\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"const MAX_SIZE\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Const);\n}\n\n#[test]\nfn rust_type() {\n    let content = \"pub type Result\u003cT\u003e = std::result::Result\u003cT, Error\u003e;\";\n    let outline = extract_outline(content, \"test.rs\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"type Result\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Type);\n}\n\n#[test]\nfn rust_nested() {\n    let content = r#\"\nimpl Config {\n    pub fn new() -\u003e Self {\n    }\n}\n\"#;\n    let outline = extract_outline(content, \"test.rs\");\n    assert_eq!(outline.len(), 2);\n    assert_eq!(outline.items[0].level, 0);\n    assert_eq!(outline.items[1].level, 1);\n}\n\n#[test]\nfn python_function() {\n    let content = \"def process(data: list) -\u003e dict:\";\n    let outline = extract_outline(content, \"test.py\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"def process\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Function);\n}\n\n#[test]\nfn python_async_function() {\n    let content = \"async def fetch(url):\";\n    let outline = extract_outline(content, \"test.py\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"async def fetch\"));\n}\n\n#[test]\nfn python_class() {\n    let content = \"class Handler(BaseHandler):\";\n    let outline = extract_outline(content, \"test.py\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"class Handler\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Class);\n}\n\n#[test]\nfn python_nested() {\n    let content = r#\"\nclass Handler:\n    def process(self):\n        pass\n\"#;\n    let outline = extract_outline(content, \"test.py\");\n    assert_eq!(outline.len(), 2);\n    assert_eq!(outline.items[0].level, 0);\n    assert_eq!(outline.items[1].level, 1);\n}\n\n#[test]\nfn js_function() {\n    let content = \"export async function fetchData(url) {\";\n    let outline = extract_outline(content, \"test.js\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"function fetchData\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Function);\n}\n\n#[test]\nfn js_arrow_function() {\n    let content = \"const handler = async (req, res) =\u003e\";\n    let outline = extract_outline(content, \"test.js\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"const handler\"));\n}\n\n#[test]\nfn js_class() {\n    let content = \"export class UserService extends Service {\";\n    let outline = extract_outline(content, \"test.js\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"class UserService\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Class);\n}\n\n#[test]\nfn ts_function() {\n    let content = \"export function process\u003cT\u003e(data: T[]): T[] {\";\n    let outline = extract_outline(content, \"test.ts\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"function process\"));\n}\n\n#[test]\nfn ruby_def() {\n    let content = \"def process(data)\";\n    let outline = extract_outline(content, \"test.rb\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"def process\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Function);\n}\n\n#[test]\nfn ruby_predicate() {\n    let content = \"def valid?\";\n    let outline = extract_outline(content, \"test.rb\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"def valid?\"));\n}\n\n#[test]\nfn ruby_class() {\n    let content = \"class Handler \u003c BaseHandler\";\n    let outline = extract_outline(content, \"test.rb\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"class Handler\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Class);\n}\n\n#[test]\nfn ruby_module() {\n    let content = \"module Utils\";\n    let outline = extract_outline(content, \"test.rb\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"module Utils\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Module);\n}\n\n#[test]\nfn go_func() {\n    let content = \"func (s *Server) Handle(w http.ResponseWriter, r *http.Request) {\";\n    let outline = extract_outline(content, \"test.go\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"func\"));\n    assert!(outline.items[0].text.contains(\"Handle\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Function);\n}\n\n#[test]\nfn go_struct() {\n    let content = \"type Config struct {\";\n    let outline = extract_outline(content, \"test.go\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"type Config struct\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Struct);\n}\n\n#[test]\nfn go_interface() {\n    let content = \"type Handler interface {\";\n    let outline = extract_outline(content, \"test.go\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"type Handler interface\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Trait);\n}\n\n#[test]\nfn markdown_headings() {\n    let content = r#\"\n# Title\n## Section 1\n### Subsection\n## Section 2\n\"#;\n    let outline = extract_outline(content, \"test.md\");\n    assert_eq!(outline.len(), 4);\n    assert_eq!(outline.items[0].text, \"Title\");\n    assert_eq!(outline.items[0].kind, ItemKind::Heading(1));\n    assert_eq!(outline.items[0].level, 0);\n    assert_eq!(outline.items[1].text, \"Section 1\");\n    assert_eq!(outline.items[1].kind, ItemKind::Heading(2));\n    assert_eq!(outline.items[1].level, 1);\n    assert_eq!(outline.items[2].text, \"Subsection\");\n    assert_eq!(outline.items[2].kind, ItemKind::Heading(3));\n    assert_eq!(outline.items[2].level, 2);\n}\n\n#[test]\nfn unknown_extension() {\n    let content = \"some content\";\n    let outline = extract_outline(content, \"test.xyz\");\n    assert!(outline.is_empty());\n}\n\n#[test]\nfn empty_content() {\n    let outline = extract_outline(\"\", \"test.rs\");\n    assert!(outline.is_empty());\n}\n\n#[test]\nfn line_numbers_correct() {\n    let content = r#\"\npub fn first() {}\npub fn second() {}\n\"#;\n    let outline = extract_outline(content, \"test.rs\");\n    assert_eq!(outline.len(), 2);\n    assert_eq!(outline.items[0].line, 2);\n    assert_eq!(outline.items[1].line, 3);\n}\n\n#[test]\nfn js_class_methods() {\n    // Test that methods inside JavaScript classes are detected\n    let content = r#\"class UserService {\n  constructor(db) {\n    this.db = db;\n  }\n\n  async findById(id) {\n    return this.db.find(id);\n  }\n\n  delete(id) {\n  }\n}\n\"#;\n    let outline = extract_outline(content, \"test.js\");\n    // class + 3 methods (constructor, findById, delete)\n    assert_eq!(outline.len(), 4);\n    assert!(outline.items[0].text.contains(\"class UserService\"));\n    assert!(outline.items[1].text.contains(\"constructor\"));\n    assert!(outline.items[2].text.contains(\"findById\"));\n    assert!(outline.items[3].text.contains(\"delete\"));\n}\n\n#[test]\nfn js_method_async() {\n    // Test async methods inside class\n    let content = r#\"class Api {\n  async fetch(url) {\n  }\n}\n\"#;\n    let outline = extract_outline(content, \"test.js\");\n    assert_eq!(outline.len(), 2);\n    assert!(outline.items[1].text.contains(\"async fetch\"));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","read","service.rs"],"content":"use anyhow::{Context, Result};\nuse std::fs;\nuse std::path::Path;\n\nuse super::around::extract_lines_around;\nuse super::cli::ReadArgs;\nuse super::diff::git_diff;\nuse super::interface::extract_interface;\nuse super::outline::extract_outline;\nuse super::types::ReadOutput;\n\n/// Run the read command - returns data, never prints\npub fn run(args: ReadArgs) -\u003e Result\u003cReadOutput\u003e {\n    let path = resolve_path(\u0026args.path)?;\n    let content = fs::read_to_string(\u0026path)\n        .with_context(|| format!(\"Failed to read file: {}\", path.display()))?;\n\n    if let Some(center) = args.around {\n        // Lines around a specific line\n        let (lines, total_lines) = extract_lines_around(\u0026content, center, args.context);\n        Ok(ReadOutput::Around {\n            lines,\n            center,\n            total_lines,\n        })\n    } else if args.diff {\n        // Git diff\n        let commit = if args.commit == \"HEAD\" {\n            None\n        } else {\n            Some(args.commit.as_str())\n        };\n        let diff = git_diff(path.to_str().unwrap_or(\"\"), commit)?;\n        Ok(ReadOutput::Diff(diff))\n    } else if args.interface {\n        // Public interface\n        let items = extract_interface(\u0026content, path.to_str().unwrap_or(\"\"));\n        Ok(ReadOutput::Interface(items))\n    } else if args.outline {\n        // File outline\n        let outline = extract_outline(\u0026content, path.to_str().unwrap_or(\"\"));\n        Ok(ReadOutput::Outline(outline))\n    } else {\n        // Full file content\n        Ok(ReadOutput::Full(content))\n    }\n}\n\n/// Resolve a path to absolute\nfn resolve_path(path_str: \u0026str) -\u003e Result\u003cstd::path::PathBuf\u003e {\n    let path = Path::new(path_str);\n    if path.is_absolute() {\n        Ok(path.to_path_buf())\n    } else {\n        let cwd = std::env::current_dir().context(\"Failed to get current directory\")?;\n        let resolved = cwd.join(path);\n        if !resolved.exists() {\n            anyhow::bail!(\"File not found: {}\", path_str);\n        }\n        Ok(resolved)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn resolve_path_absolute() {\n        let result = resolve_path(\"/tmp\");\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn resolve_path_relative() {\n        // Cargo.toml exists in project root\n        let result = resolve_path(\"Cargo.toml\");\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn resolve_path_not_found() {\n        let result = resolve_path(\"nonexistent_file_xyz.abc\");\n        assert!(result.is_err());\n    }\n\n    // Integration tests - verify correct ReadOutput variant is returned\n    #[test]\n    fn run_returns_outline() {\n        let args = ReadArgs {\n            path: concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/Cargo.toml\").to_string(),\n            outline: true,\n            interface: false,\n            around: None,\n            context: 10,\n            diff: false,\n            commit: \"HEAD\".to_string(),\n        };\n        let result = run(args).unwrap();\n        assert!(matches!(result, ReadOutput::Outline(_)));\n    }\n\n    #[test]\n    fn run_returns_around() {\n        let args = ReadArgs {\n            path: concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/Cargo.toml\").to_string(),\n            outline: false,\n            interface: false,\n            around: Some(5),\n            context: 3,\n            diff: false,\n            commit: \"HEAD\".to_string(),\n        };\n        let result = run(args).unwrap();\n        assert!(matches!(result, ReadOutput::Around { .. }));\n    }\n\n    #[test]\n    fn run_returns_full() {\n        let args = ReadArgs {\n            path: concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/Cargo.toml\").to_string(),\n            outline: false,\n            interface: false,\n            around: None,\n            context: 10,\n            diff: false,\n            commit: \"HEAD\".to_string(),\n        };\n        let result = run(args).unwrap();\n        assert!(matches!(result, ReadOutput::Full(_)));\n    }\n\n    #[test]\n    fn run_returns_interface() {\n        let args = ReadArgs {\n            path: concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/src/main.rs\").to_string(),\n            outline: false,\n            interface: true,\n            around: None,\n            context: 10,\n            diff: false,\n            commit: \"HEAD\".to_string(),\n        };\n        let result = run(args).unwrap();\n        assert!(matches!(result, ReadOutput::Interface(_)));\n    }\n\n    #[test]\n    fn run_returns_diff() {\n        let args = ReadArgs {\n            path: concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/Cargo.toml\").to_string(),\n            outline: false,\n            interface: false,\n            around: None,\n            context: 10,\n            diff: true,\n            commit: \"HEAD\".to_string(),\n        };\n        let result = run(args).unwrap();\n        assert!(matches!(result, ReadOutput::Diff(_)));\n    }\n\n    #[test]\n    fn run_diff_specific_commit() {\n        let args = ReadArgs {\n            path: concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/Cargo.toml\").to_string(),\n            outline: false,\n            interface: false,\n            around: None,\n            context: 10,\n            diff: true,\n            commit: \"HEAD~1\".to_string(),\n        };\n        // This may fail if HEAD~1 doesn't exist, but shouldn't panic\n        let _ = run(args);\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":6}},{"line":14,"address":[],"length":0,"stats":{"Line":18}},{"line":15,"address":[],"length":0,"stats":{"Line":18}},{"line":16,"address":[],"length":0,"stats":{"Line":6}},{"line":18,"address":[],"length":0,"stats":{"Line":7}},{"line":20,"address":[],"length":0,"stats":{"Line":5}},{"line":21,"address":[],"length":0,"stats":{"Line":1}},{"line":22,"address":[],"length":0,"stats":{"Line":2}},{"line":23,"address":[],"length":0,"stats":{"Line":1}},{"line":24,"address":[],"length":0,"stats":{"Line":1}},{"line":26,"address":[],"length":0,"stats":{"Line":5}},{"line":28,"address":[],"length":0,"stats":{"Line":4}},{"line":29,"address":[],"length":0,"stats":{"Line":1}},{"line":31,"address":[],"length":0,"stats":{"Line":1}},{"line":33,"address":[],"length":0,"stats":{"Line":10}},{"line":34,"address":[],"length":0,"stats":{"Line":2}},{"line":35,"address":[],"length":0,"stats":{"Line":3}},{"line":37,"address":[],"length":0,"stats":{"Line":5}},{"line":38,"address":[],"length":0,"stats":{"Line":1}},{"line":39,"address":[],"length":0,"stats":{"Line":2}},{"line":41,"address":[],"length":0,"stats":{"Line":5}},{"line":42,"address":[],"length":0,"stats":{"Line":1}},{"line":45,"address":[],"length":0,"stats":{"Line":1}},{"line":50,"address":[],"length":0,"stats":{"Line":9}},{"line":51,"address":[],"length":0,"stats":{"Line":27}},{"line":52,"address":[],"length":0,"stats":{"Line":18}},{"line":53,"address":[],"length":0,"stats":{"Line":7}},{"line":55,"address":[],"length":0,"stats":{"Line":6}},{"line":56,"address":[],"length":0,"stats":{"Line":6}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":60,"address":[],"length":0,"stats":{"Line":1}}],"covered":32,"coverable":32},{"path":["/","Users","chi","Projects","hu","src","read","types.rs"],"content":"/// An item in a file outline (function, struct, class, heading, etc.)\n#[derive(Debug, Clone, PartialEq)]\npub struct OutlineItem {\n    /// Line number where this item starts (1-indexed)\n    pub line: usize,\n    /// The signature or heading text\n    pub text: String,\n    /// Indent level (0 for top-level)\n    pub level: usize,\n    /// Kind of item (function, struct, class, heading, etc.)\n    pub kind: ItemKind,\n}\n\nimpl OutlineItem {\n    pub fn new(line: usize, text: String, level: usize, kind: ItemKind) -\u003e Self {\n        Self {\n            line,\n            text,\n            level,\n            kind,\n        }\n    }\n}\n\n/// Kind of outline item\n#[derive(Debug, Clone, PartialEq)]\npub enum ItemKind {\n    Function,\n    Struct,\n    Enum,\n    Trait,\n    Impl,\n    Class,\n    Module,\n    Const,\n    Type,\n    Heading(u8), // Heading level (1-6)\n    Other,\n}\n\nimpl ItemKind {\n    pub fn icon(\u0026self) -\u003e \u0026'static str {\n        match self {\n            ItemKind::Function =\u003e \"fn\",\n            ItemKind::Struct =\u003e \"struct\",\n            ItemKind::Enum =\u003e \"enum\",\n            ItemKind::Trait =\u003e \"trait\",\n            ItemKind::Impl =\u003e \"impl\",\n            ItemKind::Class =\u003e \"class\",\n            ItemKind::Module =\u003e \"mod\",\n            ItemKind::Const =\u003e \"const\",\n            ItemKind::Type =\u003e \"type\",\n            ItemKind::Heading(n) =\u003e match n {\n                1 =\u003e \"#\",\n                2 =\u003e \"##\",\n                3 =\u003e \"###\",\n                _ =\u003e \"####\",\n            },\n            ItemKind::Other =\u003e \"\",\n        }\n    }\n}\n\n/// File outline (collection of items)\n#[derive(Debug, Clone, Default)]\npub struct FileOutline {\n    pub items: Vec\u003cOutlineItem\u003e,\n}\n\nimpl FileOutline {\n    pub fn new() -\u003e Self {\n        Self { items: Vec::new() }\n    }\n\n    pub fn push(\u0026mut self, item: OutlineItem) {\n        self.items.push(item);\n    }\n\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.items.is_empty()\n    }\n\n    #[cfg(test)]\n    pub fn len(\u0026self) -\u003e usize {\n        self.items.len()\n    }\n}\n\n/// Result of reading a file with options\n#[derive(Debug, Clone)]\npub enum ReadOutput {\n    /// Full file content\n    Full(String),\n    /// File outline (signatures)\n    Outline(FileOutline),\n    /// Public interface only\n    Interface(Vec\u003cOutlineItem\u003e),\n    /// Lines around a specific line\n    Around {\n        lines: Vec\u003c(usize, String)\u003e,\n        center: usize,\n        total_lines: usize,\n    },\n    /// Git diff output\n    Diff(String),\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn outline_item_new() {\n        let item = OutlineItem::new(10, \"fn test()\".to_string(), 0, ItemKind::Function);\n        assert_eq!(item.line, 10);\n        assert_eq!(item.text, \"fn test()\");\n        assert_eq!(item.level, 0);\n        assert_eq!(item.kind, ItemKind::Function);\n    }\n\n    #[test]\n    fn outline_item_clone() {\n        let item = OutlineItem::new(1, \"test\".to_string(), 0, ItemKind::Function);\n        let cloned = item.clone();\n        assert_eq!(item, cloned);\n    }\n\n    #[test]\n    fn outline_item_debug() {\n        let item = OutlineItem::new(1, \"test\".to_string(), 0, ItemKind::Function);\n        let debug = format!(\"{:?}\", item);\n        assert!(debug.contains(\"OutlineItem\"));\n    }\n\n    #[test]\n    fn item_kind_icon_function() {\n        assert_eq!(ItemKind::Function.icon(), \"fn\");\n    }\n\n    #[test]\n    fn item_kind_icon_struct() {\n        assert_eq!(ItemKind::Struct.icon(), \"struct\");\n    }\n\n    #[test]\n    fn item_kind_icon_enum() {\n        assert_eq!(ItemKind::Enum.icon(), \"enum\");\n    }\n\n    #[test]\n    fn item_kind_icon_trait() {\n        assert_eq!(ItemKind::Trait.icon(), \"trait\");\n    }\n\n    #[test]\n    fn item_kind_icon_impl() {\n        assert_eq!(ItemKind::Impl.icon(), \"impl\");\n    }\n\n    #[test]\n    fn item_kind_icon_class() {\n        assert_eq!(ItemKind::Class.icon(), \"class\");\n    }\n\n    #[test]\n    fn item_kind_icon_module() {\n        assert_eq!(ItemKind::Module.icon(), \"mod\");\n    }\n\n    #[test]\n    fn item_kind_icon_const() {\n        assert_eq!(ItemKind::Const.icon(), \"const\");\n    }\n\n    #[test]\n    fn item_kind_icon_type() {\n        assert_eq!(ItemKind::Type.icon(), \"type\");\n    }\n\n    #[test]\n    fn item_kind_icon_other() {\n        assert_eq!(ItemKind::Other.icon(), \"\");\n    }\n\n    #[test]\n    fn item_kind_icon_heading() {\n        assert_eq!(ItemKind::Heading(1).icon(), \"#\");\n        assert_eq!(ItemKind::Heading(2).icon(), \"##\");\n        assert_eq!(ItemKind::Heading(3).icon(), \"###\");\n        assert_eq!(ItemKind::Heading(4).icon(), \"####\");\n        assert_eq!(ItemKind::Heading(5).icon(), \"####\");\n        assert_eq!(ItemKind::Heading(6).icon(), \"####\");\n    }\n\n    #[test]\n    fn item_kind_clone() {\n        let kind = ItemKind::Function;\n        let cloned = kind.clone();\n        assert_eq!(kind, cloned);\n    }\n\n    #[test]\n    fn item_kind_debug() {\n        let kind = ItemKind::Struct;\n        let debug = format!(\"{:?}\", kind);\n        assert!(debug.contains(\"Struct\"));\n    }\n\n    #[test]\n    fn file_outline_new() {\n        let outline = FileOutline::new();\n        assert!(outline.is_empty());\n        assert_eq!(outline.len(), 0);\n    }\n\n    #[test]\n    fn file_outline_default() {\n        let outline = FileOutline::default();\n        assert!(outline.is_empty());\n    }\n\n    #[test]\n    fn file_outline_push() {\n        let mut outline = FileOutline::new();\n        outline.push(OutlineItem::new(\n            1,\n            \"test\".to_string(),\n            0,\n            ItemKind::Function,\n        ));\n        assert_eq!(outline.len(), 1);\n        assert!(!outline.is_empty());\n    }\n\n    #[test]\n    fn file_outline_clone() {\n        let mut outline = FileOutline::new();\n        outline.push(OutlineItem::new(\n            1,\n            \"test\".to_string(),\n            0,\n            ItemKind::Function,\n        ));\n        let cloned = outline.clone();\n        assert_eq!(outline.len(), cloned.len());\n    }\n\n    #[test]\n    fn file_outline_debug() {\n        let outline = FileOutline::new();\n        let debug = format!(\"{:?}\", outline);\n        assert!(debug.contains(\"FileOutline\"));\n    }\n\n    #[test]\n    fn read_output_full() {\n        let output = ReadOutput::Full(\"content\".to_string());\n        assert!(matches!(output, ReadOutput::Full(_)));\n    }\n\n    #[test]\n    fn read_output_outline() {\n        let output = ReadOutput::Outline(FileOutline::new());\n        assert!(matches!(output, ReadOutput::Outline(_)));\n    }\n\n    #[test]\n    fn read_output_interface() {\n        let output = ReadOutput::Interface(vec![]);\n        assert!(matches!(output, ReadOutput::Interface(_)));\n    }\n\n    #[test]\n    fn read_output_around() {\n        let output = ReadOutput::Around {\n            lines: vec![(1, \"line\".to_string())],\n            center: 1,\n            total_lines: 10,\n        };\n        assert!(matches!(output, ReadOutput::Around { .. }));\n    }\n\n    #[test]\n    fn read_output_diff() {\n        let output = ReadOutput::Diff(\"diff output\".to_string());\n        assert!(matches!(output, ReadOutput::Diff(_)));\n    }\n\n    #[test]\n    fn read_output_clone() {\n        let output = ReadOutput::Full(\"test\".to_string());\n        let cloned = output.clone();\n        if let (ReadOutput::Full(a), ReadOutput::Full(b)) = (output, cloned) {\n            assert_eq!(a, b);\n        } else {\n            panic!(\"Expected Full\");\n        }\n    }\n\n    #[test]\n    fn read_output_debug() {\n        let output = ReadOutput::Diff(\"test\".to_string());\n        let debug = format!(\"{:?}\", output);\n        assert!(debug.contains(\"Diff\"));\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":79}},{"line":42,"address":[],"length":0,"stats":{"Line":20}},{"line":43,"address":[],"length":0,"stats":{"Line":20}},{"line":44,"address":[],"length":0,"stats":{"Line":4}},{"line":45,"address":[],"length":0,"stats":{"Line":1}},{"line":46,"address":[],"length":0,"stats":{"Line":1}},{"line":47,"address":[],"length":0,"stats":{"Line":1}},{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":1}},{"line":50,"address":[],"length":0,"stats":{"Line":1}},{"line":51,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":1}},{"line":53,"address":[],"length":0,"stats":{"Line":12}},{"line":54,"address":[],"length":0,"stats":{"Line":1}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":3}},{"line":59,"address":[],"length":0,"stats":{"Line":1}},{"line":71,"address":[],"length":0,"stats":{"Line":41}},{"line":72,"address":[],"length":0,"stats":{"Line":41}},{"line":75,"address":[],"length":0,"stats":{"Line":45}},{"line":76,"address":[],"length":0,"stats":{"Line":135}},{"line":79,"address":[],"length":0,"stats":{"Line":8}},{"line":80,"address":[],"length":0,"stats":{"Line":16}},{"line":84,"address":[],"length":0,"stats":{"Line":34}},{"line":85,"address":[],"length":0,"stats":{"Line":68}}],"covered":26,"coverable":26},{"path":["/","Users","chi","Projects","hu","src","sentry","client.rs"],"content":"//! Sentry HTTP client\n\nuse anyhow::Result;\nuse reqwest::Client;\nuse serde::de::DeserializeOwned;\nuse std::future::Future;\nuse std::time::Duration;\nuse tokio::time::sleep;\n\nuse super::config::{load_config, SentryConfig};\nuse super::types::{Event, Issue};\n\nconst SENTRY_API_URL: \u0026str = \"https://sentry.io/api/0\";\nconst MAX_RETRIES: u32 = 3;\nconst DEFAULT_RETRY_SECS: u64 = 5;\n\n/// Trait for Sentry API operations (enables testing with mocks)\npub trait SentryApi {\n    /// List issues for organization\n    fn list_issues(\n        \u0026self,\n        query: Option\u003c\u0026str\u003e,\n        limit: usize,\n    ) -\u003e impl Future\u003cOutput = Result\u003cVec\u003cIssue\u003e\u003e\u003e + Send;\n\n    /// List issues for a specific project\n    fn list_project_issues(\n        \u0026self,\n        project: \u0026str,\n        query: Option\u003c\u0026str\u003e,\n        limit: usize,\n    ) -\u003e impl Future\u003cOutput = Result\u003cVec\u003cIssue\u003e\u003e\u003e + Send;\n\n    /// Get a single issue by ID\n    fn get_issue(\u0026self, issue_id: \u0026str) -\u003e impl Future\u003cOutput = Result\u003cIssue\u003e\u003e + Send;\n\n    /// List events for an issue\n    fn list_issue_events(\n        \u0026self,\n        issue_id: \u0026str,\n        limit: usize,\n    ) -\u003e impl Future\u003cOutput = Result\u003cVec\u003cEvent\u003e\u003e\u003e + Send;\n}\n\n/// Sentry API client\npub struct SentryClient {\n    config: SentryConfig,\n    http: Client,\n}\n\nimpl SentryClient {\n    /// Create a new Sentry client\n    pub fn new() -\u003e Result\u003cSelf\u003e {\n        let config = load_config()?;\n        let http = Client::builder().user_agent(\"hu-cli/0.1.0\").build()?;\n        Ok(Self { config, http })\n    }\n\n    /// Get auth token\n    fn auth_token(\u0026self) -\u003e Result\u003c\u0026str\u003e {\n        self.config\n            .auth_token\n            .as_deref()\n            .ok_or_else(|| anyhow::anyhow!(\"Sentry auth_token not configured\"))\n    }\n\n    /// Get organization slug\n    fn organization(\u0026self) -\u003e Result\u003c\u0026str\u003e {\n        self.config\n            .organization\n            .as_deref()\n            .ok_or_else(|| anyhow::anyhow!(\"Sentry organization not configured\"))\n    }\n\n    /// List issues for organization\n    pub async fn list_issues(\u0026self, query: Option\u003c\u0026str\u003e, limit: usize) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n        let org = self.organization()?;\n        let url = format!(\"{}/organizations/{}/issues/\", SENTRY_API_URL, org);\n\n        let mut params = vec![(\"limit\", limit.to_string())];\n        if let Some(q) = query {\n            params.push((\"query\", q.to_string()));\n        }\n\n        self.get_with_params(\u0026url, \u0026params).await\n    }\n\n    /// List issues for a specific project\n    pub async fn list_project_issues(\n        \u0026self,\n        project: \u0026str,\n        query: Option\u003c\u0026str\u003e,\n        limit: usize,\n    ) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n        let org = self.organization()?;\n        let url = format!(\"{}/projects/{}/{}/issues/\", SENTRY_API_URL, org, project);\n\n        let mut params = vec![(\"limit\", limit.to_string())];\n        if let Some(q) = query {\n            params.push((\"query\", q.to_string()));\n        }\n\n        self.get_with_params(\u0026url, \u0026params).await\n    }\n\n    /// Get a single issue by ID\n    pub async fn get_issue(\u0026self, issue_id: \u0026str) -\u003e Result\u003cIssue\u003e {\n        let org = self.organization()?;\n        let url = format!(\n            \"{}/organizations/{}/issues/{}/\",\n            SENTRY_API_URL, org, issue_id\n        );\n\n        self.get(\u0026url).await\n    }\n\n    /// List events for an issue\n    pub async fn list_issue_events(\u0026self, issue_id: \u0026str, limit: usize) -\u003e Result\u003cVec\u003cEvent\u003e\u003e {\n        let org = self.organization()?;\n        let url = format!(\n            \"{}/organizations/{}/issues/{}/events/\",\n            SENTRY_API_URL, org, issue_id\n        );\n\n        self.get_with_params(\u0026url, \u0026[(\"limit\", limit.to_string())])\n            .await\n    }\n\n    /// Make a GET request\n    async fn get\u003cT: DeserializeOwned\u003e(\u0026self, url: \u0026str) -\u003e Result\u003cT\u003e {\n        let token = self.auth_token()?.to_string();\n\n        self.execute_with_retry(|| {\n            self.http\n                .get(url)\n                .header(\"Authorization\", format!(\"Bearer {}\", token))\n                .send()\n        })\n        .await\n    }\n\n    /// Make a GET request with parameters\n    async fn get_with_params\u003cT: DeserializeOwned\u003e(\n        \u0026self,\n        url: \u0026str,\n        params: \u0026[(\u0026str, String)],\n    ) -\u003e Result\u003cT\u003e {\n        let token = self.auth_token()?.to_string();\n        let params: Vec\u003c(String, String)\u003e = params\n            .iter()\n            .map(|(k, v)| (k.to_string(), v.clone()))\n            .collect();\n\n        self.execute_with_retry(|| {\n            self.http\n                .get(url)\n                .header(\"Authorization\", format!(\"Bearer {}\", token))\n                .query(\u0026params)\n                .send()\n        })\n        .await\n    }\n\n    /// Execute request with retry on rate limit\n    async fn execute_with_retry\u003cF, Fut, T\u003e(\u0026self, request_fn: F) -\u003e Result\u003cT\u003e\n    where\n        F: Fn() -\u003e Fut,\n        Fut: std::future::Future\u003cOutput = Result\u003creqwest::Response, reqwest::Error\u003e\u003e,\n        T: DeserializeOwned,\n    {\n        let mut retries = 0;\n\n        loop {\n            let response = request_fn().await?;\n            let status = response.status();\n\n            if status == reqwest::StatusCode::TOO_MANY_REQUESTS {\n                if retries \u003e= MAX_RETRIES {\n                    return Err(anyhow::anyhow!(\n                        \"Rate limited after {} retries\",\n                        MAX_RETRIES\n                    ));\n                }\n\n                let retry_after = response\n                    .headers()\n                    .get(\"retry-after\")\n                    .and_then(|v| v.to_str().ok())\n                    .and_then(|s| s.parse::\u003cu64\u003e().ok())\n                    .unwrap_or(DEFAULT_RETRY_SECS);\n\n                eprintln!(\n                    \"Rate limited, waiting {} seconds... (retry {}/{})\",\n                    retry_after,\n                    retries + 1,\n                    MAX_RETRIES\n                );\n                sleep(Duration::from_secs(retry_after)).await;\n                retries += 1;\n                continue;\n            }\n\n            if !status.is_success() {\n                let body = response.text().await.unwrap_or_default();\n                return Err(anyhow::anyhow!(\"HTTP {}: {}\", status.as_u16(), body));\n            }\n\n            let text = response.text().await?;\n            return serde_json::from_str(\u0026text).map_err(|e| {\n                anyhow::anyhow!(\"Parse error: {}: {}\", e, \u0026text[..text.len().min(200)])\n            });\n        }\n    }\n}\n\nimpl SentryApi for SentryClient {\n    async fn list_issues(\u0026self, query: Option\u003c\u0026str\u003e, limit: usize) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n        SentryClient::list_issues(self, query, limit).await\n    }\n\n    async fn list_project_issues(\n        \u0026self,\n        project: \u0026str,\n        query: Option\u003c\u0026str\u003e,\n        limit: usize,\n    ) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n        SentryClient::list_project_issues(self, project, query, limit).await\n    }\n\n    async fn get_issue(\u0026self, issue_id: \u0026str) -\u003e Result\u003cIssue\u003e {\n        SentryClient::get_issue(self, issue_id).await\n    }\n\n    async fn list_issue_events(\u0026self, issue_id: \u0026str, limit: usize) -\u003e Result\u003cVec\u003cEvent\u003e\u003e {\n        SentryClient::list_issue_events(self, issue_id, limit).await\n    }\n}\n","traces":[{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":90},{"path":["/","Users","chi","Projects","hu","src","sentry","config.rs"],"content":"//! Sentry configuration\n//!\n//! Loads configuration from `~/.config/hu/settings.toml`\n\nuse anyhow::Result;\nuse serde::{Deserialize, Serialize};\nuse std::fs;\nuse std::path::PathBuf;\n\n/// Sentry configuration\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct SentryConfig {\n    /// Auth token\n    pub auth_token: Option\u003cString\u003e,\n    /// Organization slug\n    pub organization: Option\u003cString\u003e,\n    /// Default project slug\n    pub project: Option\u003cString\u003e,\n}\n\nimpl SentryConfig {\n    /// Check if configured with auth token\n    #[must_use]\n    pub fn is_configured(\u0026self) -\u003e bool {\n        self.auth_token.is_some() \u0026\u0026 self.organization.is_some()\n    }\n}\n\n/// Settings file structure\n#[derive(Debug, Default, Deserialize)]\nstruct SettingsFile {\n    sentry: Option\u003cSentryConfig\u003e,\n}\n\n/// Get path to config file\npub fn config_path() -\u003e Option\u003cPathBuf\u003e {\n    dirs::home_dir().map(|p| p.join(\".config\").join(\"hu\").join(\"settings.toml\"))\n}\n\n/// Load Sentry config from settings file and environment\npub fn load_config() -\u003e Result\u003cSentryConfig\u003e {\n    let mut config = SentryConfig::default();\n\n    // Load from settings file\n    if let Some(path) = config_path() {\n        if path.exists() {\n            let contents = fs::read_to_string(\u0026path)?;\n            let settings: SettingsFile = toml::from_str(\u0026contents)?;\n            if let Some(sentry) = settings.sentry {\n                config = sentry;\n            }\n        }\n    }\n\n    // Override with environment variables\n    if let Ok(token) = std::env::var(\"SENTRY_AUTH_TOKEN\") {\n        config.auth_token = Some(token);\n    }\n    if let Ok(org) = std::env::var(\"SENTRY_ORG\") {\n        config.organization = Some(org);\n    }\n    if let Ok(project) = std::env::var(\"SENTRY_PROJECT\") {\n        config.project = Some(project);\n    }\n\n    Ok(config)\n}\n\n/// Save auth token to config file\npub fn save_auth_token(token: \u0026str, org: \u0026str) -\u003e Result\u003c()\u003e {\n    let path = config_path().ok_or_else(|| anyhow::anyhow!(\"Cannot determine config directory\"))?;\n\n    // Read existing or create new\n    let contents = if path.exists() {\n        fs::read_to_string(\u0026path)?\n    } else {\n        String::new()\n    };\n\n    // Parse as TOML value\n    let mut doc: toml::Value =\n        toml::from_str(\u0026contents).unwrap_or_else(|_| toml::Value::Table(toml::map::Map::new()));\n\n    // Ensure sentry section exists\n    let table = doc\n        .as_table_mut()\n        .ok_or_else(|| anyhow::anyhow!(\"Config is not a table\"))?;\n\n    if !table.contains_key(\"sentry\") {\n        table.insert(\n            \"sentry\".to_string(),\n            toml::Value::Table(toml::map::Map::new()),\n        );\n    }\n\n    let sentry = table\n        .get_mut(\"sentry\")\n        .and_then(|v| v.as_table_mut())\n        .ok_or_else(|| anyhow::anyhow!(\"sentry section is not a table\"))?;\n\n    sentry.insert(\n        \"auth_token\".to_string(),\n        toml::Value::String(token.to_string()),\n    );\n    sentry.insert(\n        \"organization\".to_string(),\n        toml::Value::String(org.to_string()),\n    );\n\n    // Write back\n    let output = toml::to_string_pretty(\u0026doc)?;\n\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent)?;\n    }\n\n    fs::write(\u0026path, output)?;\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_sentry_config_is_configured_both_set() {\n        let config = SentryConfig {\n            auth_token: Some(\"token\".to_string()),\n            organization: Some(\"my-org\".to_string()),\n            project: None,\n        };\n        assert!(config.is_configured());\n    }\n\n    #[test]\n    fn test_sentry_config_is_configured_only_token() {\n        let config = SentryConfig {\n            auth_token: Some(\"token\".to_string()),\n            organization: None,\n            project: None,\n        };\n        assert!(!config.is_configured());\n    }\n\n    #[test]\n    fn test_sentry_config_is_configured_only_org() {\n        let config = SentryConfig {\n            auth_token: None,\n            organization: Some(\"my-org\".to_string()),\n            project: None,\n        };\n        assert!(!config.is_configured());\n    }\n\n    #[test]\n    fn test_sentry_config_is_configured_neither() {\n        let config = SentryConfig {\n            auth_token: None,\n            organization: None,\n            project: None,\n        };\n        assert!(!config.is_configured());\n    }\n\n    #[test]\n    fn test_sentry_config_default() {\n        let config = SentryConfig::default();\n        assert!(config.auth_token.is_none());\n        assert!(config.organization.is_none());\n        assert!(config.project.is_none());\n        assert!(!config.is_configured());\n    }\n\n    #[test]\n    fn test_config_path_returns_some() {\n        let path = config_path();\n        if let Some(p) = path {\n            assert!(p.to_string_lossy().contains(\"settings.toml\"));\n        }\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":9}},{"line":25,"address":[],"length":0,"stats":{"Line":26}},{"line":36,"address":[],"length":0,"stats":{"Line":2}},{"line":37,"address":[],"length":0,"stats":{"Line":8}},{"line":41,"address":[],"length":0,"stats":{"Line":1}},{"line":42,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":1}},{"line":47,"address":[],"length":0,"stats":{"Line":3}},{"line":48,"address":[],"length":0,"stats":{"Line":4}},{"line":49,"address":[],"length":0,"stats":{"Line":1}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":1}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":1}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":1}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}}],"covered":15,"coverable":46},{"path":["/","Users","chi","Projects","hu","src","sentry","display","mod.rs"],"content":"//! Sentry output formatting\n\nuse anyhow::{Context, Result};\nuse comfy_table::{presets::UTF8_FULL_CONDENSED, Cell, Color, ContentArrangement, Table};\n\nuse super::types::{Event, Issue, OutputFormat};\n\n#[cfg(test)]\nmod tests;\n\n/// Format relative time\nfn time_ago(timestamp: \u0026str) -\u003e String {\n    let Ok(dt) = chrono::DateTime::parse_from_rfc3339(timestamp) else {\n        return timestamp.to_string();\n    };\n\n    let now = chrono::Utc::now();\n    let duration = now.signed_duration_since(dt);\n\n    if duration.num_days() \u003e 0 {\n        format!(\"{}d ago\", duration.num_days())\n    } else if duration.num_hours() \u003e 0 {\n        format!(\"{}h ago\", duration.num_hours())\n    } else if duration.num_minutes() \u003e 0 {\n        format!(\"{}m ago\", duration.num_minutes())\n    } else {\n        \"just now\".to_string()\n    }\n}\n\n/// Truncate string\nfn truncate(s: \u0026str, max_len: usize) -\u003e String {\n    if s.len() \u003c= max_len {\n        s.to_string()\n    } else {\n        format!(\"{}...\", \u0026s[..max_len.saturating_sub(3)])\n    }\n}\n\n/// Color for issue level\nfn level_color(level: \u0026str) -\u003e Color {\n    match level {\n        \"error\" =\u003e Color::Red,\n        \"warning\" =\u003e Color::Yellow,\n        \"info\" =\u003e Color::Blue,\n        _ =\u003e Color::White,\n    }\n}\n\n/// Color for issue status\n#[allow(dead_code)]\nfn status_color(status: \u0026str) -\u003e Color {\n    match status {\n        \"resolved\" =\u003e Color::Green,\n        \"ignored\" =\u003e Color::DarkGrey,\n        _ =\u003e Color::White,\n    }\n}\n\n/// Output issues list\npub fn output_issues(issues: \u0026[Issue], format: OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            if issues.is_empty() {\n                println!(\"No issues found.\");\n                return Ok(());\n            }\n\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_content_arrangement(ContentArrangement::Dynamic);\n            table.set_header(vec![\"ID\", \"Level\", \"Title\", \"Events\", \"Users\", \"Last Seen\"]);\n\n            for issue in issues {\n                table.add_row(vec![\n                    Cell::new(\u0026issue.short_id).fg(Color::Cyan),\n                    Cell::new(\u0026issue.level).fg(level_color(\u0026issue.level)),\n                    Cell::new(truncate(\u0026issue.title, 50)),\n                    Cell::new(\u0026issue.count),\n                    Cell::new(issue.user_count.to_string()),\n                    Cell::new(time_ago(\u0026issue.last_seen)),\n                ]);\n            }\n\n            println!(\"{table}\");\n            println!(\"\\n{} issues\", issues.len());\n        }\n        OutputFormat::Json =\u003e {\n            let json =\n                serde_json::to_string_pretty(issues).context(\"Failed to serialize issues\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n\n/// Output single issue detail\npub fn output_issue_detail(issue: \u0026Issue, format: OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            println!(\"{}\", \"-\".repeat(60));\n            println!(\"{} - {}\", issue.short_id, issue.title);\n            println!(\"{}\", \"-\".repeat(60));\n            println!(\n                \"Project:    {} ({})\",\n                issue.project.name, issue.project.slug\n            );\n            println!(\"Level:      {}\", issue.level);\n            println!(\"Status:     {}\", issue.status);\n            println!(\"Platform:   {}\", issue.platform);\n            println!(\"Events:     {}\", issue.count);\n            println!(\"Users:      {}\", issue.user_count);\n            println!(\"First seen: {}\", time_ago(\u0026issue.first_seen));\n            println!(\"Last seen:  {}\", time_ago(\u0026issue.last_seen));\n\n            if !issue.culprit.is_empty() {\n                println!(\"\\nCulprit: {}\", issue.culprit);\n            }\n\n            if !issue.metadata.error_type.is_empty() || !issue.metadata.value.is_empty() {\n                println!(\"\\nError:\");\n                if !issue.metadata.error_type.is_empty() {\n                    println!(\"  Type: {}\", issue.metadata.error_type);\n                }\n                if !issue.metadata.value.is_empty() {\n                    println!(\"  Message: {}\", issue.metadata.value);\n                }\n                if !issue.metadata.filename.is_empty() {\n                    println!(\"  File: {}\", issue.metadata.filename);\n                }\n                if !issue.metadata.function.is_empty() {\n                    println!(\"  Function: {}\", issue.metadata.function);\n                }\n            }\n\n            println!(\"\\nLink: {}\", issue.permalink);\n        }\n        OutputFormat::Json =\u003e {\n            let json = serde_json::to_string_pretty(issue).context(\"Failed to serialize issue\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n\n/// Output events list\npub fn output_events(events: \u0026[Event], format: OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            if events.is_empty() {\n                println!(\"No events found.\");\n                return Ok(());\n            }\n\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_content_arrangement(ContentArrangement::Dynamic);\n            table.set_header(vec![\"Event ID\", \"Time\", \"User\", \"Message\"]);\n\n            for event in events {\n                let user = event\n                    .user\n                    .as_ref()\n                    .and_then(|u| u.email.as_ref().or(u.username.as_ref()).or(u.id.as_ref()))\n                    .map(|s| s.as_str())\n                    .unwrap_or(\"-\");\n\n                let message = if event.message.is_empty() {\n                    \u0026event.title\n                } else {\n                    \u0026event.message\n                };\n\n                let event_id_short = if event.id.len() \u003e 12 {\n                    \u0026event.id[..12]\n                } else {\n                    \u0026event.id\n                };\n                let date = event.date_created.as_deref().unwrap_or(\"-\");\n\n                table.add_row(vec![\n                    Cell::new(event_id_short).fg(Color::Cyan),\n                    Cell::new(time_ago(date)),\n                    Cell::new(truncate(user, 20)),\n                    Cell::new(truncate(message, 40)),\n                ]);\n            }\n\n            println!(\"{table}\");\n            println!(\"\\n{} events\", events.len());\n        }\n        OutputFormat::Json =\u003e {\n            let json =\n                serde_json::to_string_pretty(events).context(\"Failed to serialize events\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n\n/// Output config status\npub fn output_config_status(config: \u0026super::config::SentryConfig) {\n    println!(\"Sentry Configuration\");\n    println!(\"{}\", \"-\".repeat(40));\n    println!(\n        \"Auth token:   {}\",\n        if config.auth_token.is_some() {\n            \"Yes\"\n        } else {\n            \"No\"\n        }\n    );\n    println!(\n        \"Organization: {}\",\n        config.organization.as_deref().unwrap_or(\"Not set\")\n    );\n    println!(\n        \"Project:      {}\",\n        config.project.as_deref().unwrap_or(\"Not set\")\n    );\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":15}},{"line":13,"address":[],"length":0,"stats":{"Line":29}},{"line":14,"address":[],"length":0,"stats":{"Line":2}},{"line":17,"address":[],"length":0,"stats":{"Line":28}},{"line":18,"address":[],"length":0,"stats":{"Line":56}},{"line":20,"address":[],"length":0,"stats":{"Line":14}},{"line":21,"address":[],"length":0,"stats":{"Line":4}},{"line":22,"address":[],"length":0,"stats":{"Line":13}},{"line":23,"address":[],"length":0,"stats":{"Line":4}},{"line":24,"address":[],"length":0,"stats":{"Line":12}},{"line":25,"address":[],"length":0,"stats":{"Line":4}},{"line":27,"address":[],"length":0,"stats":{"Line":22}},{"line":32,"address":[],"length":0,"stats":{"Line":10}},{"line":33,"address":[],"length":0,"stats":{"Line":20}},{"line":34,"address":[],"length":0,"stats":{"Line":18}},{"line":36,"address":[],"length":0,"stats":{"Line":4}},{"line":41,"address":[],"length":0,"stats":{"Line":5}},{"line":42,"address":[],"length":0,"stats":{"Line":5}},{"line":43,"address":[],"length":0,"stats":{"Line":7}},{"line":44,"address":[],"length":0,"stats":{"Line":4}},{"line":45,"address":[],"length":0,"stats":{"Line":3}},{"line":46,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":3}},{"line":53,"address":[],"length":0,"stats":{"Line":3}},{"line":54,"address":[],"length":0,"stats":{"Line":4}},{"line":55,"address":[],"length":0,"stats":{"Line":3}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":61,"address":[],"length":0,"stats":{"Line":3}},{"line":62,"address":[],"length":0,"stats":{"Line":3}},{"line":64,"address":[],"length":0,"stats":{"Line":4}},{"line":65,"address":[],"length":0,"stats":{"Line":2}},{"line":66,"address":[],"length":0,"stats":{"Line":1}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":3}},{"line":71,"address":[],"length":0,"stats":{"Line":3}},{"line":72,"address":[],"length":0,"stats":{"Line":8}},{"line":74,"address":[],"length":0,"stats":{"Line":4}},{"line":75,"address":[],"length":0,"stats":{"Line":4}},{"line":76,"address":[],"length":0,"stats":{"Line":5}},{"line":77,"address":[],"length":0,"stats":{"Line":6}},{"line":78,"address":[],"length":0,"stats":{"Line":4}},{"line":79,"address":[],"length":0,"stats":{"Line":3}},{"line":80,"address":[],"length":0,"stats":{"Line":4}},{"line":81,"address":[],"length":0,"stats":{"Line":2}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":4}},{"line":89,"address":[],"length":0,"stats":{"Line":1}},{"line":90,"address":[],"length":0,"stats":{"Line":3}},{"line":91,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":2}},{"line":98,"address":[],"length":0,"stats":{"Line":4}},{"line":99,"address":[],"length":0,"stats":{"Line":4}},{"line":101,"address":[],"length":0,"stats":{"Line":12}},{"line":102,"address":[],"length":0,"stats":{"Line":6}},{"line":103,"address":[],"length":0,"stats":{"Line":12}},{"line":104,"address":[],"length":0,"stats":{"Line":3}},{"line":105,"address":[],"length":0,"stats":{"Line":3}},{"line":108,"address":[],"length":0,"stats":{"Line":6}},{"line":109,"address":[],"length":0,"stats":{"Line":6}},{"line":110,"address":[],"length":0,"stats":{"Line":6}},{"line":111,"address":[],"length":0,"stats":{"Line":6}},{"line":112,"address":[],"length":0,"stats":{"Line":6}},{"line":113,"address":[],"length":0,"stats":{"Line":12}},{"line":114,"address":[],"length":0,"stats":{"Line":12}},{"line":116,"address":[],"length":0,"stats":{"Line":5}},{"line":117,"address":[],"length":0,"stats":{"Line":2}},{"line":120,"address":[],"length":0,"stats":{"Line":4}},{"line":121,"address":[],"length":0,"stats":{"Line":4}},{"line":122,"address":[],"length":0,"stats":{"Line":4}},{"line":123,"address":[],"length":0,"stats":{"Line":2}},{"line":125,"address":[],"length":0,"stats":{"Line":3}},{"line":126,"address":[],"length":0,"stats":{"Line":1}},{"line":128,"address":[],"length":0,"stats":{"Line":3}},{"line":129,"address":[],"length":0,"stats":{"Line":1}},{"line":131,"address":[],"length":0,"stats":{"Line":4}},{"line":132,"address":[],"length":0,"stats":{"Line":2}},{"line":136,"address":[],"length":0,"stats":{"Line":6}},{"line":139,"address":[],"length":0,"stats":{"Line":4}},{"line":140,"address":[],"length":0,"stats":{"Line":2}},{"line":143,"address":[],"length":0,"stats":{"Line":4}},{"line":147,"address":[],"length":0,"stats":{"Line":4}},{"line":148,"address":[],"length":0,"stats":{"Line":4}},{"line":150,"address":[],"length":0,"stats":{"Line":6}},{"line":151,"address":[],"length":0,"stats":{"Line":2}},{"line":152,"address":[],"length":0,"stats":{"Line":1}},{"line":155,"address":[],"length":0,"stats":{"Line":4}},{"line":156,"address":[],"length":0,"stats":{"Line":6}},{"line":157,"address":[],"length":0,"stats":{"Line":6}},{"line":158,"address":[],"length":0,"stats":{"Line":12}},{"line":160,"address":[],"length":0,"stats":{"Line":8}},{"line":161,"address":[],"length":0,"stats":{"Line":6}},{"line":162,"address":[],"length":0,"stats":{"Line":3}},{"line":164,"address":[],"length":0,"stats":{"Line":27}},{"line":165,"address":[],"length":0,"stats":{"Line":9}},{"line":168,"address":[],"length":0,"stats":{"Line":9}},{"line":169,"address":[],"length":0,"stats":{"Line":1}},{"line":171,"address":[],"length":0,"stats":{"Line":2}},{"line":174,"address":[],"length":0,"stats":{"Line":6}},{"line":175,"address":[],"length":0,"stats":{"Line":1}},{"line":177,"address":[],"length":0,"stats":{"Line":2}},{"line":179,"address":[],"length":0,"stats":{"Line":15}},{"line":181,"address":[],"length":0,"stats":{"Line":9}},{"line":182,"address":[],"length":0,"stats":{"Line":12}},{"line":183,"address":[],"length":0,"stats":{"Line":9}},{"line":184,"address":[],"length":0,"stats":{"Line":9}},{"line":185,"address":[],"length":0,"stats":{"Line":9}},{"line":189,"address":[],"length":0,"stats":{"Line":4}},{"line":190,"address":[],"length":0,"stats":{"Line":8}},{"line":193,"address":[],"length":0,"stats":{"Line":1}},{"line":194,"address":[],"length":0,"stats":{"Line":3}},{"line":195,"address":[],"length":0,"stats":{"Line":2}},{"line":198,"address":[],"length":0,"stats":{"Line":3}},{"line":202,"address":[],"length":0,"stats":{"Line":2}},{"line":203,"address":[],"length":0,"stats":{"Line":4}},{"line":204,"address":[],"length":0,"stats":{"Line":8}},{"line":205,"address":[],"length":0,"stats":{"Line":2}},{"line":206,"address":[],"length":0,"stats":{"Line":2}},{"line":207,"address":[],"length":0,"stats":{"Line":4}},{"line":208,"address":[],"length":0,"stats":{"Line":1}},{"line":210,"address":[],"length":0,"stats":{"Line":1}},{"line":213,"address":[],"length":0,"stats":{"Line":2}},{"line":214,"address":[],"length":0,"stats":{"Line":2}},{"line":215,"address":[],"length":0,"stats":{"Line":8}},{"line":217,"address":[],"length":0,"stats":{"Line":2}},{"line":218,"address":[],"length":0,"stats":{"Line":2}},{"line":219,"address":[],"length":0,"stats":{"Line":8}}],"covered":126,"coverable":126},{"path":["/","Users","chi","Projects","hu","src","sentry","display","tests.rs"],"content":"use super::*;\nuse crate::sentry::types::{EventUser, IssueMetadata, ProjectInfo};\n\n#[test]\nfn test_time_ago_days() {\n    let now = chrono::Utc::now();\n    let two_days_ago = now - chrono::Duration::days(2);\n    let ts = two_days_ago.to_rfc3339();\n    assert_eq!(time_ago(\u0026ts), \"2d ago\");\n}\n\n#[test]\nfn test_time_ago_hours() {\n    let now = chrono::Utc::now();\n    let two_hours_ago = now - chrono::Duration::hours(2);\n    let ts = two_hours_ago.to_rfc3339();\n    assert_eq!(time_ago(\u0026ts), \"2h ago\");\n}\n\n#[test]\nfn test_time_ago_minutes() {\n    let now = chrono::Utc::now();\n    let five_mins_ago = now - chrono::Duration::minutes(5);\n    let ts = five_mins_ago.to_rfc3339();\n    assert_eq!(time_ago(\u0026ts), \"5m ago\");\n}\n\n#[test]\nfn test_time_ago_just_now() {\n    let now = chrono::Utc::now();\n    let ts = now.to_rfc3339();\n    assert_eq!(time_ago(\u0026ts), \"just now\");\n}\n\n#[test]\nfn test_time_ago_invalid() {\n    assert_eq!(time_ago(\"invalid\"), \"invalid\");\n}\n\n#[test]\nfn test_truncate_short() {\n    assert_eq!(truncate(\"hello\", 10), \"hello\");\n}\n\n#[test]\nfn test_truncate_exact() {\n    assert_eq!(truncate(\"hello\", 5), \"hello\");\n}\n\n#[test]\nfn test_truncate_long() {\n    assert_eq!(truncate(\"hello world\", 8), \"hello...\");\n}\n\n#[test]\nfn test_level_color() {\n    assert_eq!(level_color(\"error\"), Color::Red);\n    assert_eq!(level_color(\"warning\"), Color::Yellow);\n    assert_eq!(level_color(\"info\"), Color::Blue);\n    assert_eq!(level_color(\"debug\"), Color::White);\n}\n\n#[test]\nfn test_status_color() {\n    assert_eq!(status_color(\"resolved\"), Color::Green);\n    assert_eq!(status_color(\"ignored\"), Color::DarkGrey);\n    assert_eq!(status_color(\"unresolved\"), Color::White);\n}\n\nfn make_test_issue() -\u003e Issue {\n    Issue {\n        id: \"12345\".to_string(),\n        short_id: \"PROJ-123\".to_string(),\n        title: \"Test error\".to_string(),\n        culprit: \"src/main.rs\".to_string(),\n        level: \"error\".to_string(),\n        status: \"unresolved\".to_string(),\n        platform: \"rust\".to_string(),\n        count: \"42\".to_string(),\n        user_count: 10,\n        first_seen: chrono::Utc::now().to_rfc3339(),\n        last_seen: chrono::Utc::now().to_rfc3339(),\n        permalink: \"https://sentry.io/issue/123\".to_string(),\n        is_subscribed: false,\n        is_bookmarked: false,\n        project: ProjectInfo {\n            id: \"1\".to_string(),\n            name: \"Test Project\".to_string(),\n            slug: \"test-project\".to_string(),\n        },\n        metadata: IssueMetadata {\n            error_type: \"RuntimeError\".to_string(),\n            value: \"Something went wrong\".to_string(),\n            filename: \"main.rs\".to_string(),\n            function: \"main\".to_string(),\n        },\n    }\n}\n\n#[test]\nfn test_output_issues_empty() {\n    let issues: Vec\u003cIssue\u003e = vec![];\n    let result = output_issues(\u0026issues, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_issues_table() {\n    let issues = vec![make_test_issue()];\n    let result = output_issues(\u0026issues, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_issues_json() {\n    let issues = vec![make_test_issue()];\n    let result = output_issues(\u0026issues, OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_issue_detail_table() {\n    let issue = make_test_issue();\n    let result = output_issue_detail(\u0026issue, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_issue_detail_json() {\n    let issue = make_test_issue();\n    let result = output_issue_detail(\u0026issue, OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_events_empty() {\n    let events: Vec\u003cEvent\u003e = vec![];\n    let result = output_events(\u0026events, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_events_table() {\n    let events = vec![Event {\n        id: \"abcdef123456\".to_string(),\n        title: \"Test event\".to_string(),\n        message: \"Error message\".to_string(),\n        platform: \"rust\".to_string(),\n        date_created: Some(chrono::Utc::now().to_rfc3339()),\n        user: Some(EventUser {\n            id: Some(\"user123\".to_string()),\n            email: Some(\"test@example.com\".to_string()),\n            username: None,\n            ip_address: None,\n        }),\n        tags: vec![],\n    }];\n    let result = output_events(\u0026events, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_events_json() {\n    let events = vec![Event {\n        id: \"abcdef123456\".to_string(),\n        title: \"Test event\".to_string(),\n        message: \"\".to_string(),\n        platform: \"\".to_string(),\n        date_created: None,\n        user: None,\n        tags: vec![],\n    }];\n    let result = output_events(\u0026events, OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_issue_detail_empty_metadata() {\n    // Test with empty culprit and empty metadata fields\n    let issue = Issue {\n        id: \"12345\".to_string(),\n        short_id: \"PROJ-456\".to_string(),\n        title: \"Test error\".to_string(),\n        culprit: \"\".to_string(), // empty culprit\n        level: \"warning\".to_string(),\n        status: \"resolved\".to_string(),\n        platform: \"python\".to_string(),\n        count: \"1\".to_string(),\n        user_count: 1,\n        first_seen: chrono::Utc::now().to_rfc3339(),\n        last_seen: chrono::Utc::now().to_rfc3339(),\n        permalink: \"https://sentry.io/issue/456\".to_string(),\n        is_subscribed: false,\n        is_bookmarked: false,\n        project: ProjectInfo {\n            id: \"2\".to_string(),\n            name: \"Other Project\".to_string(),\n            slug: \"other-project\".to_string(),\n        },\n        metadata: IssueMetadata {\n            error_type: \"\".to_string(), // empty\n            value: \"\".to_string(),      // empty\n            filename: \"\".to_string(),   // empty\n            function: \"\".to_string(),   // empty\n        },\n    };\n    let result = output_issue_detail(\u0026issue, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_issue_detail_partial_metadata() {\n    // Test with only some metadata fields populated\n    let issue = Issue {\n        id: \"12345\".to_string(),\n        short_id: \"PROJ-789\".to_string(),\n        title: \"Partial metadata\".to_string(),\n        culprit: \"some/path.py\".to_string(),\n        level: \"error\".to_string(),\n        status: \"unresolved\".to_string(),\n        platform: \"python\".to_string(),\n        count: \"5\".to_string(),\n        user_count: 3,\n        first_seen: chrono::Utc::now().to_rfc3339(),\n        last_seen: chrono::Utc::now().to_rfc3339(),\n        permalink: \"https://sentry.io/issue/789\".to_string(),\n        is_subscribed: false,\n        is_bookmarked: false,\n        project: ProjectInfo {\n            id: \"3\".to_string(),\n            name: \"Third Project\".to_string(),\n            slug: \"third-project\".to_string(),\n        },\n        metadata: IssueMetadata {\n            error_type: \"ValueError\".to_string(),\n            value: \"\".to_string(), // empty value\n            filename: \"\".to_string(),\n            function: \"process_data\".to_string(),\n        },\n    };\n    let result = output_issue_detail(\u0026issue, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_events_user_variants() {\n    // Test event with username instead of email\n    let events = vec![\n        Event {\n            id: \"event1234567890\".to_string(),\n            title: \"Event with username\".to_string(),\n            message: \"Has message\".to_string(),\n            platform: \"rust\".to_string(),\n            date_created: Some(chrono::Utc::now().to_rfc3339()),\n            user: Some(EventUser {\n                id: None,\n                email: None,\n                username: Some(\"testuser\".to_string()),\n                ip_address: None,\n            }),\n            tags: vec![],\n        },\n        Event {\n            id: \"event2\".to_string(), // short ID\n            title: \"Event with only id\".to_string(),\n            message: \"\".to_string(), // empty message - should use title\n            platform: \"rust\".to_string(),\n            date_created: Some(chrono::Utc::now().to_rfc3339()),\n            user: Some(EventUser {\n                id: Some(\"user-id-only\".to_string()),\n                email: None,\n                username: None,\n                ip_address: None,\n            }),\n            tags: vec![],\n        },\n    ];\n    let result = output_events(\u0026events, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_config_status() {\n    use crate::sentry::config::SentryConfig;\n\n    // Test with all fields set\n    let config = SentryConfig {\n        auth_token: Some(\"test-token\".to_string()),\n        organization: Some(\"my-org\".to_string()),\n        project: Some(\"my-project\".to_string()),\n    };\n    output_config_status(\u0026config);\n\n    // Test with no fields set\n    let empty_config = SentryConfig {\n        auth_token: None,\n        organization: None,\n        project: None,\n    };\n    output_config_status(\u0026empty_config);\n}\n","traces":[{"line":70,"address":[],"length":0,"stats":{"Line":4}},{"line":72,"address":[],"length":0,"stats":{"Line":12}},{"line":73,"address":[],"length":0,"stats":{"Line":12}},{"line":74,"address":[],"length":0,"stats":{"Line":12}},{"line":75,"address":[],"length":0,"stats":{"Line":12}},{"line":76,"address":[],"length":0,"stats":{"Line":12}},{"line":77,"address":[],"length":0,"stats":{"Line":12}},{"line":78,"address":[],"length":0,"stats":{"Line":12}},{"line":79,"address":[],"length":0,"stats":{"Line":12}},{"line":81,"address":[],"length":0,"stats":{"Line":12}},{"line":82,"address":[],"length":0,"stats":{"Line":12}},{"line":83,"address":[],"length":0,"stats":{"Line":12}},{"line":86,"address":[],"length":0,"stats":{"Line":8}},{"line":91,"address":[],"length":0,"stats":{"Line":4}}],"covered":14,"coverable":14},{"path":["/","Users","chi","Projects","hu","src","sentry","mod.rs"],"content":"//! Sentry integration\n//!\n//! List and view issues from Sentry.\n//!\n//! # CLI Usage\n//! Use [`run`] for CLI commands that format and print output.\n//!\n//! # Programmatic Usage (MCP/HTTP)\n//! Use the reusable functions that return typed data:\n//! - [`get_config`] - Get configuration status\n//! - [`list_issues`] - List issues with filters\n//! - [`get_issue`] - Get issue details\n//! - [`list_events`] - List events for an issue\n\nmod client;\nmod config;\nmod display;\nmod service;\npub mod types;\n\nuse anyhow::Result;\nuse clap::Subcommand;\n\nuse client::SentryClient;\npub use config::SentryConfig;\npub use service::{EventOptions, IssueOptions};\nuse types::OutputFormat;\npub use types::{Event, Issue};\n\n/// Sentry subcommands\n#[derive(Debug, Subcommand)]\npub enum SentryCommand {\n    /// Show configuration status\n    Config,\n\n    /// List issues\n    Issues {\n        /// Filter by project\n        #[arg(short, long)]\n        project: Option\u003cString\u003e,\n\n        /// Search query (Sentry search syntax)\n        #[arg(short, long)]\n        query: Option\u003cString\u003e,\n\n        /// Maximum number of issues to return\n        #[arg(short, long, default_value = \"25\")]\n        limit: usize,\n\n        /// Output as JSON\n        #[arg(long)]\n        json: bool,\n    },\n\n    /// Show issue details\n    Show {\n        /// Issue ID or short ID\n        issue: String,\n\n        /// Output as JSON\n        #[arg(long)]\n        json: bool,\n    },\n\n    /// List events for an issue\n    Events {\n        /// Issue ID or short ID\n        issue: String,\n\n        /// Maximum number of events to return\n        #[arg(short, long, default_value = \"25\")]\n        limit: usize,\n\n        /// Output as JSON\n        #[arg(long)]\n        json: bool,\n    },\n\n    /// Set auth token\n    Auth {\n        /// Auth token\n        token: String,\n\n        /// Organization slug\n        #[arg(short, long)]\n        org: String,\n    },\n}\n\n/// Run a Sentry command (CLI entry point - formats and prints)\n#[cfg(not(tarpaulin_include))]\npub async fn run(cmd: SentryCommand) -\u003e Result\u003c()\u003e {\n    match cmd {\n        SentryCommand::Config =\u003e cmd_config(),\n        SentryCommand::Issues {\n            project,\n            query,\n            limit,\n            json,\n        } =\u003e cmd_issues(project, query, limit, json).await,\n        SentryCommand::Show { issue, json } =\u003e cmd_show(\u0026issue, json).await,\n        SentryCommand::Events { issue, limit, json } =\u003e cmd_events(\u0026issue, limit, json).await,\n        SentryCommand::Auth { token, org } =\u003e cmd_auth(\u0026token, \u0026org),\n    }\n}\n\n// ============================================================================\n// Reusable functions for MCP/HTTP - return typed data, never print\n// ============================================================================\n\n/// Get Sentry configuration status (for MCP/HTTP)\n#[allow(dead_code)]\npub fn get_config() -\u003e Result\u003cSentryConfig\u003e {\n    service::get_config()\n}\n\n/// List issues with filters (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn list_issues(opts: \u0026IssueOptions) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n    let client = SentryClient::new()?;\n    service::list_issues(\u0026client, opts).await\n}\n\n/// Get issue details by ID (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn get_issue(issue_id: \u0026str) -\u003e Result\u003cIssue\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n    let client = SentryClient::new()?;\n    service::get_issue(\u0026client, issue_id).await\n}\n\n/// List events for an issue (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn list_events(opts: \u0026EventOptions) -\u003e Result\u003cVec\u003cEvent\u003e\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n    let client = SentryClient::new()?;\n    service::list_events(\u0026client, opts).await\n}\n\n// ============================================================================\n// CLI command handlers - create client, call service, format and print\n// ============================================================================\n\n/// Show config status\nfn cmd_config() -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    display::output_config_status(\u0026config);\n    Ok(())\n}\n\n/// Set auth token\nfn cmd_auth(token: \u0026str, org: \u0026str) -\u003e Result\u003c()\u003e {\n    service::save_auth(token, org)?;\n    println!(\"Sentry auth token saved for organization: {}\", org);\n    Ok(())\n}\n\n/// List issues\nasync fn cmd_issues(\n    project: Option\u003cString\u003e,\n    query: Option\u003cString\u003e,\n    limit: usize,\n    json: bool,\n) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n\n    let client = SentryClient::new()?;\n    let opts = IssueOptions {\n        project,\n        query,\n        limit,\n    };\n    let issues = service::list_issues(\u0026client, \u0026opts).await?;\n\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n\n    display::output_issues(\u0026issues, format)?;\n    Ok(())\n}\n\n/// Show issue details\nasync fn cmd_show(issue_id: \u0026str, json: bool) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n\n    let client = SentryClient::new()?;\n    let issue = service::get_issue(\u0026client, issue_id).await?;\n\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n\n    display::output_issue_detail(\u0026issue, format)?;\n    Ok(())\n}\n\n/// List events for an issue\nasync fn cmd_events(issue_id: \u0026str, limit: usize, json: bool) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n\n    let client = SentryClient::new()?;\n    let opts = EventOptions {\n        issue_id: issue_id.to_string(),\n        limit,\n    };\n    let events = service::list_events(\u0026client, \u0026opts).await?;\n\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n\n    display::output_events(\u0026events, format)?;\n    Ok(())\n}\n","traces":[{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":1}},{"line":169,"address":[],"length":0,"stats":{"Line":2}},{"line":170,"address":[],"length":0,"stats":{"Line":3}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}}],"covered":3,"coverable":56},{"path":["/","Users","chi","Projects","hu","src","sentry","service.rs"],"content":"//! Sentry service layer - business logic that returns data\n//!\n//! Functions in this module accept trait objects and return typed data.\n//! They never print - that's the CLI layer's job.\n\nuse anyhow::{bail, Result};\n\nuse super::client::SentryApi;\nuse super::config::{self, SentryConfig};\nuse super::types::{Event, Issue};\n\n/// Options for listing issues\n#[derive(Debug, Default)]\npub struct IssueOptions {\n    /// Filter by project slug\n    pub project: Option\u003cString\u003e,\n    /// Search query (Sentry search syntax)\n    pub query: Option\u003cString\u003e,\n    /// Maximum number of results\n    pub limit: usize,\n}\n\nimpl IssueOptions {\n    /// Create with default limit\n    #[allow(dead_code)]\n    pub fn new() -\u003e Self {\n        Self {\n            project: None,\n            query: None,\n            limit: 25,\n        }\n    }\n}\n\n/// Options for listing events\n#[derive(Debug)]\npub struct EventOptions {\n    /// Issue ID\n    pub issue_id: String,\n    /// Maximum number of results\n    pub limit: usize,\n}\n\nimpl Default for EventOptions {\n    fn default() -\u003e Self {\n        Self {\n            issue_id: String::new(),\n            limit: 25,\n        }\n    }\n}\n\n/// Get current configuration\npub fn get_config() -\u003e Result\u003cSentryConfig\u003e {\n    config::load_config()\n}\n\n/// Save auth token and organization\npub fn save_auth(token: \u0026str, org: \u0026str) -\u003e Result\u003c()\u003e {\n    config::save_auth_token(token, org)\n}\n\n/// Check if API is configured, return error if not\npub fn ensure_configured(config: \u0026SentryConfig) -\u003e Result\u003c()\u003e {\n    if !config.is_configured() {\n        bail!(\n            \"Sentry not configured. Run: hu sentry auth \u003ctoken\u003e --org \u003corg\u003e\\n\\\n             Or set SENTRY_AUTH_TOKEN and SENTRY_ORG environment variables.\"\n        );\n    }\n    Ok(())\n}\n\n/// List issues with options\npub async fn list_issues(api: \u0026impl SentryApi, opts: \u0026IssueOptions) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n    if let Some(ref project) = opts.project {\n        api.list_project_issues(project, opts.query.as_deref(), opts.limit)\n            .await\n    } else {\n        api.list_issues(opts.query.as_deref(), opts.limit).await\n    }\n}\n\n/// Get a single issue by ID\npub async fn get_issue(api: \u0026impl SentryApi, issue_id: \u0026str) -\u003e Result\u003cIssue\u003e {\n    api.get_issue(issue_id).await\n}\n\n/// List events for an issue\npub async fn list_events(api: \u0026impl SentryApi, opts: \u0026EventOptions) -\u003e Result\u003cVec\u003cEvent\u003e\u003e {\n    api.list_issue_events(\u0026opts.issue_id, opts.limit).await\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::sentry::types::{IssueMetadata, ProjectInfo};\n\n    /// Mock Sentry API for testing\n    struct MockApi {\n        issues: Vec\u003cIssue\u003e,\n        events: Vec\u003cEvent\u003e,\n    }\n\n    impl MockApi {\n        fn new() -\u003e Self {\n            Self {\n                issues: vec![],\n                events: vec![],\n            }\n        }\n\n        fn with_issues(mut self, issues: Vec\u003cIssue\u003e) -\u003e Self {\n            self.issues = issues;\n            self\n        }\n\n        fn with_events(mut self, events: Vec\u003cEvent\u003e) -\u003e Self {\n            self.events = events;\n            self\n        }\n    }\n\n    impl SentryApi for MockApi {\n        async fn list_issues(\u0026self, query: Option\u003c\u0026str\u003e, limit: usize) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n            let filtered: Vec\u003cIssue\u003e = self\n                .issues\n                .iter()\n                .filter(|i| {\n                    query\n                        .map(|q| i.title.contains(q) || i.short_id.contains(q))\n                        .unwrap_or(true)\n                })\n                .take(limit)\n                .cloned()\n                .collect();\n            Ok(filtered)\n        }\n\n        async fn list_project_issues(\n            \u0026self,\n            project: \u0026str,\n            query: Option\u003c\u0026str\u003e,\n            limit: usize,\n        ) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n            let filtered: Vec\u003cIssue\u003e = self\n                .issues\n                .iter()\n                .filter(|i| i.project.slug == project)\n                .filter(|i| {\n                    query\n                        .map(|q| i.title.contains(q) || i.short_id.contains(q))\n                        .unwrap_or(true)\n                })\n                .take(limit)\n                .cloned()\n                .collect();\n            Ok(filtered)\n        }\n\n        async fn get_issue(\u0026self, issue_id: \u0026str) -\u003e Result\u003cIssue\u003e {\n            self.issues\n                .iter()\n                .find(|i| i.id == issue_id || i.short_id == issue_id)\n                .cloned()\n                .ok_or_else(|| anyhow::anyhow!(\"Issue not found: {}\", issue_id))\n        }\n\n        async fn list_issue_events(\u0026self, _issue_id: \u0026str, limit: usize) -\u003e Result\u003cVec\u003cEvent\u003e\u003e {\n            Ok(self.events.iter().take(limit).cloned().collect())\n        }\n    }\n\n    fn make_issue(id: \u0026str, short_id: \u0026str, title: \u0026str, project_slug: \u0026str) -\u003e Issue {\n        Issue {\n            id: id.to_string(),\n            short_id: short_id.to_string(),\n            title: title.to_string(),\n            culprit: \"app.module\".to_string(),\n            level: \"error\".to_string(),\n            status: \"unresolved\".to_string(),\n            platform: \"python\".to_string(),\n            project: ProjectInfo {\n                id: \"1\".to_string(),\n                name: \"Test Project\".to_string(),\n                slug: project_slug.to_string(),\n            },\n            count: \"100\".to_string(),\n            user_count: 10,\n            first_seen: \"2024-01-01T00:00:00Z\".to_string(),\n            last_seen: \"2024-01-02T00:00:00Z\".to_string(),\n            permalink: format!(\"https://sentry.io/issues/{}\", id),\n            is_subscribed: false,\n            is_bookmarked: false,\n            metadata: IssueMetadata::default(),\n        }\n    }\n\n    fn make_event(id: \u0026str, title: \u0026str) -\u003e Event {\n        Event {\n            id: id.to_string(),\n            title: title.to_string(),\n            message: \"Error occurred\".to_string(),\n            platform: \"python\".to_string(),\n            date_created: Some(\"2024-01-01T00:00:00Z\".to_string()),\n            user: None,\n            tags: vec![],\n        }\n    }\n\n    #[tokio::test]\n    async fn list_issues_returns_all() {\n        let api = MockApi::new().with_issues(vec![\n            make_issue(\"1\", \"PROJ-1\", \"Error 1\", \"proj\"),\n            make_issue(\"2\", \"PROJ-2\", \"Error 2\", \"proj\"),\n        ]);\n\n        let opts = IssueOptions {\n            project: None,\n            query: None,\n            limit: 10,\n        };\n        let result = list_issues(\u0026api, \u0026opts).await.unwrap();\n        assert_eq!(result.len(), 2);\n    }\n\n    #[tokio::test]\n    async fn list_issues_filters_by_project() {\n        let api = MockApi::new().with_issues(vec![\n            make_issue(\"1\", \"PROJ-1\", \"Error 1\", \"proj-a\"),\n            make_issue(\"2\", \"PROJ-2\", \"Error 2\", \"proj-b\"),\n        ]);\n\n        let opts = IssueOptions {\n            project: Some(\"proj-a\".to_string()),\n            query: None,\n            limit: 10,\n        };\n        let result = list_issues(\u0026api, \u0026opts).await.unwrap();\n        assert_eq!(result.len(), 1);\n        assert_eq!(result[0].short_id, \"PROJ-1\");\n    }\n\n    #[tokio::test]\n    async fn list_issues_filters_by_query() {\n        let api = MockApi::new().with_issues(vec![\n            make_issue(\"1\", \"PROJ-1\", \"Database error\", \"proj\"),\n            make_issue(\"2\", \"PROJ-2\", \"Network timeout\", \"proj\"),\n        ]);\n\n        let opts = IssueOptions {\n            project: None,\n            query: Some(\"Database\".to_string()),\n            limit: 10,\n        };\n        let result = list_issues(\u0026api, \u0026opts).await.unwrap();\n        assert_eq!(result.len(), 1);\n        assert_eq!(result[0].title, \"Database error\");\n    }\n\n    #[tokio::test]\n    async fn list_issues_respects_limit() {\n        let api = MockApi::new().with_issues(vec![\n            make_issue(\"1\", \"PROJ-1\", \"Error 1\", \"proj\"),\n            make_issue(\"2\", \"PROJ-2\", \"Error 2\", \"proj\"),\n            make_issue(\"3\", \"PROJ-3\", \"Error 3\", \"proj\"),\n        ]);\n\n        let opts = IssueOptions {\n            project: None,\n            query: None,\n            limit: 2,\n        };\n        let result = list_issues(\u0026api, \u0026opts).await.unwrap();\n        assert_eq!(result.len(), 2);\n    }\n\n    #[tokio::test]\n    async fn get_issue_by_id() {\n        let api = MockApi::new().with_issues(vec![\n            make_issue(\"123\", \"PROJ-1\", \"Error 1\", \"proj\"),\n            make_issue(\"456\", \"PROJ-2\", \"Error 2\", \"proj\"),\n        ]);\n\n        let result = get_issue(\u0026api, \"456\").await.unwrap();\n        assert_eq!(result.id, \"456\");\n        assert_eq!(result.title, \"Error 2\");\n    }\n\n    #[tokio::test]\n    async fn get_issue_by_short_id() {\n        let api = MockApi::new().with_issues(vec![make_issue(\"123\", \"PROJ-42\", \"Error\", \"proj\")]);\n\n        let result = get_issue(\u0026api, \"PROJ-42\").await.unwrap();\n        assert_eq!(result.short_id, \"PROJ-42\");\n    }\n\n    #[tokio::test]\n    async fn get_issue_not_found() {\n        let api = MockApi::new();\n        let result = get_issue(\u0026api, \"MISSING\").await;\n        assert!(result.is_err());\n    }\n\n    #[tokio::test]\n    async fn list_events_returns_data() {\n        let api = MockApi::new().with_events(vec![\n            make_event(\"evt1\", \"Event 1\"),\n            make_event(\"evt2\", \"Event 2\"),\n        ]);\n\n        let opts = EventOptions {\n            issue_id: \"123\".to_string(),\n            limit: 10,\n        };\n        let result = list_events(\u0026api, \u0026opts).await.unwrap();\n        assert_eq!(result.len(), 2);\n    }\n\n    #[tokio::test]\n    async fn list_events_respects_limit() {\n        let api = MockApi::new().with_events(vec![\n            make_event(\"evt1\", \"Event 1\"),\n            make_event(\"evt2\", \"Event 2\"),\n            make_event(\"evt3\", \"Event 3\"),\n        ]);\n\n        let opts = EventOptions {\n            issue_id: \"123\".to_string(),\n            limit: 2,\n        };\n        let result = list_events(\u0026api, \u0026opts).await.unwrap();\n        assert_eq!(result.len(), 2);\n    }\n\n    #[test]\n    fn ensure_configured_fails_without_token() {\n        let config = SentryConfig::default();\n        let result = ensure_configured(\u0026config);\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"not configured\"));\n    }\n\n    #[test]\n    fn ensure_configured_fails_without_org() {\n        let config = SentryConfig {\n            auth_token: Some(\"token\".to_string()),\n            organization: None,\n            project: None,\n        };\n        let result = ensure_configured(\u0026config);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn ensure_configured_succeeds_with_token_and_org() {\n        let config = SentryConfig {\n            auth_token: Some(\"token\".to_string()),\n            organization: Some(\"my-org\".to_string()),\n            project: None,\n        };\n        let result = ensure_configured(\u0026config);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn issue_options_default() {\n        let opts = IssueOptions::default();\n        assert!(opts.project.is_none());\n        assert!(opts.query.is_none());\n        assert_eq!(opts.limit, 0);\n    }\n\n    #[test]\n    fn issue_options_new() {\n        let opts = IssueOptions::new();\n        assert_eq!(opts.limit, 25);\n    }\n\n    #[test]\n    fn event_options_default() {\n        let opts = EventOptions::default();\n        assert!(opts.issue_id.is_empty());\n        assert_eq!(opts.limit, 25);\n    }\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":1}},{"line":45,"address":[],"length":0,"stats":{"Line":1}},{"line":47,"address":[],"length":0,"stats":{"Line":1}},{"line":54,"address":[],"length":0,"stats":{"Line":1}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":4}},{"line":65,"address":[],"length":0,"stats":{"Line":4}},{"line":66,"address":[],"length":0,"stats":{"Line":3}},{"line":67,"address":[],"length":0,"stats":{"Line":3}},{"line":68,"address":[],"length":0,"stats":{"Line":3}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":75,"address":[],"length":0,"stats":{"Line":8}},{"line":76,"address":[],"length":0,"stats":{"Line":5}},{"line":77,"address":[],"length":0,"stats":{"Line":6}},{"line":78,"address":[],"length":0,"stats":{"Line":1}},{"line":80,"address":[],"length":0,"stats":{"Line":15}},{"line":85,"address":[],"length":0,"stats":{"Line":6}},{"line":86,"address":[],"length":0,"stats":{"Line":9}},{"line":90,"address":[],"length":0,"stats":{"Line":4}},{"line":91,"address":[],"length":0,"stats":{"Line":8}}],"covered":20,"coverable":22},{"path":["/","Users","chi","Projects","hu","src","sentry","types.rs"],"content":"//! Sentry data types\n\nuse serde::{Deserialize, Serialize};\n\n/// Sentry issue\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Issue {\n    /// Issue ID\n    pub id: String,\n    /// Short ID (e.g., \"PROJECT-123\")\n    pub short_id: String,\n    /// Issue title\n    pub title: String,\n    /// Culprit (location in code)\n    #[serde(default)]\n    pub culprit: String,\n    /// Issue level (error, warning, info)\n    pub level: String,\n    /// Issue status (unresolved, resolved, ignored)\n    pub status: String,\n    /// Platform (python, javascript, etc.)\n    #[serde(default)]\n    pub platform: String,\n    /// Project info\n    pub project: ProjectInfo,\n    /// Number of events\n    pub count: String,\n    /// Number of affected users\n    pub user_count: u32,\n    /// First seen timestamp\n    pub first_seen: String,\n    /// Last seen timestamp\n    pub last_seen: String,\n    /// Permalink to Sentry UI\n    pub permalink: String,\n    /// Is subscribed\n    #[serde(default)]\n    pub is_subscribed: bool,\n    /// Is bookmarked\n    #[serde(default)]\n    pub is_bookmarked: bool,\n    /// Metadata\n    #[serde(default)]\n    pub metadata: IssueMetadata,\n}\n\n/// Project info embedded in issue\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ProjectInfo {\n    /// Project ID\n    pub id: String,\n    /// Project name\n    pub name: String,\n    /// Project slug\n    pub slug: String,\n}\n\n/// Issue metadata\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct IssueMetadata {\n    /// Error type\n    #[serde(rename = \"type\", default)]\n    pub error_type: String,\n    /// Error value/message\n    #[serde(default)]\n    pub value: String,\n    /// Filename\n    #[serde(default)]\n    pub filename: String,\n    /// Function name\n    #[serde(default)]\n    pub function: String,\n}\n\n/// Sentry event\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Event {\n    /// Event ID\n    #[serde(rename = \"eventID\")]\n    pub id: String,\n    /// Event title\n    #[serde(default)]\n    pub title: String,\n    /// Event message\n    #[serde(default)]\n    pub message: String,\n    /// Platform\n    #[serde(default)]\n    pub platform: String,\n    /// Timestamp\n    #[serde(rename = \"dateCreated\")]\n    pub date_created: Option\u003cString\u003e,\n    /// User info\n    pub user: Option\u003cEventUser\u003e,\n    /// Tags\n    #[serde(default)]\n    pub tags: Vec\u003cEventTag\u003e,\n}\n\n/// User info in event\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct EventUser {\n    /// User ID\n    pub id: Option\u003cString\u003e,\n    /// Email\n    pub email: Option\u003cString\u003e,\n    /// Username\n    pub username: Option\u003cString\u003e,\n    /// IP address\n    pub ip_address: Option\u003cString\u003e,\n}\n\n/// Event tag\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct EventTag {\n    /// Tag key\n    pub key: String,\n    /// Tag value\n    pub value: String,\n}\n\n/// Output format\n#[derive(Debug, Clone, Copy, Default)]\npub enum OutputFormat {\n    #[default]\n    Table,\n    Json,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_issue_debug() {\n        let issue = Issue {\n            id: \"12345\".to_string(),\n            short_id: \"PROJ-123\".to_string(),\n            title: \"Test error\".to_string(),\n            culprit: \"src/main.rs\".to_string(),\n            level: \"error\".to_string(),\n            status: \"unresolved\".to_string(),\n            platform: \"rust\".to_string(),\n            count: \"42\".to_string(),\n            user_count: 10,\n            first_seen: \"2024-01-01T00:00:00Z\".to_string(),\n            last_seen: \"2024-01-02T00:00:00Z\".to_string(),\n            permalink: \"https://sentry.io/issue/123\".to_string(),\n            is_subscribed: false,\n            is_bookmarked: true,\n            project: ProjectInfo {\n                id: \"1\".to_string(),\n                name: \"Test Project\".to_string(),\n                slug: \"test-project\".to_string(),\n            },\n            metadata: IssueMetadata::default(),\n        };\n        let debug = format!(\"{:?}\", issue);\n        assert!(debug.contains(\"Issue\"));\n        assert!(debug.contains(\"PROJ-123\"));\n    }\n\n    #[test]\n    fn test_issue_clone() {\n        let issue = Issue {\n            id: \"12345\".to_string(),\n            short_id: \"PROJ-123\".to_string(),\n            title: \"Test\".to_string(),\n            culprit: \"\".to_string(),\n            level: \"error\".to_string(),\n            status: \"unresolved\".to_string(),\n            platform: \"\".to_string(),\n            count: \"1\".to_string(),\n            user_count: 1,\n            first_seen: \"\".to_string(),\n            last_seen: \"\".to_string(),\n            permalink: \"\".to_string(),\n            is_subscribed: false,\n            is_bookmarked: false,\n            project: ProjectInfo {\n                id: \"1\".to_string(),\n                name: \"Test\".to_string(),\n                slug: \"test\".to_string(),\n            },\n            metadata: IssueMetadata::default(),\n        };\n        let cloned = issue.clone();\n        assert_eq!(cloned.id, issue.id);\n        assert_eq!(cloned.short_id, issue.short_id);\n    }\n\n    #[test]\n    fn test_project_info_debug() {\n        let project = ProjectInfo {\n            id: \"1\".to_string(),\n            name: \"My Project\".to_string(),\n            slug: \"my-project\".to_string(),\n        };\n        let debug = format!(\"{:?}\", project);\n        assert!(debug.contains(\"ProjectInfo\"));\n    }\n\n    #[test]\n    fn test_issue_metadata_default() {\n        let metadata = IssueMetadata::default();\n        assert!(metadata.error_type.is_empty());\n        assert!(metadata.value.is_empty());\n        assert!(metadata.filename.is_empty());\n        assert!(metadata.function.is_empty());\n    }\n\n    #[test]\n    fn test_issue_metadata_debug() {\n        let metadata = IssueMetadata {\n            error_type: \"RuntimeError\".to_string(),\n            value: \"Error message\".to_string(),\n            filename: \"main.rs\".to_string(),\n            function: \"main\".to_string(),\n        };\n        let debug = format!(\"{:?}\", metadata);\n        assert!(debug.contains(\"IssueMetadata\"));\n    }\n\n    #[test]\n    fn test_event_debug() {\n        let event = Event {\n            id: \"event123\".to_string(),\n            title: \"Error event\".to_string(),\n            message: \"Something went wrong\".to_string(),\n            platform: \"rust\".to_string(),\n            date_created: Some(\"2024-01-01T00:00:00Z\".to_string()),\n            user: None,\n            tags: vec![],\n        };\n        let debug = format!(\"{:?}\", event);\n        assert!(debug.contains(\"Event\"));\n    }\n\n    #[test]\n    fn test_event_clone() {\n        let event = Event {\n            id: \"event123\".to_string(),\n            title: \"Test\".to_string(),\n            message: \"\".to_string(),\n            platform: \"\".to_string(),\n            date_created: None,\n            user: Some(EventUser {\n                id: Some(\"user1\".to_string()),\n                email: None,\n                username: None,\n                ip_address: None,\n            }),\n            tags: vec![EventTag {\n                key: \"env\".to_string(),\n                value: \"prod\".to_string(),\n            }],\n        };\n        let cloned = event.clone();\n        assert_eq!(cloned.id, event.id);\n        assert!(cloned.user.is_some());\n    }\n\n    #[test]\n    fn test_event_user_debug() {\n        let user = EventUser {\n            id: Some(\"user123\".to_string()),\n            email: Some(\"test@example.com\".to_string()),\n            username: Some(\"testuser\".to_string()),\n            ip_address: Some(\"192.168.1.1\".to_string()),\n        };\n        let debug = format!(\"{:?}\", user);\n        assert!(debug.contains(\"EventUser\"));\n    }\n\n    #[test]\n    fn test_event_tag_debug() {\n        let tag = EventTag {\n            key: \"environment\".to_string(),\n            value: \"production\".to_string(),\n        };\n        let debug = format!(\"{:?}\", tag);\n        assert!(debug.contains(\"EventTag\"));\n    }\n\n    #[test]\n    fn test_output_format_default() {\n        let format = OutputFormat::default();\n        assert!(matches!(format, OutputFormat::Table));\n    }\n\n    #[test]\n    fn test_output_format_clone() {\n        let format = OutputFormat::Json;\n        let cloned = format.clone();\n        assert!(matches!(cloned, OutputFormat::Json));\n    }\n\n    #[test]\n    fn test_output_format_debug() {\n        let format = OutputFormat::Table;\n        let debug = format!(\"{:?}\", format);\n        assert_eq!(debug, \"Table\");\n    }\n\n    #[test]\n    fn test_issue_serde_default_fields() {\n        // Test that serde default works for optional fields\n        let json = r#\"{\n            \"id\": \"1\",\n            \"shortId\": \"PROJ-1\",\n            \"title\": \"Test\",\n            \"level\": \"error\",\n            \"status\": \"unresolved\",\n            \"count\": \"1\",\n            \"userCount\": 1,\n            \"firstSeen\": \"2024-01-01T00:00:00Z\",\n            \"lastSeen\": \"2024-01-01T00:00:00Z\",\n            \"permalink\": \"http://example.com\",\n            \"project\": {\"id\": \"1\", \"name\": \"Test\", \"slug\": \"test\"}\n        }\"#;\n        let issue: Issue = serde_json::from_str(json).unwrap();\n        assert!(issue.culprit.is_empty());\n        assert!(issue.platform.is_empty());\n        assert!(!issue.is_subscribed);\n        assert!(!issue.is_bookmarked);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","slack","auth","mod.rs"],"content":"//! OAuth 2.0 authentication flow for Slack\n//!\n//! Implements the browser-based OAuth flow to obtain bot tokens.\n\nuse anyhow::Result;\nuse std::time::Duration;\nuse tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader};\nuse tokio::net::TcpListener;\n\nuse super::config::{load_config, update_oauth_tokens};\n\n#[cfg(test)]\nmod tests;\n\nconst SLACK_AUTH_URL: \u0026str = \"https://slack.com/oauth/v2/authorize\";\nconst SLACK_TOKEN_URL: \u0026str = \"https://slack.com/api/oauth.v2.access\";\n\n/// OAuth scopes needed for Slack bot access\nconst OAUTH_SCOPES: \u0026str =\n    \"channels:read,channels:history,chat:write,search:read,users:read,groups:read\";\n\n/// Result of the OAuth flow\npub struct OAuthResult {\n    /// Whether authentication succeeded\n    pub success: bool,\n    /// Error message if failed\n    pub error: Option\u003cString\u003e,\n    /// Slack workspace name if successful\n    pub team_name: Option\u003cString\u003e,\n}\n\nimpl OAuthResult {\n    const fn success(team_name: String) -\u003e Self {\n        Self {\n            success: true,\n            error: None,\n            team_name: Some(team_name),\n        }\n    }\n\n    const fn failure(error: String) -\u003e Self {\n        Self {\n            success: false,\n            error: Some(error),\n            team_name: None,\n        }\n    }\n}\n\n/// Token response from Slack OAuth\n#[derive(serde::Deserialize)]\nstruct TokenResponse {\n    ok: bool,\n    access_token: Option\u003cString\u003e,\n    team: Option\u003cTeamInfo\u003e,\n    error: Option\u003cString\u003e,\n}\n\n/// Team info from OAuth response\n#[derive(serde::Deserialize)]\nstruct TeamInfo {\n    id: String,\n    name: String,\n}\n\n/// Generate a random state parameter for OAuth\nfn generate_state() -\u003e String {\n    use rand::Rng;\n\n    let mut rng = rand::thread_rng();\n    let bytes: [u8; 16] = rng.gen();\n    hex::encode(bytes)\n}\n\n/// Build the OAuth authorization URL\nfn build_authorization_url(client_id: \u0026str, redirect_uri: \u0026str, state: \u0026str) -\u003e String {\n    let params = [\n        (\"client_id\", client_id),\n        (\"scope\", OAUTH_SCOPES),\n        (\"redirect_uri\", redirect_uri),\n        (\"state\", state),\n    ];\n\n    let query = params\n        .iter()\n        .map(|(k, v)| format!(\"{}={}\", k, urlencoding::encode(v)))\n        .collect::\u003cVec\u003c_\u003e\u003e()\n        .join(\"\u0026\");\n\n    format!(\"{}?{}\", SLACK_AUTH_URL, query)\n}\n\n/// Exchange authorization code for tokens\nasync fn exchange_code_for_tokens(\n    client: \u0026reqwest::Client,\n    code: \u0026str,\n    redirect_uri: \u0026str,\n    client_id: \u0026str,\n    client_secret: \u0026str,\n) -\u003e Result\u003cTokenResponse\u003e {\n    let response = client\n        .post(SLACK_TOKEN_URL)\n        .form(\u0026[\n            (\"client_id\", client_id),\n            (\"client_secret\", client_secret),\n            (\"code\", code),\n            (\"redirect_uri\", redirect_uri),\n        ])\n        .send()\n        .await?;\n\n    if !response.status().is_success() {\n        let status = response.status().as_u16();\n        let body = response.text().await.unwrap_or_default();\n        return Err(anyhow::anyhow!(\"Token exchange failed ({status}): {body}\"));\n    }\n\n    let token_resp: TokenResponse = response.json().await?;\n\n    if !token_resp.ok {\n        let error = token_resp\n            .error\n            .unwrap_or_else(|| \"Unknown error\".to_string());\n        return Err(anyhow::anyhow!(format!(\"Token exchange failed: {}\", error)));\n    }\n\n    Ok(token_resp)\n}\n\n/// Parse the OAuth callback request to extract code and state\nfn parse_callback_request(request: \u0026str) -\u003e Option\u003c(String, String)\u003e {\n    let path = request.split_whitespace().nth(1)?;\n    let query = path.split('?').nth(1)?;\n\n    let mut code = None;\n    let mut state = None;\n\n    for param in query.split('\u0026') {\n        let mut parts = param.splitn(2, '=');\n        let key = parts.next()?;\n        let value = parts.next().unwrap_or(\"\");\n\n        match key {\n            \"code\" =\u003e code = Some(urlencoding::decode(value).ok()?.into_owned()),\n            \"state\" =\u003e state = Some(urlencoding::decode(value).ok()?.into_owned()),\n            _ =\u003e {}\n        }\n    }\n\n    Some((code?, state?))\n}\n\n/// Send HTTP response to browser\nasync fn send_response(\n    stream: \u0026mut tokio::net::TcpStream,\n    status: \u0026str,\n    title: \u0026str,\n    message: \u0026str,\n) -\u003e std::io::Result\u003c()\u003e {\n    let body = format!(\n        r#\"\u003c!DOCTYPE html\u003e\n\u003chtml\u003e\n\u003chead\u003e\u003ctitle\u003e{}\u003c/title\u003e\u003c/head\u003e\n\u003cbody style=\"font-family: sans-serif; padding: 40px; text-align: center;\"\u003e\n\u003ch1\u003e{}\u003c/h1\u003e\n\u003cp\u003e{}\u003c/p\u003e\n\u003cp\u003eYou can close this window.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\"#,\n        title, title, message\n    );\n\n    let response = format!(\n        \"HTTP/1.1 {}\\r\\nContent-Type: text/html\\r\\nContent-Length: {}\\r\\nConnection: close\\r\\n\\r\\n{}\",\n        status,\n        body.len(),\n        body\n    );\n\n    stream.write_all(response.as_bytes()).await\n}\n\n/// Run the OAuth authorization flow\n///\n/// Starts a local server, opens the browser, and waits for the callback.\npub async fn run_oauth_flow(port: u16) -\u003e Result\u003cOAuthResult\u003e {\n    let config = load_config()?;\n\n    let client_id = config.oauth.client_id.as_ref().ok_or_else(|| {\n        anyhow::anyhow!(\n            \"client_id not configured. Set slack.oauth.client_id in ~/.config/hu/settings.toml\"\n        )\n    })?;\n\n    let client_secret = config.oauth.client_secret.as_ref().ok_or_else(|| {\n        anyhow::anyhow!(\n            \"client_secret not configured. Set slack.oauth.client_secret in ~/.config/hu/settings.toml\"\n        )\n    })?;\n\n    let redirect_uri = format!(\"http://localhost:{}/callback\", port);\n    let state = generate_state();\n    let auth_url = build_authorization_url(client_id, \u0026redirect_uri, \u0026state);\n\n    // Start local server\n    let listener = TcpListener::bind(format!(\"127.0.0.1:{}\", port))\n        .await\n        .map_err(|e| {\n            anyhow::anyhow!(format!(\n                \"Failed to start local server on port {}: {}\",\n                port, e\n            ))\n        })?;\n\n    println!(\"\\nOpen this URL in your browser to authorize:\\n\");\n    println!(\"{}\\n\", auth_url);\n    println!(\"Waiting for authorization...\");\n\n    // Try to open browser\n    if let Err(_e) = open::that(\u0026auth_url) {\n        // debug!(\"Failed to open browser: {}\", _e);\n    }\n\n    // Wait for callback with timeout\n    let ctx = CallbackContext {\n        listener: \u0026listener,\n        expected_state: \u0026state,\n        redirect_uri: \u0026redirect_uri,\n        client_id,\n        client_secret,\n    };\n\n    tokio::time::timeout(Duration::from_secs(300), handle_callback(ctx))\n        .await\n        .unwrap_or_else(|_| {\n            Ok(OAuthResult::failure(\n                \"Authorization timed out after 5 minutes\".to_string(),\n            ))\n        })\n}\n\n/// Context for handling the OAuth callback\nstruct CallbackContext\u003c'a\u003e {\n    listener: \u0026'a TcpListener,\n    expected_state: \u0026'a str,\n    redirect_uri: \u0026'a str,\n    client_id: \u0026'a str,\n    client_secret: \u0026'a str,\n}\n\n/// Handle the OAuth callback - accepts connections and processes the callback\nasync fn handle_callback(ctx: CallbackContext\u003c'_\u003e) -\u003e Result\u003cOAuthResult\u003e {\n    loop {\n        let (mut stream, _) = ctx\n            .listener\n            .accept()\n            .await\n            .map_err(|e| anyhow::anyhow!(format!(\"Failed to accept connection: {}\", e)))?;\n\n        let mut reader = BufReader::new(\u0026mut stream);\n        let mut request_line = String::new();\n        reader\n            .read_line(\u0026mut request_line)\n            .await\n            .map_err(|e| anyhow::anyhow!(format!(\"Failed to read request: {}\", e)))?;\n\n        // Skip non-callback requests (favicon, etc.)\n        if !request_line.contains(\"/callback\") {\n            send_response(\u0026mut stream, \"404 Not Found\", \"Not Found\", \"\")\n                .await\n                .ok();\n            continue;\n        }\n\n        return process_callback(\u0026mut stream, \u0026request_line, \u0026ctx).await;\n    }\n}\n\n/// Process the OAuth callback request\nasync fn process_callback(\n    stream: \u0026mut tokio::net::TcpStream,\n    request_line: \u0026str,\n    ctx: \u0026CallbackContext\u003c'_\u003e,\n) -\u003e Result\u003cOAuthResult\u003e {\n    // Parse callback parameters\n    let Some((code, returned_state)) = parse_callback_request(request_line) else {\n        send_response(\n            stream,\n            \"400 Bad Request\",\n            \"Invalid Request\",\n            \"Missing code or state\",\n        )\n        .await\n        .ok();\n        return Ok(OAuthResult::failure(\n            \"Missing code or state parameter\".to_string(),\n        ));\n    };\n\n    // Verify state\n    if returned_state != ctx.expected_state {\n        send_response(stream, \"400 Bad Request\", \"Invalid State\", \"State mismatch\")\n            .await\n            .ok();\n        return Ok(OAuthResult::failure(\n            \"State mismatch - possible CSRF attack\".to_string(),\n        ));\n    }\n\n    // Exchange code for tokens\n    let http = reqwest::Client::new();\n    let tokens = match exchange_code_for_tokens(\n        \u0026http,\n        \u0026code,\n        ctx.redirect_uri,\n        ctx.client_id,\n        ctx.client_secret,\n    )\n    .await\n    {\n        Ok(t) =\u003e t,\n        Err(e) =\u003e {\n            send_response(\n                stream,\n                \"500 Internal Server Error\",\n                \"Token Exchange Failed\",\n                \u0026e.to_string(),\n            )\n            .await\n            .ok();\n            return Ok(OAuthResult::failure(e.to_string()));\n        }\n    };\n\n    // Save tokens and complete\n    complete_auth(stream, \u0026tokens).await\n}\n\n/// Complete authentication by saving tokens\nasync fn complete_auth(\n    stream: \u0026mut tokio::net::TcpStream,\n    tokens: \u0026TokenResponse,\n) -\u003e Result\u003cOAuthResult\u003e {\n    let access_token = tokens\n        .access_token\n        .as_ref()\n        .ok_or_else(|| anyhow::anyhow!(\"No access token in response\".to_string()))?;\n\n    let team = tokens\n        .team\n        .as_ref()\n        .ok_or_else(|| anyhow::anyhow!(\"No team info in response\".to_string()))?;\n\n    // Save tokens\n    if let Err(e) = update_oauth_tokens(access_token, \u0026team.id, \u0026team.name) {\n        send_response(\n            stream,\n            \"500 Internal Server Error\",\n            \"Failed to Save Tokens\",\n            \u0026e.to_string(),\n        )\n        .await\n        .ok();\n        return Ok(OAuthResult::failure(e.to_string()));\n    }\n\n    send_response(\n        stream,\n        \"200 OK\",\n        \"Authorization Successful!\",\n        \u0026format!(\"Connected to {}.\", team.name),\n    )\n    .await\n    .ok();\n    Ok(OAuthResult::success(team.name.clone()))\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":1}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":41,"address":[],"length":0,"stats":{"Line":1}},{"line":44,"address":[],"length":0,"stats":{"Line":1}},{"line":67,"address":[],"length":0,"stats":{"Line":4}},{"line":70,"address":[],"length":0,"stats":{"Line":8}},{"line":71,"address":[],"length":0,"stats":{"Line":16}},{"line":72,"address":[],"length":0,"stats":{"Line":8}},{"line":76,"address":[],"length":0,"stats":{"Line":2}},{"line":77,"address":[],"length":0,"stats":{"Line":4}},{"line":78,"address":[],"length":0,"stats":{"Line":4}},{"line":79,"address":[],"length":0,"stats":{"Line":4}},{"line":80,"address":[],"length":0,"stats":{"Line":4}},{"line":81,"address":[],"length":0,"stats":{"Line":2}},{"line":84,"address":[],"length":0,"stats":{"Line":4}},{"line":86,"address":[],"length":0,"stats":{"Line":34}},{"line":90,"address":[],"length":0,"stats":{"Line":4}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":7}},{"line":132,"address":[],"length":0,"stats":{"Line":21}},{"line":133,"address":[],"length":0,"stats":{"Line":18}},{"line":135,"address":[],"length":0,"stats":{"Line":10}},{"line":136,"address":[],"length":0,"stats":{"Line":10}},{"line":138,"address":[],"length":0,"stats":{"Line":19}},{"line":139,"address":[],"length":0,"stats":{"Line":27}},{"line":140,"address":[],"length":0,"stats":{"Line":27}},{"line":141,"address":[],"length":0,"stats":{"Line":45}},{"line":143,"address":[],"length":0,"stats":{"Line":9}},{"line":144,"address":[],"length":0,"stats":{"Line":29}},{"line":145,"address":[],"length":0,"stats":{"Line":25}},{"line":146,"address":[],"length":0,"stats":{"Line":1}},{"line":150,"address":[],"length":0,"stats":{"Line":11}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}}],"covered":31,"coverable":142},{"path":["/","Users","chi","Projects","hu","src","slack","auth","tests.rs"],"content":"use super::*;\n\n#[test]\nfn test_oauth_result_success() {\n    let result = OAuthResult::success(\"Test Team\".to_string());\n    assert!(result.success);\n    assert!(result.error.is_none());\n    assert_eq!(result.team_name, Some(\"Test Team\".to_string()));\n}\n\n#[test]\nfn test_oauth_result_failure() {\n    let result = OAuthResult::failure(\"auth error\".to_string());\n    assert!(!result.success);\n    assert_eq!(result.error, Some(\"auth error\".to_string()));\n    assert!(result.team_name.is_none());\n}\n\n#[test]\nfn test_generate_state_length() {\n    let state = generate_state();\n    // 16 bytes encoded as hex = 32 characters\n    assert_eq!(state.len(), 32);\n}\n\n#[test]\nfn test_generate_state_unique() {\n    let state1 = generate_state();\n    let state2 = generate_state();\n    assert_ne!(state1, state2);\n}\n\n#[test]\nfn test_generate_state_hex_chars() {\n    let state = generate_state();\n    assert!(state.chars().all(|c| c.is_ascii_hexdigit()));\n}\n\n#[test]\nfn test_build_authorization_url() {\n    let url = build_authorization_url(\"test-client-id\", \"http://localhost:9877/callback\", \"abc123\");\n    assert!(url.starts_with(\"https://slack.com/oauth/v2/authorize?\"));\n    assert!(url.contains(\"client_id=test-client-id\"));\n    assert!(url.contains(\"redirect_uri=http%3A%2F%2Flocalhost%3A9877%2Fcallback\"));\n    assert!(url.contains(\"state=abc123\"));\n    assert!(url.contains(\"scope=\"));\n}\n\n#[test]\nfn test_build_authorization_url_encodes_special_chars() {\n    let url = build_authorization_url(\"client\u0026id\", \"http://localhost/test?a=b\", \"state value\");\n    assert!(url.contains(\"client_id=client%26id\"));\n    assert!(url.contains(\"state=state%20value\"));\n}\n\n#[test]\nfn test_parse_callback_request_valid() {\n    let request = \"GET /callback?code=abc123\u0026state=xyz789 HTTP/1.1\";\n    let result = parse_callback_request(request);\n    assert!(result.is_some());\n    let (code, state) = result.unwrap();\n    assert_eq!(code, \"abc123\");\n    assert_eq!(state, \"xyz789\");\n}\n\n#[test]\nfn test_parse_callback_request_url_encoded() {\n    let request = \"GET /callback?code=abc%20123\u0026state=xyz%26789 HTTP/1.1\";\n    let result = parse_callback_request(request);\n    assert!(result.is_some());\n    let (code, state) = result.unwrap();\n    assert_eq!(code, \"abc 123\");\n    assert_eq!(state, \"xyz\u0026789\");\n}\n\n#[test]\nfn test_parse_callback_request_missing_code() {\n    let request = \"GET /callback?state=xyz789 HTTP/1.1\";\n    let result = parse_callback_request(request);\n    assert!(result.is_none());\n}\n\n#[test]\nfn test_parse_callback_request_missing_state() {\n    let request = \"GET /callback?code=abc123 HTTP/1.1\";\n    let result = parse_callback_request(request);\n    assert!(result.is_none());\n}\n\n#[test]\nfn test_parse_callback_request_no_query() {\n    let request = \"GET /callback HTTP/1.1\";\n    let result = parse_callback_request(request);\n    assert!(result.is_none());\n}\n\n#[test]\nfn test_parse_callback_request_empty() {\n    let request = \"\";\n    let result = parse_callback_request(request);\n    assert!(result.is_none());\n}\n\n#[test]\nfn test_parse_callback_request_extra_params() {\n    let request = \"GET /callback?code=abc\u0026state=xyz\u0026extra=foo HTTP/1.1\";\n    let result = parse_callback_request(request);\n    assert!(result.is_some());\n    let (code, state) = result.unwrap();\n    assert_eq!(code, \"abc\");\n    assert_eq!(state, \"xyz\");\n}\n\n#[test]\nfn test_token_response_deserialize_success() {\n    let json =\n        r#\"{\"ok\": true, \"access_token\": \"xoxb-test\", \"team\": {\"id\": \"T123\", \"name\": \"Test\"}}\"#;\n    let resp: TokenResponse = serde_json::from_str(json).unwrap();\n    assert!(resp.ok);\n    assert_eq!(resp.access_token, Some(\"xoxb-test\".to_string()));\n    assert!(resp.team.is_some());\n    let team = resp.team.unwrap();\n    assert_eq!(team.id, \"T123\");\n    assert_eq!(team.name, \"Test\");\n}\n\n#[test]\nfn test_token_response_deserialize_error() {\n    let json = r#\"{\"ok\": false, \"error\": \"invalid_code\"}\"#;\n    let resp: TokenResponse = serde_json::from_str(json).unwrap();\n    assert!(!resp.ok);\n    assert_eq!(resp.error, Some(\"invalid_code\".to_string()));\n    assert!(resp.access_token.is_none());\n}\n\n#[test]\nfn test_team_info_deserialize() {\n    let json = r#\"{\"id\": \"T12345\", \"name\": \"My Team\"}\"#;\n    let team: TeamInfo = serde_json::from_str(json).unwrap();\n    assert_eq!(team.id, \"T12345\");\n    assert_eq!(team.name, \"My Team\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","slack","channels","mod.rs"],"content":"//! Slack channel operations\n//!\n//! List channels, get channel info, and resolve channel names to IDs.\n\nuse anyhow::Result;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::PathBuf;\nuse std::time::{Duration, SystemTime};\nuse tokio::time::sleep;\n\nuse super::client::SlackClient;\nuse super::config::config_path;\nuse super::types::{SlackChannel, SlackUser};\n\n#[cfg(test)]\nmod tests;\n\n/// Cache expiry time (1 hour)\nconst CACHE_EXPIRY_SECS: u64 = 3600;\n\n/// Cached user lookup data\n#[derive(Serialize, Deserialize)]\nstruct UserCache {\n    /// Timestamp when cache was created\n    created: u64,\n    /// User ID to username mapping\n    users: HashMap\u003cString, String\u003e,\n}\n\n/// Get path to user cache file\nfn user_cache_path() -\u003e Option\u003cPathBuf\u003e {\n    config_path().map(|p| p.with_file_name(\"slack_users_cache.json\"))\n}\n\n/// Response from conversations.list API\n#[derive(Deserialize)]\nstruct ConversationsListResponse {\n    channels: Vec\u003cChannelResponse\u003e,\n    response_metadata: Option\u003cResponseMetadata\u003e,\n}\n\n/// Response from conversations.info API\n#[derive(Deserialize)]\nstruct ConversationsInfoResponse {\n    channel: ChannelResponse,\n}\n\n/// Response from users.list API\n#[derive(Deserialize)]\nstruct UsersListResponse {\n    members: Vec\u003cUserResponse\u003e,\n}\n\n/// Raw channel data from API\n#[derive(Deserialize)]\nstruct ChannelResponse {\n    id: String,\n    name: String,\n    is_private: Option\u003cbool\u003e,\n    is_member: Option\u003cbool\u003e,\n    topic: Option\u003cTopicResponse\u003e,\n    purpose: Option\u003cTopicResponse\u003e,\n    num_members: Option\u003cu32\u003e,\n    created: Option\u003ci64\u003e,\n}\n\n/// Raw user data from API\n#[derive(Deserialize)]\nstruct UserResponse {\n    id: String,\n    team_id: Option\u003cString\u003e,\n    name: String,\n    real_name: Option\u003cString\u003e,\n    is_bot: Option\u003cbool\u003e,\n    deleted: Option\u003cbool\u003e,\n    tz: Option\u003cString\u003e,\n}\n\n/// Topic or purpose field\n#[derive(Deserialize)]\nstruct TopicResponse {\n    value: String,\n}\n\n/// Pagination metadata\n#[derive(Deserialize)]\nstruct ResponseMetadata {\n    next_cursor: Option\u003cString\u003e,\n}\n\nimpl From\u003cChannelResponse\u003e for SlackChannel {\n    fn from(r: ChannelResponse) -\u003e Self {\n        Self {\n            id: r.id,\n            name: r.name,\n            is_private: r.is_private.unwrap_or(false),\n            is_member: r.is_member.unwrap_or(false),\n            topic: r.topic.map(|t| t.value).filter(|s| !s.is_empty()),\n            purpose: r.purpose.map(|p| p.value).filter(|s| !s.is_empty()),\n            num_members: r.num_members,\n            created: r.created.unwrap_or(0),\n        }\n    }\n}\n\nimpl From\u003cUserResponse\u003e for SlackUser {\n    fn from(r: UserResponse) -\u003e Self {\n        Self {\n            id: r.id,\n            team_id: r.team_id,\n            name: r.name,\n            real_name: r.real_name,\n            is_bot: r.is_bot.unwrap_or(false),\n            deleted: r.deleted.unwrap_or(false),\n            tz: r.tz,\n        }\n    }\n}\n\n/// List all accessible channels\npub async fn list_channels(client: \u0026SlackClient) -\u003e Result\u003cVec\u003cSlackChannel\u003e\u003e {\n    let mut all_channels = Vec::new();\n    let mut cursor: Option\u003cString\u003e = None;\n    let mut first_request = true;\n\n    loop {\n        // Rate limit: delay between paginated requests (Tier 2 = ~20 req/min)\n        if !first_request {\n            sleep(Duration::from_millis(500)).await;\n        }\n        first_request = false;\n\n        let mut params = vec![\n            (\"types\", \"public_channel\"),\n            (\"exclude_archived\", \"true\"),\n            (\"limit\", \"200\"),\n        ];\n\n        let cursor_str;\n        if let Some(ref c) = cursor {\n            cursor_str = c.clone();\n            params.push((\"cursor\", \u0026cursor_str));\n        }\n\n        let response: ConversationsListResponse = client\n            .get_with_params(\"conversations.list\", \u0026params)\n            .await?;\n\n        all_channels.extend(response.channels.into_iter().map(SlackChannel::from));\n\n        // Check for more pages\n        match response.response_metadata.and_then(|m| m.next_cursor) {\n            Some(c) if !c.is_empty() =\u003e cursor = Some(c),\n            _ =\u003e break,\n        }\n    }\n\n    // Sort by name\n    all_channels.sort_by(|a, b| a.name.cmp(\u0026b.name));\n\n    Ok(all_channels)\n}\n\n/// Get detailed info for a specific channel\npub async fn get_channel_info(client: \u0026SlackClient, channel_id: \u0026str) -\u003e Result\u003cSlackChannel\u003e {\n    let response: ConversationsInfoResponse = client\n        .get_with_params(\"conversations.info\", \u0026[(\"channel\", channel_id)])\n        .await?;\n\n    Ok(SlackChannel::from(response.channel))\n}\n\n/// Resolve a channel name (with or without #) to a channel ID\npub async fn resolve_channel(client: \u0026SlackClient, name_or_id: \u0026str) -\u003e Result\u003cString\u003e {\n    // If it already looks like an ID (channel, group, DM, or user), return it\n    // C = public channel, G = private channel, D = DM, U = user (for DM)\n    if name_or_id.starts_with('C')\n        || name_or_id.starts_with('G')\n        || name_or_id.starts_with('D')\n        || name_or_id.starts_with('U')\n    {\n        return Ok(name_or_id.to_string());\n    }\n\n    // Strip leading # if present\n    let name = name_or_id.trim_start_matches('#');\n\n    // List channels and find by name\n    let channels = list_channels(client).await?;\n    channels\n        .iter()\n        .find(|c| c.name == name)\n        .map(|c| c.id.clone())\n        .ok_or_else(|| anyhow::anyhow!(\"Channel not found: {}\", name))\n}\n\n/// List all users in the workspace\npub async fn list_users(client: \u0026SlackClient) -\u003e Result\u003cVec\u003cSlackUser\u003e\u003e {\n    let response: UsersListResponse = client.get(\"users.list\").await?;\n\n    let users: Vec\u003cSlackUser\u003e = response\n        .members\n        .into_iter()\n        .map(SlackUser::from)\n        .filter(|u| !u.deleted \u0026\u0026 !u.is_bot)\n        .collect();\n\n    Ok(users)\n}\n\n/// Build a lookup map from user ID to username (with caching)\npub async fn build_user_lookup(client: \u0026SlackClient) -\u003e Result\u003cHashMap\u003cString, String\u003e\u003e {\n    // Try to load from cache first\n    if let Some(cached) = load_user_cache() {\n        return Ok(cached);\n    }\n\n    // Fetch from API\n    let users = list_users(client).await?;\n    let lookup: HashMap\u003cString, String\u003e = users.into_iter().map(|u| (u.id, u.name)).collect();\n\n    // Save to cache\n    save_user_cache(\u0026lookup);\n\n    Ok(lookup)\n}\n\n/// Load user cache if valid\nfn load_user_cache() -\u003e Option\u003cHashMap\u003cString, String\u003e\u003e {\n    let path = user_cache_path()?;\n    let contents = fs::read_to_string(\u0026path).ok()?;\n    let cache: UserCache = serde_json::from_str(\u0026contents).ok()?;\n\n    // Check if cache is expired\n    let now = SystemTime::now()\n        .duration_since(SystemTime::UNIX_EPOCH)\n        .ok()?\n        .as_secs();\n\n    if now - cache.created \u003e CACHE_EXPIRY_SECS {\n        return None;\n    }\n\n    Some(cache.users)\n}\n\n/// Save user lookup to cache\nfn save_user_cache(users: \u0026HashMap\u003cString, String\u003e) {\n    let Some(path) = user_cache_path() else {\n        return;\n    };\n\n    let now = SystemTime::now()\n        .duration_since(SystemTime::UNIX_EPOCH)\n        .map(|d| d.as_secs())\n        .unwrap_or(0);\n\n    let cache = UserCache {\n        created: now,\n        users: users.clone(),\n    };\n\n    if let Ok(json) = serde_json::to_string(\u0026cache) {\n        let _ = fs::write(\u0026path, json);\n    }\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":1}},{"line":34,"address":[],"length":0,"stats":{"Line":4}},{"line":94,"address":[],"length":0,"stats":{"Line":3}},{"line":96,"address":[],"length":0,"stats":{"Line":3}},{"line":97,"address":[],"length":0,"stats":{"Line":3}},{"line":98,"address":[],"length":0,"stats":{"Line":6}},{"line":99,"address":[],"length":0,"stats":{"Line":6}},{"line":100,"address":[],"length":0,"stats":{"Line":13}},{"line":101,"address":[],"length":0,"stats":{"Line":13}},{"line":102,"address":[],"length":0,"stats":{"Line":3}},{"line":103,"address":[],"length":0,"stats":{"Line":6}},{"line":109,"address":[],"length":0,"stats":{"Line":3}},{"line":111,"address":[],"length":0,"stats":{"Line":6}},{"line":112,"address":[],"length":0,"stats":{"Line":6}},{"line":113,"address":[],"length":0,"stats":{"Line":6}},{"line":114,"address":[],"length":0,"stats":{"Line":6}},{"line":115,"address":[],"length":0,"stats":{"Line":9}},{"line":116,"address":[],"length":0,"stats":{"Line":6}},{"line":117,"address":[],"length":0,"stats":{"Line":3}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}}],"covered":19,"coverable":91},{"path":["/","Users","chi","Projects","hu","src","slack","channels","tests.rs"],"content":"use super::*;\n\n#[test]\nfn test_channel_response_to_slack_channel_full() {\n    let response = ChannelResponse {\n        id: \"C12345\".to_string(),\n        name: \"general\".to_string(),\n        is_private: Some(true),\n        is_member: Some(true),\n        topic: Some(TopicResponse {\n            value: \"Channel topic\".to_string(),\n        }),\n        purpose: Some(TopicResponse {\n            value: \"Channel purpose\".to_string(),\n        }),\n        num_members: Some(42),\n        created: Some(1704067200),\n    };\n\n    let channel = SlackChannel::from(response);\n    assert_eq!(channel.id, \"C12345\");\n    assert_eq!(channel.name, \"general\");\n    assert!(channel.is_private);\n    assert!(channel.is_member);\n    assert_eq!(channel.topic, Some(\"Channel topic\".to_string()));\n    assert_eq!(channel.purpose, Some(\"Channel purpose\".to_string()));\n    assert_eq!(channel.num_members, Some(42));\n    assert_eq!(channel.created, 1704067200);\n}\n\n#[test]\nfn test_channel_response_to_slack_channel_minimal() {\n    let response = ChannelResponse {\n        id: \"C12345\".to_string(),\n        name: \"general\".to_string(),\n        is_private: None,\n        is_member: None,\n        topic: None,\n        purpose: None,\n        num_members: None,\n        created: None,\n    };\n\n    let channel = SlackChannel::from(response);\n    assert_eq!(channel.id, \"C12345\");\n    assert_eq!(channel.name, \"general\");\n    assert!(!channel.is_private);\n    assert!(!channel.is_member);\n    assert!(channel.topic.is_none());\n    assert!(channel.purpose.is_none());\n    assert!(channel.num_members.is_none());\n    assert_eq!(channel.created, 0);\n}\n\n#[test]\nfn test_channel_response_empty_topic_filtered() {\n    let response = ChannelResponse {\n        id: \"C12345\".to_string(),\n        name: \"general\".to_string(),\n        is_private: None,\n        is_member: None,\n        topic: Some(TopicResponse {\n            value: \"\".to_string(),\n        }),\n        purpose: Some(TopicResponse {\n            value: \"\".to_string(),\n        }),\n        num_members: None,\n        created: None,\n    };\n\n    let channel = SlackChannel::from(response);\n    assert!(channel.topic.is_none());\n    assert!(channel.purpose.is_none());\n}\n\n#[test]\nfn test_user_response_to_slack_user_full() {\n    let response = UserResponse {\n        id: \"U12345\".to_string(),\n        team_id: Some(\"T12345\".to_string()),\n        name: \"alice\".to_string(),\n        real_name: Some(\"Alice Smith\".to_string()),\n        is_bot: Some(false),\n        deleted: Some(false),\n        tz: Some(\"America/New_York\".to_string()),\n    };\n\n    let user = SlackUser::from(response);\n    assert_eq!(user.id, \"U12345\");\n    assert_eq!(user.team_id, Some(\"T12345\".to_string()));\n    assert_eq!(user.name, \"alice\");\n    assert_eq!(user.real_name, Some(\"Alice Smith\".to_string()));\n    assert!(!user.is_bot);\n    assert!(!user.deleted);\n    assert_eq!(user.tz, Some(\"America/New_York\".to_string()));\n}\n\n#[test]\nfn test_user_response_to_slack_user_minimal() {\n    let response = UserResponse {\n        id: \"U12345\".to_string(),\n        team_id: None,\n        name: \"alice\".to_string(),\n        real_name: None,\n        is_bot: None,\n        deleted: None,\n        tz: None,\n    };\n\n    let user = SlackUser::from(response);\n    assert_eq!(user.id, \"U12345\");\n    assert!(user.team_id.is_none());\n    assert_eq!(user.name, \"alice\");\n    assert!(user.real_name.is_none());\n    assert!(!user.is_bot);\n    assert!(!user.deleted);\n    assert!(user.tz.is_none());\n}\n\n#[test]\nfn test_user_response_to_slack_user_bot() {\n    let response = UserResponse {\n        id: \"U12345\".to_string(),\n        team_id: None,\n        name: \"bot\".to_string(),\n        real_name: None,\n        is_bot: Some(true),\n        deleted: Some(true),\n        tz: None,\n    };\n\n    let user = SlackUser::from(response);\n    assert!(user.is_bot);\n    assert!(user.deleted);\n}\n\n#[test]\nfn test_user_cache_serialize_deserialize() {\n    let mut users = HashMap::new();\n    users.insert(\"U12345\".to_string(), \"alice\".to_string());\n    users.insert(\"U67890\".to_string(), \"bob\".to_string());\n\n    let cache = UserCache {\n        created: 1704067200,\n        users,\n    };\n\n    let json = serde_json::to_string(\u0026cache).unwrap();\n    let deserialized: UserCache = serde_json::from_str(\u0026json).unwrap();\n\n    assert_eq!(deserialized.created, 1704067200);\n    assert_eq!(deserialized.users.len(), 2);\n    assert_eq!(deserialized.users.get(\"U12345\"), Some(\u0026\"alice\".to_string()));\n}\n\n#[test]\nfn test_user_cache_path_is_some() {\n    // Should return Some on systems with a home directory\n    let path = user_cache_path();\n    if let Some(p) = path {\n        assert!(p.to_string_lossy().contains(\"slack_users_cache.json\"));\n    }\n}\n\n#[test]\nfn test_conversations_list_response_deserialize() {\n    let json = r#\"{\n            \"channels\": [\n                {\"id\": \"C12345\", \"name\": \"general\", \"is_private\": false, \"is_member\": true}\n            ],\n            \"response_metadata\": {\"next_cursor\": \"abc123\"}\n        }\"#;\n\n    let response: ConversationsListResponse = serde_json::from_str(json).unwrap();\n    assert_eq!(response.channels.len(), 1);\n    assert_eq!(response.channels[0].id, \"C12345\");\n    assert_eq!(\n        response.response_metadata.unwrap().next_cursor,\n        Some(\"abc123\".to_string())\n    );\n}\n\n#[test]\nfn test_conversations_list_response_no_cursor() {\n    let json = r#\"{\n            \"channels\": [\n                {\"id\": \"C12345\", \"name\": \"general\"}\n            ]\n        }\"#;\n\n    let response: ConversationsListResponse = serde_json::from_str(json).unwrap();\n    assert_eq!(response.channels.len(), 1);\n    assert!(response.response_metadata.is_none());\n}\n\n#[test]\nfn test_conversations_info_response_deserialize() {\n    let json = r#\"{\n            \"channel\": {\n                \"id\": \"C12345\",\n                \"name\": \"general\",\n                \"is_private\": true,\n                \"is_member\": true,\n                \"topic\": {\"value\": \"Discussion\"},\n                \"purpose\": {\"value\": \"General chat\"},\n                \"num_members\": 100,\n                \"created\": 1704067200\n            }\n        }\"#;\n\n    let response: ConversationsInfoResponse = serde_json::from_str(json).unwrap();\n    assert_eq!(response.channel.id, \"C12345\");\n    assert_eq!(response.channel.name, \"general\");\n}\n\n#[test]\nfn test_users_list_response_deserialize() {\n    let json = r#\"{\n            \"members\": [\n                {\"id\": \"U12345\", \"name\": \"alice\", \"real_name\": \"Alice\"},\n                {\"id\": \"U67890\", \"name\": \"bob\"}\n            ]\n        }\"#;\n\n    let response: UsersListResponse = serde_json::from_str(json).unwrap();\n    assert_eq!(response.members.len(), 2);\n    assert_eq!(response.members[0].id, \"U12345\");\n    assert_eq!(response.members[1].name, \"bob\");\n}\n\n#[test]\nfn test_topic_response_deserialize() {\n    let json = r#\"{\"value\": \"Test topic\"}\"#;\n    let topic: TopicResponse = serde_json::from_str(json).unwrap();\n    assert_eq!(topic.value, \"Test topic\");\n}\n\n#[test]\nfn test_response_metadata_deserialize() {\n    let json = r#\"{\"next_cursor\": \"cursor123\"}\"#;\n    let meta: ResponseMetadata = serde_json::from_str(json).unwrap();\n    assert_eq!(meta.next_cursor, Some(\"cursor123\".to_string()));\n}\n\n#[test]\nfn test_response_metadata_empty_cursor() {\n    let json = r#\"{}\"#;\n    let meta: ResponseMetadata = serde_json::from_str(json).unwrap();\n    assert!(meta.next_cursor.is_none());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","slack","client.rs"],"content":"//! Slack HTTP client\n//!\n//! Handles API requests with Bot token authentication.\n\nuse anyhow::Result;\nuse reqwest::Client;\nuse serde::de::DeserializeOwned;\nuse std::time::Duration;\nuse tokio::time::sleep;\n\nuse super::config::{load_config, SlackConfig};\n\nconst SLACK_API_URL: \u0026str = \"https://slack.com/api\";\nconst MAX_RETRIES: u32 = 3;\nconst DEFAULT_RETRY_SECS: u64 = 5;\n\n/// Slack API client\npub struct SlackClient {\n    config: SlackConfig,\n    http: Client,\n}\n\nimpl SlackClient {\n    /// Create a new Slack client\n    pub fn new() -\u003e Result\u003cSelf\u003e {\n        let config = load_config()?;\n        let http = Client::builder()\n            .user_agent(\"hu-cli/0.1.0\")\n            .no_proxy()\n            .build()\n            .map_err(|e| anyhow::anyhow!(format!(\"Failed to create HTTP client: {}\", e)))?;\n        Ok(Self { config, http })\n    }\n\n    /// Create a client for testing with explicit config and http client\n    #[cfg(test)]\n    pub fn with_config(config: SlackConfig, http: Client) -\u003e Self {\n        Self { config, http }\n    }\n\n    /// Get a reference to the current config (for testing)\n    #[cfg(test)]\n    #[must_use]\n    pub const fn config(\u0026self) -\u003e \u0026SlackConfig {\n        \u0026self.config\n    }\n\n    /// Get the bot token\n    fn bot_token(\u0026self) -\u003e Result\u003c\u0026str\u003e {\n        self.config\n            .oauth\n            .bot_token\n            .as_deref()\n            .ok_or_else(|| anyhow::anyhow!(\"bot_token not configured\".to_string()))\n    }\n\n    /// Get the user token (required for search API)\n    fn user_token(\u0026self) -\u003e Result\u003c\u0026str\u003e {\n        self.config.oauth.user_token.as_deref().ok_or_else(|| {\n            anyhow::anyhow!(\"user_token not configured (required for search)\".to_string())\n        })\n    }\n\n    /// Make a GET request to the Slack API\n    pub async fn get\u003cT: DeserializeOwned\u003e(\u0026self, method: \u0026str) -\u003e Result\u003cT\u003e {\n        let url = format!(\"{}/{}\", SLACK_API_URL, method);\n        let token = self.bot_token()?.to_string();\n\n        self.execute_with_retry(|| {\n            self.http\n                .get(\u0026url)\n                .header(\"Authorization\", format!(\"Bearer {}\", token))\n                .header(\"Accept\", \"application/json\")\n                .send()\n        })\n        .await\n    }\n\n    /// Make a GET request with query parameters\n    pub async fn get_with_params\u003cT: DeserializeOwned\u003e(\n        \u0026self,\n        method: \u0026str,\n        params: \u0026[(\u0026str, \u0026str)],\n    ) -\u003e Result\u003cT\u003e {\n        let url = format!(\"{}/{}\", SLACK_API_URL, method);\n        let token = self.bot_token()?.to_string();\n        let params: Vec\u003c(String, String)\u003e = params\n            .iter()\n            .map(|(k, v)| (k.to_string(), v.to_string()))\n            .collect();\n\n        self.execute_with_retry(|| {\n            self.http\n                .get(\u0026url)\n                .header(\"Authorization\", format!(\"Bearer {}\", token))\n                .header(\"Accept\", \"application/json\")\n                .query(\u0026params)\n                .send()\n        })\n        .await\n    }\n\n    /// Make a GET request using user token (required for search API)\n    pub async fn get_with_user_token\u003cT: DeserializeOwned\u003e(\n        \u0026self,\n        method: \u0026str,\n        params: \u0026[(\u0026str, \u0026str)],\n    ) -\u003e Result\u003cT\u003e {\n        let url = format!(\"{}/{}\", SLACK_API_URL, method);\n        let token = self.user_token()?.to_string();\n        let params: Vec\u003c(String, String)\u003e = params\n            .iter()\n            .map(|(k, v)| (k.to_string(), v.to_string()))\n            .collect();\n\n        self.execute_with_retry(|| {\n            self.http\n                .get(\u0026url)\n                .header(\"Authorization\", format!(\"Bearer {}\", token))\n                .header(\"Accept\", \"application/json\")\n                .query(\u0026params)\n                .send()\n        })\n        .await\n    }\n\n    /// Make a POST request to the Slack API\n    pub async fn post\u003cT, B\u003e(\u0026self, method: \u0026str, body: \u0026B) -\u003e Result\u003cT\u003e\n    where\n        T: DeserializeOwned,\n        B: serde::Serialize + Sync,\n    {\n        let url = format!(\"{}/{}\", SLACK_API_URL, method);\n        let token = self.bot_token()?.to_string();\n        let body_json = serde_json::to_string(body)?;\n\n        self.execute_with_retry(|| {\n            self.http\n                .post(\u0026url)\n                .header(\"Authorization\", format!(\"Bearer {}\", token))\n                .header(\"Accept\", \"application/json\")\n                .header(\"Content-Type\", \"application/json; charset=utf-8\")\n                .body(body_json.clone())\n                .send()\n        })\n        .await\n    }\n\n    /// Make a POST request using user token (required for conversations.mark)\n    pub async fn post_with_user_token\u003cT, B\u003e(\u0026self, method: \u0026str, body: \u0026B) -\u003e Result\u003cT\u003e\n    where\n        T: DeserializeOwned,\n        B: serde::Serialize + Sync,\n    {\n        let url = format!(\"{}/{}\", SLACK_API_URL, method);\n        let token = self.user_token()?.to_string();\n        let body_json = serde_json::to_string(body)?;\n\n        self.execute_with_retry(|| {\n            self.http\n                .post(\u0026url)\n                .header(\"Authorization\", format!(\"Bearer {}\", token))\n                .header(\"Accept\", \"application/json\")\n                .header(\"Content-Type\", \"application/json; charset=utf-8\")\n                .body(body_json.clone())\n                .send()\n        })\n        .await\n    }\n\n    /// Handle API response and check for Slack-specific errors\n    fn parse_response\u003cT: DeserializeOwned\u003e(\u0026self, text: \u0026str) -\u003e Result\u003cT\u003e {\n        // Slack returns { \"ok\": false, \"error\": \"...\" } for API errors\n        let value: serde_json::Value = serde_json::from_str(text)\n            .map_err(|e| anyhow::anyhow!(\"Parse error: {}: {}\", e, \u0026text[..text.len().min(200)]))?;\n\n        if let Some(ok) = value.get(\"ok\").and_then(serde_json::Value::as_bool) {\n            if !ok {\n                let error = value\n                    .get(\"error\")\n                    .and_then(|v| v.as_str())\n                    .unwrap_or(\"unknown error\");\n                return Err(anyhow::anyhow!(error.to_string()));\n            }\n        }\n\n        serde_json::from_str(text)\n            .map_err(|e| anyhow::anyhow!(\"Parse error: {}: {}\", e, \u0026text[..text.len().min(200)]))\n    }\n\n    /// Execute request with retry on rate limit\n    async fn execute_with_retry\u003cF, Fut, T\u003e(\u0026self, request_fn: F) -\u003e Result\u003cT\u003e\n    where\n        F: Fn() -\u003e Fut,\n        Fut: std::future::Future\u003cOutput = Result\u003creqwest::Response, reqwest::Error\u003e\u003e,\n        T: DeserializeOwned,\n    {\n        let mut retries = 0;\n\n        loop {\n            let response = request_fn().await?;\n            let status = response.status();\n\n            if status == reqwest::StatusCode::TOO_MANY_REQUESTS {\n                if retries \u003e= MAX_RETRIES {\n                    return Err(anyhow::anyhow!(\n                        \"Rate limited after {} retries\",\n                        MAX_RETRIES\n                    ));\n                }\n\n                // Get retry delay from header or use default\n                let retry_after = response\n                    .headers()\n                    .get(\"retry-after\")\n                    .and_then(|v| v.to_str().ok())\n                    .and_then(|s| s.parse::\u003cu64\u003e().ok())\n                    .unwrap_or(DEFAULT_RETRY_SECS);\n\n                eprintln!(\n                    \"Rate limited, waiting {} seconds... (retry {}/{})\",\n                    retry_after,\n                    retries + 1,\n                    MAX_RETRIES\n                );\n                sleep(Duration::from_secs(retry_after)).await;\n                retries += 1;\n                continue;\n            }\n\n            if !status.is_success() {\n                let body = response.text().await.unwrap_or_default();\n                return Err(anyhow::anyhow!(\"HTTP {}: {}\", status.as_u16(), body));\n            }\n\n            let text = response.text().await?;\n            return self.parse_response(\u0026text);\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::slack::config::{OAuthConfig, SlackConfig};\n\n    fn make_test_client() -\u003e SlackClient {\n        let config = SlackConfig {\n            oauth: OAuthConfig {\n                client_id: None,\n                client_secret: None,\n                bot_token: Some(\"xoxb-test\".to_string()),\n                user_token: Some(\"xoxp-test\".to_string()),\n                team_id: Some(\"T12345\".to_string()),\n                team_name: Some(\"Test Team\".to_string()),\n            },\n            default_channel: String::new(),\n            is_configured: true,\n        };\n        let http = Client::builder().build().unwrap();\n        SlackClient::with_config(config, http)\n    }\n\n    #[test]\n    fn test_parse_response_success() {\n        let client = make_test_client();\n        let json = r#\"{\"ok\": true, \"name\": \"test\"}\"#;\n\n        #[derive(Debug, serde::Deserialize, PartialEq)]\n        struct TestResponse {\n            ok: bool,\n            name: String,\n        }\n\n        let result: Result\u003cTestResponse\u003e = client.parse_response(json);\n        assert!(result.is_ok());\n        let resp = result.unwrap();\n        assert!(resp.ok);\n        assert_eq!(resp.name, \"test\");\n    }\n\n    #[test]\n    fn test_parse_response_slack_error() {\n        let client = make_test_client();\n        let json = r#\"{\"ok\": false, \"error\": \"channel_not_found\"}\"#;\n\n        #[derive(Debug, serde::Deserialize)]\n        struct TestResponse {\n            ok: bool,\n        }\n\n        let result: Result\u003cTestResponse\u003e = client.parse_response(json);\n        assert!(result.is_err());\n        let err = result.unwrap_err();\n        assert!(err.to_string().contains(\"channel_not_found\"));\n    }\n\n    #[test]\n    fn test_parse_response_slack_error_unknown() {\n        let client = make_test_client();\n        let json = r#\"{\"ok\": false}\"#;\n\n        #[derive(Debug, serde::Deserialize)]\n        struct TestResponse {\n            ok: bool,\n        }\n\n        let result: Result\u003cTestResponse\u003e = client.parse_response(json);\n        assert!(result.is_err());\n        let err = result.unwrap_err();\n        assert!(err.to_string().contains(\"unknown error\"));\n    }\n\n    #[test]\n    fn test_parse_response_invalid_json() {\n        let client = make_test_client();\n        let json = \"not json at all\";\n\n        #[derive(Debug, serde::Deserialize)]\n        struct TestResponse {\n            ok: bool,\n        }\n\n        let result: Result\u003cTestResponse\u003e = client.parse_response(json);\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"Parse error\"));\n    }\n\n    #[test]\n    fn test_bot_token() {\n        let client = make_test_client();\n        assert_eq!(client.bot_token().unwrap(), \"xoxb-test\");\n    }\n\n    #[test]\n    fn test_user_token() {\n        let client = make_test_client();\n        assert_eq!(client.user_token().unwrap(), \"xoxp-test\");\n    }\n\n    #[test]\n    fn test_bot_token_missing() {\n        let config = SlackConfig {\n            oauth: OAuthConfig {\n                client_id: None,\n                client_secret: None,\n                bot_token: None,\n                user_token: None,\n                team_id: None,\n                team_name: None,\n            },\n            default_channel: String::new(),\n            is_configured: false,\n        };\n        let http = Client::builder().build().unwrap();\n        let client = SlackClient::with_config(config, http);\n\n        assert!(client.bot_token().is_err());\n    }\n\n    #[test]\n    fn test_user_token_missing() {\n        let config = SlackConfig {\n            oauth: OAuthConfig {\n                client_id: None,\n                client_secret: None,\n                bot_token: Some(\"xoxb-test\".to_string()),\n                user_token: None,\n                team_id: None,\n                team_name: None,\n            },\n            default_channel: String::new(),\n            is_configured: true,\n        };\n        let http = Client::builder().build().unwrap();\n        let client = SlackClient::with_config(config, http);\n\n        assert!(client.user_token().is_err());\n    }\n\n    #[test]\n    fn test_config_accessor() {\n        let client = make_test_client();\n        assert!(client.config().is_configured);\n        assert_eq!(\n            client.config().oauth.team_name,\n            Some(\"Test Team\".to_string())\n        );\n    }\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":9}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":2}},{"line":50,"address":[],"length":0,"stats":{"Line":2}},{"line":51,"address":[],"length":0,"stats":{"Line":2}},{"line":52,"address":[],"length":0,"stats":{"Line":2}},{"line":54,"address":[],"length":0,"stats":{"Line":4}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":59,"address":[],"length":0,"stats":{"Line":7}},{"line":60,"address":[],"length":0,"stats":{"Line":2}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":4}},{"line":174,"address":[],"length":0,"stats":{"Line":14}},{"line":175,"address":[],"length":0,"stats":{"Line":10}},{"line":177,"address":[],"length":0,"stats":{"Line":9}},{"line":178,"address":[],"length":0,"stats":{"Line":3}},{"line":179,"address":[],"length":0,"stats":{"Line":4}},{"line":181,"address":[],"length":0,"stats":{"Line":4}},{"line":183,"address":[],"length":0,"stats":{"Line":4}},{"line":187,"address":[],"length":0,"stats":{"Line":2}},{"line":188,"address":[],"length":0,"stats":{"Line":1}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}}],"covered":21,"coverable":115},{"path":["/","Users","chi","Projects","hu","src","slack","config","mod.rs"],"content":"//! Slack configuration management\n//!\n//! Loads configuration from `~/.config/hu/settings.toml` with environment variable overrides.\n\nuse anyhow::Result;\nuse serde::{Deserialize, Serialize};\nuse std::fs;\nuse std::path::PathBuf;\n\n#[cfg(test)]\nmod tests;\n\n/// Slack configuration\n#[derive(Debug, Clone, Default)]\npub struct SlackConfig {\n    /// Default channel (e.g., \"#general\")\n    pub default_channel: String,\n    /// OAuth configuration\n    pub oauth: OAuthConfig,\n    /// Whether configuration is complete\n    pub is_configured: bool,\n}\n\n/// OAuth 2.0 configuration for Slack\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct OAuthConfig {\n    /// OAuth client ID\n    pub client_id: Option\u003cString\u003e,\n    /// OAuth client secret\n    pub client_secret: Option\u003cString\u003e,\n    /// Bot token (xoxb-...)\n    pub bot_token: Option\u003cString\u003e,\n    /// User token (xoxp-...) - required for search API\n    pub user_token: Option\u003cString\u003e,\n    /// Team/workspace ID\n    pub team_id: Option\u003cString\u003e,\n    /// Team/workspace name\n    pub team_name: Option\u003cString\u003e,\n}\n\nimpl OAuthConfig {\n    /// Check if OAuth is fully configured (bot token present)\n    #[must_use]\n    pub fn is_configured(\u0026self) -\u003e bool {\n        self.bot_token\n            .as_ref()\n            .is_some_and(|t| t.starts_with(\"xoxb-\"))\n    }\n\n    /// Check if user token is available (required for search)\n    #[must_use]\n    pub fn has_user_token(\u0026self) -\u003e bool {\n        self.user_token\n            .as_ref()\n            .is_some_and(|t| t.starts_with(\"xoxp-\"))\n    }\n}\n\n/// Raw TOML structure for settings file\n#[derive(Debug, Deserialize)]\nstruct SettingsFile {\n    slack: Option\u003cSlackSection\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct SlackSection {\n    default_channel: Option\u003cString\u003e,\n    oauth: Option\u003cOAuthSection\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct OAuthSection {\n    client_id: Option\u003cString\u003e,\n    client_secret: Option\u003cString\u003e,\n    bot_token: Option\u003cString\u003e,\n    user_token: Option\u003cString\u003e,\n    team_id: Option\u003cString\u003e,\n    team_name: Option\u003cString\u003e,\n}\n\n/// Get the config file path\n///\n/// Uses `~/.config/hu/settings.toml` following XDG convention.\n#[must_use]\npub fn config_path() -\u003e Option\u003cPathBuf\u003e {\n    dirs::home_dir().map(|p| p.join(\".config\").join(\"hu\").join(\"settings.toml\"))\n}\n\n/// Load Slack configuration from settings file and environment variables\npub fn load_config() -\u003e Result\u003cSlackConfig\u003e {\n    let mut config = SlackConfig::default();\n\n    // Try to load from settings file\n    if let Some(path) = config_path() {\n        if path.exists() {\n            // debug!(\"Loading Slack config from {}\", path.display());\n            let contents = fs::read_to_string(\u0026path).map_err(|e| {\n                anyhow::anyhow!(format!(\"Failed to read {}: {}\", path.display(), e))\n            })?;\n\n            let settings: SettingsFile = toml::from_str(\u0026contents).map_err(|e| {\n                anyhow::anyhow!(format!(\"Failed to parse {}: {}\", path.display(), e))\n            })?;\n\n            if let Some(slack) = settings.slack {\n                config.default_channel = slack.default_channel.unwrap_or_default();\n\n                if let Some(oauth) = slack.oauth {\n                    config.oauth = OAuthConfig {\n                        client_id: oauth.client_id,\n                        client_secret: oauth.client_secret,\n                        bot_token: oauth.bot_token,\n                        user_token: oauth.user_token,\n                        team_id: oauth.team_id,\n                        team_name: oauth.team_name,\n                    };\n                }\n            }\n        }\n    }\n\n    // Environment variable overrides\n    if let Ok(token) = std::env::var(\"SLACK_BOT_TOKEN\") {\n        config.oauth.bot_token = Some(token);\n    }\n    if let Ok(token) = std::env::var(\"SLACK_USER_TOKEN\") {\n        config.oauth.user_token = Some(token);\n    }\n    if let Ok(channel) = std::env::var(\"SLACK_DEFAULT_CHANNEL\") {\n        config.default_channel = channel;\n    }\n\n    // Determine configuration status\n    config.is_configured = config.oauth.is_configured();\n\n    Ok(config)\n}\n\n/// Update OAuth tokens in the config file after successful authentication\npub fn update_oauth_tokens(bot_token: \u0026str, team_id: \u0026str, team_name: \u0026str) -\u003e Result\u003c()\u003e {\n    let path = config_path()\n        .ok_or_else(|| anyhow::anyhow!(\"Cannot determine config directory\".to_string()))?;\n\n    // Read existing file\n    let contents = if path.exists() {\n        fs::read_to_string(\u0026path)\n            .map_err(|e| anyhow::anyhow!(format!(\"Failed to read {}: {}\", path.display(), e)))?\n    } else {\n        String::new()\n    };\n\n    // Parse as TOML value for modification\n    let mut doc: toml::Value =\n        toml::from_str(\u0026contents).unwrap_or_else(|_| toml::Value::Table(toml::map::Map::new()));\n\n    // Ensure slack.oauth section exists\n    let table = doc\n        .as_table_mut()\n        .ok_or_else(|| anyhow::anyhow!(\"Config is not a table\".to_string()))?;\n\n    if !table.contains_key(\"slack\") {\n        table.insert(\n            \"slack\".to_string(),\n            toml::Value::Table(toml::map::Map::new()),\n        );\n    }\n\n    let slack = table\n        .get_mut(\"slack\")\n        .and_then(|v| v.as_table_mut())\n        .ok_or_else(|| anyhow::anyhow!(\"slack section is not a table\".to_string()))?;\n\n    if !slack.contains_key(\"oauth\") {\n        slack.insert(\n            \"oauth\".to_string(),\n            toml::Value::Table(toml::map::Map::new()),\n        );\n    }\n\n    let oauth = slack\n        .get_mut(\"oauth\")\n        .and_then(|v| v.as_table_mut())\n        .ok_or_else(|| anyhow::anyhow!(\"slack.oauth section is not a table\".to_string()))?;\n\n    // Update tokens\n    oauth.insert(\n        \"bot_token\".to_string(),\n        toml::Value::String(bot_token.to_string()),\n    );\n    oauth.insert(\n        \"team_id\".to_string(),\n        toml::Value::String(team_id.to_string()),\n    );\n    oauth.insert(\n        \"team_name\".to_string(),\n        toml::Value::String(team_name.to_string()),\n    );\n\n    // Write back\n    let output = toml::to_string_pretty(\u0026doc)\n        .map_err(|e| anyhow::anyhow!(format!(\"Failed to serialize config: {}\", e)))?;\n\n    // Ensure parent directory exists\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent)\n            .map_err(|e| anyhow::anyhow!(format!(\"Failed to create config directory: {}\", e)))?;\n    }\n\n    fs::write(\u0026path, output)\n        .map_err(|e| anyhow::anyhow!(format!(\"Failed to write {}: {}\", path.display(), e)))?;\n\n    // debug!(\"Updated Slack OAuth tokens in {}\", path.display());\n    Ok(())\n}\n\n/// Update user token in the config file\npub fn update_user_token(user_token: \u0026str) -\u003e Result\u003c()\u003e {\n    let path = config_path()\n        .ok_or_else(|| anyhow::anyhow!(\"Cannot determine config directory\".to_string()))?;\n\n    // Read existing file\n    let contents = if path.exists() {\n        fs::read_to_string(\u0026path)\n            .map_err(|e| anyhow::anyhow!(format!(\"Failed to read {}: {}\", path.display(), e)))?\n    } else {\n        String::new()\n    };\n\n    // Parse as TOML value for modification\n    let mut doc: toml::Value =\n        toml::from_str(\u0026contents).unwrap_or_else(|_| toml::Value::Table(toml::map::Map::new()));\n\n    // Ensure slack.oauth section exists\n    let table = doc\n        .as_table_mut()\n        .ok_or_else(|| anyhow::anyhow!(\"Config is not a table\".to_string()))?;\n\n    if !table.contains_key(\"slack\") {\n        table.insert(\n            \"slack\".to_string(),\n            toml::Value::Table(toml::map::Map::new()),\n        );\n    }\n\n    let slack = table\n        .get_mut(\"slack\")\n        .and_then(|v| v.as_table_mut())\n        .ok_or_else(|| anyhow::anyhow!(\"slack section is not a table\".to_string()))?;\n\n    if !slack.contains_key(\"oauth\") {\n        slack.insert(\n            \"oauth\".to_string(),\n            toml::Value::Table(toml::map::Map::new()),\n        );\n    }\n\n    let oauth = slack\n        .get_mut(\"oauth\")\n        .and_then(|v| v.as_table_mut())\n        .ok_or_else(|| anyhow::anyhow!(\"slack.oauth section is not a table\".to_string()))?;\n\n    // Update user token\n    oauth.insert(\n        \"user_token\".to_string(),\n        toml::Value::String(user_token.to_string()),\n    );\n\n    // Write back\n    let output = toml::to_string_pretty(\u0026doc)\n        .map_err(|e| anyhow::anyhow!(format!(\"Failed to serialize config: {}\", e)))?;\n\n    // Ensure parent directory exists\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent)\n            .map_err(|e| anyhow::anyhow!(format!(\"Failed to create config directory: {}\", e)))?;\n    }\n\n    fs::write(\u0026path, output)\n        .map_err(|e| anyhow::anyhow!(format!(\"Failed to write {}: {}\", path.display(), e)))?;\n\n    // debug!(\"Updated Slack user token in {}\", path.display());\n    Ok(())\n}\n","traces":[{"line":44,"address":[],"length":0,"stats":{"Line":4}},{"line":45,"address":[],"length":0,"stats":{"Line":4}},{"line":47,"address":[],"length":0,"stats":{"Line":8}},{"line":52,"address":[],"length":0,"stats":{"Line":5}},{"line":53,"address":[],"length":0,"stats":{"Line":5}},{"line":55,"address":[],"length":0,"stats":{"Line":11}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":8}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}}],"covered":8,"coverable":112},{"path":["/","Users","chi","Projects","hu","src","slack","config","tests.rs"],"content":"use super::*;\n\n#[test]\nfn test_oauth_config_is_configured_with_valid_bot_token() {\n    let config = OAuthConfig {\n        client_id: None,\n        client_secret: None,\n        bot_token: Some(\"xoxb-12345-67890\".to_string()),\n        user_token: None,\n        team_id: None,\n        team_name: None,\n    };\n    assert!(config.is_configured());\n}\n\n#[test]\nfn test_oauth_config_is_configured_with_invalid_bot_token() {\n    let config = OAuthConfig {\n        client_id: None,\n        client_secret: None,\n        bot_token: Some(\"invalid-token\".to_string()),\n        user_token: None,\n        team_id: None,\n        team_name: None,\n    };\n    assert!(!config.is_configured());\n}\n\n#[test]\nfn test_oauth_config_is_configured_without_bot_token() {\n    let config = OAuthConfig {\n        client_id: None,\n        client_secret: None,\n        bot_token: None,\n        user_token: None,\n        team_id: None,\n        team_name: None,\n    };\n    assert!(!config.is_configured());\n}\n\n#[test]\nfn test_oauth_config_has_user_token_with_valid_token() {\n    let config = OAuthConfig {\n        client_id: None,\n        client_secret: None,\n        bot_token: None,\n        user_token: Some(\"xoxp-12345-67890\".to_string()),\n        team_id: None,\n        team_name: None,\n    };\n    assert!(config.has_user_token());\n}\n\n#[test]\nfn test_oauth_config_has_user_token_with_invalid_token() {\n    let config = OAuthConfig {\n        client_id: None,\n        client_secret: None,\n        bot_token: None,\n        user_token: Some(\"invalid-token\".to_string()),\n        team_id: None,\n        team_name: None,\n    };\n    assert!(!config.has_user_token());\n}\n\n#[test]\nfn test_oauth_config_has_user_token_without_token() {\n    let config = OAuthConfig {\n        client_id: None,\n        client_secret: None,\n        bot_token: None,\n        user_token: None,\n        team_id: None,\n        team_name: None,\n    };\n    assert!(!config.has_user_token());\n}\n\n#[test]\nfn test_config_path_returns_some() {\n    // This test just verifies config_path returns Some on systems with a home dir\n    let path = config_path();\n    // On most systems this should return Some\n    if let Some(p) = path {\n        assert!(p.to_string_lossy().contains(\"settings.toml\"));\n    }\n}\n\n#[test]\nfn test_slack_config_default() {\n    let config = SlackConfig::default();\n    assert!(!config.is_configured);\n    assert!(config.default_channel.is_empty());\n    assert!(!config.oauth.is_configured());\n}\n\n#[test]\nfn test_oauth_config_default() {\n    let config = OAuthConfig::default();\n    assert!(config.client_id.is_none());\n    assert!(config.client_secret.is_none());\n    assert!(config.bot_token.is_none());\n    assert!(config.user_token.is_none());\n    assert!(config.team_id.is_none());\n    assert!(config.team_name.is_none());\n}\n\n#[test]\nfn test_oauth_config_serialize_deserialize() {\n    let config = OAuthConfig {\n        client_id: Some(\"client123\".to_string()),\n        client_secret: Some(\"secret456\".to_string()),\n        bot_token: Some(\"xoxb-test\".to_string()),\n        user_token: Some(\"xoxp-test\".to_string()),\n        team_id: Some(\"T12345\".to_string()),\n        team_name: Some(\"Test Team\".to_string()),\n    };\n\n    let json = serde_json::to_string(\u0026config).unwrap();\n    let deserialized: OAuthConfig = serde_json::from_str(\u0026json).unwrap();\n\n    assert_eq!(deserialized.client_id, Some(\"client123\".to_string()));\n    assert_eq!(deserialized.client_secret, Some(\"secret456\".to_string()));\n    assert_eq!(deserialized.bot_token, Some(\"xoxb-test\".to_string()));\n    assert_eq!(deserialized.user_token, Some(\"xoxp-test\".to_string()));\n    assert_eq!(deserialized.team_id, Some(\"T12345\".to_string()));\n    assert_eq!(deserialized.team_name, Some(\"Test Team\".to_string()));\n}\n\n#[test]\nfn test_oauth_config_debug() {\n    let config = OAuthConfig {\n        client_id: Some(\"client123\".to_string()),\n        client_secret: None,\n        bot_token: None,\n        user_token: None,\n        team_id: None,\n        team_name: None,\n    };\n\n    let debug = format!(\"{:?}\", config);\n    assert!(debug.contains(\"OAuthConfig\"));\n    assert!(debug.contains(\"client123\"));\n}\n\n#[test]\nfn test_oauth_config_clone() {\n    let config = OAuthConfig {\n        client_id: Some(\"client123\".to_string()),\n        client_secret: None,\n        bot_token: Some(\"xoxb-test\".to_string()),\n        user_token: None,\n        team_id: None,\n        team_name: None,\n    };\n\n    let cloned = config.clone();\n    assert_eq!(cloned.client_id, config.client_id);\n    assert_eq!(cloned.bot_token, config.bot_token);\n}\n\n#[test]\nfn test_slack_config_clone() {\n    let config = SlackConfig {\n        default_channel: \"general\".to_string(),\n        oauth: OAuthConfig::default(),\n        is_configured: true,\n    };\n\n    let cloned = config.clone();\n    assert_eq!(cloned.default_channel, \"general\");\n    assert!(cloned.is_configured);\n}\n\n#[test]\nfn test_slack_config_debug() {\n    let config = SlackConfig {\n        default_channel: \"test\".to_string(),\n        oauth: OAuthConfig::default(),\n        is_configured: false,\n    };\n\n    let debug = format!(\"{:?}\", config);\n    assert!(debug.contains(\"SlackConfig\"));\n    assert!(debug.contains(\"test\"));\n}\n\n#[test]\nfn test_settings_file_parse() {\n    let toml_str = r##\"\n            [slack]\n            default_channel = \"general\"\n\n            [slack.oauth]\n            client_id = \"client123\"\n            client_secret = \"secret456\"\n            bot_token = \"xoxb-token\"\n            user_token = \"xoxp-token\"\n            team_id = \"T12345\"\n            team_name = \"Test Team\"\n        \"##;\n\n    let settings: SettingsFile = toml::from_str(toml_str).unwrap();\n    let slack = settings.slack.unwrap();\n    assert_eq!(slack.default_channel, Some(\"general\".to_string()));\n\n    let oauth = slack.oauth.unwrap();\n    assert_eq!(oauth.client_id, Some(\"client123\".to_string()));\n    assert_eq!(oauth.bot_token, Some(\"xoxb-token\".to_string()));\n    assert_eq!(oauth.team_name, Some(\"Test Team\".to_string()));\n}\n\n#[test]\nfn test_settings_file_parse_empty() {\n    let toml_str = \"\";\n    let settings: SettingsFile = toml::from_str(toml_str).unwrap();\n    assert!(settings.slack.is_none());\n}\n\n#[test]\nfn test_settings_file_parse_no_oauth() {\n    let toml_str = r##\"\n            [slack]\n            default_channel = \"test\"\n        \"##;\n\n    let settings: SettingsFile = toml::from_str(toml_str).unwrap();\n    let slack = settings.slack.unwrap();\n    assert_eq!(slack.default_channel, Some(\"test\".to_string()));\n    assert!(slack.oauth.is_none());\n}\n\n#[test]\nfn test_settings_file_parse_partial_oauth() {\n    let toml_str = r##\"\n            [slack.oauth]\n            bot_token = \"xoxb-test\"\n        \"##;\n\n    let settings: SettingsFile = toml::from_str(toml_str).unwrap();\n    let slack = settings.slack.unwrap();\n    let oauth = slack.oauth.unwrap();\n    assert_eq!(oauth.bot_token, Some(\"xoxb-test\".to_string()));\n    assert!(oauth.client_id.is_none());\n}\n\n#[test]\nfn test_slack_section_debug() {\n    let toml_str = r##\"\n            [slack]\n            default_channel = \"test\"\n        \"##;\n\n    let settings: SettingsFile = toml::from_str(toml_str).unwrap();\n    let debug = format!(\"{:?}\", settings);\n    assert!(debug.contains(\"SettingsFile\"));\n}\n\n#[test]\nfn test_oauth_section_debug() {\n    let toml_str = r##\"\n            [slack.oauth]\n            bot_token = \"xoxb-test\"\n        \"##;\n\n    let settings: SettingsFile = toml::from_str(toml_str).unwrap();\n    let debug = format!(\"{:?}\", settings.slack.unwrap().oauth.unwrap());\n    assert!(debug.contains(\"OAuthSection\"));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","slack","display","mod.rs"],"content":"//! Slack output formatting\n\nuse anyhow::{Context, Result};\nuse comfy_table::{presets::UTF8_FULL_CONDENSED, Cell, Color, ContentArrangement, Table};\nuse regex::Regex;\nuse std::collections::HashMap;\n\nuse super::types::{OutputFormat, SlackChannel, SlackMessage, SlackSearchResult, SlackUser};\n\n#[cfg(test)]\nmod tests;\n\n/// Truncate string to max length with ellipsis\nfn truncate(s: \u0026str, max_len: usize) -\u003e String {\n    if s.len() \u003c= max_len {\n        s.to_string()\n    } else {\n        format!(\"{}...\", \u0026s[..max_len.saturating_sub(3)])\n    }\n}\n\n/// Clean up Slack message text for display\n/// - Converts \u003c@U04H482TK6Z|Adam Ladachowski\u003e to @Adam Ladachowski\n/// - Converts \u003c@U04H482TK6Z\u003e to @username using lookup\n/// - Converts \u003c#C12345678|channel-name\u003e to #channel-name\n/// - Converts \u003cURL|text\u003e to text\nfn clean_message_text(text: \u0026str, user_lookup: \u0026HashMap\u003cString, String\u003e) -\u003e String {\n    // Match Slack's special formatting: \u003c...\u003e\n    let re = Regex::new(r\"\u003c([^\u003e]+)\u003e\").unwrap();\n\n    re.replace_all(text, |caps: \u0026regex::Captures| {\n        let content = \u0026caps[1];\n\n        if let Some(rest) = content.strip_prefix('@') {\n            // User mention: \u003c@U12345|Display Name\u003e or \u003c@U12345\u003e\n            if let Some((_, display_name)) = rest.split_once('|') {\n                format!(\"@{}\", display_name)\n            } else {\n                // No display name, look up user ID\n                user_lookup\n                    .get(rest)\n                    .map(|name| format!(\"@{}\", name))\n                    .unwrap_or_else(|| format!(\"@{}\", rest))\n            }\n        } else if let Some(rest) = content.strip_prefix('#') {\n            // Channel mention: \u003c#C12345|channel-name\u003e\n            if let Some((_, channel_name)) = rest.split_once('|') {\n                format!(\"#{}\", channel_name)\n            } else {\n                format!(\"#{}\", rest)\n            }\n        } else if let Some(rest) = content.strip_prefix('!') {\n            // Special mention: \u003c!here\u003e, \u003c!channel\u003e, \u003c!everyone\u003e\n            format!(\"@{}\", rest)\n        } else if content.contains('|') {\n            // URL with display text: \u003chttps://example.com|Example\u003e\n            let (_, display) = content.split_once('|').unwrap();\n            display.to_string()\n        } else {\n            // Plain URL or other\n            content.to_string()\n        }\n    })\n    .to_string()\n}\n\n/// Format channel name for display\n/// Converts mpdm-user1--user2--user3-1 to @user1, @user2, @user3\n/// Converts user IDs like U04H482TK6Z to @username using lookup\nfn format_channel_name(name: \u0026str, user_lookup: \u0026HashMap\u003cString, String\u003e) -\u003e String {\n    if name.starts_with(\"mpdm-\") {\n        // Multi-person DM: mpdm-user1--user2--user3-1\n        let without_prefix = name.strip_prefix(\"mpdm-\").unwrap_or(name);\n        // Remove trailing -1, -2, etc.\n        let without_suffix = without_prefix\n            .rsplit_once('-')\n            .map(|(rest, _)| rest)\n            .unwrap_or(without_prefix);\n        // Split on -- and format as @mentions\n        let users: Vec\u003cString\u003e = without_suffix\n            .split(\"--\")\n            .map(|u| format!(\"@{}\", u))\n            .collect();\n        users.join(\", \")\n    } else if name.starts_with('U')\n        \u0026\u0026 name.len() == 11\n        \u0026\u0026 name.chars().all(|c| c.is_ascii_alphanumeric())\n    {\n        // User ID (DM): resolve to @username\n        user_lookup\n            .get(name)\n            .map(|n| format!(\"@{}\", n))\n            .unwrap_or_else(|| \"DM\".to_string())\n    } else {\n        format!(\"#{}\", name)\n    }\n}\n\n/// Format Unix timestamp to readable date\nfn format_timestamp(ts: \u0026str) -\u003e String {\n    // Slack timestamps are like \"1234567890.123456\"\n    ts.split('.')\n        .next()\n        .and_then(|s| s.parse::\u003ci64\u003e().ok())\n        .and_then(|secs| chrono::DateTime::from_timestamp(secs, 0))\n        .map_or_else(\n            || ts.to_string(),\n            |dt| dt.format(\"%Y-%m-%d %H:%M\").to_string(),\n        )\n}\n\n/// Output channels list\npub fn output_channels(channels: \u0026[SlackChannel], format: OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            if channels.is_empty() {\n                println!(\"No channels found.\");\n                return Ok(());\n            }\n\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_content_arrangement(ContentArrangement::Dynamic);\n            table.set_header(vec![\"Name\", \"Type\", \"Members\", \"Topic\"]);\n\n            for channel in channels {\n                let channel_type = if channel.is_private {\n                    \"private\"\n                } else {\n                    \"public\"\n                };\n                let members = channel\n                    .num_members\n                    .map_or_else(|| \"-\".to_string(), |n| n.to_string());\n                let topic = channel.topic.as_deref().unwrap_or(\"-\");\n\n                table.add_row(vec![\n                    Cell::new(format!(\"#{}\", channel.name)).fg(Color::Cyan),\n                    Cell::new(channel_type),\n                    Cell::new(members),\n                    Cell::new(truncate(topic, 40)),\n                ]);\n            }\n\n            println!(\"{table}\");\n            println!(\"\\n{} channels\", channels.len());\n        }\n        OutputFormat::Json =\u003e {\n            let json = serde_json::to_string_pretty(channels)\n                .context(\"Failed to serialize channels to JSON\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n\n/// Output channel detail\npub fn output_channel_detail(channel: \u0026SlackChannel, format: OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            println!(\"{}\", \"-\".repeat(60));\n            println!(\"#{} ({})\", channel.name, channel.id);\n            println!(\"{}\", \"-\".repeat(60));\n            println!(\n                \"Type:    {}\",\n                if channel.is_private {\n                    \"private\"\n                } else {\n                    \"public\"\n                }\n            );\n            println!(\"Member:  {}\", if channel.is_member { \"yes\" } else { \"no\" });\n            if let Some(n) = channel.num_members {\n                println!(\"Members: {}\", n);\n            }\n            if let Some(ref topic) = channel.topic {\n                println!(\"\\nTopic: {}\", topic);\n            }\n            if let Some(ref purpose) = channel.purpose {\n                println!(\"\\nPurpose: {}\", purpose);\n            }\n        }\n        OutputFormat::Json =\u003e {\n            let json = serde_json::to_string_pretty(channel)\n                .context(\"Failed to serialize channel to JSON\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n\n/// Output message history\npub fn output_messages(\n    messages: \u0026[SlackMessage],\n    channel_name: \u0026str,\n    format: OutputFormat,\n) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            if messages.is_empty() {\n                println!(\"No messages found.\");\n                return Ok(());\n            }\n\n            println!(\"Messages in #{}\", channel_name);\n            println!(\"{}\", \"-\".repeat(60));\n\n            for msg in messages.iter().rev() {\n                let time = format_timestamp(\u0026msg.ts);\n                let user = msg\n                    .username\n                    .as_deref()\n                    .or(msg.user.as_deref())\n                    .unwrap_or(\"unknown\");\n                let thread = msg\n                    .reply_count\n                    .map_or(String::new(), |n| format!(\" [{} replies]\", n));\n\n                println!(\"[{}] {}: {}{}\", time, user, msg.text, thread);\n            }\n\n            println!(\"\\n{} messages\", messages.len());\n        }\n        OutputFormat::Json =\u003e {\n            let json = serde_json::to_string_pretty(messages)\n                .context(\"Failed to serialize messages to JSON\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n\n/// Output search results\npub fn output_search_results(\n    results: \u0026SlackSearchResult,\n    format: OutputFormat,\n    user_lookup: \u0026HashMap\u003cString, String\u003e,\n) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            if results.matches.is_empty() {\n                println!(\"No messages found.\");\n                return Ok(());\n            }\n\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_content_arrangement(ContentArrangement::Dynamic);\n            table.set_header(vec![\"Channel\", \"User\", \"Time\", \"Message\"]);\n\n            for m in \u0026results.matches {\n                let time = format_timestamp(\u0026m.ts);\n                let user = m.username.as_deref().unwrap_or(\"-\");\n                let channel = format_channel_name(\u0026m.channel.name, user_lookup);\n                let text = clean_message_text(\u0026m.text, user_lookup);\n\n                table.add_row(vec![\n                    Cell::new(\u0026channel).fg(Color::Cyan),\n                    Cell::new(user),\n                    Cell::new(time),\n                    Cell::new(truncate(\u0026text, 50)),\n                ]);\n            }\n\n            println!(\"{table}\");\n            println!(\n                \"\\nShowing {} of {} matches\",\n                results.matches.len(),\n                results.total\n            );\n        }\n        OutputFormat::Json =\u003e {\n            let json = serde_json::to_string_pretty(results)\n                .context(\"Failed to serialize search results to JSON\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n\n/// Output users list\npub fn output_users(users: \u0026[SlackUser], format: OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            if users.is_empty() {\n                println!(\"No users found.\");\n                return Ok(());\n            }\n\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_content_arrangement(ContentArrangement::Dynamic);\n            table.set_header(vec![\"Username\", \"Name\", \"Timezone\"]);\n\n            for user in users {\n                let name = user.real_name.as_deref().unwrap_or(\"-\");\n                let tz = user.tz.as_deref().unwrap_or(\"-\");\n\n                table.add_row(vec![\n                    Cell::new(format!(\"@{}\", user.name)).fg(Color::Cyan),\n                    Cell::new(name),\n                    Cell::new(tz),\n                ]);\n            }\n\n            println!(\"{table}\");\n            println!(\"\\n{} users\", users.len());\n        }\n        OutputFormat::Json =\u003e {\n            let json =\n                serde_json::to_string_pretty(users).context(\"Failed to serialize users to JSON\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n\n/// Output config status\npub fn output_config_status(\n    is_configured: bool,\n    has_user_token: bool,\n    team_name: Option\u003c\u0026str\u003e,\n    default_channel: \u0026str,\n) {\n    println!(\"Slack Configuration\");\n    println!(\"{}\", \"-\".repeat(40));\n    println!(\"Bot token:  {}\", if is_configured { \"Yes\" } else { \"No\" });\n    println!(\n        \"User token: {}\",\n        if has_user_token {\n            \"Yes (search enabled)\"\n        } else {\n            \"No (search disabled)\"\n        }\n    );\n    if let Some(name) = team_name {\n        println!(\"Workspace:  {}\", name);\n    }\n    if !default_channel.is_empty() {\n        println!(\"Default:    {}\", default_channel);\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":8}},{"line":15,"address":[],"length":0,"stats":{"Line":16}},{"line":16,"address":[],"length":0,"stats":{"Line":12}},{"line":18,"address":[],"length":0,"stats":{"Line":8}},{"line":27,"address":[],"length":0,"stats":{"Line":13}},{"line":29,"address":[],"length":0,"stats":{"Line":52}},{"line":31,"address":[],"length":0,"stats":{"Line":53}},{"line":32,"address":[],"length":0,"stats":{"Line":28}},{"line":34,"address":[],"length":0,"stats":{"Line":19}},{"line":36,"address":[],"length":0,"stats":{"Line":7}},{"line":37,"address":[],"length":0,"stats":{"Line":4}},{"line":40,"address":[],"length":0,"stats":{"Line":3}},{"line":41,"address":[],"length":0,"stats":{"Line":6}},{"line":42,"address":[],"length":0,"stats":{"Line":7}},{"line":43,"address":[],"length":0,"stats":{"Line":5}},{"line":45,"address":[],"length":0,"stats":{"Line":13}},{"line":47,"address":[],"length":0,"stats":{"Line":7}},{"line":48,"address":[],"length":0,"stats":{"Line":6}},{"line":50,"address":[],"length":0,"stats":{"Line":2}},{"line":52,"address":[],"length":0,"stats":{"Line":8}},{"line":54,"address":[],"length":0,"stats":{"Line":6}},{"line":55,"address":[],"length":0,"stats":{"Line":4}},{"line":57,"address":[],"length":0,"stats":{"Line":3}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":61,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":6}},{"line":71,"address":[],"length":0,"stats":{"Line":12}},{"line":73,"address":[],"length":0,"stats":{"Line":10}},{"line":75,"address":[],"length":0,"stats":{"Line":4}},{"line":77,"address":[],"length":0,"stats":{"Line":2}},{"line":78,"address":[],"length":0,"stats":{"Line":4}},{"line":80,"address":[],"length":0,"stats":{"Line":6}},{"line":82,"address":[],"length":0,"stats":{"Line":12}},{"line":84,"address":[],"length":0,"stats":{"Line":4}},{"line":85,"address":[],"length":0,"stats":{"Line":8}},{"line":86,"address":[],"length":0,"stats":{"Line":2}},{"line":87,"address":[],"length":0,"stats":{"Line":48}},{"line":90,"address":[],"length":0,"stats":{"Line":2}},{"line":91,"address":[],"length":0,"stats":{"Line":4}},{"line":92,"address":[],"length":0,"stats":{"Line":4}},{"line":93,"address":[],"length":0,"stats":{"Line":4}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":100,"address":[],"length":0,"stats":{"Line":7}},{"line":102,"address":[],"length":0,"stats":{"Line":7}},{"line":104,"address":[],"length":0,"stats":{"Line":28}},{"line":105,"address":[],"length":0,"stats":{"Line":19}},{"line":107,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":18}},{"line":113,"address":[],"length":0,"stats":{"Line":3}},{"line":114,"address":[],"length":0,"stats":{"Line":3}},{"line":116,"address":[],"length":0,"stats":{"Line":4}},{"line":117,"address":[],"length":0,"stats":{"Line":2}},{"line":118,"address":[],"length":0,"stats":{"Line":1}},{"line":121,"address":[],"length":0,"stats":{"Line":2}},{"line":122,"address":[],"length":0,"stats":{"Line":3}},{"line":123,"address":[],"length":0,"stats":{"Line":3}},{"line":124,"address":[],"length":0,"stats":{"Line":6}},{"line":126,"address":[],"length":0,"stats":{"Line":5}},{"line":127,"address":[],"length":0,"stats":{"Line":4}},{"line":128,"address":[],"length":0,"stats":{"Line":1}},{"line":130,"address":[],"length":0,"stats":{"Line":1}},{"line":132,"address":[],"length":0,"stats":{"Line":4}},{"line":133,"address":[],"length":0,"stats":{"Line":2}},{"line":134,"address":[],"length":0,"stats":{"Line":6}},{"line":135,"address":[],"length":0,"stats":{"Line":10}},{"line":137,"address":[],"length":0,"stats":{"Line":6}},{"line":138,"address":[],"length":0,"stats":{"Line":10}},{"line":139,"address":[],"length":0,"stats":{"Line":4}},{"line":140,"address":[],"length":0,"stats":{"Line":4}},{"line":141,"address":[],"length":0,"stats":{"Line":6}},{"line":145,"address":[],"length":0,"stats":{"Line":2}},{"line":146,"address":[],"length":0,"stats":{"Line":4}},{"line":149,"address":[],"length":0,"stats":{"Line":3}},{"line":151,"address":[],"length":0,"stats":{"Line":2}},{"line":154,"address":[],"length":0,"stats":{"Line":2}},{"line":158,"address":[],"length":0,"stats":{"Line":3}},{"line":159,"address":[],"length":0,"stats":{"Line":3}},{"line":161,"address":[],"length":0,"stats":{"Line":8}},{"line":162,"address":[],"length":0,"stats":{"Line":4}},{"line":163,"address":[],"length":0,"stats":{"Line":8}},{"line":164,"address":[],"length":0,"stats":{"Line":2}},{"line":165,"address":[],"length":0,"stats":{"Line":2}},{"line":166,"address":[],"length":0,"stats":{"Line":2}},{"line":167,"address":[],"length":0,"stats":{"Line":1}},{"line":169,"address":[],"length":0,"stats":{"Line":1}},{"line":172,"address":[],"length":0,"stats":{"Line":8}},{"line":173,"address":[],"length":0,"stats":{"Line":6}},{"line":174,"address":[],"length":0,"stats":{"Line":2}},{"line":176,"address":[],"length":0,"stats":{"Line":6}},{"line":177,"address":[],"length":0,"stats":{"Line":2}},{"line":179,"address":[],"length":0,"stats":{"Line":6}},{"line":180,"address":[],"length":0,"stats":{"Line":2}},{"line":184,"address":[],"length":0,"stats":{"Line":3}},{"line":186,"address":[],"length":0,"stats":{"Line":2}},{"line":189,"address":[],"length":0,"stats":{"Line":3}},{"line":193,"address":[],"length":0,"stats":{"Line":3}},{"line":198,"address":[],"length":0,"stats":{"Line":3}},{"line":200,"address":[],"length":0,"stats":{"Line":4}},{"line":201,"address":[],"length":0,"stats":{"Line":2}},{"line":202,"address":[],"length":0,"stats":{"Line":1}},{"line":205,"address":[],"length":0,"stats":{"Line":2}},{"line":206,"address":[],"length":0,"stats":{"Line":4}},{"line":208,"address":[],"length":0,"stats":{"Line":5}},{"line":209,"address":[],"length":0,"stats":{"Line":6}},{"line":210,"address":[],"length":0,"stats":{"Line":4}},{"line":211,"address":[],"length":0,"stats":{"Line":2}},{"line":213,"address":[],"length":0,"stats":{"Line":6}},{"line":215,"address":[],"length":0,"stats":{"Line":4}},{"line":216,"address":[],"length":0,"stats":{"Line":2}},{"line":217,"address":[],"length":0,"stats":{"Line":6}},{"line":219,"address":[],"length":0,"stats":{"Line":4}},{"line":222,"address":[],"length":0,"stats":{"Line":4}},{"line":225,"address":[],"length":0,"stats":{"Line":3}},{"line":227,"address":[],"length":0,"stats":{"Line":2}},{"line":230,"address":[],"length":0,"stats":{"Line":2}},{"line":234,"address":[],"length":0,"stats":{"Line":3}},{"line":239,"address":[],"length":0,"stats":{"Line":3}},{"line":241,"address":[],"length":0,"stats":{"Line":4}},{"line":242,"address":[],"length":0,"stats":{"Line":2}},{"line":243,"address":[],"length":0,"stats":{"Line":1}},{"line":246,"address":[],"length":0,"stats":{"Line":2}},{"line":247,"address":[],"length":0,"stats":{"Line":3}},{"line":248,"address":[],"length":0,"stats":{"Line":3}},{"line":249,"address":[],"length":0,"stats":{"Line":6}},{"line":251,"address":[],"length":0,"stats":{"Line":7}},{"line":252,"address":[],"length":0,"stats":{"Line":8}},{"line":253,"address":[],"length":0,"stats":{"Line":12}},{"line":254,"address":[],"length":0,"stats":{"Line":10}},{"line":255,"address":[],"length":0,"stats":{"Line":10}},{"line":257,"address":[],"length":0,"stats":{"Line":8}},{"line":258,"address":[],"length":0,"stats":{"Line":10}},{"line":259,"address":[],"length":0,"stats":{"Line":6}},{"line":260,"address":[],"length":0,"stats":{"Line":6}},{"line":261,"address":[],"length":0,"stats":{"Line":4}},{"line":265,"address":[],"length":0,"stats":{"Line":2}},{"line":266,"address":[],"length":0,"stats":{"Line":1}},{"line":267,"address":[],"length":0,"stats":{"Line":1}},{"line":268,"address":[],"length":0,"stats":{"Line":2}},{"line":273,"address":[],"length":0,"stats":{"Line":3}},{"line":275,"address":[],"length":0,"stats":{"Line":2}},{"line":278,"address":[],"length":0,"stats":{"Line":2}},{"line":282,"address":[],"length":0,"stats":{"Line":3}},{"line":283,"address":[],"length":0,"stats":{"Line":3}},{"line":285,"address":[],"length":0,"stats":{"Line":4}},{"line":286,"address":[],"length":0,"stats":{"Line":2}},{"line":287,"address":[],"length":0,"stats":{"Line":1}},{"line":290,"address":[],"length":0,"stats":{"Line":2}},{"line":291,"address":[],"length":0,"stats":{"Line":3}},{"line":292,"address":[],"length":0,"stats":{"Line":3}},{"line":293,"address":[],"length":0,"stats":{"Line":5}},{"line":295,"address":[],"length":0,"stats":{"Line":7}},{"line":296,"address":[],"length":0,"stats":{"Line":12}},{"line":297,"address":[],"length":0,"stats":{"Line":12}},{"line":299,"address":[],"length":0,"stats":{"Line":8}},{"line":300,"address":[],"length":0,"stats":{"Line":12}},{"line":301,"address":[],"length":0,"stats":{"Line":6}},{"line":302,"address":[],"length":0,"stats":{"Line":2}},{"line":306,"address":[],"length":0,"stats":{"Line":2}},{"line":307,"address":[],"length":0,"stats":{"Line":4}},{"line":310,"address":[],"length":0,"stats":{"Line":1}},{"line":311,"address":[],"length":0,"stats":{"Line":3}},{"line":312,"address":[],"length":0,"stats":{"Line":2}},{"line":315,"address":[],"length":0,"stats":{"Line":2}},{"line":319,"address":[],"length":0,"stats":{"Line":3}},{"line":325,"address":[],"length":0,"stats":{"Line":6}},{"line":326,"address":[],"length":0,"stats":{"Line":12}},{"line":327,"address":[],"length":0,"stats":{"Line":12}},{"line":328,"address":[],"length":0,"stats":{"Line":3}},{"line":329,"address":[],"length":0,"stats":{"Line":3}},{"line":330,"address":[],"length":0,"stats":{"Line":3}},{"line":331,"address":[],"length":0,"stats":{"Line":1}},{"line":333,"address":[],"length":0,"stats":{"Line":2}},{"line":336,"address":[],"length":0,"stats":{"Line":7}},{"line":337,"address":[],"length":0,"stats":{"Line":2}},{"line":339,"address":[],"length":0,"stats":{"Line":4}},{"line":340,"address":[],"length":0,"stats":{"Line":1}}],"covered":176,"coverable":176},{"path":["/","Users","chi","Projects","hu","src","slack","display","tests.rs"],"content":"use super::*;\n\n#[test]\nfn test_truncate_short_string() {\n    assert_eq!(truncate(\"hello\", 10), \"hello\");\n}\n\n#[test]\nfn test_truncate_exact_length() {\n    assert_eq!(truncate(\"hello\", 5), \"hello\");\n}\n\n#[test]\nfn test_truncate_long_string() {\n    assert_eq!(truncate(\"hello world\", 8), \"hello...\");\n}\n\n#[test]\nfn test_truncate_very_short_max() {\n    assert_eq!(truncate(\"hello\", 3), \"...\");\n}\n\n#[test]\nfn test_clean_message_text_user_mention_with_display() {\n    let lookup = HashMap::new();\n    assert_eq!(\n        clean_message_text(\"\u003c@U12345|John Doe\u003e\", \u0026lookup),\n        \"@John Doe\"\n    );\n}\n\n#[test]\nfn test_clean_message_text_user_mention_with_lookup() {\n    let mut lookup = HashMap::new();\n    lookup.insert(\"U12345\".to_string(), \"johndoe\".to_string());\n    assert_eq!(clean_message_text(\"\u003c@U12345\u003e\", \u0026lookup), \"@johndoe\");\n}\n\n#[test]\nfn test_clean_message_text_user_mention_without_lookup() {\n    let lookup = HashMap::new();\n    assert_eq!(clean_message_text(\"\u003c@U12345\u003e\", \u0026lookup), \"@U12345\");\n}\n\n#[test]\nfn test_clean_message_text_channel_mention() {\n    let lookup = HashMap::new();\n    assert_eq!(clean_message_text(\"\u003c#C12345|general\u003e\", \u0026lookup), \"#general\");\n}\n\n#[test]\nfn test_clean_message_text_channel_mention_no_name() {\n    let lookup = HashMap::new();\n    assert_eq!(clean_message_text(\"\u003c#C12345\u003e\", \u0026lookup), \"#C12345\");\n}\n\n#[test]\nfn test_clean_message_text_special_mention() {\n    let lookup = HashMap::new();\n    assert_eq!(clean_message_text(\"\u003c!here\u003e\", \u0026lookup), \"@here\");\n    assert_eq!(clean_message_text(\"\u003c!channel\u003e\", \u0026lookup), \"@channel\");\n    assert_eq!(clean_message_text(\"\u003c!everyone\u003e\", \u0026lookup), \"@everyone\");\n}\n\n#[test]\nfn test_clean_message_text_url_with_display() {\n    let lookup = HashMap::new();\n    assert_eq!(\n        clean_message_text(\"\u003chttps://example.com|Example Site\u003e\", \u0026lookup),\n        \"Example Site\"\n    );\n}\n\n#[test]\nfn test_clean_message_text_plain_url() {\n    let lookup = HashMap::new();\n    assert_eq!(\n        clean_message_text(\"\u003chttps://example.com\u003e\", \u0026lookup),\n        \"https://example.com\"\n    );\n}\n\n#[test]\nfn test_clean_message_text_mixed() {\n    let mut lookup = HashMap::new();\n    lookup.insert(\"U12345\".to_string(), \"bob\".to_string());\n    assert_eq!(\n        clean_message_text(\"Hey \u003c@U12345\u003e, check \u003c#C99999|dev\u003e!\", \u0026lookup),\n        \"Hey @bob, check #dev!\"\n    );\n}\n\n#[test]\nfn test_format_channel_name_regular() {\n    let lookup = HashMap::new();\n    assert_eq!(format_channel_name(\"general\", \u0026lookup), \"#general\");\n}\n\n#[test]\nfn test_format_channel_name_mpdm() {\n    let lookup = HashMap::new();\n    assert_eq!(\n        format_channel_name(\"mpdm-alice--bob--charlie-1\", \u0026lookup),\n        \"@alice, @bob, @charlie\"\n    );\n}\n\n#[test]\nfn test_format_channel_name_user_id_with_lookup() {\n    let mut lookup = HashMap::new();\n    lookup.insert(\"U04H482TK6Z\".to_string(), \"alice\".to_string());\n    assert_eq!(format_channel_name(\"U04H482TK6Z\", \u0026lookup), \"@alice\");\n}\n\n#[test]\nfn test_format_channel_name_user_id_without_lookup() {\n    let lookup = HashMap::new();\n    assert_eq!(format_channel_name(\"U04H482TK6Z\", \u0026lookup), \"DM\");\n}\n\n#[test]\nfn test_format_timestamp_valid() {\n    // 2024-01-01 00:00:00 UTC\n    let result = format_timestamp(\"1704067200.123456\");\n    assert_eq!(result, \"2024-01-01 00:00\");\n}\n\n#[test]\nfn test_format_timestamp_no_decimal() {\n    let result = format_timestamp(\"1704067200\");\n    assert_eq!(result, \"2024-01-01 00:00\");\n}\n\n#[test]\nfn test_format_timestamp_invalid() {\n    let result = format_timestamp(\"invalid\");\n    assert_eq!(result, \"invalid\");\n}\n\n#[test]\nfn test_output_channels_empty() {\n    // Just verify it doesn't panic\n    let channels: Vec\u003cSlackChannel\u003e = vec![];\n    let result = output_channels(\u0026channels, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_channels_json() {\n    let channels = vec![SlackChannel {\n        id: \"C12345\".to_string(),\n        name: \"general\".to_string(),\n        is_private: false,\n        is_member: true,\n        topic: Some(\"General discussion\".to_string()),\n        purpose: None,\n        num_members: Some(100),\n        created: 1704067200,\n    }];\n    let result = output_channels(\u0026channels, OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_channel_detail_table() {\n    let channel = SlackChannel {\n        id: \"C12345\".to_string(),\n        name: \"general\".to_string(),\n        is_private: true,\n        is_member: false,\n        topic: Some(\"Topic\".to_string()),\n        purpose: Some(\"Purpose\".to_string()),\n        num_members: Some(50),\n        created: 1704067200,\n    };\n    let result = output_channel_detail(\u0026channel, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_messages_empty() {\n    let messages: Vec\u003cSlackMessage\u003e = vec![];\n    let result = output_messages(\u0026messages, \"general\", OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_messages_json() {\n    let messages = vec![SlackMessage {\n        msg_type: \"message\".to_string(),\n        user: Some(\"U12345\".to_string()),\n        text: \"Hello world\".to_string(),\n        ts: \"1704067200.123456\".to_string(),\n        thread_ts: None,\n        reply_count: Some(5),\n        username: Some(\"alice\".to_string()),\n    }];\n    let result = output_messages(\u0026messages, \"general\", OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_users_empty() {\n    let users: Vec\u003cSlackUser\u003e = vec![];\n    let result = output_users(\u0026users, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_users_json() {\n    let users = vec![SlackUser {\n        id: \"U12345\".to_string(),\n        team_id: Some(\"T12345\".to_string()),\n        name: \"alice\".to_string(),\n        real_name: Some(\"Alice Smith\".to_string()),\n        is_bot: false,\n        deleted: false,\n        tz: Some(\"America/New_York\".to_string()),\n    }];\n    let result = output_users(\u0026users, OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_search_results_empty() {\n    let results = SlackSearchResult {\n        total: 0,\n        matches: vec![],\n    };\n    let lookup = HashMap::new();\n    let result = output_search_results(\u0026results, OutputFormat::Table, \u0026lookup);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_search_results_json() {\n    use crate::slack::types::{SlackSearchChannel, SlackSearchMatch};\n    let results = SlackSearchResult {\n        total: 1,\n        matches: vec![SlackSearchMatch {\n            channel: SlackSearchChannel {\n                id: \"C12345\".to_string(),\n                name: \"general\".to_string(),\n            },\n            user: Some(\"U12345\".to_string()),\n            username: Some(\"alice\".to_string()),\n            text: \"Hello world\".to_string(),\n            ts: \"1704067200.123456\".to_string(),\n            permalink: Some(\"https://slack.com/...\".to_string()),\n        }],\n    };\n    let lookup = HashMap::new();\n    let result = output_search_results(\u0026results, OutputFormat::Json, \u0026lookup);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_channels_table_with_data() {\n    let channels = vec![\n        SlackChannel {\n            id: \"C12345\".to_string(),\n            name: \"general\".to_string(),\n            is_private: false,\n            is_member: true,\n            topic: Some(\"General discussion\".to_string()),\n            purpose: None,\n            num_members: Some(100),\n            created: 1704067200,\n        },\n        SlackChannel {\n            id: \"C67890\".to_string(),\n            name: \"private-team\".to_string(),\n            is_private: true,\n            is_member: false,\n            topic: None,\n            purpose: None,\n            num_members: None,\n            created: 1704067200,\n        },\n    ];\n    let result = output_channels(\u0026channels, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_channel_detail_json() {\n    let channel = SlackChannel {\n        id: \"C12345\".to_string(),\n        name: \"general\".to_string(),\n        is_private: false,\n        is_member: true,\n        topic: None,\n        purpose: None,\n        num_members: None,\n        created: 1704067200,\n    };\n    let result = output_channel_detail(\u0026channel, OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_channel_detail_table_public() {\n    // Tests the \"public\" branch (line 166) in table output\n    let channel = SlackChannel {\n        id: \"C12345\".to_string(),\n        name: \"general\".to_string(),\n        is_private: false, // public channel\n        is_member: true,\n        topic: Some(\"General chat\".to_string()),\n        purpose: Some(\"For general discussion\".to_string()),\n        num_members: Some(50),\n        created: 1704067200,\n    };\n    let result = output_channel_detail(\u0026channel, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_messages_table_with_data() {\n    let messages = vec![\n        SlackMessage {\n            msg_type: \"message\".to_string(),\n            user: Some(\"U12345\".to_string()),\n            text: \"Hello world\".to_string(),\n            ts: \"1704067200.123456\".to_string(),\n            thread_ts: None,\n            reply_count: Some(5),\n            username: Some(\"alice\".to_string()),\n        },\n        SlackMessage {\n            msg_type: \"message\".to_string(),\n            user: None,\n            text: \"Another message\".to_string(),\n            ts: \"1704067201.123456\".to_string(),\n            thread_ts: None,\n            reply_count: None,\n            username: None,\n        },\n    ];\n    let result = output_messages(\u0026messages, \"general\", OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_users_table_with_data() {\n    let users = vec![\n        SlackUser {\n            id: \"U12345\".to_string(),\n            team_id: Some(\"T12345\".to_string()),\n            name: \"alice\".to_string(),\n            real_name: Some(\"Alice Smith\".to_string()),\n            is_bot: false,\n            deleted: false,\n            tz: Some(\"America/New_York\".to_string()),\n        },\n        SlackUser {\n            id: \"U67890\".to_string(),\n            team_id: None,\n            name: \"bob\".to_string(),\n            real_name: None,\n            is_bot: true,\n            deleted: false,\n            tz: None,\n        },\n    ];\n    let result = output_users(\u0026users, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_search_results_table_with_data() {\n    use crate::slack::types::{SlackSearchChannel, SlackSearchMatch};\n    let results = SlackSearchResult {\n        total: 100,\n        matches: vec![\n            SlackSearchMatch {\n                channel: SlackSearchChannel {\n                    id: \"C12345\".to_string(),\n                    name: \"general\".to_string(),\n                },\n                user: Some(\"U12345\".to_string()),\n                username: Some(\"alice\".to_string()),\n                text: \"Hello world\".to_string(),\n                ts: \"1704067200.123456\".to_string(),\n                permalink: Some(\"https://slack.com/...\".to_string()),\n            },\n            SlackSearchMatch {\n                channel: SlackSearchChannel {\n                    id: \"C67890\".to_string(),\n                    name: \"mpdm-alice--bob-1\".to_string(),\n                },\n                user: None,\n                username: None,\n                text: \"\u003c@U12345|Alice\u003e mentioned \u003c#C99999|dev\u003e\".to_string(),\n                ts: \"1704067201.123456\".to_string(),\n                permalink: None,\n            },\n        ],\n    };\n    let mut lookup = HashMap::new();\n    lookup.insert(\"U12345\".to_string(), \"alice\".to_string());\n    let result = output_search_results(\u0026results, OutputFormat::Table, \u0026lookup);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_config_status_all_configured() {\n    output_config_status(true, true, Some(\"Acme Corp\"), \"#general\");\n}\n\n#[test]\nfn test_output_config_status_not_configured() {\n    output_config_status(false, false, None, \"\");\n}\n\n#[test]\nfn test_output_config_status_partial() {\n    output_config_status(true, false, Some(\"My Team\"), \"\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","slack","handlers.rs"],"content":"use anyhow::Result;\n\nuse super::auth;\nuse super::client::SlackClient;\nuse super::config::{self, load_config};\nuse super::display;\nuse super::service;\nuse super::tidy;\nuse super::types::OutputFormat;\nuse super::SlackCommands;\n\n/// Run a Slack command (CLI entry point - formats and prints)\n#[cfg(not(tarpaulin_include))]\npub async fn run(command: SlackCommands) -\u003e Result\u003c()\u003e {\n    match command {\n        SlackCommands::Auth {\n            token,\n            user_token,\n            port,\n        } =\u003e cmd_auth(token.as_deref(), user_token.as_deref(), port).await,\n        SlackCommands::Channels { json } =\u003e cmd_channels(json).await,\n        SlackCommands::Info { channel, json } =\u003e cmd_info(\u0026channel, json).await,\n        SlackCommands::Send { channel, message } =\u003e cmd_send(\u0026channel, \u0026message).await,\n        SlackCommands::History {\n            channel,\n            limit,\n            json,\n        } =\u003e cmd_history(\u0026channel, limit, json).await,\n        SlackCommands::Search { query, count, json } =\u003e cmd_search(\u0026query, count, json).await,\n        SlackCommands::Users { json } =\u003e cmd_users(json).await,\n        SlackCommands::Config =\u003e cmd_config(),\n        SlackCommands::Whoami =\u003e cmd_whoami().await,\n        SlackCommands::Tidy { dry_run } =\u003e cmd_tidy(dry_run).await,\n    }\n}\n\n/// Verify a Slack token by calling auth.test and return the response\nasync fn verify_token(token: \u0026str) -\u003e Result\u003cserde_json::Value\u003e {\n    let client = reqwest::Client::new();\n    let response = client\n        .get(\"https://slack.com/api/auth.test\")\n        .header(\"Authorization\", format!(\"Bearer {}\", token))\n        .send()\n        .await?;\n\n    let result: serde_json::Value = response.json().await?;\n\n    if result.get(\"ok\").and_then(serde_json::Value::as_bool) != Some(true) {\n        let error = result\n            .get(\"error\")\n            .and_then(serde_json::Value::as_str)\n            .unwrap_or(\"unknown\");\n        anyhow::bail!(\"Token validation failed: {}\", error);\n    }\n\n    Ok(result)\n}\n\n/// Authenticate with Slack via OAuth or direct token\nasync fn cmd_auth(token: Option\u003c\u0026str\u003e, user_token: Option\u003c\u0026str\u003e, port: u16) -\u003e Result\u003c()\u003e {\n    // If user token provided, save it\n    if let Some(user_tok) = user_token {\n        if !user_tok.starts_with(\"xoxp-\") {\n            anyhow::bail!(\"Invalid user token format. Token should start with 'xoxp-'\");\n        }\n        verify_token(user_tok).await?;\n        config::update_user_token(user_tok)?;\n        println!(\"User token saved successfully!\");\n        println!(\"\\nYou can now use `hu slack search` command.\");\n        return Ok(());\n    }\n\n    // If bot token provided directly, save it and verify\n    if let Some(bot_token) = token {\n        if !bot_token.starts_with(\"xoxb-\") {\n            anyhow::bail!(\"Invalid bot token format. Token should start with 'xoxb-'\");\n        }\n        let result = verify_token(bot_token).await?;\n        let team_id = result\n            .get(\"team_id\")\n            .and_then(serde_json::Value::as_str)\n            .unwrap_or(\"\");\n        let team_name = result\n            .get(\"team\")\n            .and_then(serde_json::Value::as_str)\n            .unwrap_or(\"Unknown\");\n        config::update_oauth_tokens(bot_token, team_id, team_name)?;\n        println!(\"Token saved successfully!\");\n        println!(\"Connected to: {}\", team_name);\n        println!(\"\\nYou can now use `hu slack channels` and other commands.\");\n        return Ok(());\n    }\n\n    // Otherwise, run OAuth flow\n    let result = auth::run_oauth_flow(port).await?;\n\n    if result.success {\n        println!(\"\\nAuthentication successful!\");\n        if let Some(team) = result.team_name {\n            println!(\"Connected to: {}\", team);\n        }\n        println!(\"\\nYou can now use `hu slack channels` and other commands.\");\n    } else {\n        let error = result.error.unwrap_or_else(|| \"Unknown error\".to_string());\n        anyhow::bail!(\"Authentication failed: {}\", error);\n    }\n\n    Ok(())\n}\n\n/// List channels\nasync fn cmd_channels(json: bool) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n\n    let client = SlackClient::new()?;\n    let channels = service::list_channels(\u0026client).await?;\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n\n    display::output_channels(\u0026channels, format)?;\n    Ok(())\n}\n\n/// Get channel info\nasync fn cmd_info(channel: \u0026str, json: bool) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n\n    let client = SlackClient::new()?;\n    let info = service::get_channel_info(\u0026client, channel).await?;\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n\n    display::output_channel_detail(\u0026info, format)?;\n    Ok(())\n}\n\n/// Send a message\nasync fn cmd_send(channel: \u0026str, text: \u0026str) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n\n    let client = SlackClient::new()?;\n    let (sent_channel, ts) = service::send_message(\u0026client, channel, text).await?;\n\n    println!(\"Message sent to {} (ts: {})\", sent_channel, ts);\n    Ok(())\n}\n\n/// Get message history\nasync fn cmd_history(channel: \u0026str, limit: usize, json: bool) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n\n    let client = SlackClient::new()?;\n    let messages = service::get_history(\u0026client, channel, limit).await?;\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n\n    // Get channel name for display\n    let channel_name = channel.trim_start_matches('#');\n    display::output_messages(\u0026messages, channel_name, format)?;\n    Ok(())\n}\n\n/// Search messages\nasync fn cmd_search(query: \u0026str, count: usize, json: bool) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n\n    let client = SlackClient::new()?;\n    let results = service::search_messages(\u0026client, query, count).await?;\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n\n    // Build user lookup for resolving DM user IDs to names\n    let user_lookup = service::build_user_lookup(\u0026client).await?;\n\n    display::output_search_results(\u0026results, format, \u0026user_lookup)?;\n    Ok(())\n}\n\n/// List users\nasync fn cmd_users(json: bool) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n\n    let client = SlackClient::new()?;\n    let users = service::list_users(\u0026client).await?;\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n\n    display::output_users(\u0026users, format)?;\n    Ok(())\n}\n\n/// Show configuration status\nfn cmd_config() -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n\n    display::output_config_status(\n        config.is_configured,\n        config.oauth.has_user_token(),\n        config.oauth.team_name.as_deref(),\n        \u0026config.default_channel,\n    );\n\n    if let Some(path) = config::config_path() {\n        println!(\"Config:     {}\", path.display());\n    }\n\n    Ok(())\n}\n\n/// Show current user info from token\nasync fn cmd_whoami() -\u003e Result\u003c()\u003e {\n    let config = load_config()?;\n    let token = config\n        .oauth\n        .user_token\n        .or(config.oauth.bot_token)\n        .ok_or_else(|| anyhow::anyhow!(\"No token configured\"))?;\n\n    let result = verify_token(\u0026token).await?;\n\n    println!(\n        \"User ID:   {}\",\n        result\n            .get(\"user_id\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"unknown\")\n    );\n    println!(\n        \"User:      {}\",\n        result\n            .get(\"user\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"unknown\")\n    );\n    println!(\n        \"Team ID:   {}\",\n        result\n            .get(\"team_id\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"unknown\")\n    );\n    println!(\n        \"Team:      {}\",\n        result\n            .get(\"team\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"unknown\")\n    );\n\n    Ok(())\n}\n\n/// Tidy channels - mark as read if no mentions\nasync fn cmd_tidy(dry_run: bool) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_user_token(\u0026config)?;\n\n    let client = SlackClient::new()?;\n    let token = config.oauth.user_token.as_deref().unwrap();\n    let result = verify_token(token).await?;\n\n    let user_info = tidy::UserInfo {\n        user_id: result\n            .get(\"user_id\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"\")\n            .to_string(),\n        name: \"Adam\".to_string(),\n        full_name: \"Adam Ladachowski\".to_string(),\n    };\n\n    if dry_run {\n        println!(\"DRY RUN - no channels will be marked as read\\n\");\n    }\n\n    let results = tidy::tidy_channels(\u0026client, \u0026user_info, dry_run).await?;\n\n    // Print results\n    let mut marked = 0;\n    let mut skipped = 0;\n    let mut has_mentions = 0;\n\n    for r in \u0026results {\n        match \u0026r.action {\n            tidy::TidyAction::Skipped =\u003e skipped += 1,\n            tidy::TidyAction::MarkedRead =\u003e {\n                marked += 1;\n                println!(\"Marked read: #{}\", r.channel_name);\n            }\n            tidy::TidyAction::HasMention(mention) =\u003e {\n                has_mentions += 1;\n                println!(\"Has mention: #{} - {}\", r.channel_name, mention);\n            }\n        }\n    }\n\n    println!(\"\\nSummary:\");\n    println!(\"  Marked as read: {}\", marked);\n    println!(\"  Has mentions:   {}\", has_mentions);\n    println!(\"  Already read:   {}\", skipped);\n\n    Ok(())\n}\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":172},{"path":["/","Users","chi","Projects","hu","src","slack","messages.rs"],"content":"//! Slack message operations\n//!\n//! Send messages and retrieve message history.\n\nuse anyhow::Result;\nuse serde::Deserialize;\n\nuse super::client::SlackClient;\nuse super::types::SlackMessage;\n\n/// Response from conversations.history API\n#[derive(Deserialize)]\nstruct HistoryResponse {\n    messages: Vec\u003cMessageResponse\u003e,\n}\n\n/// Response from chat.postMessage API\n#[derive(Deserialize)]\nstruct PostMessageResponse {\n    ts: String,\n    channel: String,\n}\n\n/// Raw message data from API\n#[derive(Deserialize)]\nstruct MessageResponse {\n    #[serde(rename = \"type\")]\n    msg_type: Option\u003cString\u003e,\n    user: Option\u003cString\u003e,\n    text: Option\u003cString\u003e,\n    ts: String,\n    thread_ts: Option\u003cString\u003e,\n    reply_count: Option\u003cu32\u003e,\n}\n\nimpl From\u003cMessageResponse\u003e for SlackMessage {\n    fn from(r: MessageResponse) -\u003e Self {\n        Self {\n            msg_type: r.msg_type.unwrap_or_else(|| \"message\".to_string()),\n            user: r.user,\n            text: r.text.unwrap_or_default(),\n            ts: r.ts,\n            thread_ts: r.thread_ts,\n            reply_count: r.reply_count,\n            username: None,\n        }\n    }\n}\n\n/// Get message history for a channel\npub async fn get_history(\n    client: \u0026SlackClient,\n    channel_id: \u0026str,\n    limit: usize,\n) -\u003e Result\u003cVec\u003cSlackMessage\u003e\u003e {\n    let limit_str = limit.to_string();\n    let response: HistoryResponse = client\n        .get_with_params(\n            \"conversations.history\",\n            \u0026[(\"channel\", channel_id), (\"limit\", \u0026limit_str)],\n        )\n        .await?;\n\n    let messages: Vec\u003cSlackMessage\u003e = response\n        .messages\n        .into_iter()\n        .map(SlackMessage::from)\n        .collect();\n\n    Ok(messages)\n}\n\n/// Send a message to a channel\npub async fn send_message(\n    client: \u0026SlackClient,\n    channel_id: \u0026str,\n    text: \u0026str,\n) -\u003e Result\u003c(String, String), anyhow::Error\u003e {\n    let body = serde_json::json!({\n        \"channel\": channel_id,\n        \"text\": text,\n    });\n\n    let response: PostMessageResponse = client.post(\"chat.postMessage\", \u0026body).await?;\n\n    Ok((response.channel, response.ts))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_message_response_to_slack_message_full() {\n        let response = MessageResponse {\n            msg_type: Some(\"message\".to_string()),\n            user: Some(\"U12345\".to_string()),\n            text: Some(\"Hello world\".to_string()),\n            ts: \"1704067200.123456\".to_string(),\n            thread_ts: Some(\"1704067100.000000\".to_string()),\n            reply_count: Some(5),\n        };\n\n        let message = SlackMessage::from(response);\n        assert_eq!(message.msg_type, \"message\");\n        assert_eq!(message.user, Some(\"U12345\".to_string()));\n        assert_eq!(message.text, \"Hello world\");\n        assert_eq!(message.ts, \"1704067200.123456\");\n        assert_eq!(message.thread_ts, Some(\"1704067100.000000\".to_string()));\n        assert_eq!(message.reply_count, Some(5));\n        assert!(message.username.is_none());\n    }\n\n    #[test]\n    fn test_message_response_to_slack_message_minimal() {\n        let response = MessageResponse {\n            msg_type: None,\n            user: None,\n            text: None,\n            ts: \"1704067200.123456\".to_string(),\n            thread_ts: None,\n            reply_count: None,\n        };\n\n        let message = SlackMessage::from(response);\n        assert_eq!(message.msg_type, \"message\"); // default value\n        assert!(message.user.is_none());\n        assert_eq!(message.text, \"\"); // default empty\n        assert_eq!(message.ts, \"1704067200.123456\");\n        assert!(message.thread_ts.is_none());\n        assert!(message.reply_count.is_none());\n    }\n\n    #[test]\n    fn test_history_response_deserialize() {\n        let json = r#\"{\n            \"messages\": [\n                {\"ts\": \"1704067200.123456\", \"text\": \"Hello\", \"user\": \"U12345\"},\n                {\"ts\": \"1704067100.123456\"}\n            ]\n        }\"#;\n\n        let response: HistoryResponse = serde_json::from_str(json).unwrap();\n        assert_eq!(response.messages.len(), 2);\n        assert_eq!(response.messages[0].ts, \"1704067200.123456\");\n        assert_eq!(response.messages[0].text, Some(\"Hello\".to_string()));\n    }\n\n    #[test]\n    fn test_post_message_response_deserialize() {\n        let json = r#\"{\"ts\": \"1704067200.123456\", \"channel\": \"C12345\"}\"#;\n        let response: PostMessageResponse = serde_json::from_str(json).unwrap();\n        assert_eq!(response.ts, \"1704067200.123456\");\n        assert_eq!(response.channel, \"C12345\");\n    }\n\n    #[test]\n    fn test_message_response_deserialize_with_type() {\n        let json = r#\"{\n            \"type\": \"message\",\n            \"user\": \"U12345\",\n            \"text\": \"Test message\",\n            \"ts\": \"1704067200.123456\",\n            \"thread_ts\": \"1704067100.000000\",\n            \"reply_count\": 10\n        }\"#;\n\n        let response: MessageResponse = serde_json::from_str(json).unwrap();\n        assert_eq!(response.msg_type, Some(\"message\".to_string()));\n        assert_eq!(response.user, Some(\"U12345\".to_string()));\n        assert_eq!(response.text, Some(\"Test message\".to_string()));\n        assert_eq!(response.ts, \"1704067200.123456\");\n        assert_eq!(response.thread_ts, Some(\"1704067100.000000\".to_string()));\n        assert_eq!(response.reply_count, Some(10));\n    }\n\n    #[test]\n    fn test_message_response_deserialize_empty_messages() {\n        let json = r#\"{\"messages\": []}\"#;\n        let response: HistoryResponse = serde_json::from_str(json).unwrap();\n        assert!(response.messages.is_empty());\n    }\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":2}},{"line":39,"address":[],"length":0,"stats":{"Line":6}},{"line":40,"address":[],"length":0,"stats":{"Line":2}},{"line":41,"address":[],"length":0,"stats":{"Line":4}},{"line":42,"address":[],"length":0,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}}],"covered":7,"coverable":22},{"path":["/","Users","chi","Projects","hu","src","slack","mod.rs"],"content":"//! Slack integration module\n//!\n//! Provides commands for interacting with Slack:\n//! - Authenticate via OAuth browser flow\n//! - List channels\n//! - Get channel info\n//! - Send messages\n//! - View message history\n//! - Search messages\n//! - List users\n//! - Show configuration status\n//!\n//! # CLI Usage\n//! Use [`run`] for CLI commands that format and print output.\n//!\n//! # Programmatic Usage (MCP/HTTP)\n//! Use the reusable functions that return typed data:\n//! - [`get_config`] - Get configuration status\n//! - [`list_channels`] - List all channels\n//! - [`get_channel_info`] - Get channel details\n//! - [`get_history`] - Get message history\n//! - [`send_message`] - Send a message\n//! - [`search_messages`] - Search messages\n//! - [`list_users`] - List workspace users\n\nmod auth;\nmod channels;\nmod client;\nmod config;\nmod display;\nmod handlers;\nmod messages;\nmod search;\nmod service;\nmod tidy;\nmod types;\n\nuse anyhow::Result;\nuse clap::Subcommand;\n\nuse client::SlackClient;\npub use config::SlackConfig;\npub use handlers::run;\npub use types::{SlackChannel, SlackMessage, SlackSearchResult, SlackUser};\n\n/// Slack subcommands\n#[derive(Subcommand, Debug)]\npub enum SlackCommands {\n    /// Authenticate with Slack (OAuth flow or direct token)\n    Auth {\n        /// Bot token to save directly (skips OAuth flow)\n        #[arg(short, long)]\n        token: Option\u003cString\u003e,\n        /// User token for search API (xoxp-...)\n        #[arg(short, long)]\n        user_token: Option\u003cString\u003e,\n        /// Local server port for OAuth callback\n        #[arg(short, long, default_value = \"9877\")]\n        port: u16,\n    },\n    /// List channels in the workspace\n    Channels {\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n    },\n    /// Show channel details\n    Info {\n        /// Channel name or ID (e.g., \"#general\" or \"C12345678\")\n        channel: String,\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n    },\n    /// Send a message to a channel\n    Send {\n        /// Channel name or ID\n        channel: String,\n        /// Message text\n        message: String,\n    },\n    /// Show message history for a channel\n    History {\n        /// Channel name or ID\n        channel: String,\n        /// Number of messages to show\n        #[arg(short, long, default_value = \"20\")]\n        limit: usize,\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n    },\n    /// Search messages\n    Search {\n        /// Search query\n        query: String,\n        /// Maximum results to return\n        #[arg(short = 'n', long, default_value = \"20\")]\n        count: usize,\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n    },\n    /// List users in the workspace\n    Users {\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n    },\n    /// Show Slack configuration status\n    Config,\n    /// Show current user info from token\n    Whoami,\n    /// Mark channels as read if no direct mentions\n    Tidy {\n        /// Dry run - show what would be marked without marking\n        #[arg(short, long)]\n        dry_run: bool,\n    },\n}\n\n// ============================================================================\n// Reusable functions for MCP/HTTP - return typed data, never print\n// ============================================================================\n\n/// Get Slack configuration status (for MCP/HTTP)\n#[allow(dead_code)]\npub fn get_config() -\u003e Result\u003cSlackConfig\u003e {\n    service::get_config()\n}\n\n/// List all channels (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn list_channels() -\u003e Result\u003cVec\u003cSlackChannel\u003e\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n    let client = SlackClient::new()?;\n    service::list_channels(\u0026client).await\n}\n\n/// Get channel info by name or ID (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn get_channel_info(channel: \u0026str) -\u003e Result\u003cSlackChannel\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n    let client = SlackClient::new()?;\n    service::get_channel_info(\u0026client, channel).await\n}\n\n/// Get message history for a channel (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn get_history(channel: \u0026str, limit: usize) -\u003e Result\u003cVec\u003cSlackMessage\u003e\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n    let client = SlackClient::new()?;\n    service::get_history(\u0026client, channel, limit).await\n}\n\n/// Send a message to a channel (for MCP/HTTP)\n/// Returns (channel_id, timestamp)\n#[allow(dead_code)]\npub async fn send_message(channel: \u0026str, text: \u0026str) -\u003e Result\u003c(String, String)\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n    let client = SlackClient::new()?;\n    service::send_message(\u0026client, channel, text).await\n}\n\n/// Search messages (for MCP/HTTP) - requires user token\n#[allow(dead_code)]\npub async fn search_messages(query: \u0026str, count: usize) -\u003e Result\u003cSlackSearchResult\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n    service::ensure_user_token(\u0026config)?;\n    let client = SlackClient::new()?;\n    service::search_messages(\u0026client, query, count).await\n}\n\n/// List users in the workspace (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn list_users() -\u003e Result\u003cVec\u003cSlackUser\u003e\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n    let client = SlackClient::new()?;\n    service::list_users(\u0026client).await\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":33},{"path":["/","Users","chi","Projects","hu","src","slack","search.rs"],"content":"//! Slack message search\n//!\n//! Search messages across channels.\n\nuse anyhow::Result;\nuse serde::Deserialize;\n\nuse super::client::SlackClient;\nuse super::types::{SlackSearchChannel, SlackSearchMatch, SlackSearchResult};\n\n/// Response from search.messages API\n#[derive(Deserialize)]\nstruct SearchResponse {\n    messages: MessagesContainer,\n}\n\n/// Container for search matches\n#[derive(Deserialize)]\nstruct MessagesContainer {\n    total: u32,\n    matches: Vec\u003cMatchResponse\u003e,\n}\n\n/// Raw match data from API\n#[derive(Deserialize)]\nstruct MatchResponse {\n    channel: ChannelResponse,\n    user: Option\u003cString\u003e,\n    username: Option\u003cString\u003e,\n    text: String,\n    ts: String,\n    permalink: Option\u003cString\u003e,\n}\n\n/// Channel info in search response\n#[derive(Deserialize)]\nstruct ChannelResponse {\n    id: String,\n    name: String,\n}\n\nimpl From\u003cMatchResponse\u003e for SlackSearchMatch {\n    fn from(r: MatchResponse) -\u003e Self {\n        Self {\n            channel: SlackSearchChannel {\n                id: r.channel.id,\n                name: r.channel.name,\n            },\n            user: r.user,\n            username: r.username,\n            text: r.text,\n            ts: r.ts,\n            permalink: r.permalink,\n        }\n    }\n}\n\n/// Search messages across the workspace (requires user token)\npub async fn search_messages(\n    client: \u0026SlackClient,\n    query: \u0026str,\n    count: usize,\n) -\u003e Result\u003cSlackSearchResult\u003e {\n    let count_str = count.to_string();\n    let response: SearchResponse = client\n        .get_with_user_token(\n            \"search.messages\",\n            \u0026[\n                (\"query\", query),\n                (\"count\", \u0026count_str),\n                (\"sort\", \"timestamp\"),\n                (\"sort_dir\", \"desc\"),\n            ],\n        )\n        .await?;\n\n    Ok(SlackSearchResult {\n        total: response.messages.total,\n        matches: response\n            .messages\n            .matches\n            .into_iter()\n            .map(SlackSearchMatch::from)\n            .collect(),\n    })\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_response_to_slack_search_match_full() {\n        let response = MatchResponse {\n            channel: ChannelResponse {\n                id: \"C12345\".to_string(),\n                name: \"general\".to_string(),\n            },\n            user: Some(\"U12345\".to_string()),\n            username: Some(\"alice\".to_string()),\n            text: \"Hello world\".to_string(),\n            ts: \"1704067200.123456\".to_string(),\n            permalink: Some(\"https://slack.com/archives/C12345/p1704067200123456\".to_string()),\n        };\n\n        let match_result = SlackSearchMatch::from(response);\n        assert_eq!(match_result.channel.id, \"C12345\");\n        assert_eq!(match_result.channel.name, \"general\");\n        assert_eq!(match_result.user, Some(\"U12345\".to_string()));\n        assert_eq!(match_result.username, Some(\"alice\".to_string()));\n        assert_eq!(match_result.text, \"Hello world\");\n        assert_eq!(match_result.ts, \"1704067200.123456\");\n        assert!(match_result.permalink.is_some());\n    }\n\n    #[test]\n    fn test_match_response_to_slack_search_match_minimal() {\n        let response = MatchResponse {\n            channel: ChannelResponse {\n                id: \"C12345\".to_string(),\n                name: \"general\".to_string(),\n            },\n            user: None,\n            username: None,\n            text: \"Message\".to_string(),\n            ts: \"1704067200.123456\".to_string(),\n            permalink: None,\n        };\n\n        let match_result = SlackSearchMatch::from(response);\n        assert_eq!(match_result.channel.id, \"C12345\");\n        assert!(match_result.user.is_none());\n        assert!(match_result.username.is_none());\n        assert!(match_result.permalink.is_none());\n    }\n\n    #[test]\n    fn test_search_response_deserialize() {\n        let json = r#\"{\n            \"messages\": {\n                \"total\": 42,\n                \"matches\": [\n                    {\n                        \"channel\": {\"id\": \"C12345\", \"name\": \"general\"},\n                        \"user\": \"U12345\",\n                        \"username\": \"alice\",\n                        \"text\": \"Hello\",\n                        \"ts\": \"1704067200.123456\",\n                        \"permalink\": \"https://slack.com/...\"\n                    }\n                ]\n            }\n        }\"#;\n\n        let response: SearchResponse = serde_json::from_str(json).unwrap();\n        assert_eq!(response.messages.total, 42);\n        assert_eq!(response.messages.matches.len(), 1);\n        assert_eq!(response.messages.matches[0].text, \"Hello\");\n    }\n\n    #[test]\n    fn test_search_response_empty_matches() {\n        let json = r#\"{\n            \"messages\": {\n                \"total\": 0,\n                \"matches\": []\n            }\n        }\"#;\n\n        let response: SearchResponse = serde_json::from_str(json).unwrap();\n        assert_eq!(response.messages.total, 0);\n        assert!(response.messages.matches.is_empty());\n    }\n\n    #[test]\n    fn test_messages_container_deserialize() {\n        let json = r#\"{\"total\": 100, \"matches\": []}\"#;\n        let container: MessagesContainer = serde_json::from_str(json).unwrap();\n        assert_eq!(container.total, 100);\n        assert!(container.matches.is_empty());\n    }\n\n    #[test]\n    fn test_channel_response_deserialize() {\n        let json = r#\"{\"id\": \"C12345\", \"name\": \"test-channel\"}\"#;\n        let channel: ChannelResponse = serde_json::from_str(json).unwrap();\n        assert_eq!(channel.id, \"C12345\");\n        assert_eq!(channel.name, \"test-channel\");\n    }\n}\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":4}},{"line":49,"address":[],"length":0,"stats":{"Line":4}},{"line":50,"address":[],"length":0,"stats":{"Line":4}},{"line":51,"address":[],"length":0,"stats":{"Line":4}},{"line":52,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}}],"covered":7,"coverable":24},{"path":["/","Users","chi","Projects","hu","src","slack","service.rs"],"content":"//! Slack service layer - business logic that returns data\n//!\n//! Functions in this module return typed data and never print.\n//! They delegate to the existing submodule functions after config checks.\n\nuse anyhow::{bail, Result};\n\nuse super::channels;\nuse super::client::SlackClient;\nuse super::config::{self, SlackConfig};\nuse super::messages;\nuse super::search;\nuse super::types::{SlackChannel, SlackMessage, SlackSearchResult, SlackUser};\n\n/// Get current configuration\npub fn get_config() -\u003e Result\u003cSlackConfig\u003e {\n    config::load_config()\n}\n\n/// Check if API is configured, return error if not\npub fn ensure_configured(config: \u0026SlackConfig) -\u003e Result\u003c()\u003e {\n    if !config.is_configured {\n        bail!(\"Slack is not configured. Run `hu slack auth` to authenticate.\");\n    }\n    Ok(())\n}\n\n/// Check if user token is configured, return error if not\npub fn ensure_user_token(config: \u0026SlackConfig) -\u003e Result\u003c()\u003e {\n    if !config.oauth.has_user_token() {\n        bail!(\"User token required. Run `hu slack auth --user-token \u003ctoken\u003e`\");\n    }\n    Ok(())\n}\n\n/// List all channels\npub async fn list_channels(client: \u0026SlackClient) -\u003e Result\u003cVec\u003cSlackChannel\u003e\u003e {\n    channels::list_channels(client).await\n}\n\n/// Get channel info by ID or name\npub async fn get_channel_info(client: \u0026SlackClient, channel: \u0026str) -\u003e Result\u003cSlackChannel\u003e {\n    let channel_id = channels::resolve_channel(client, channel).await?;\n    channels::get_channel_info(client, \u0026channel_id).await\n}\n\n/// Get message history for a channel\npub async fn get_history(\n    client: \u0026SlackClient,\n    channel: \u0026str,\n    limit: usize,\n) -\u003e Result\u003cVec\u003cSlackMessage\u003e\u003e {\n    let channel_id = channels::resolve_channel(client, channel).await?;\n    messages::get_history(client, \u0026channel_id, limit).await\n}\n\n/// Send a message to a channel\npub async fn send_message(\n    client: \u0026SlackClient,\n    channel: \u0026str,\n    text: \u0026str,\n) -\u003e Result\u003c(String, String)\u003e {\n    let channel_id = channels::resolve_channel(client, channel).await?;\n    messages::send_message(client, \u0026channel_id, text).await\n}\n\n/// Search messages (requires user token)\npub async fn search_messages(\n    client: \u0026SlackClient,\n    query: \u0026str,\n    count: usize,\n) -\u003e Result\u003cSlackSearchResult\u003e {\n    search::search_messages(client, query, count).await\n}\n\n/// List users\npub async fn list_users(client: \u0026SlackClient) -\u003e Result\u003cVec\u003cSlackUser\u003e\u003e {\n    channels::list_users(client).await\n}\n\n/// Build user lookup map for DM resolution\npub async fn build_user_lookup(\n    client: \u0026SlackClient,\n) -\u003e Result\u003cstd::collections::HashMap\u003cString, String\u003e\u003e {\n    channels::build_user_lookup(client).await\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn ensure_configured_fails_when_not_configured() {\n        let config = SlackConfig {\n            oauth: config::OAuthConfig::default(),\n            default_channel: String::new(),\n            is_configured: false,\n        };\n        let result = ensure_configured(\u0026config);\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"not configured\"));\n    }\n\n    #[test]\n    fn ensure_configured_succeeds_when_configured() {\n        let config = SlackConfig {\n            oauth: config::OAuthConfig {\n                client_id: None,\n                client_secret: None,\n                bot_token: Some(\"xoxb-test\".to_string()),\n                user_token: None,\n                team_id: Some(\"T123\".to_string()),\n                team_name: Some(\"Test\".to_string()),\n            },\n            default_channel: String::new(),\n            is_configured: true,\n        };\n        let result = ensure_configured(\u0026config);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn ensure_user_token_fails_when_missing() {\n        let config = SlackConfig {\n            oauth: config::OAuthConfig {\n                client_id: None,\n                client_secret: None,\n                bot_token: Some(\"xoxb-test\".to_string()),\n                user_token: None,\n                team_id: None,\n                team_name: None,\n            },\n            default_channel: String::new(),\n            is_configured: true,\n        };\n        let result = ensure_user_token(\u0026config);\n        assert!(result.is_err());\n        assert!(result\n            .unwrap_err()\n            .to_string()\n            .contains(\"User token required\"));\n    }\n\n    #[test]\n    fn ensure_user_token_succeeds_when_present() {\n        let config = SlackConfig {\n            oauth: config::OAuthConfig {\n                client_id: None,\n                client_secret: None,\n                bot_token: Some(\"xoxb-test\".to_string()),\n                user_token: Some(\"xoxp-test\".to_string()),\n                team_id: None,\n                team_name: None,\n            },\n            default_channel: String::new(),\n            is_configured: true,\n        };\n        let result = ensure_user_token(\u0026config);\n        assert!(result.is_ok());\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":4}},{"line":22,"address":[],"length":0,"stats":{"Line":4}},{"line":23,"address":[],"length":0,"stats":{"Line":4}},{"line":25,"address":[],"length":0,"stats":{"Line":2}},{"line":29,"address":[],"length":0,"stats":{"Line":2}},{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":31,"address":[],"length":0,"stats":{"Line":2}},{"line":33,"address":[],"length":0,"stats":{"Line":1}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}}],"covered":8,"coverable":27},{"path":["/","Users","chi","Projects","hu","src","slack","tests.rs"],"content":"use super::*;\nuse config::{OAuthConfig, SlackConfig};\n\n#[test]\nfn test_ensure_configured_when_not_configured() {\n    let config = SlackConfig {\n        oauth: OAuthConfig::default(),\n        default_channel: String::new(),\n        is_configured: false,\n    };\n    let result = service::ensure_configured(\u0026config);\n    assert!(result.is_err());\n    assert!(result.unwrap_err().to_string().contains(\"not configured\"));\n}\n\n#[test]\nfn test_ensure_configured_when_configured() {\n    let config = SlackConfig {\n        oauth: OAuthConfig {\n            client_id: None,\n            client_secret: None,\n            bot_token: Some(\"xoxb-test\".to_string()),\n            user_token: None,\n            team_id: Some(\"T123\".to_string()),\n            team_name: Some(\"Test\".to_string()),\n        },\n        default_channel: String::new(),\n        is_configured: true,\n    };\n    let result = service::ensure_configured(\u0026config);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_slack_commands_debug() {\n    let cmd = SlackCommands::Channels { json: false };\n    let debug = format!(\"{:?}\", cmd);\n    assert!(debug.contains(\"Channels\"));\n}\n\n#[test]\nfn test_slack_commands_auth_debug() {\n    let cmd = SlackCommands::Auth {\n        token: Some(\"xoxb-test\".to_string()),\n        user_token: None,\n        port: 9877,\n    };\n    let debug = format!(\"{:?}\", cmd);\n    assert!(debug.contains(\"Auth\"));\n    assert!(debug.contains(\"9877\"));\n}\n\n#[test]\nfn test_slack_commands_info_debug() {\n    let cmd = SlackCommands::Info {\n        channel: \"#general\".to_string(),\n        json: true,\n    };\n    let debug = format!(\"{:?}\", cmd);\n    assert!(debug.contains(\"Info\"));\n    assert!(debug.contains(\"#general\"));\n}\n\n#[test]\nfn test_slack_commands_send_debug() {\n    let cmd = SlackCommands::Send {\n        channel: \"#test\".to_string(),\n        message: \"Hello\".to_string(),\n    };\n    let debug = format!(\"{:?}\", cmd);\n    assert!(debug.contains(\"Send\"));\n    assert!(debug.contains(\"Hello\"));\n}\n\n#[test]\nfn test_slack_commands_history_debug() {\n    let cmd = SlackCommands::History {\n        channel: \"#dev\".to_string(),\n        limit: 50,\n        json: false,\n    };\n    let debug = format!(\"{:?}\", cmd);\n    assert!(debug.contains(\"History\"));\n    assert!(debug.contains(\"50\"));\n}\n\n#[test]\nfn test_slack_commands_search_debug() {\n    let cmd = SlackCommands::Search {\n        query: \"deploy\".to_string(),\n        count: 20,\n        json: true,\n    };\n    let debug = format!(\"{:?}\", cmd);\n    assert!(debug.contains(\"Search\"));\n    assert!(debug.contains(\"deploy\"));\n}\n\n#[test]\nfn test_slack_commands_users_debug() {\n    let cmd = SlackCommands::Users { json: false };\n    let debug = format!(\"{:?}\", cmd);\n    assert!(debug.contains(\"Users\"));\n}\n\n#[test]\nfn test_slack_commands_config_debug() {\n    let cmd = SlackCommands::Config;\n    let debug = format!(\"{:?}\", cmd);\n    assert!(debug.contains(\"Config\"));\n}\n\n#[test]\nfn test_slack_commands_whoami_debug() {\n    let cmd = SlackCommands::Whoami;\n    let debug = format!(\"{:?}\", cmd);\n    assert!(debug.contains(\"Whoami\"));\n}\n\n#[test]\nfn test_slack_commands_tidy_debug() {\n    let cmd = SlackCommands::Tidy { dry_run: true };\n    let debug = format!(\"{:?}\", cmd);\n    assert!(debug.contains(\"Tidy\"));\n    assert!(debug.contains(\"true\"));\n}\n\n#[test]\nfn test_output_format_reexport() {\n    // Verify OutputFormat is accessible via types module\n    let format = types::OutputFormat::Table;\n    assert!(matches!(format, types::OutputFormat::Table));\n    let format = types::OutputFormat::Json;\n    assert!(matches!(format, types::OutputFormat::Json));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","slack","tidy","mod.rs"],"content":"//! Slack tidy operations\n//!\n//! Mark channels as read if no direct mentions in unread messages.\n\nuse anyhow::Result;\nuse serde::{Deserialize, Serialize};\nuse std::time::Duration;\nuse tokio::time::sleep;\n\nuse super::client::SlackClient;\n\n#[cfg(test)]\nmod tests;\n\n/// User info for mention detection\npub struct UserInfo {\n    pub user_id: String,\n    pub name: String,\n    pub full_name: String,\n}\n\n/// Channel with unread info\nstruct ChannelUnreadInfo {\n    last_read: String,\n    has_unreads: bool,\n}\n\n/// Response from conversations.list with membership info\n#[derive(Deserialize)]\nstruct ConversationsListResponse {\n    channels: Vec\u003cChannelListItem\u003e,\n    response_metadata: Option\u003cResponseMetadata\u003e,\n}\n\n#[derive(Deserialize)]\nstruct ChannelListItem {\n    id: String,\n    name: Option\u003cString\u003e,\n    user: Option\u003cString\u003e, // For DMs, contains the other user's ID\n    is_member: Option\u003cbool\u003e,\n    is_im: Option\u003cbool\u003e,\n}\n\n#[derive(Deserialize)]\nstruct ResponseMetadata {\n    next_cursor: Option\u003cString\u003e,\n}\n\n/// Response from conversations.info\n#[derive(Deserialize)]\nstruct ConversationsInfoResponse {\n    channel: ChannelInfoItem,\n}\n\n#[derive(Deserialize)]\nstruct ChannelInfoItem {\n    last_read: Option\u003cString\u003e,\n    latest: Option\u003cLatestMessage\u003e,\n}\n\n#[derive(Deserialize)]\nstruct LatestMessage {\n    ts: String,\n}\n\n/// Response from conversations.history\n#[derive(Deserialize)]\nstruct HistoryResponse {\n    messages: Vec\u003cHistoryMessage\u003e,\n}\n\n#[derive(Deserialize)]\nstruct HistoryMessage {\n    ts: String,\n    text: Option\u003cString\u003e,\n}\n\n/// Request body for conversations.mark\n#[derive(Serialize)]\nstruct MarkRequest {\n    channel: String,\n    ts: String,\n}\n\n/// Empty response from conversations.mark\n#[derive(Deserialize)]\nstruct MarkResponse {}\n\n/// Result of tidy operation for a single channel\n#[derive(Debug)]\npub struct TidyResult {\n    pub channel_name: String,\n    pub action: TidyAction,\n}\n\n#[derive(Debug)]\npub enum TidyAction {\n    Skipped,            // No unreads\n    MarkedRead,         // Marked as read (no mentions)\n    HasMention(String), // Has mention, not marked\n}\n\n/// Run tidy operation on all channels\npub async fn tidy_channels(\n    client: \u0026SlackClient,\n    user_info: \u0026UserInfo,\n    dry_run: bool,\n) -\u003e Result\u003cVec\u003cTidyResult\u003e\u003e {\n    let mut results = Vec::new();\n\n    // Get channels user is member of\n    let channels = list_member_channels(client).await?;\n    println!(\"Found {} channels you're a member of\", channels.len());\n\n    for channel in channels {\n        let display_name = get_display_name(\u0026channel);\n\n        // Rate limit\n        sleep(Duration::from_millis(500)).await;\n\n        // Get channel info with last_read\n        let info = get_channel_unread_info(client, \u0026channel.id).await?;\n\n        if !info.has_unreads {\n            results.push(TidyResult {\n                channel_name: display_name,\n                action: TidyAction::Skipped,\n            });\n            continue;\n        }\n\n        // Get unread messages\n        sleep(Duration::from_millis(500)).await;\n        let messages = get_messages_since(client, \u0026channel.id, \u0026info.last_read).await?;\n\n        // Check for mentions\n        if let Some(mention) = find_mention(\u0026messages, user_info) {\n            results.push(TidyResult {\n                channel_name: display_name,\n                action: TidyAction::HasMention(mention),\n            });\n            continue;\n        }\n\n        // No mentions - mark as read\n        if !dry_run {\n            if let Some(latest_ts) = messages.first().map(|m| m.ts.as_str()) {\n                sleep(Duration::from_millis(500)).await;\n                mark_channel_read(client, \u0026channel.id, latest_ts).await?;\n            }\n        }\n\n        results.push(TidyResult {\n            channel_name: display_name,\n            action: TidyAction::MarkedRead,\n        });\n    }\n\n    Ok(results)\n}\n\n/// Get display name for a channel/DM\nfn get_display_name(channel: \u0026ChannelListItem) -\u003e String {\n    if let Some(ref name) = channel.name {\n        name.clone()\n    } else if let Some(ref user_id) = channel.user {\n        // DM - show user ID (ideally we'd look up the name, but this works for now)\n        format!(\"DM:{}\", user_id)\n    } else {\n        channel.id.clone()\n    }\n}\n\n/// List channels where user is a member\nasync fn list_member_channels(client: \u0026SlackClient) -\u003e Result\u003cVec\u003cChannelListItem\u003e\u003e {\n    let mut all_channels = Vec::new();\n    let mut cursor: Option\u003cString\u003e = None;\n    let mut first = true;\n\n    loop {\n        if !first {\n            sleep(Duration::from_millis(500)).await;\n        }\n        first = false;\n\n        let mut params = vec![\n            (\"types\", \"public_channel,private_channel,mpim,im\"),\n            (\"exclude_archived\", \"true\"),\n            (\"limit\", \"200\"),\n        ];\n\n        let cursor_str;\n        if let Some(ref c) = cursor {\n            cursor_str = c.clone();\n            params.push((\"cursor\", \u0026cursor_str));\n        }\n\n        let response: ConversationsListResponse = client\n            .get_with_user_token(\"conversations.list\", \u0026params)\n            .await?;\n\n        for ch in response.channels {\n            // DMs (is_im) don't have is_member field - user is implicitly a member\n            let is_member = ch.is_im.unwrap_or(false) || ch.is_member.unwrap_or(false);\n            if is_member {\n                all_channels.push(ch);\n            }\n        }\n\n        match response.response_metadata.and_then(|m| m.next_cursor) {\n            Some(c) if !c.is_empty() =\u003e cursor = Some(c),\n            _ =\u003e break,\n        }\n    }\n\n    Ok(all_channels)\n}\n\n/// Get channel info to determine if there are unreads\nasync fn get_channel_unread_info(\n    client: \u0026SlackClient,\n    channel_id: \u0026str,\n) -\u003e Result\u003cChannelUnreadInfo\u003e {\n    let response: ConversationsInfoResponse = client\n        .get_with_user_token(\"conversations.info\", \u0026[(\"channel\", channel_id)])\n        .await?;\n\n    let last_read = response.channel.last_read.unwrap_or_default();\n    let latest_ts = response.channel.latest.map(|l| l.ts).unwrap_or_default();\n\n    // Has unreads if latest message ts \u003e last_read ts\n    let has_unreads = !last_read.is_empty() \u0026\u0026 !latest_ts.is_empty() \u0026\u0026 latest_ts \u003e last_read;\n\n    Ok(ChannelUnreadInfo {\n        last_read,\n        has_unreads,\n    })\n}\n\n/// Get messages since last_read timestamp\nasync fn get_messages_since(\n    client: \u0026SlackClient,\n    channel_id: \u0026str,\n    oldest: \u0026str,\n) -\u003e Result\u003cVec\u003cHistoryMessage\u003e\u003e {\n    let response: HistoryResponse = client\n        .get_with_user_token(\n            \"conversations.history\",\n            \u0026[\n                (\"channel\", channel_id),\n                (\"oldest\", oldest),\n                (\"limit\", \"100\"),\n            ],\n        )\n        .await?;\n\n    Ok(response.messages)\n}\n\n/// Check if any message contains a mention of the user\nfn find_mention(messages: \u0026[HistoryMessage], user_info: \u0026UserInfo) -\u003e Option\u003cString\u003e {\n    let user_mention = format!(\"\u003c@{}\u003e\", user_info.user_id);\n    let name_lower = user_info.name.to_lowercase();\n    let full_name_lower = user_info.full_name.to_lowercase();\n\n    for msg in messages {\n        if let Some(ref text) = msg.text {\n            // Check direct mention\n            if text.contains(\u0026user_mention) {\n                return Some(format!(\"@mention: {}\", truncate(text, 50)));\n            }\n\n            // Check name (case-insensitive)\n            let text_lower = text.to_lowercase();\n            if text_lower.contains(\u0026name_lower) {\n                return Some(format!(\"name '{}': {}\", user_info.name, truncate(text, 50)));\n            }\n\n            // Check full name (case-insensitive)\n            if text_lower.contains(\u0026full_name_lower) {\n                return Some(format!(\"full name: {}\", truncate(text, 50)));\n            }\n        }\n    }\n\n    None\n}\n\n/// Mark a channel as read at the given timestamp\nasync fn mark_channel_read(client: \u0026SlackClient, channel_id: \u0026str, ts: \u0026str) -\u003e Result\u003c()\u003e {\n    let body = MarkRequest {\n        channel: channel_id.to_string(),\n        ts: ts.to_string(),\n    };\n\n    let _: MarkResponse = client\n        .post_with_user_token(\"conversations.mark\", \u0026body)\n        .await?;\n    Ok(())\n}\n\nfn truncate(s: \u0026str, max: usize) -\u003e String {\n    if s.len() \u003c= max {\n        s.to_string()\n    } else {\n        format!(\"{}...\", \u0026s[..max.saturating_sub(3)])\n    }\n}\n","traces":[{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":3}},{"line":164,"address":[],"length":0,"stats":{"Line":4}},{"line":165,"address":[],"length":0,"stats":{"Line":2}},{"line":166,"address":[],"length":0,"stats":{"Line":3}},{"line":168,"address":[],"length":0,"stats":{"Line":2}},{"line":170,"address":[],"length":0,"stats":{"Line":2}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":7}},{"line":262,"address":[],"length":0,"stats":{"Line":21}},{"line":263,"address":[],"length":0,"stats":{"Line":14}},{"line":264,"address":[],"length":0,"stats":{"Line":14}},{"line":266,"address":[],"length":0,"stats":{"Line":15}},{"line":267,"address":[],"length":0,"stats":{"Line":11}},{"line":269,"address":[],"length":0,"stats":{"Line":10}},{"line":270,"address":[],"length":0,"stats":{"Line":3}},{"line":274,"address":[],"length":0,"stats":{"Line":8}},{"line":275,"address":[],"length":0,"stats":{"Line":8}},{"line":276,"address":[],"length":0,"stats":{"Line":6}},{"line":280,"address":[],"length":0,"stats":{"Line":4}},{"line":281,"address":[],"length":0,"stats":{"Line":3}},{"line":286,"address":[],"length":0,"stats":{"Line":3}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":8}},{"line":303,"address":[],"length":0,"stats":{"Line":16}},{"line":304,"address":[],"length":0,"stats":{"Line":12}},{"line":306,"address":[],"length":0,"stats":{"Line":8}}],"covered":24,"coverable":102},{"path":["/","Users","chi","Projects","hu","src","slack","tidy","tests.rs"],"content":"use super::*;\n\n#[test]\nfn test_user_info_creation() {\n    let info = UserInfo {\n        user_id: \"U12345\".to_string(),\n        name: \"Alice\".to_string(),\n        full_name: \"Alice Smith\".to_string(),\n    };\n    assert_eq!(info.user_id, \"U12345\");\n    assert_eq!(info.name, \"Alice\");\n    assert_eq!(info.full_name, \"Alice Smith\");\n}\n\n#[test]\nfn test_tidy_result_debug() {\n    let result = TidyResult {\n        channel_name: \"general\".to_string(),\n        action: TidyAction::MarkedRead,\n    };\n    let debug = format!(\"{:?}\", result);\n    assert!(debug.contains(\"general\"));\n    assert!(debug.contains(\"MarkedRead\"));\n}\n\n#[test]\nfn test_tidy_action_skipped_debug() {\n    let action = TidyAction::Skipped;\n    assert_eq!(format!(\"{:?}\", action), \"Skipped\");\n}\n\n#[test]\nfn test_tidy_action_marked_read_debug() {\n    let action = TidyAction::MarkedRead;\n    assert_eq!(format!(\"{:?}\", action), \"MarkedRead\");\n}\n\n#[test]\nfn test_tidy_action_has_mention_debug() {\n    let action = TidyAction::HasMention(\"@alice mentioned you\".to_string());\n    let debug = format!(\"{:?}\", action);\n    assert!(debug.contains(\"HasMention\"));\n    assert!(debug.contains(\"@alice mentioned you\"));\n}\n\n#[test]\nfn test_get_display_name_with_name() {\n    let channel = ChannelListItem {\n        id: \"C12345\".to_string(),\n        name: Some(\"general\".to_string()),\n        user: None,\n        is_member: Some(true),\n        is_im: None,\n    };\n    assert_eq!(get_display_name(\u0026channel), \"general\");\n}\n\n#[test]\nfn test_get_display_name_dm() {\n    let channel = ChannelListItem {\n        id: \"D12345\".to_string(),\n        name: None,\n        user: Some(\"U67890\".to_string()),\n        is_member: None,\n        is_im: Some(true),\n    };\n    assert_eq!(get_display_name(\u0026channel), \"DM:U67890\");\n}\n\n#[test]\nfn test_get_display_name_fallback_to_id() {\n    let channel = ChannelListItem {\n        id: \"G12345\".to_string(),\n        name: None,\n        user: None,\n        is_member: None,\n        is_im: None,\n    };\n    assert_eq!(get_display_name(\u0026channel), \"G12345\");\n}\n\n#[test]\nfn test_truncate_short_string() {\n    assert_eq!(truncate(\"hello\", 10), \"hello\");\n}\n\n#[test]\nfn test_truncate_exact_length() {\n    assert_eq!(truncate(\"hello\", 5), \"hello\");\n}\n\n#[test]\nfn test_truncate_long_string() {\n    assert_eq!(truncate(\"hello world\", 8), \"hello...\");\n}\n\n#[test]\nfn test_truncate_very_short_max() {\n    assert_eq!(truncate(\"hello\", 3), \"...\");\n}\n\n#[test]\nfn test_find_mention_direct_user_mention() {\n    let messages = vec![HistoryMessage {\n        ts: \"1704067200.123456\".to_string(),\n        text: Some(\"Hey \u003c@U12345\u003e check this out\".to_string()),\n    }];\n    let user_info = UserInfo {\n        user_id: \"U12345\".to_string(),\n        name: \"Alice\".to_string(),\n        full_name: \"Alice Smith\".to_string(),\n    };\n\n    let result = find_mention(\u0026messages, \u0026user_info);\n    assert!(result.is_some());\n    assert!(result.unwrap().contains(\"@mention\"));\n}\n\n#[test]\nfn test_find_mention_name_match() {\n    let messages = vec![HistoryMessage {\n        ts: \"1704067200.123456\".to_string(),\n        text: Some(\"Hey Alice, how are you?\".to_string()),\n    }];\n    let user_info = UserInfo {\n        user_id: \"U12345\".to_string(),\n        name: \"Alice\".to_string(),\n        full_name: \"Alice Smith\".to_string(),\n    };\n\n    let result = find_mention(\u0026messages, \u0026user_info);\n    assert!(result.is_some());\n    assert!(result.unwrap().contains(\"name 'Alice'\"));\n}\n\n#[test]\nfn test_find_mention_full_name_match() {\n    let messages = vec![HistoryMessage {\n        ts: \"1704067200.123456\".to_string(),\n        text: Some(\"I talked to Alice Smith yesterday\".to_string()),\n    }];\n    let user_info = UserInfo {\n        user_id: \"U12345\".to_string(),\n        name: \"Bob\".to_string(),\n        full_name: \"Alice Smith\".to_string(),\n    };\n\n    let result = find_mention(\u0026messages, \u0026user_info);\n    assert!(result.is_some());\n    assert!(result.unwrap().contains(\"full name\"));\n}\n\n#[test]\nfn test_find_mention_case_insensitive() {\n    let messages = vec![HistoryMessage {\n        ts: \"1704067200.123456\".to_string(),\n        text: Some(\"ALICE is here\".to_string()),\n    }];\n    let user_info = UserInfo {\n        user_id: \"U12345\".to_string(),\n        name: \"alice\".to_string(),\n        full_name: \"Alice Smith\".to_string(),\n    };\n\n    let result = find_mention(\u0026messages, \u0026user_info);\n    assert!(result.is_some());\n}\n\n#[test]\nfn test_find_mention_no_match() {\n    let messages = vec![HistoryMessage {\n        ts: \"1704067200.123456\".to_string(),\n        text: Some(\"Just a regular message\".to_string()),\n    }];\n    let user_info = UserInfo {\n        user_id: \"U12345\".to_string(),\n        name: \"Alice\".to_string(),\n        full_name: \"Alice Smith\".to_string(),\n    };\n\n    let result = find_mention(\u0026messages, \u0026user_info);\n    assert!(result.is_none());\n}\n\n#[test]\nfn test_find_mention_empty_messages() {\n    let messages: Vec\u003cHistoryMessage\u003e = vec![];\n    let user_info = UserInfo {\n        user_id: \"U12345\".to_string(),\n        name: \"Alice\".to_string(),\n        full_name: \"Alice Smith\".to_string(),\n    };\n\n    let result = find_mention(\u0026messages, \u0026user_info);\n    assert!(result.is_none());\n}\n\n#[test]\nfn test_find_mention_message_without_text() {\n    let messages = vec![HistoryMessage {\n        ts: \"1704067200.123456\".to_string(),\n        text: None,\n    }];\n    let user_info = UserInfo {\n        user_id: \"U12345\".to_string(),\n        name: \"Alice\".to_string(),\n        full_name: \"Alice Smith\".to_string(),\n    };\n\n    let result = find_mention(\u0026messages, \u0026user_info);\n    assert!(result.is_none());\n}\n\n#[test]\nfn test_conversations_list_response_deserialize() {\n    let json = r#\"{\n            \"channels\": [\n                {\"id\": \"C12345\", \"name\": \"general\", \"is_member\": true},\n                {\"id\": \"D67890\", \"user\": \"U99999\", \"is_im\": true}\n            ],\n            \"response_metadata\": {\"next_cursor\": \"abc123\"}\n        }\"#;\n\n    let response: ConversationsListResponse = serde_json::from_str(json).unwrap();\n    assert_eq!(response.channels.len(), 2);\n    assert_eq!(response.channels[0].id, \"C12345\");\n    assert_eq!(response.channels[1].user, Some(\"U99999\".to_string()));\n}\n\n#[test]\nfn test_channel_list_item_deserialize() {\n    let json = r#\"{\"id\": \"C12345\", \"name\": \"test\", \"is_member\": true, \"is_im\": false}\"#;\n    let item: ChannelListItem = serde_json::from_str(json).unwrap();\n    assert_eq!(item.id, \"C12345\");\n    assert_eq!(item.name, Some(\"test\".to_string()));\n    assert_eq!(item.is_member, Some(true));\n    assert_eq!(item.is_im, Some(false));\n}\n\n#[test]\nfn test_conversations_info_response_deserialize() {\n    let json = r#\"{\n            \"channel\": {\n                \"last_read\": \"1704067200.000000\",\n                \"latest\": {\"ts\": \"1704067300.000000\"}\n            }\n        }\"#;\n\n    let response: ConversationsInfoResponse = serde_json::from_str(json).unwrap();\n    assert_eq!(\n        response.channel.last_read,\n        Some(\"1704067200.000000\".to_string())\n    );\n    assert_eq!(response.channel.latest.unwrap().ts, \"1704067300.000000\");\n}\n\n#[test]\nfn test_history_response_deserialize() {\n    let json = r#\"{\n            \"messages\": [\n                {\"ts\": \"1704067200.123456\", \"text\": \"Hello\"},\n                {\"ts\": \"1704067100.123456\"}\n            ]\n        }\"#;\n\n    let response: HistoryResponse = serde_json::from_str(json).unwrap();\n    assert_eq!(response.messages.len(), 2);\n    assert_eq!(response.messages[0].ts, \"1704067200.123456\");\n    assert_eq!(response.messages[0].text, Some(\"Hello\".to_string()));\n}\n\n#[test]\nfn test_mark_request_serialize() {\n    let request = MarkRequest {\n        channel: \"C12345\".to_string(),\n        ts: \"1704067200.123456\".to_string(),\n    };\n\n    let json = serde_json::to_string(\u0026request).unwrap();\n    assert!(json.contains(\"C12345\"));\n    assert!(json.contains(\"1704067200.123456\"));\n}\n\n#[test]\nfn test_mark_response_deserialize() {\n    let json = r#\"{}\"#;\n    let response: MarkResponse = serde_json::from_str(json).unwrap();\n    // Just verify it deserializes without error\n    let _ = response;\n}\n\n#[test]\nfn test_response_metadata_deserialize() {\n    let json = r#\"{\"next_cursor\": \"cursor123\"}\"#;\n    let meta: ResponseMetadata = serde_json::from_str(json).unwrap();\n    assert_eq!(meta.next_cursor, Some(\"cursor123\".to_string()));\n}\n\n#[test]\nfn test_channel_info_item_deserialize() {\n    let json = r#\"{\"last_read\": \"1704067200.000000\"}\"#;\n    let item: ChannelInfoItem = serde_json::from_str(json).unwrap();\n    assert_eq!(item.last_read, Some(\"1704067200.000000\".to_string()));\n    assert!(item.latest.is_none());\n}\n\n#[test]\nfn test_latest_message_deserialize() {\n    let json = r#\"{\"ts\": \"1704067200.123456\"}\"#;\n    let latest: LatestMessage = serde_json::from_str(json).unwrap();\n    assert_eq!(latest.ts, \"1704067200.123456\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","slack","types.rs"],"content":"//! Slack data types and structures\n\nuse serde::{Deserialize, Serialize};\n\n/// Slack channel information\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SlackChannel {\n    /// Channel ID (e.g., \"C12345678\")\n    pub id: String,\n    /// Channel name (without #)\n    pub name: String,\n    /// Whether this is a private channel\n    pub is_private: bool,\n    /// Whether the bot is a member of this channel\n    pub is_member: bool,\n    /// Channel topic\n    pub topic: Option\u003cString\u003e,\n    /// Channel purpose\n    pub purpose: Option\u003cString\u003e,\n    /// Number of members\n    pub num_members: Option\u003cu32\u003e,\n    /// Creation timestamp\n    pub created: i64,\n}\n\n/// Slack message\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SlackMessage {\n    /// Message type (usually \"message\")\n    #[serde(rename = \"type\")]\n    pub msg_type: String,\n    /// User ID who sent the message\n    pub user: Option\u003cString\u003e,\n    /// Message text\n    pub text: String,\n    /// Timestamp (unique ID for the message)\n    pub ts: String,\n    /// Thread timestamp (if this is a reply)\n    pub thread_ts: Option\u003cString\u003e,\n    /// Number of replies in thread\n    pub reply_count: Option\u003cu32\u003e,\n    /// User display name (enriched after fetch)\n    #[serde(skip_deserializing)]\n    pub username: Option\u003cString\u003e,\n}\n\n/// Slack user information\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SlackUser {\n    /// User ID\n    pub id: String,\n    /// Team ID\n    pub team_id: Option\u003cString\u003e,\n    /// Username (handle without @)\n    pub name: String,\n    /// Display name\n    pub real_name: Option\u003cString\u003e,\n    /// Whether this is a bot\n    pub is_bot: bool,\n    /// Whether this user is deleted\n    pub deleted: bool,\n    /// User's timezone\n    pub tz: Option\u003cString\u003e,\n}\n\n/// Search result match\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SlackSearchMatch {\n    /// Channel where the message was posted\n    pub channel: SlackSearchChannel,\n    /// User ID who posted\n    pub user: Option\u003cString\u003e,\n    /// Username who posted\n    pub username: Option\u003cString\u003e,\n    /// Message text\n    pub text: String,\n    /// Timestamp\n    pub ts: String,\n    /// Permalink to the message\n    pub permalink: Option\u003cString\u003e,\n}\n\n/// Channel info in search results\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SlackSearchChannel {\n    /// Channel ID\n    pub id: String,\n    /// Channel name\n    pub name: String,\n}\n\n/// Search results container\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SlackSearchResult {\n    /// Total matches found\n    pub total: u32,\n    /// Matches returned\n    pub matches: Vec\u003cSlackSearchMatch\u003e,\n}\n\n/// Output format for Slack commands\n#[derive(Debug, Clone, Copy, Default)]\npub enum OutputFormat {\n    /// Human-readable table format\n    #[default]\n    Table,\n    /// JSON format for scripting\n    Json,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_output_format_default() {\n        let format = OutputFormat::default();\n        assert!(matches!(format, OutputFormat::Table));\n    }\n\n    #[test]\n    fn test_output_format_clone() {\n        let format = OutputFormat::Json;\n        let cloned = format.clone();\n        assert!(matches!(cloned, OutputFormat::Json));\n    }\n\n    #[test]\n    fn test_output_format_debug() {\n        let format = OutputFormat::Table;\n        let debug = format!(\"{:?}\", format);\n        assert_eq!(debug, \"Table\");\n    }\n\n    #[test]\n    fn test_slack_channel_debug() {\n        let channel = SlackChannel {\n            id: \"C12345\".to_string(),\n            name: \"general\".to_string(),\n            is_private: false,\n            is_member: true,\n            topic: Some(\"Test topic\".to_string()),\n            purpose: None,\n            num_members: Some(100),\n            created: 1704067200,\n        };\n        let debug = format!(\"{:?}\", channel);\n        assert!(debug.contains(\"SlackChannel\"));\n        assert!(debug.contains(\"general\"));\n    }\n\n    #[test]\n    fn test_slack_channel_clone() {\n        let channel = SlackChannel {\n            id: \"C12345\".to_string(),\n            name: \"general\".to_string(),\n            is_private: false,\n            is_member: true,\n            topic: None,\n            purpose: None,\n            num_members: None,\n            created: 1704067200,\n        };\n        let cloned = channel.clone();\n        assert_eq!(cloned.id, channel.id);\n        assert_eq!(cloned.name, channel.name);\n    }\n\n    #[test]\n    fn test_slack_message_debug() {\n        let msg = SlackMessage {\n            msg_type: \"message\".to_string(),\n            user: Some(\"U12345\".to_string()),\n            text: \"Hello world\".to_string(),\n            ts: \"1704067200.123456\".to_string(),\n            thread_ts: None,\n            reply_count: Some(5),\n            username: None,\n        };\n        let debug = format!(\"{:?}\", msg);\n        assert!(debug.contains(\"SlackMessage\"));\n    }\n\n    #[test]\n    fn test_slack_user_debug() {\n        let user = SlackUser {\n            id: \"U12345\".to_string(),\n            team_id: Some(\"T12345\".to_string()),\n            name: \"alice\".to_string(),\n            real_name: Some(\"Alice Smith\".to_string()),\n            is_bot: false,\n            deleted: false,\n            tz: Some(\"America/New_York\".to_string()),\n        };\n        let debug = format!(\"{:?}\", user);\n        assert!(debug.contains(\"SlackUser\"));\n    }\n\n    #[test]\n    fn test_slack_search_result_debug() {\n        let result = SlackSearchResult {\n            total: 42,\n            matches: vec![],\n        };\n        let debug = format!(\"{:?}\", result);\n        assert!(debug.contains(\"SlackSearchResult\"));\n        assert!(debug.contains(\"42\"));\n    }\n\n    #[test]\n    fn test_slack_search_match_debug() {\n        let m = SlackSearchMatch {\n            channel: SlackSearchChannel {\n                id: \"C12345\".to_string(),\n                name: \"general\".to_string(),\n            },\n            user: Some(\"U12345\".to_string()),\n            username: Some(\"alice\".to_string()),\n            text: \"Hello\".to_string(),\n            ts: \"1704067200.123456\".to_string(),\n            permalink: Some(\"https://slack.com/...\".to_string()),\n        };\n        let debug = format!(\"{:?}\", m);\n        assert!(debug.contains(\"SlackSearchMatch\"));\n    }\n\n    #[test]\n    fn test_slack_search_channel_clone() {\n        let channel = SlackSearchChannel {\n            id: \"C12345\".to_string(),\n            name: \"general\".to_string(),\n        };\n        let cloned = channel.clone();\n        assert_eq!(cloned.id, channel.id);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","util","config","mod.rs"],"content":"use anyhow::{Context, Result};\nuse serde::{Deserialize, Serialize};\nuse std::fs;\nuse std::path::PathBuf;\n\n#[cfg(test)]\nmod tests;\n\n#[derive(Debug, Serialize, Deserialize, Default)]\npub struct Credentials {\n    #[serde(default)]\n    pub github: Option\u003cGithubCredentials\u003e,\n    #[serde(default)]\n    pub jira: Option\u003cJiraCredentials\u003e,\n    #[serde(default)]\n    pub brave: Option\u003cBraveCredentials\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct BraveCredentials {\n    pub api_key: String,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct GithubCredentials {\n    pub token: String,\n    pub username: String,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone, Default)]\npub struct JiraCredentials {\n    pub access_token: String,\n    pub refresh_token: String,\n    pub expires_at: i64, // Unix timestamp\n    pub cloud_id: String,\n    pub site_url: String,\n}\n\n/// Returns the config directory path\npub fn config_dir() -\u003e Result\u003cPathBuf\u003e {\n    let proj_dirs = directories::ProjectDirs::from(\"\", \"\", \"hu\")\n        .context(\"Could not determine config directory\")?;\n    Ok(proj_dirs.config_dir().to_path_buf())\n}\n\n/// Returns the path to credentials.toml\nfn credentials_path() -\u003e Result\u003cPathBuf\u003e {\n    Ok(config_dir()?.join(\"credentials.toml\"))\n}\n\n/// Load credentials from config dir\npub fn load_credentials() -\u003e Result\u003cCredentials\u003e {\n    let path = credentials_path()?;\n    load_credentials_from(\u0026path)\n}\n\n/// Load credentials from a specific path (testable)\npub fn load_credentials_from(path: \u0026PathBuf) -\u003e Result\u003cCredentials\u003e {\n    if !path.exists() {\n        return Ok(Credentials::default());\n    }\n\n    let contents =\n        fs::read_to_string(path).with_context(|| format!(\"Failed to read {}\", path.display()))?;\n\n    toml::from_str(\u0026contents).with_context(|| format!(\"Failed to parse {}\", path.display()))\n}\n\n/// Save credentials to config dir\npub fn save_credentials(creds: \u0026Credentials) -\u003e Result\u003c()\u003e {\n    let path = credentials_path()?;\n    save_credentials_to(creds, \u0026path)\n}\n\n/// Save credentials to a specific path (testable)\npub fn save_credentials_to(creds: \u0026Credentials, path: \u0026PathBuf) -\u003e Result\u003c()\u003e {\n    if let Some(dir) = path.parent() {\n        fs::create_dir_all(dir)\n            .with_context(|| format!(\"Failed to create directory {}\", dir.display()))?;\n    }\n\n    let contents = toml::to_string_pretty(creds).context(\"Failed to serialize credentials\")?;\n\n    fs::write(path, contents).with_context(|| format!(\"Failed to write {}\", path.display()))?;\n\n    Ok(())\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":17}},{"line":41,"address":[],"length":0,"stats":{"Line":85}},{"line":43,"address":[],"length":0,"stats":{"Line":17}},{"line":47,"address":[],"length":0,"stats":{"Line":15}},{"line":48,"address":[],"length":0,"stats":{"Line":30}},{"line":52,"address":[],"length":0,"stats":{"Line":11}},{"line":53,"address":[],"length":0,"stats":{"Line":22}},{"line":54,"address":[],"length":0,"stats":{"Line":22}},{"line":58,"address":[],"length":0,"stats":{"Line":25}},{"line":59,"address":[],"length":0,"stats":{"Line":25}},{"line":60,"address":[],"length":0,"stats":{"Line":4}},{"line":63,"address":[],"length":0,"stats":{"Line":21}},{"line":64,"address":[],"length":0,"stats":{"Line":63}},{"line":66,"address":[],"length":0,"stats":{"Line":63}},{"line":70,"address":[],"length":0,"stats":{"Line":2}},{"line":71,"address":[],"length":0,"stats":{"Line":4}},{"line":72,"address":[],"length":0,"stats":{"Line":6}},{"line":76,"address":[],"length":0,"stats":{"Line":11}},{"line":77,"address":[],"length":0,"stats":{"Line":22}},{"line":78,"address":[],"length":0,"stats":{"Line":22}},{"line":79,"address":[],"length":0,"stats":{"Line":11}},{"line":82,"address":[],"length":0,"stats":{"Line":44}},{"line":84,"address":[],"length":0,"stats":{"Line":44}},{"line":86,"address":[],"length":0,"stats":{"Line":11}}],"covered":24,"coverable":24},{"path":["/","Users","chi","Projects","hu","src","util","config","tests.rs"],"content":"use super::*;\n\n#[test]\nfn config_dir_returns_path() {\n    let dir = config_dir().unwrap();\n    assert!(dir.to_string_lossy().contains(\"hu\"));\n}\n\n#[test]\nfn credentials_path_is_in_config_dir() {\n    let path = credentials_path().unwrap();\n    assert!(path.to_string_lossy().contains(\"hu\"));\n    assert!(path.to_string_lossy().ends_with(\"credentials.toml\"));\n}\n\n#[test]\nfn credentials_serialize_deserialize() {\n    let creds = Credentials {\n        github: Some(GithubCredentials {\n            token: \"test_token\".to_string(),\n            username: \"testuser\".to_string(),\n        }),\n        jira: None,\n        brave: None,\n    };\n\n    let toml_str = toml::to_string(\u0026creds).unwrap();\n    let parsed: Credentials = toml::from_str(\u0026toml_str).unwrap();\n\n    assert!(parsed.github.is_some());\n    let gh = parsed.github.unwrap();\n    assert_eq!(gh.token, \"test_token\");\n    assert_eq!(gh.username, \"testuser\");\n}\n\n#[test]\nfn empty_credentials_default() {\n    let creds = Credentials::default();\n    assert!(creds.github.is_none());\n    assert!(creds.jira.is_none());\n}\n\n#[test]\nfn credentials_without_github_parses() {\n    let toml_str = \"\";\n    let creds: Credentials = toml::from_str(toml_str).unwrap();\n    assert!(creds.github.is_none());\n    assert!(creds.jira.is_none());\n}\n\n#[test]\nfn credentials_toml_format() {\n    let creds = Credentials {\n        github: Some(GithubCredentials {\n            token: \"ghp_abc123\".to_string(),\n            username: \"octocat\".to_string(),\n        }),\n        jira: None,\n        brave: None,\n    };\n\n    let toml_str = toml::to_string_pretty(\u0026creds).unwrap();\n    assert!(toml_str.contains(\"[github]\"));\n    assert!(toml_str.contains(\"token = \\\"ghp_abc123\\\"\"));\n    assert!(toml_str.contains(\"username = \\\"octocat\\\"\"));\n}\n\n#[test]\nfn github_credentials_clone() {\n    let creds = GithubCredentials {\n        token: \"token\".to_string(),\n        username: \"user\".to_string(),\n    };\n    let cloned = creds.clone();\n    assert_eq!(cloned.token, creds.token);\n    assert_eq!(cloned.username, creds.username);\n}\n\n#[test]\nfn credentials_debug_format() {\n    let creds = Credentials::default();\n    let debug_str = format!(\"{:?}\", creds);\n    assert!(debug_str.contains(\"Credentials\"));\n}\n\n#[test]\nfn github_credentials_debug_format() {\n    let creds = GithubCredentials {\n        token: \"token\".to_string(),\n        username: \"user\".to_string(),\n    };\n    let debug_str = format!(\"{:?}\", creds);\n    assert!(debug_str.contains(\"GithubCredentials\"));\n}\n\n#[test]\nfn load_credentials_handles_missing_file() {\n    // load_credentials returns Ok with default if file doesn't exist\n    // This tests the path exists check\n    let result = load_credentials();\n    // Either returns existing creds or default\n    assert!(result.is_ok());\n}\n\n#[test]\nfn credentials_path_parent_exists() {\n    let path = credentials_path().unwrap();\n    let parent = path.parent();\n    assert!(parent.is_some());\n}\n\n#[test]\nfn config_dir_is_absolute() {\n    let dir = config_dir().unwrap();\n    assert!(dir.is_absolute());\n}\n\n// File I/O tests with temp files\n#[test]\nfn save_and_load_credentials_roundtrip() {\n    let temp_dir = std::env::temp_dir().join(\"hu_test_config\");\n    let _ = std::fs::remove_dir_all(\u0026temp_dir); // Clean up from previous runs\n    let path = temp_dir.join(\"credentials.toml\");\n\n    let creds = Credentials {\n        github: Some(GithubCredentials {\n            token: \"test_token_123\".to_string(),\n            username: \"testuser\".to_string(),\n        }),\n        jira: None,\n        brave: None,\n    };\n\n    // Save\n    save_credentials_to(\u0026creds, \u0026path).unwrap();\n    assert!(path.exists());\n\n    // Load\n    let loaded = load_credentials_from(\u0026path).unwrap();\n    assert!(loaded.github.is_some());\n    let gh = loaded.github.unwrap();\n    assert_eq!(gh.token, \"test_token_123\");\n    assert_eq!(gh.username, \"testuser\");\n\n    // Cleanup\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n}\n\n#[test]\nfn load_credentials_from_missing_file() {\n    let path = PathBuf::from(\"/nonexistent/path/credentials.toml\");\n    let creds = load_credentials_from(\u0026path).unwrap();\n    assert!(creds.github.is_none());\n}\n\n#[test]\nfn load_credentials_from_empty_file() {\n    let temp_dir = std::env::temp_dir().join(\"hu_test_empty\");\n    let _ = std::fs::create_dir_all(\u0026temp_dir);\n    let path = temp_dir.join(\"credentials.toml\");\n\n    std::fs::write(\u0026path, \"\").unwrap();\n    let creds = load_credentials_from(\u0026path).unwrap();\n    assert!(creds.github.is_none());\n\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n}\n\n#[test]\nfn load_credentials_from_partial_file() {\n    let temp_dir = std::env::temp_dir().join(\"hu_test_partial\");\n    let _ = std::fs::create_dir_all(\u0026temp_dir);\n    let path = temp_dir.join(\"credentials.toml\");\n\n    std::fs::write(\u0026path, \"[github]\\ntoken = \\\"abc\\\"\\nusername = \\\"user\\\"\").unwrap();\n    let creds = load_credentials_from(\u0026path).unwrap();\n    assert!(creds.github.is_some());\n    assert_eq!(creds.github.unwrap().token, \"abc\");\n\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n}\n\n#[test]\nfn save_credentials_creates_parent_dirs() {\n    let temp_dir = std::env::temp_dir().join(\"hu_test_nested/a/b/c\");\n    let _ = std::fs::remove_dir_all(std::env::temp_dir().join(\"hu_test_nested\"));\n    let path = temp_dir.join(\"credentials.toml\");\n\n    let creds = Credentials::default();\n    save_credentials_to(\u0026creds, \u0026path).unwrap();\n    assert!(path.exists());\n\n    let _ = std::fs::remove_dir_all(std::env::temp_dir().join(\"hu_test_nested\"));\n}\n\n#[test]\nfn save_credentials_overwrites_existing() {\n    let temp_dir = std::env::temp_dir().join(\"hu_test_overwrite\");\n    let _ = std::fs::create_dir_all(\u0026temp_dir);\n    let path = temp_dir.join(\"credentials.toml\");\n\n    // Save first version\n    let creds1 = Credentials {\n        github: Some(GithubCredentials {\n            token: \"old\".to_string(),\n            username: \"old\".to_string(),\n        }),\n        jira: None,\n        brave: None,\n    };\n    save_credentials_to(\u0026creds1, \u0026path).unwrap();\n\n    // Save second version\n    let creds2 = Credentials {\n        github: Some(GithubCredentials {\n            token: \"new\".to_string(),\n            username: \"new\".to_string(),\n        }),\n        jira: None,\n        brave: None,\n    };\n    save_credentials_to(\u0026creds2, \u0026path).unwrap();\n\n    // Load and verify\n    let loaded = load_credentials_from(\u0026path).unwrap();\n    assert_eq!(loaded.github.unwrap().token, \"new\");\n\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n}\n\n// JiraCredentials tests\n#[test]\nfn jira_credentials_default() {\n    let creds = JiraCredentials::default();\n    assert_eq!(creds.access_token, \"\");\n    assert_eq!(creds.refresh_token, \"\");\n    assert_eq!(creds.expires_at, 0);\n    assert_eq!(creds.cloud_id, \"\");\n    assert_eq!(creds.site_url, \"\");\n}\n\n#[test]\nfn jira_credentials_clone() {\n    let creds = JiraCredentials {\n        access_token: \"access\".to_string(),\n        refresh_token: \"refresh\".to_string(),\n        expires_at: 1234567890,\n        cloud_id: \"cloud123\".to_string(),\n        site_url: \"https://example.atlassian.net\".to_string(),\n    };\n    let cloned = creds.clone();\n    assert_eq!(cloned.access_token, creds.access_token);\n    assert_eq!(cloned.refresh_token, creds.refresh_token);\n    assert_eq!(cloned.expires_at, creds.expires_at);\n    assert_eq!(cloned.cloud_id, creds.cloud_id);\n    assert_eq!(cloned.site_url, creds.site_url);\n}\n\n#[test]\nfn jira_credentials_debug_format() {\n    let creds = JiraCredentials::default();\n    let debug_str = format!(\"{:?}\", creds);\n    assert!(debug_str.contains(\"JiraCredentials\"));\n}\n\n#[test]\nfn jira_credentials_serialize_deserialize() {\n    let creds = Credentials {\n        github: None,\n        jira: Some(JiraCredentials {\n            access_token: \"access_token\".to_string(),\n            refresh_token: \"refresh_token\".to_string(),\n            expires_at: 1234567890,\n            cloud_id: \"cloud123\".to_string(),\n            site_url: \"https://example.atlassian.net\".to_string(),\n        }),\n        brave: None,\n    };\n\n    let toml_str = toml::to_string(\u0026creds).unwrap();\n    let parsed: Credentials = toml::from_str(\u0026toml_str).unwrap();\n\n    assert!(parsed.jira.is_some());\n    let jira = parsed.jira.unwrap();\n    assert_eq!(jira.access_token, \"access_token\");\n    assert_eq!(jira.refresh_token, \"refresh_token\");\n    assert_eq!(jira.expires_at, 1234567890);\n    assert_eq!(jira.cloud_id, \"cloud123\");\n    assert_eq!(jira.site_url, \"https://example.atlassian.net\");\n}\n\n#[test]\nfn jira_credentials_toml_format() {\n    let creds = Credentials {\n        github: None,\n        jira: Some(JiraCredentials {\n            access_token: \"test_access\".to_string(),\n            refresh_token: \"test_refresh\".to_string(),\n            expires_at: 9876543210,\n            cloud_id: \"test_cloud\".to_string(),\n            site_url: \"https://test.atlassian.net\".to_string(),\n        }),\n        brave: None,\n    };\n\n    let toml_str = toml::to_string_pretty(\u0026creds).unwrap();\n    assert!(toml_str.contains(\"[jira]\"));\n    assert!(toml_str.contains(\"access_token = \\\"test_access\\\"\"));\n    assert!(toml_str.contains(\"refresh_token = \\\"test_refresh\\\"\"));\n    assert!(toml_str.contains(\"expires_at = 9876543210\"));\n    assert!(toml_str.contains(\"cloud_id = \\\"test_cloud\\\"\"));\n    assert!(toml_str.contains(\"site_url = \\\"https://test.atlassian.net\\\"\"));\n}\n\n#[test]\nfn save_and_load_jira_credentials_roundtrip() {\n    let temp_dir = std::env::temp_dir().join(\"hu_test_jira_config\");\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n    let path = temp_dir.join(\"credentials.toml\");\n\n    let creds = Credentials {\n        github: None,\n        jira: Some(JiraCredentials {\n            access_token: \"jira_access\".to_string(),\n            refresh_token: \"jira_refresh\".to_string(),\n            expires_at: 1111111111,\n            cloud_id: \"jira_cloud\".to_string(),\n            site_url: \"https://jira.atlassian.net\".to_string(),\n        }),\n        brave: None,\n    };\n\n    save_credentials_to(\u0026creds, \u0026path).unwrap();\n    assert!(path.exists());\n\n    let loaded = load_credentials_from(\u0026path).unwrap();\n    assert!(loaded.jira.is_some());\n    let jira = loaded.jira.unwrap();\n    assert_eq!(jira.access_token, \"jira_access\");\n    assert_eq!(jira.refresh_token, \"jira_refresh\");\n    assert_eq!(jira.expires_at, 1111111111);\n    assert_eq!(jira.cloud_id, \"jira_cloud\");\n    assert_eq!(jira.site_url, \"https://jira.atlassian.net\");\n\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n}\n\n#[test]\nfn credentials_with_both_github_and_jira() {\n    let creds = Credentials {\n        github: Some(GithubCredentials {\n            token: \"gh_token\".to_string(),\n            username: \"ghuser\".to_string(),\n        }),\n        jira: Some(JiraCredentials {\n            access_token: \"jira_access\".to_string(),\n            refresh_token: \"jira_refresh\".to_string(),\n            expires_at: 2222222222,\n            cloud_id: \"both_cloud\".to_string(),\n            site_url: \"https://both.atlassian.net\".to_string(),\n        }),\n        brave: None,\n    };\n\n    let toml_str = toml::to_string(\u0026creds).unwrap();\n    let parsed: Credentials = toml::from_str(\u0026toml_str).unwrap();\n\n    assert!(parsed.github.is_some());\n    assert!(parsed.jira.is_some());\n    assert_eq!(parsed.github.unwrap().token, \"gh_token\");\n    assert_eq!(parsed.jira.unwrap().access_token, \"jira_access\");\n}\n\n// BraveCredentials tests\n#[test]\nfn brave_credentials_clone() {\n    let creds = BraveCredentials {\n        api_key: \"brave_key\".to_string(),\n    };\n    let cloned = creds.clone();\n    assert_eq!(cloned.api_key, creds.api_key);\n}\n\n#[test]\nfn brave_credentials_debug_format() {\n    let creds = BraveCredentials {\n        api_key: \"key\".to_string(),\n    };\n    let debug_str = format!(\"{:?}\", creds);\n    assert!(debug_str.contains(\"BraveCredentials\"));\n}\n\n#[test]\nfn brave_credentials_serialize_deserialize() {\n    let creds = Credentials {\n        github: None,\n        jira: None,\n        brave: Some(BraveCredentials {\n            api_key: \"test_api_key\".to_string(),\n        }),\n    };\n\n    let toml_str = toml::to_string(\u0026creds).unwrap();\n    let parsed: Credentials = toml::from_str(\u0026toml_str).unwrap();\n\n    assert!(parsed.brave.is_some());\n    let brave = parsed.brave.unwrap();\n    assert_eq!(brave.api_key, \"test_api_key\");\n}\n\n#[test]\nfn brave_credentials_toml_format() {\n    let creds = Credentials {\n        github: None,\n        jira: None,\n        brave: Some(BraveCredentials {\n            api_key: \"brave_api_key_123\".to_string(),\n        }),\n    };\n\n    let toml_str = toml::to_string_pretty(\u0026creds).unwrap();\n    assert!(toml_str.contains(\"[brave]\"));\n    assert!(toml_str.contains(\"api_key = \\\"brave_api_key_123\\\"\"));\n}\n\n#[test]\nfn save_and_load_brave_credentials_roundtrip() {\n    let temp_dir = std::env::temp_dir().join(\"hu_test_brave_config\");\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n    let path = temp_dir.join(\"credentials.toml\");\n\n    let creds = Credentials {\n        github: None,\n        jira: None,\n        brave: Some(BraveCredentials {\n            api_key: \"brave_roundtrip_key\".to_string(),\n        }),\n    };\n\n    save_credentials_to(\u0026creds, \u0026path).unwrap();\n    assert!(path.exists());\n\n    let loaded = load_credentials_from(\u0026path).unwrap();\n    assert!(loaded.brave.is_some());\n    let brave = loaded.brave.unwrap();\n    assert_eq!(brave.api_key, \"brave_roundtrip_key\");\n\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n}\n\n#[test]\nfn credentials_with_all_three() {\n    let creds = Credentials {\n        github: Some(GithubCredentials {\n            token: \"gh\".to_string(),\n            username: \"user\".to_string(),\n        }),\n        jira: Some(JiraCredentials {\n            access_token: \"jira\".to_string(),\n            refresh_token: \"refresh\".to_string(),\n            expires_at: 123,\n            cloud_id: \"cloud\".to_string(),\n            site_url: \"https://x.atlassian.net\".to_string(),\n        }),\n        brave: Some(BraveCredentials {\n            api_key: \"brave\".to_string(),\n        }),\n    };\n\n    let toml_str = toml::to_string(\u0026creds).unwrap();\n    let parsed: Credentials = toml::from_str(\u0026toml_str).unwrap();\n\n    assert!(parsed.github.is_some());\n    assert!(parsed.jira.is_some());\n    assert!(parsed.brave.is_some());\n    assert_eq!(parsed.brave.unwrap().api_key, \"brave\");\n}\n\n#[test]\nfn save_credentials_and_load_integration() {\n    // Integration test: save and load using actual config path\n    // First load existing to preserve it\n    let original = load_credentials().ok();\n\n    // Save test credentials\n    let test_creds = Credentials {\n        github: Some(GithubCredentials {\n            token: \"integration_test_token\".to_string(),\n            username: \"integration_test_user\".to_string(),\n        }),\n        jira: None,\n        brave: None,\n    };\n    save_credentials(\u0026test_creds).unwrap();\n\n    // Load and verify\n    let loaded = load_credentials().unwrap();\n    assert!(loaded.github.is_some());\n    assert_eq!(\n        loaded.github.as_ref().unwrap().token,\n        \"integration_test_token\"\n    );\n\n    // Restore original if it existed, or save empty\n    if let Some(orig) = original {\n        save_credentials(\u0026orig).unwrap();\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","util","mod.rs"],"content":"mod config;\n\npub use config::{\n    load_credentials, save_credentials, BraveCredentials, GithubCredentials, JiraCredentials,\n};\n\n#[allow(unused_imports)]\npub use config::{config_dir, Credentials};\n\n// These are used in tests\n#[allow(unused_imports)]\npub use config::{load_credentials_from, save_credentials_to};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","utils","cli.rs"],"content":"use clap::{Args, Subcommand};\n\n#[derive(Debug, Subcommand)]\npub enum UtilsCommand {\n    /// Fetch URL and convert to markdown\n    FetchHtml(FetchHtmlArgs),\n    /// Smart grep with token-saving options\n    Grep(GrepArgs),\n    /// Web search using Brave Search API\n    WebSearch(WebSearchArgs),\n    /// Build heading index for markdown files\n    DocsIndex(DocsIndexArgs),\n    /// Search docs index for matching sections\n    DocsSearch(DocsSearchArgs),\n    /// Extract a section from a markdown file\n    DocsSection(DocsSectionArgs),\n}\n\n#[derive(Debug, Args)]\npub struct FetchHtmlArgs {\n    /// URL to fetch\n    pub url: String,\n\n    /// Extract main content only (strip nav, footer, scripts, ads)\n    #[arg(long, short = 'c')]\n    pub content: bool,\n\n    /// Return summary (first N paragraphs + headings)\n    #[arg(long, short = 's')]\n    pub summary: bool,\n\n    /// Extract links only [text](url)\n    #[arg(long, short = 'l')]\n    pub links: bool,\n\n    /// Extract headings only (document outline)\n    #[arg(long, short = 'H')]\n    pub headings: bool,\n\n    /// CSS selector to target (e.g., \"article\", \"main\", \".content\")\n    #[arg(long)]\n    pub selector: Option\u003cString\u003e,\n\n    /// Output to file instead of stdout\n    #[arg(long, short = 'o')]\n    pub output: Option\u003cString\u003e,\n\n    /// Raw output (no filtering)\n    #[arg(long, short = 'r')]\n    pub raw: bool,\n}\n\n#[derive(Debug, Args)]\npub struct GrepArgs {\n    /// Pattern to search for (regex)\n    pub pattern: String,\n\n    /// Path to search (default: current directory)\n    #[arg(default_value = \".\")]\n    pub path: String,\n\n    /// Return file:line references only (no content)\n    #[arg(long)]\n    pub refs: bool,\n\n    /// Deduplicate similar matches\n    #[arg(long)]\n    pub unique: bool,\n\n    /// Sort by relevance (match density)\n    #[arg(long)]\n    pub ranked: bool,\n\n    /// Limit number of results\n    #[arg(long, short = 'n')]\n    pub limit: Option\u003cusize\u003e,\n\n    /// Show function/class signature only (not body)\n    #[arg(long)]\n    pub signature: bool,\n\n    /// File glob pattern (e.g., \"*.rs\", \"*.py\")\n    #[arg(long, short = 'g')]\n    pub glob: Option\u003cString\u003e,\n\n    /// Case insensitive search\n    #[arg(long, short = 'i')]\n    pub ignore_case: bool,\n\n    /// Include hidden files\n    #[arg(long)]\n    pub hidden: bool,\n}\n\n#[derive(Debug, Args)]\npub struct WebSearchArgs {\n    /// Search query\n    pub query: String,\n\n    /// Number of results to fetch content from (default: 3)\n    #[arg(long, short = 'n', default_value = \"3\")]\n    pub results: usize,\n\n    /// Only show search results (don't fetch content)\n    #[arg(long, short = 'l')]\n    pub list: bool,\n\n    /// Output to file instead of stdout\n    #[arg(long, short = 'o')]\n    pub output: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Args)]\npub struct DocsIndexArgs {\n    /// Directory to index\n    #[arg(default_value = \".\")]\n    pub path: String,\n\n    /// Output index to file (JSON)\n    #[arg(long, short = 'o')]\n    pub output: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Args)]\npub struct DocsSearchArgs {\n    /// Path to index file (JSON)\n    pub index: String,\n\n    /// Search query\n    pub query: String,\n\n    /// Limit number of results\n    #[arg(long, short = 'n')]\n    pub limit: Option\u003cusize\u003e,\n}\n\n#[derive(Debug, Args)]\npub struct DocsSectionArgs {\n    /// Markdown file path\n    pub file: String,\n\n    /// Section heading to extract\n    pub heading: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","utils","docs_index","mod.rs"],"content":"use anyhow::{Context, Result};\nuse regex::Regex;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::Path;\n\n#[cfg(test)]\nmod tests;\n\n/// Section in a markdown file\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct Section {\n    /// Heading text (without # prefix)\n    pub heading: String,\n    /// Heading level (1-6)\n    pub level: u8,\n    /// Start line (1-indexed)\n    pub start_line: usize,\n    /// End line (exclusive, 0 means end of file)\n    pub end_line: usize,\n}\n\nimpl Section {\n    pub fn new(heading: String, level: u8, start_line: usize) -\u003e Self {\n        Self {\n            heading,\n            level,\n            start_line,\n            end_line: 0,\n        }\n    }\n}\n\n/// Index of a single markdown file\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct FileIndex {\n    /// File path (relative to index root)\n    pub path: String,\n    /// Total line count\n    pub line_count: usize,\n    /// Sections in the file\n    pub sections: Vec\u003cSection\u003e,\n}\n\nimpl FileIndex {\n    pub fn new(path: String, line_count: usize) -\u003e Self {\n        Self {\n            path,\n            line_count,\n            sections: Vec::new(),\n        }\n    }\n}\n\n/// Index of all markdown files in a directory\n#[derive(Debug, Clone, Serialize, Deserialize, Default, PartialEq)]\npub struct DocsIndex {\n    /// Root directory path\n    pub root: String,\n    /// Map of relative path to file index\n    pub files: HashMap\u003cString, FileIndex\u003e,\n}\n\nimpl DocsIndex {\n    pub fn new(root: String) -\u003e Self {\n        Self {\n            root,\n            files: HashMap::new(),\n        }\n    }\n\n    /// Add a file index\n    pub fn add_file(\u0026mut self, index: FileIndex) {\n        self.files.insert(index.path.clone(), index);\n    }\n\n    /// Get file count\n    pub fn file_count(\u0026self) -\u003e usize {\n        self.files.len()\n    }\n\n    /// Get total section count\n    pub fn section_count(\u0026self) -\u003e usize {\n        self.files.values().map(|f| f.sections.len()).sum()\n    }\n}\n\n/// Build an index for markdown files in a directory\npub fn build_index(dir: \u0026str) -\u003e Result\u003cDocsIndex\u003e {\n    let root = Path::new(dir);\n    if !root.is_dir() {\n        anyhow::bail!(\"Not a directory: {}\", dir);\n    }\n\n    let mut index = DocsIndex::new(dir.to_string());\n    index_directory(root, root, \u0026mut index)?;\n\n    Ok(index)\n}\n\n/// Recursively index a directory\nfn index_directory(root: \u0026Path, dir: \u0026Path, index: \u0026mut DocsIndex) -\u003e Result\u003c()\u003e {\n    let entries = fs::read_dir(dir)\n        .with_context(|| format!(\"Failed to read directory: {}\", dir.display()))?;\n\n    for entry in entries.flatten() {\n        let path = entry.path();\n        let name = path.file_name().and_then(|n| n.to_str()).unwrap_or(\"\");\n\n        // Skip hidden directories\n        if name.starts_with('.') {\n            continue;\n        }\n\n        if path.is_dir() {\n            index_directory(root, \u0026path, index)?;\n        } else if let Some(ext) = path.extension().and_then(|e| e.to_str()) {\n            if ext == \"md\" || ext == \"markdown\" {\n                let file_index = index_file(root, \u0026path)?;\n                index.add_file(file_index);\n            }\n        }\n    }\n\n    Ok(())\n}\n\n/// Index a single markdown file\nfn index_file(root: \u0026Path, path: \u0026Path) -\u003e Result\u003cFileIndex\u003e {\n    let content = fs::read_to_string(path)\n        .with_context(|| format!(\"Failed to read file: {}\", path.display()))?;\n\n    let relative_path = path\n        .strip_prefix(root)\n        .map(|p| p.to_string_lossy().to_string())\n        .unwrap_or_else(|_| path.to_string_lossy().to_string());\n\n    let line_count = content.lines().count();\n    let mut file_index = FileIndex::new(relative_path, line_count);\n\n    // Parse headings\n    let heading_re = Regex::new(r\"^(#{1,6})\\s+(.+)$\").unwrap();\n    let mut sections: Vec\u003cSection\u003e = Vec::new();\n\n    for (line_num, line) in content.lines().enumerate() {\n        let line_num = line_num + 1;\n\n        if let Some(caps) = heading_re.captures(line) {\n            let level = caps.get(1).unwrap().as_str().len() as u8;\n            let heading = caps.get(2).unwrap().as_str().to_string();\n\n            // Close the most recent unclosed section\n            // Each section ends when the next heading starts, regardless of level\n            // This gives simple non-overlapping ranges for extraction\n            if let Some(last) = sections.iter_mut().rev().find(|s| s.end_line == 0) {\n                last.end_line = line_num;\n            }\n\n            sections.push(Section::new(heading, level, line_num));\n        }\n    }\n\n    // Close remaining open sections at end of file\n    for section in \u0026mut sections {\n        if section.end_line == 0 {\n            section.end_line = line_count + 1;\n        }\n    }\n\n    file_index.sections = sections;\n    Ok(file_index)\n}\n\n/// Save index to JSON file\npub fn save_index(index: \u0026DocsIndex, path: \u0026str) -\u003e Result\u003c()\u003e {\n    let json = serde_json::to_string_pretty(index).context(\"Failed to serialize index\")?;\n    fs::write(path, json).with_context(|| format!(\"Failed to write index to {}\", path))?;\n    Ok(())\n}\n\n/// Load index from JSON file\npub fn load_index(path: \u0026str) -\u003e Result\u003cDocsIndex\u003e {\n    let content =\n        fs::read_to_string(path).with_context(|| format!(\"Failed to read index from {}\", path))?;\n    serde_json::from_str(\u0026content).with_context(|| format!(\"Failed to parse index from {}\", path))\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":33}},{"line":47,"address":[],"length":0,"stats":{"Line":30}},{"line":51,"address":[],"length":0,"stats":{"Line":30}},{"line":66,"address":[],"length":0,"stats":{"Line":17}},{"line":69,"address":[],"length":0,"stats":{"Line":17}},{"line":74,"address":[],"length":0,"stats":{"Line":26}},{"line":75,"address":[],"length":0,"stats":{"Line":130}},{"line":79,"address":[],"length":0,"stats":{"Line":4}},{"line":80,"address":[],"length":0,"stats":{"Line":8}},{"line":84,"address":[],"length":0,"stats":{"Line":1}},{"line":85,"address":[],"length":0,"stats":{"Line":8}},{"line":90,"address":[],"length":0,"stats":{"Line":6}},{"line":91,"address":[],"length":0,"stats":{"Line":18}},{"line":92,"address":[],"length":0,"stats":{"Line":6}},{"line":93,"address":[],"length":0,"stats":{"Line":2}},{"line":96,"address":[],"length":0,"stats":{"Line":20}},{"line":97,"address":[],"length":0,"stats":{"Line":20}},{"line":99,"address":[],"length":0,"stats":{"Line":5}},{"line":103,"address":[],"length":0,"stats":{"Line":10}},{"line":104,"address":[],"length":0,"stats":{"Line":30}},{"line":105,"address":[],"length":0,"stats":{"Line":10}},{"line":107,"address":[],"length":0,"stats":{"Line":36}},{"line":108,"address":[],"length":0,"stats":{"Line":48}},{"line":109,"address":[],"length":0,"stats":{"Line":112}},{"line":112,"address":[],"length":0,"stats":{"Line":32}},{"line":113,"address":[],"length":0,"stats":{"Line":1}},{"line":116,"address":[],"length":0,"stats":{"Line":15}},{"line":117,"address":[],"length":0,"stats":{"Line":20}},{"line":118,"address":[],"length":0,"stats":{"Line":50}},{"line":119,"address":[],"length":0,"stats":{"Line":10}},{"line":120,"address":[],"length":0,"stats":{"Line":40}},{"line":121,"address":[],"length":0,"stats":{"Line":30}},{"line":126,"address":[],"length":0,"stats":{"Line":10}},{"line":130,"address":[],"length":0,"stats":{"Line":10}},{"line":131,"address":[],"length":0,"stats":{"Line":30}},{"line":132,"address":[],"length":0,"stats":{"Line":10}},{"line":134,"address":[],"length":0,"stats":{"Line":20}},{"line":135,"address":[],"length":0,"stats":{"Line":20}},{"line":136,"address":[],"length":0,"stats":{"Line":30}},{"line":137,"address":[],"length":0,"stats":{"Line":10}},{"line":139,"address":[],"length":0,"stats":{"Line":30}},{"line":140,"address":[],"length":0,"stats":{"Line":40}},{"line":143,"address":[],"length":0,"stats":{"Line":40}},{"line":144,"address":[],"length":0,"stats":{"Line":30}},{"line":146,"address":[],"length":0,"stats":{"Line":180}},{"line":147,"address":[],"length":0,"stats":{"Line":160}},{"line":149,"address":[],"length":0,"stats":{"Line":185}},{"line":150,"address":[],"length":0,"stats":{"Line":75}},{"line":151,"address":[],"length":0,"stats":{"Line":100}},{"line":156,"address":[],"length":0,"stats":{"Line":95}},{"line":157,"address":[],"length":0,"stats":{"Line":15}},{"line":160,"address":[],"length":0,"stats":{"Line":150}},{"line":165,"address":[],"length":0,"stats":{"Line":60}},{"line":166,"address":[],"length":0,"stats":{"Line":35}},{"line":167,"address":[],"length":0,"stats":{"Line":10}},{"line":171,"address":[],"length":0,"stats":{"Line":20}},{"line":172,"address":[],"length":0,"stats":{"Line":10}},{"line":176,"address":[],"length":0,"stats":{"Line":1}},{"line":177,"address":[],"length":0,"stats":{"Line":4}},{"line":178,"address":[],"length":0,"stats":{"Line":4}},{"line":179,"address":[],"length":0,"stats":{"Line":1}},{"line":183,"address":[],"length":0,"stats":{"Line":2}},{"line":184,"address":[],"length":0,"stats":{"Line":1}},{"line":185,"address":[],"length":0,"stats":{"Line":9}},{"line":186,"address":[],"length":0,"stats":{"Line":3}}],"covered":65,"coverable":65},{"path":["/","Users","chi","Projects","hu","src","utils","docs_index","tests.rs"],"content":"use super::*;\n\n#[test]\nfn section_new() {\n    let section = Section::new(\"Test\".to_string(), 2, 5);\n    assert_eq!(section.heading, \"Test\");\n    assert_eq!(section.level, 2);\n    assert_eq!(section.start_line, 5);\n    assert_eq!(section.end_line, 0);\n}\n\n#[test]\nfn section_clone() {\n    let section = Section::new(\"Test\".to_string(), 1, 1);\n    let cloned = section.clone();\n    assert_eq!(section, cloned);\n}\n\n#[test]\nfn section_debug() {\n    let section = Section::new(\"Test\".to_string(), 1, 1);\n    let debug = format!(\"{:?}\", section);\n    assert!(debug.contains(\"Section\"));\n}\n\n#[test]\nfn section_serialize() {\n    let section = Section::new(\"Test\".to_string(), 1, 1);\n    let json = serde_json::to_string(\u0026section).unwrap();\n    let parsed: Section = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(section, parsed);\n}\n\n#[test]\nfn file_index_new() {\n    let index = FileIndex::new(\"test.md\".to_string(), 100);\n    assert_eq!(index.path, \"test.md\");\n    assert_eq!(index.line_count, 100);\n    assert!(index.sections.is_empty());\n}\n\n#[test]\nfn file_index_clone() {\n    let index = FileIndex::new(\"test.md\".to_string(), 50);\n    let cloned = index.clone();\n    assert_eq!(index, cloned);\n}\n\n#[test]\nfn file_index_debug() {\n    let index = FileIndex::new(\"test.md\".to_string(), 50);\n    let debug = format!(\"{:?}\", index);\n    assert!(debug.contains(\"FileIndex\"));\n}\n\n#[test]\nfn file_index_serialize() {\n    let mut index = FileIndex::new(\"test.md\".to_string(), 50);\n    index\n        .sections\n        .push(Section::new(\"Heading\".to_string(), 1, 1));\n    let json = serde_json::to_string(\u0026index).unwrap();\n    let parsed: FileIndex = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(index, parsed);\n}\n\n#[test]\nfn docs_index_new() {\n    let index = DocsIndex::new(\"./docs\".to_string());\n    assert_eq!(index.root, \"./docs\");\n    assert!(index.files.is_empty());\n}\n\n#[test]\nfn docs_index_default() {\n    let index = DocsIndex::default();\n    assert_eq!(index.root, \"\");\n    assert!(index.files.is_empty());\n}\n\n#[test]\nfn docs_index_add_file() {\n    let mut index = DocsIndex::new(\"./\".to_string());\n    index.add_file(FileIndex::new(\"test.md\".to_string(), 50));\n    assert_eq!(index.file_count(), 1);\n}\n\n#[test]\nfn docs_index_counts() {\n    let mut index = DocsIndex::new(\"./\".to_string());\n    let mut file1 = FileIndex::new(\"a.md\".to_string(), 50);\n    file1.sections.push(Section::new(\"H1\".to_string(), 1, 1));\n    file1.sections.push(Section::new(\"H2\".to_string(), 2, 10));\n    let mut file2 = FileIndex::new(\"b.md\".to_string(), 30);\n    file2.sections.push(Section::new(\"Intro\".to_string(), 1, 1));\n\n    index.add_file(file1);\n    index.add_file(file2);\n\n    assert_eq!(index.file_count(), 2);\n    assert_eq!(index.section_count(), 3);\n}\n\n#[test]\nfn docs_index_clone() {\n    let index = DocsIndex::new(\"./\".to_string());\n    let cloned = index.clone();\n    assert_eq!(index, cloned);\n}\n\n#[test]\nfn docs_index_debug() {\n    let index = DocsIndex::new(\"./\".to_string());\n    let debug = format!(\"{:?}\", index);\n    assert!(debug.contains(\"DocsIndex\"));\n}\n\n#[test]\nfn docs_index_serialize() {\n    let mut index = DocsIndex::new(\"./docs\".to_string());\n    index.add_file(FileIndex::new(\"test.md\".to_string(), 50));\n    let json = serde_json::to_string(\u0026index).unwrap();\n    let parsed: DocsIndex = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(index, parsed);\n}\n\n// Test indexing with temp directory\nfn create_test_docs(suffix: \u0026str) -\u003e std::path::PathBuf {\n    use std::sync::atomic::{AtomicU64, Ordering};\n    static COUNTER: AtomicU64 = AtomicU64::new(0);\n    let id = COUNTER.fetch_add(1, Ordering::SeqCst);\n\n    let tmp_dir = std::env::temp_dir().join(format!(\n        \"hu_docs_test_{}_{}_{suffix}\",\n        std::process::id(),\n        id\n    ));\n    let _ = std::fs::remove_dir_all(\u0026tmp_dir);\n    std::fs::create_dir_all(\u0026tmp_dir).unwrap();\n\n    // Create test markdown files\n    std::fs::write(\n        tmp_dir.join(\"README.md\"),\n        \"# Project\\n\\nIntroduction.\\n\\n## Setup\\n\\nSetup steps.\\n\\n## Usage\\n\\nUsage info.\\n\",\n    )\n    .unwrap();\n\n    std::fs::create_dir_all(tmp_dir.join(\"docs\")).unwrap();\n    std::fs::write(\n        tmp_dir.join(\"docs/api.md\"),\n        \"# API Reference\\n\\n## Endpoints\\n\\nList of endpoints.\\n\",\n    )\n    .unwrap();\n\n    tmp_dir\n}\n\nfn cleanup_test_docs(path: \u0026std::path::Path) {\n    let _ = std::fs::remove_dir_all(path);\n}\n\n#[test]\nfn build_index_basic() {\n    let tmp_dir = create_test_docs(\"test\");\n    let index = build_index(tmp_dir.to_str().unwrap()).unwrap();\n\n    assert_eq!(index.file_count(), 2);\n    assert!(index.files.contains_key(\"README.md\"));\n    assert!(index.files.contains_key(\"docs/api.md\"));\n\n    cleanup_test_docs(\u0026tmp_dir);\n}\n\n#[test]\nfn build_index_sections() {\n    let tmp_dir = create_test_docs(\"test\");\n    let index = build_index(tmp_dir.to_str().unwrap()).unwrap();\n\n    let readme = index.files.get(\"README.md\").unwrap();\n    assert_eq!(readme.sections.len(), 3);\n    assert_eq!(readme.sections[0].heading, \"Project\");\n    assert_eq!(readme.sections[0].level, 1);\n    assert_eq!(readme.sections[1].heading, \"Setup\");\n    assert_eq!(readme.sections[1].level, 2);\n\n    cleanup_test_docs(\u0026tmp_dir);\n}\n\n#[test]\nfn build_index_section_ranges() {\n    let tmp_dir = create_test_docs(\"test\");\n    let index = build_index(tmp_dir.to_str().unwrap()).unwrap();\n\n    let readme = index.files.get(\"README.md\").unwrap();\n    // \"# Project\" starts at line 1, ends when \"## Setup\" starts at line 5\n    assert_eq!(readme.sections[0].start_line, 1);\n    assert_eq!(readme.sections[0].end_line, 5);\n    // \"## Setup\" ends when \"## Usage\" starts\n    assert_eq!(readme.sections[1].start_line, 5);\n    assert_eq!(readme.sections[1].end_line, 9);\n\n    cleanup_test_docs(\u0026tmp_dir);\n}\n\n#[test]\nfn build_index_not_directory() {\n    let result = build_index(\"/nonexistent/path\");\n    assert!(result.is_err());\n}\n\n#[test]\nfn save_and_load_index() {\n    let tmp_dir = create_test_docs(\"test\");\n    let index = build_index(tmp_dir.to_str().unwrap()).unwrap();\n\n    let index_path = tmp_dir.join(\"index.json\");\n    save_index(\u0026index, index_path.to_str().unwrap()).unwrap();\n    assert!(index_path.exists());\n\n    let loaded = load_index(index_path.to_str().unwrap()).unwrap();\n    assert_eq!(index, loaded);\n\n    cleanup_test_docs(\u0026tmp_dir);\n}\n\n#[test]\nfn load_index_not_found() {\n    let result = load_index(\"/nonexistent/index.json\");\n    assert!(result.is_err());\n}\n\n#[test]\nfn build_index_skips_hidden_dirs() {\n    let tmp_dir = create_test_docs(\"hidden\");\n\n    // Create a hidden directory with a markdown file\n    let hidden_dir = tmp_dir.join(\".hidden\");\n    std::fs::create_dir_all(\u0026hidden_dir).unwrap();\n    std::fs::write(\n        hidden_dir.join(\"secret.md\"),\n        \"# Secret\\n\\nHidden content.\\n\",\n    )\n    .unwrap();\n\n    let index = build_index(tmp_dir.to_str().unwrap()).unwrap();\n\n    // Should have 2 files (README.md and docs/api.md) but not .hidden/secret.md\n    assert_eq!(index.file_count(), 2);\n    assert!(!index.files.contains_key(\".hidden/secret.md\"));\n\n    cleanup_test_docs(\u0026tmp_dir);\n}\n","traces":[{"line":128,"address":[],"length":0,"stats":{"Line":5}},{"line":131,"address":[],"length":0,"stats":{"Line":20}},{"line":133,"address":[],"length":0,"stats":{"Line":25}},{"line":134,"address":[],"length":0,"stats":{"Line":5}},{"line":135,"address":[],"length":0,"stats":{"Line":5}},{"line":136,"address":[],"length":0,"stats":{"Line":5}},{"line":138,"address":[],"length":0,"stats":{"Line":5}},{"line":139,"address":[],"length":0,"stats":{"Line":15}},{"line":143,"address":[],"length":0,"stats":{"Line":5}},{"line":148,"address":[],"length":0,"stats":{"Line":15}},{"line":150,"address":[],"length":0,"stats":{"Line":5}},{"line":155,"address":[],"length":0,"stats":{"Line":5}},{"line":158,"address":[],"length":0,"stats":{"Line":5}},{"line":159,"address":[],"length":0,"stats":{"Line":5}}],"covered":14,"coverable":14},{"path":["/","Users","chi","Projects","hu","src","utils","docs_search.rs"],"content":"use super::docs_index::DocsIndex;\n\n/// Search result\n#[derive(Debug, Clone, PartialEq)]\npub struct SearchResult {\n    /// File path (relative)\n    pub file: String,\n    /// Section heading\n    pub heading: String,\n    /// Section level\n    pub level: u8,\n    /// Start line in file\n    pub start_line: usize,\n    /// End line in file\n    pub end_line: usize,\n    /// Match score (higher is better)\n    pub score: u32,\n}\n\n/// Search the index for matching sections\npub fn search_index(index: \u0026DocsIndex, query: \u0026str) -\u003e Vec\u003cSearchResult\u003e {\n    let query_lower = query.to_lowercase();\n    let query_words: Vec\u003c\u0026str\u003e = query_lower.split_whitespace().collect();\n    let mut results = Vec::new();\n\n    for (path, file_index) in \u0026index.files {\n        for section in \u0026file_index.sections {\n            if let Some(score) = match_score(\u0026section.heading, \u0026query_lower, \u0026query_words) {\n                results.push(SearchResult {\n                    file: path.clone(),\n                    heading: section.heading.clone(),\n                    level: section.level,\n                    start_line: section.start_line,\n                    end_line: section.end_line,\n                    score,\n                });\n            }\n        }\n    }\n\n    // Sort by score (descending)\n    results.sort_by(|a, b| b.score.cmp(\u0026a.score));\n\n    results\n}\n\n/// Calculate match score for a heading against a query\nfn match_score(heading: \u0026str, query_lower: \u0026str, query_words: \u0026[\u0026str]) -\u003e Option\u003cu32\u003e {\n    let heading_lower = heading.to_lowercase();\n\n    // Exact match (highest priority)\n    if heading_lower == query_lower {\n        return Some(1000);\n    }\n\n    // Contains full query\n    if heading_lower.contains(query_lower) {\n        return Some(500);\n    }\n\n    // Word matching\n    let heading_words: Vec\u003c\u0026str\u003e = heading_lower.split_whitespace().collect();\n    let mut matched_words = 0;\n\n    for qw in query_words {\n        for hw in \u0026heading_words {\n            if hw.contains(qw) || qw.contains(hw) {\n                matched_words += 1;\n                break;\n            }\n        }\n    }\n\n    if matched_words \u003e 0 {\n        // Score based on percentage of query words matched\n        let score = (matched_words * 100) / query_words.len().max(1);\n        return Some(score as u32);\n    }\n\n    None\n}\n\n/// Format search results for display\npub fn format_results(results: \u0026[SearchResult], limit: Option\u003cusize\u003e) -\u003e String {\n    if results.is_empty() {\n        return \"No matching sections found\".to_string();\n    }\n\n    let results = if let Some(n) = limit {\n        \u0026results[..n.min(results.len())]\n    } else {\n        results\n    };\n\n    let mut output = Vec::new();\n\n    for result in results {\n        let level_marker = \"#\".repeat(result.level as usize);\n        output.push(format!(\n            \"{} {} ({}:L{}-{})\",\n            level_marker, result.heading, result.file, result.start_line, result.end_line\n        ));\n    }\n\n    output.join(\"\\n\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::utils::docs_index::{FileIndex, Section};\n\n    fn test_index() -\u003e DocsIndex {\n        let mut index = DocsIndex::new(\"./\".to_string());\n\n        let mut readme = FileIndex::new(\"README.md\".to_string(), 50);\n        readme.sections.push(Section {\n            heading: \"Getting Started\".to_string(),\n            level: 1,\n            start_line: 1,\n            end_line: 20,\n        });\n        readme.sections.push(Section {\n            heading: \"Installation\".to_string(),\n            level: 2,\n            start_line: 5,\n            end_line: 15,\n        });\n        readme.sections.push(Section {\n            heading: \"Configuration\".to_string(),\n            level: 2,\n            start_line: 15,\n            end_line: 20,\n        });\n\n        let mut api = FileIndex::new(\"api.md\".to_string(), 100);\n        api.sections.push(Section {\n            heading: \"API Reference\".to_string(),\n            level: 1,\n            start_line: 1,\n            end_line: 100,\n        });\n        api.sections.push(Section {\n            heading: \"Getting Started with API\".to_string(),\n            level: 2,\n            start_line: 10,\n            end_line: 50,\n        });\n\n        index.add_file(readme);\n        index.add_file(api);\n\n        index\n    }\n\n    #[test]\n    fn search_exact_match() {\n        let index = test_index();\n        let results = search_index(\u0026index, \"Installation\");\n        assert!(!results.is_empty());\n        assert_eq!(results[0].heading, \"Installation\");\n        assert_eq!(results[0].score, 1000);\n    }\n\n    #[test]\n    fn search_case_insensitive() {\n        let index = test_index();\n        let results = search_index(\u0026index, \"installation\");\n        assert!(!results.is_empty());\n        assert_eq!(results[0].heading, \"Installation\");\n    }\n\n    #[test]\n    fn search_contains() {\n        let index = test_index();\n        let results = search_index(\u0026index, \"Config\");\n        assert!(!results.is_empty());\n        assert!(results.iter().any(|r| r.heading == \"Configuration\"));\n    }\n\n    #[test]\n    fn search_word_match() {\n        let index = test_index();\n        let results = search_index(\u0026index, \"Getting\");\n        assert_eq!(results.len(), 2); // \"Getting Started\" and \"Getting Started with API\"\n    }\n\n    #[test]\n    fn search_no_match() {\n        let index = test_index();\n        let results = search_index(\u0026index, \"nonexistent\");\n        assert!(results.is_empty());\n    }\n\n    #[test]\n    fn search_sorted_by_score() {\n        let index = test_index();\n        let results = search_index(\u0026index, \"Installation\");\n        // Exact match should be first\n        assert!(results[0].score \u003e= results.last().map(|r| r.score).unwrap_or(0));\n    }\n\n    #[test]\n    fn search_result_clone() {\n        let result = SearchResult {\n            file: \"test.md\".to_string(),\n            heading: \"Test\".to_string(),\n            level: 1,\n            start_line: 1,\n            end_line: 10,\n            score: 100,\n        };\n        let cloned = result.clone();\n        assert_eq!(result, cloned);\n    }\n\n    #[test]\n    fn search_result_debug() {\n        let result = SearchResult {\n            file: \"test.md\".to_string(),\n            heading: \"Test\".to_string(),\n            level: 1,\n            start_line: 1,\n            end_line: 10,\n            score: 100,\n        };\n        let debug = format!(\"{:?}\", result);\n        assert!(debug.contains(\"SearchResult\"));\n    }\n\n    #[test]\n    fn match_score_exact() {\n        let score = match_score(\"Installation\", \"installation\", \u0026[\"installation\"]);\n        assert_eq!(score, Some(1000));\n    }\n\n    #[test]\n    fn match_score_contains() {\n        let score = match_score(\"Configuration Options\", \"config\", \u0026[\"config\"]);\n        assert_eq!(score, Some(500));\n    }\n\n    #[test]\n    fn match_score_word_partial() {\n        // Test that partial word matches work when heading word contains query word\n        // or query word contains heading word\n        // \"started\" contains \"start\" - heading word contains query word\n        let score = match_score(\"Started Guide\", \"start\", \u0026[\"start\"]);\n        // But \"started guide\" also contains \"start\" as substring, so it gets 500\n        assert_eq!(score, Some(500));\n\n        // Test case where query word contains heading word (qw.contains(hw))\n        // \"testing\" contains \"test\"\n        let score2 = match_score(\"Test Results\", \"testing\", \u0026[\"testing\"]);\n        // \"test results\" does NOT contain \"testing\", so it falls through to word matching\n        // Word matching: \"testing\".contains(\"test\")? Yes\n        assert!(score2.is_some());\n        assert!(score2.unwrap() \u003c 500);\n\n        // Another case: heading contains partial word but not as substring\n        let score3 = match_score(\"API Docs\", \"apis\", \u0026[\"apis\"]);\n        // \"api docs\" does NOT contain \"apis\", but \"apis\".contains(\"api\")? Yes\n        assert!(score3.is_some());\n        assert!(score3.unwrap() \u003c 500);\n    }\n\n    #[test]\n    fn match_score_no_match() {\n        let score = match_score(\"Installation\", \"api\", \u0026[\"api\"]);\n        assert!(score.is_none());\n    }\n\n    #[test]\n    fn format_results_empty() {\n        let results: Vec\u003cSearchResult\u003e = vec![];\n        let output = format_results(\u0026results, None);\n        assert_eq!(output, \"No matching sections found\");\n    }\n\n    #[test]\n    fn format_results_single() {\n        let results = vec![SearchResult {\n            file: \"test.md\".to_string(),\n            heading: \"Test Section\".to_string(),\n            level: 2,\n            start_line: 5,\n            end_line: 15,\n            score: 100,\n        }];\n        let output = format_results(\u0026results, None);\n        assert!(output.contains(\"## Test Section\"));\n        assert!(output.contains(\"test.md:L5-15\"));\n    }\n\n    #[test]\n    fn format_results_multiple() {\n        let results = vec![\n            SearchResult {\n                file: \"a.md\".to_string(),\n                heading: \"First\".to_string(),\n                level: 1,\n                start_line: 1,\n                end_line: 10,\n                score: 100,\n            },\n            SearchResult {\n                file: \"b.md\".to_string(),\n                heading: \"Second\".to_string(),\n                level: 2,\n                start_line: 5,\n                end_line: 20,\n                score: 50,\n            },\n        ];\n        let output = format_results(\u0026results, None);\n        let lines: Vec\u003c\u0026str\u003e = output.lines().collect();\n        assert_eq!(lines.len(), 2);\n    }\n\n    #[test]\n    fn format_results_with_limit() {\n        let results = vec![\n            SearchResult {\n                file: \"a.md\".to_string(),\n                heading: \"First\".to_string(),\n                level: 1,\n                start_line: 1,\n                end_line: 10,\n                score: 100,\n            },\n            SearchResult {\n                file: \"b.md\".to_string(),\n                heading: \"Second\".to_string(),\n                level: 2,\n                start_line: 5,\n                end_line: 20,\n                score: 50,\n            },\n        ];\n        let output = format_results(\u0026results, Some(1));\n        let lines: Vec\u003c\u0026str\u003e = output.lines().collect();\n        assert_eq!(lines.len(), 1);\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":6}},{"line":22,"address":[],"length":0,"stats":{"Line":18}},{"line":23,"address":[],"length":0,"stats":{"Line":24}},{"line":24,"address":[],"length":0,"stats":{"Line":12}},{"line":26,"address":[],"length":0,"stats":{"Line":42}},{"line":27,"address":[],"length":0,"stats":{"Line":72}},{"line":28,"address":[],"length":0,"stats":{"Line":102}},{"line":29,"address":[],"length":0,"stats":{"Line":18}},{"line":30,"address":[],"length":0,"stats":{"Line":18}},{"line":31,"address":[],"length":0,"stats":{"Line":18}},{"line":32,"address":[],"length":0,"stats":{"Line":12}},{"line":33,"address":[],"length":0,"stats":{"Line":12}},{"line":34,"address":[],"length":0,"stats":{"Line":6}},{"line":35,"address":[],"length":0,"stats":{"Line":6}},{"line":42,"address":[],"length":0,"stats":{"Line":15}},{"line":44,"address":[],"length":0,"stats":{"Line":6}},{"line":48,"address":[],"length":0,"stats":{"Line":36}},{"line":49,"address":[],"length":0,"stats":{"Line":108}},{"line":52,"address":[],"length":0,"stats":{"Line":36}},{"line":53,"address":[],"length":0,"stats":{"Line":4}},{"line":57,"address":[],"length":0,"stats":{"Line":64}},{"line":58,"address":[],"length":0,"stats":{"Line":5}},{"line":62,"address":[],"length":0,"stats":{"Line":108}},{"line":63,"address":[],"length":0,"stats":{"Line":54}},{"line":65,"address":[],"length":0,"stats":{"Line":81}},{"line":66,"address":[],"length":0,"stats":{"Line":131}},{"line":67,"address":[],"length":0,"stats":{"Line":318}},{"line":68,"address":[],"length":0,"stats":{"Line":2}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":74,"address":[],"length":0,"stats":{"Line":27}},{"line":76,"address":[],"length":0,"stats":{"Line":8}},{"line":77,"address":[],"length":0,"stats":{"Line":2}},{"line":80,"address":[],"length":0,"stats":{"Line":25}},{"line":84,"address":[],"length":0,"stats":{"Line":4}},{"line":85,"address":[],"length":0,"stats":{"Line":8}},{"line":86,"address":[],"length":0,"stats":{"Line":2}},{"line":89,"address":[],"length":0,"stats":{"Line":7}},{"line":90,"address":[],"length":0,"stats":{"Line":4}},{"line":92,"address":[],"length":0,"stats":{"Line":2}},{"line":95,"address":[],"length":0,"stats":{"Line":6}},{"line":97,"address":[],"length":0,"stats":{"Line":15}},{"line":98,"address":[],"length":0,"stats":{"Line":20}},{"line":99,"address":[],"length":0,"stats":{"Line":12}},{"line":100,"address":[],"length":0,"stats":{"Line":4}},{"line":101,"address":[],"length":0,"stats":{"Line":4}},{"line":105,"address":[],"length":0,"stats":{"Line":6}}],"covered":46,"coverable":46},{"path":["/","Users","chi","Projects","hu","src","utils","docs_section.rs"],"content":"use anyhow::{Context, Result};\nuse regex::Regex;\nuse std::fs;\n\n/// Extract a section from markdown content by heading\npub fn extract_section(content: \u0026str, heading: \u0026str) -\u003e Option\u003cString\u003e {\n    let heading_lower = heading.to_lowercase();\n    let heading_re = Regex::new(r\"^(#{1,6})\\s+(.+)$\").unwrap();\n\n    let lines: Vec\u003c\u0026str\u003e = content.lines().collect();\n    let mut section_start: Option\u003c(usize, u8)\u003e = None;\n    let mut section_end: Option\u003cusize\u003e = None;\n\n    for (i, line) in lines.iter().enumerate() {\n        if let Some(caps) = heading_re.captures(line) {\n            let level = caps.get(1).unwrap().as_str().len() as u8;\n            let text = caps.get(2).unwrap().as_str();\n\n            if let Some((_, start_level)) = section_start {\n                // We're in a section - check if this heading ends it\n                if level \u003c= start_level {\n                    section_end = Some(i);\n                    break;\n                }\n            } else if text.to_lowercase() == heading_lower\n                || text.to_lowercase().contains(\u0026heading_lower)\n            {\n                // Found the section\n                section_start = Some((i, level));\n            }\n        }\n    }\n\n    // If we found the start but not the end, section goes to end of file\n    if let Some((start, _)) = section_start {\n        let end = section_end.unwrap_or(lines.len());\n        let section_lines: Vec\u003c\u0026str\u003e = lines[start..end].to_vec();\n        return Some(section_lines.join(\"\\n\"));\n    }\n\n    None\n}\n\n/// Extract a section from a file by heading\npub fn extract_section_from_file(path: \u0026str, heading: \u0026str) -\u003e Result\u003cString\u003e {\n    let content =\n        fs::read_to_string(path).with_context(|| format!(\"Failed to read file: {}\", path))?;\n\n    extract_section(\u0026content, heading)\n        .ok_or_else(|| anyhow::anyhow!(\"Section not found: {}\", heading))\n}\n\n/// Extract a section by line range\n#[cfg(test)]\npub fn extract_lines(content: \u0026str, start: usize, end: usize) -\u003e String {\n    let lines: Vec\u003c\u0026str\u003e = content.lines().collect();\n    // Convert 1-indexed line numbers to 0-indexed array indices\n    // start is inclusive, end is exclusive\n    let start_idx = start.saturating_sub(1).min(lines.len());\n    let end_idx = end.saturating_sub(1).min(lines.len());\n\n    if start_idx \u003e= end_idx {\n        return String::new();\n    }\n\n    lines[start_idx..end_idx].join(\"\\n\")\n}\n\n/// Extract a section from a file by line range\n#[cfg(test)]\npub fn extract_lines_from_file(path: \u0026str, start: usize, end: usize) -\u003e Result\u003cString\u003e {\n    let content =\n        fs::read_to_string(path).with_context(|| format!(\"Failed to read file: {}\", path))?;\n    Ok(extract_lines(\u0026content, start, end))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    const TEST_CONTENT: \u0026str = r#\"# Main Title\n\nIntroduction paragraph.\n\n## First Section\n\nFirst section content.\nMore content here.\n\n### Nested Section\n\nNested content.\n\n## Second Section\n\nSecond section content.\n\n### Another Nested\n\nMore nested.\n\n## Third Section\n\nFinal content.\n\"#;\n\n    #[test]\n    fn extract_section_h1() {\n        let section = extract_section(TEST_CONTENT, \"Main Title\").unwrap();\n        assert!(section.starts_with(\"# Main Title\"));\n        // H1 section should include everything until another H1 (none here)\n        // or end of file\n    }\n\n    #[test]\n    fn extract_section_h2() {\n        let section = extract_section(TEST_CONTENT, \"First Section\").unwrap();\n        assert!(section.starts_with(\"## First Section\"));\n        assert!(section.contains(\"First section content\"));\n        assert!(section.contains(\"### Nested Section\"));\n        // Should NOT include \"## Second Section\"\n        assert!(!section.contains(\"## Second Section\"));\n    }\n\n    #[test]\n    fn extract_section_h3() {\n        let section = extract_section(TEST_CONTENT, \"Nested Section\").unwrap();\n        assert!(section.starts_with(\"### Nested Section\"));\n        assert!(section.contains(\"Nested content\"));\n        // Should end at \"## Second Section\"\n        assert!(!section.contains(\"## Second Section\"));\n    }\n\n    #[test]\n    fn extract_section_last() {\n        let section = extract_section(TEST_CONTENT, \"Third Section\").unwrap();\n        assert!(section.starts_with(\"## Third Section\"));\n        assert!(section.contains(\"Final content\"));\n    }\n\n    #[test]\n    fn extract_section_case_insensitive() {\n        let section = extract_section(TEST_CONTENT, \"first section\").unwrap();\n        assert!(section.starts_with(\"## First Section\"));\n    }\n\n    #[test]\n    fn extract_section_partial_match() {\n        let section = extract_section(TEST_CONTENT, \"Nested\").unwrap();\n        // Should match first \"Nested Section\"\n        assert!(section.starts_with(\"### Nested Section\"));\n    }\n\n    #[test]\n    fn extract_section_not_found() {\n        let section = extract_section(TEST_CONTENT, \"Nonexistent\");\n        assert!(section.is_none());\n    }\n\n    #[test]\n    fn extract_section_empty_content() {\n        let section = extract_section(\"\", \"Any\");\n        assert!(section.is_none());\n    }\n\n    #[test]\n    fn extract_section_no_headings() {\n        let content = \"Just some text\\nNo headings here\\n\";\n        let section = extract_section(content, \"Test\");\n        assert!(section.is_none());\n    }\n\n    #[test]\n    fn extract_lines_basic() {\n        let content = \"line1\\nline2\\nline3\\nline4\\nline5\";\n        let section = extract_lines(content, 2, 4);\n        assert_eq!(section, \"line2\\nline3\");\n    }\n\n    #[test]\n    fn extract_lines_from_start() {\n        let content = \"line1\\nline2\\nline3\";\n        let section = extract_lines(content, 1, 2);\n        assert_eq!(section, \"line1\");\n    }\n\n    #[test]\n    fn extract_lines_to_end() {\n        let content = \"line1\\nline2\\nline3\";\n        let section = extract_lines(content, 2, 100);\n        assert_eq!(section, \"line2\\nline3\");\n    }\n\n    #[test]\n    fn extract_lines_out_of_bounds() {\n        let content = \"line1\\nline2\";\n        let section = extract_lines(content, 10, 20);\n        assert_eq!(section, \"\");\n    }\n\n    #[test]\n    fn extract_lines_invalid_range() {\n        let content = \"line1\\nline2\\nline3\";\n        let section = extract_lines(content, 5, 2);\n        assert_eq!(section, \"\");\n    }\n\n    #[test]\n    fn extract_lines_empty_content() {\n        let section = extract_lines(\"\", 1, 10);\n        assert_eq!(section, \"\");\n    }\n\n    // File-based tests\n    #[test]\n    fn extract_section_from_file_cargo_toml() {\n        // Cargo.toml doesn't have markdown headings, so this should fail\n        let result = extract_section_from_file(\n            concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/Cargo.toml\"),\n            \"dependencies\",\n        );\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn extract_section_from_file_not_found() {\n        let result = extract_section_from_file(\"/nonexistent/file.md\", \"Test\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn extract_lines_from_file_cargo_toml() {\n        let result =\n            extract_lines_from_file(concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/Cargo.toml\"), 1, 5);\n        assert!(result.is_ok());\n        let content = result.unwrap();\n        assert!(!content.is_empty());\n    }\n\n    #[test]\n    fn extract_lines_from_file_not_found() {\n        let result = extract_lines_from_file(\"/nonexistent/file.md\", 1, 10);\n        assert!(result.is_err());\n    }\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":10}},{"line":7,"address":[],"length":0,"stats":{"Line":30}},{"line":8,"address":[],"length":0,"stats":{"Line":40}},{"line":10,"address":[],"length":0,"stats":{"Line":50}},{"line":11,"address":[],"length":0,"stats":{"Line":30}},{"line":12,"address":[],"length":0,"stats":{"Line":30}},{"line":14,"address":[],"length":0,"stats":{"Line":384}},{"line":15,"address":[],"length":0,"stats":{"Line":398}},{"line":16,"address":[],"length":0,"stats":{"Line":102}},{"line":17,"address":[],"length":0,"stats":{"Line":136}},{"line":19,"address":[],"length":0,"stats":{"Line":45}},{"line":21,"address":[],"length":0,"stats":{"Line":11}},{"line":22,"address":[],"length":0,"stats":{"Line":4}},{"line":23,"address":[],"length":0,"stats":{"Line":4}},{"line":25,"address":[],"length":0,"stats":{"Line":23}},{"line":26,"address":[],"length":0,"stats":{"Line":36}},{"line":29,"address":[],"length":0,"stats":{"Line":6}},{"line":35,"address":[],"length":0,"stats":{"Line":16}},{"line":36,"address":[],"length":0,"stats":{"Line":30}},{"line":37,"address":[],"length":0,"stats":{"Line":30}},{"line":38,"address":[],"length":0,"stats":{"Line":12}},{"line":41,"address":[],"length":0,"stats":{"Line":4}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":1}},{"line":47,"address":[],"length":0,"stats":{"Line":9}},{"line":49,"address":[],"length":0,"stats":{"Line":3}},{"line":50,"address":[],"length":0,"stats":{"Line":3}},{"line":55,"address":[],"length":0,"stats":{"Line":7}},{"line":56,"address":[],"length":0,"stats":{"Line":35}},{"line":59,"address":[],"length":0,"stats":{"Line":42}},{"line":60,"address":[],"length":0,"stats":{"Line":42}},{"line":62,"address":[],"length":0,"stats":{"Line":7}},{"line":63,"address":[],"length":0,"stats":{"Line":3}},{"line":66,"address":[],"length":0,"stats":{"Line":16}},{"line":71,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":9}},{"line":74,"address":[],"length":0,"stats":{"Line":3}}],"covered":38,"coverable":38},{"path":["/","Users","chi","Projects","hu","src","utils","fetch_html","mod.rs"],"content":"use anyhow::{Context, Result};\nuse regex::Regex;\nuse std::fs;\n\nuse super::cli::FetchHtmlArgs;\n\n#[cfg(test)]\nmod tests;\n\n/// Handle the `hu utils fetch-html` command\npub async fn run(args: FetchHtmlArgs) -\u003e Result\u003c()\u003e {\n    let html = fetch_url(\u0026args.url).await?;\n\n    let output = if args.raw {\n        html_to_markdown(\u0026html)\n    } else if args.links {\n        extract_links(\u0026html)\n    } else if args.headings {\n        extract_headings(\u0026html)\n    } else if args.summary {\n        extract_summary(\u0026html)\n    } else if args.content || args.selector.is_some() {\n        let selector = args.selector.as_deref();\n        extract_content(\u0026html, selector)\n    } else {\n        // Default: content extraction\n        extract_content(\u0026html, None)\n    };\n\n    if let Some(path) = args.output {\n        fs::write(\u0026path, \u0026output).with_context(|| format!(\"Failed to write to {}\", path))?;\n        eprintln!(\"Written to {}\", path);\n    } else {\n        println!(\"{}\", output);\n    }\n\n    Ok(())\n}\n\n/// Fetch URL content\nasync fn fetch_url(url: \u0026str) -\u003e Result\u003cString\u003e {\n    let client = reqwest::Client::builder()\n        .user_agent(\"hu-cli/0.1\")\n        .build()?;\n\n    let response = client\n        .get(url)\n        .send()\n        .await\n        .with_context(|| format!(\"Failed to fetch {}\", url))?;\n\n    response\n        .text()\n        .await\n        .with_context(|| format!(\"Failed to read response from {}\", url))\n}\n\n/// Convert HTML to markdown (basic conversion)\npub fn html_to_markdown(html: \u0026str) -\u003e String {\n    let mut result = html.to_string();\n\n    // Remove script and style tags with content\n    result = remove_tag_with_content(\u0026result, \"script\");\n    result = remove_tag_with_content(\u0026result, \"style\");\n    result = remove_tag_with_content(\u0026result, \"noscript\");\n\n    // Convert headings\n    for level in 1..=6 {\n        let prefix = \"#\".repeat(level);\n        let open_re = Regex::new(\u0026format!(r\"(?i)\u003ch{}\\b[^\u003e]*\u003e\", level)).unwrap();\n        let close_re = Regex::new(\u0026format!(r\"(?i)\u003c/h{}\u003e\", level)).unwrap();\n        result = open_re\n            .replace_all(\u0026result, format!(\"\\n{} \", prefix))\n            .to_string();\n        result = close_re.replace_all(\u0026result, \"\\n\").to_string();\n    }\n\n    // Convert links\n    let link_re = Regex::new(r#\"(?i)\u003ca\\s+[^\u003e]*href=[\"']([^\"']+)[\"'][^\u003e]*\u003e([^\u003c]*)\u003c/a\u003e\"#).unwrap();\n    result = link_re.replace_all(\u0026result, \"[$2]($1)\").to_string();\n\n    // Convert emphasis (strong/b -\u003e **, em/i -\u003e *)\n    for tag in [\"strong\", \"b\"] {\n        let re = Regex::new(\u0026format!(r\"(?i)\u003c{}\\b[^\u003e]*\u003e([^\u003c]*)\u003c/{}\u003e\", tag, tag)).unwrap();\n        result = re.replace_all(\u0026result, \"**$1**\").to_string();\n    }\n    for tag in [\"em\", \"i\"] {\n        let re = Regex::new(\u0026format!(r\"(?i)\u003c{}\\b[^\u003e]*\u003e([^\u003c]*)\u003c/{}\u003e\", tag, tag)).unwrap();\n        result = re.replace_all(\u0026result, \"*$1*\").to_string();\n    }\n\n    // Convert code\n    result = Regex::new(r\"(?i)\u003ccode\\b[^\u003e]*\u003e([^\u003c]*)\u003c/code\u003e\")\n        .unwrap()\n        .replace_all(\u0026result, \"`$1`\")\n        .to_string();\n\n    // Convert pre/code blocks\n    let pre_re = Regex::new(r\"(?is)\u003cpre\\b[^\u003e]*\u003e\u003ccode\\b[^\u003e]*\u003e(.+?)\u003c/code\u003e\u003c/pre\u003e\").unwrap();\n    result = pre_re.replace_all(\u0026result, \"\\n```\\n$1\\n```\\n\").to_string();\n\n    // Convert lists\n    result = Regex::new(r\"(?i)\u003cli\\b[^\u003e]*\u003e\")\n        .unwrap()\n        .replace_all(\u0026result, \"\\n- \")\n        .to_string();\n    result = Regex::new(r\"(?i)\u003c/li\u003e\")\n        .unwrap()\n        .replace_all(\u0026result, \"\")\n        .to_string();\n\n    // Convert paragraphs and line breaks\n    result = Regex::new(r\"(?i)\u003cp\\b[^\u003e]*\u003e\")\n        .unwrap()\n        .replace_all(\u0026result, \"\\n\\n\")\n        .to_string();\n    result = Regex::new(r\"(?i)\u003c/p\u003e\")\n        .unwrap()\n        .replace_all(\u0026result, \"\\n\")\n        .to_string();\n    result = Regex::new(r\"(?i)\u003cbr\\s*/?\u003e\")\n        .unwrap()\n        .replace_all(\u0026result, \"\\n\")\n        .to_string();\n\n    // Remove remaining HTML tags\n    result = Regex::new(r\"\u003c[^\u003e]+\u003e\")\n        .unwrap()\n        .replace_all(\u0026result, \"\")\n        .to_string();\n\n    // Decode common HTML entities\n    result = result\n        .replace(\"\u0026amp;\", \"\u0026\")\n        .replace(\"\u0026lt;\", \"\u003c\")\n        .replace(\"\u0026gt;\", \"\u003e\")\n        .replace(\"\u0026quot;\", \"\\\"\")\n        .replace(\"\u0026#39;\", \"'\")\n        .replace(\"\u0026nbsp;\", \" \");\n\n    // Clean up whitespace\n    result = Regex::new(r\"\\n{3,}\")\n        .unwrap()\n        .replace_all(\u0026result, \"\\n\\n\")\n        .to_string();\n    result = Regex::new(r\"[ \\t]+\")\n        .unwrap()\n        .replace_all(\u0026result, \" \")\n        .to_string();\n\n    result.trim().to_string()\n}\n\n/// Remove HTML tag and its content\nfn remove_tag_with_content(html: \u0026str, tag: \u0026str) -\u003e String {\n    let re = Regex::new(\u0026format!(r\"(?is)\u003c{}\\b[^\u003e]*\u003e.*?\u003c/{}\u003e\", tag, tag)).unwrap();\n    re.replace_all(html, \"\").to_string()\n}\n\n/// Extract main content only (strip nav, footer, scripts, ads)\npub fn extract_content(html: \u0026str, selector: Option\u003c\u0026str\u003e) -\u003e String {\n    let mut result = html.to_string();\n\n    // If selector provided, try to extract just that\n    if let Some(sel) = selector {\n        if let Some(content) = extract_by_selector(\u0026result, sel) {\n            return html_to_markdown(\u0026content);\n        }\n    }\n\n    // Remove noise elements\n    for tag in \u0026[\n        \"script\", \"style\", \"noscript\", \"nav\", \"footer\", \"header\", \"aside\", \"iframe\", \"svg\",\n    ] {\n        result = remove_tag_with_content(\u0026result, tag);\n    }\n\n    // Remove common ad/noise classes\n    let noise_patterns = [\n        r#\"\u003c[^\u003e]+class=\"[^\"]*(?:ad|advertisement|sidebar|menu|nav|footer|header|cookie|popup|modal|banner)[^\"]*\"[^\u003e]*\u003e.*?\u003c/[^\u003e]+\u003e\"#,\n        r#\"\u003c[^\u003e]+id=\"[^\"]*(?:ad|advertisement|sidebar|menu|nav|footer|header|cookie|popup|modal|banner)[^\"]*\"[^\u003e]*\u003e.*?\u003c/[^\u003e]+\u003e\"#,\n    ];\n\n    for pattern in \u0026noise_patterns {\n        if let Ok(re) = Regex::new(\u0026format!(\"(?is){}\", pattern)) {\n            result = re.replace_all(\u0026result, \"\").to_string();\n        }\n    }\n\n    // Try to find main content area\n    if let Some(main) = extract_by_selector(\u0026result, \"main\") {\n        return html_to_markdown(\u0026main);\n    }\n    if let Some(article) = extract_by_selector(\u0026result, \"article\") {\n        return html_to_markdown(\u0026article);\n    }\n    if let Some(content) = extract_by_selector(\u0026result, \".content\") {\n        return html_to_markdown(\u0026content);\n    }\n\n    html_to_markdown(\u0026result)\n}\n\n/// Try to extract content by CSS-like selector (simplified)\nfn extract_by_selector(html: \u0026str, selector: \u0026str) -\u003e Option\u003cString\u003e {\n    let pattern = if let Some(class) = selector.strip_prefix('.') {\n        // Class selector\n        format!(\n            r#\"(?is)\u003c[^\u003e]+class=\"[^\"]*\\b{}\\b[^\"]*\"[^\u003e]*\u003e(.*?)\u003c/[^\u003e]+\u003e\"#,\n            regex::escape(class)\n        )\n    } else if let Some(id) = selector.strip_prefix('#') {\n        // ID selector\n        format!(\n            r#\"(?is)\u003c[^\u003e]+id=\"{}\"[^\u003e]*\u003e(.*?)\u003c/[^\u003e]+\u003e\"#,\n            regex::escape(id)\n        )\n    } else {\n        // Tag selector\n        format!(\n            r\"(?is)\u003c{}\\b[^\u003e]*\u003e(.*?)\u003c/{}\u003e\",\n            regex::escape(selector),\n            regex::escape(selector)\n        )\n    };\n\n    Regex::new(\u0026pattern)\n        .ok()\n        .and_then(|re| re.captures(html))\n        .map(|caps| caps.get(1).map_or(\"\", |m| m.as_str()).to_string())\n}\n\n/// Extract links only\npub fn extract_links(html: \u0026str) -\u003e String {\n    let link_re = Regex::new(r#\"(?i)\u003ca\\s+[^\u003e]*href=[\"']([^\"']+)[\"'][^\u003e]*\u003e([^\u003c]*)\u003c/a\u003e\"#).unwrap();\n\n    let mut links = Vec::new();\n    for cap in link_re.captures_iter(html) {\n        let url = cap.get(1).map_or(\"\", |m| m.as_str());\n        let text = cap.get(2).map_or(\"\", |m| m.as_str()).trim();\n\n        // Skip empty links, anchors, javascript\n        if url.is_empty()\n            || url.starts_with('#')\n            || url.starts_with(\"javascript:\")\n            || text.is_empty()\n        {\n            continue;\n        }\n\n        links.push(format!(\"- [{}]({})\", text, url));\n    }\n\n    links.join(\"\\n\")\n}\n\n/// Extract headings only (document outline)\npub fn extract_headings(html: \u0026str) -\u003e String {\n    let mut headings = Vec::new();\n    let strip_tags_re = Regex::new(r\"\u003c[^\u003e]+\u003e\").unwrap();\n\n    for level in 1..=6 {\n        let re = Regex::new(\u0026format!(r\"(?is)\u003ch{}\\b[^\u003e]*\u003e(.*?)\u003c/h{}\u003e\", level, level)).unwrap();\n\n        for cap in re.captures_iter(html) {\n            let text = cap.get(1).map_or(\"\", |m| m.as_str());\n            // Strip any nested tags\n            let clean = strip_tags_re.replace_all(text, \"\").trim().to_string();\n\n            if !clean.is_empty() {\n                let indent = \"  \".repeat(level - 1);\n                headings.push(format!(\"{}{} {}\", indent, \"#\".repeat(level), clean));\n            }\n        }\n    }\n\n    headings.join(\"\\n\")\n}\n\n/// Extract summary (first N paragraphs + all headings)\npub fn extract_summary(html: \u0026str) -\u003e String {\n    let content = extract_content(html, None);\n    let lines: Vec\u003c\u0026str\u003e = content.lines().collect();\n\n    let mut result = Vec::new();\n    let mut para_count = 0;\n    let max_paras = 3;\n\n    for line in lines {\n        let trimmed = line.trim();\n        if trimmed.is_empty() {\n            continue;\n        }\n\n        // Always include headings\n        if trimmed.starts_with('#') {\n            result.push(line.to_string());\n            continue;\n        }\n\n        // Include first N paragraphs\n        if para_count \u003c max_paras {\n            result.push(line.to_string());\n            if !trimmed.starts_with('-') \u0026\u0026 !trimmed.starts_with('*') {\n                para_count += 1;\n            }\n        }\n    }\n\n    result.join(\"\\n\\n\")\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":27}},{"line":60,"address":[],"length":0,"stats":{"Line":81}},{"line":63,"address":[],"length":0,"stats":{"Line":108}},{"line":64,"address":[],"length":0,"stats":{"Line":108}},{"line":65,"address":[],"length":0,"stats":{"Line":108}},{"line":68,"address":[],"length":0,"stats":{"Line":513}},{"line":69,"address":[],"length":0,"stats":{"Line":810}},{"line":70,"address":[],"length":0,"stats":{"Line":810}},{"line":71,"address":[],"length":0,"stats":{"Line":810}},{"line":72,"address":[],"length":0,"stats":{"Line":648}},{"line":73,"address":[],"length":0,"stats":{"Line":648}},{"line":74,"address":[],"length":0,"stats":{"Line":324}},{"line":75,"address":[],"length":0,"stats":{"Line":486}},{"line":79,"address":[],"length":0,"stats":{"Line":108}},{"line":80,"address":[],"length":0,"stats":{"Line":108}},{"line":83,"address":[],"length":0,"stats":{"Line":135}},{"line":84,"address":[],"length":0,"stats":{"Line":270}},{"line":85,"address":[],"length":0,"stats":{"Line":162}},{"line":87,"address":[],"length":0,"stats":{"Line":135}},{"line":88,"address":[],"length":0,"stats":{"Line":270}},{"line":89,"address":[],"length":0,"stats":{"Line":162}},{"line":93,"address":[],"length":0,"stats":{"Line":108}},{"line":94,"address":[],"length":0,"stats":{"Line":54}},{"line":95,"address":[],"length":0,"stats":{"Line":27}},{"line":96,"address":[],"length":0,"stats":{"Line":27}},{"line":99,"address":[],"length":0,"stats":{"Line":108}},{"line":100,"address":[],"length":0,"stats":{"Line":108}},{"line":103,"address":[],"length":0,"stats":{"Line":108}},{"line":104,"address":[],"length":0,"stats":{"Line":54}},{"line":105,"address":[],"length":0,"stats":{"Line":27}},{"line":106,"address":[],"length":0,"stats":{"Line":27}},{"line":107,"address":[],"length":0,"stats":{"Line":108}},{"line":108,"address":[],"length":0,"stats":{"Line":54}},{"line":109,"address":[],"length":0,"stats":{"Line":27}},{"line":110,"address":[],"length":0,"stats":{"Line":27}},{"line":113,"address":[],"length":0,"stats":{"Line":108}},{"line":114,"address":[],"length":0,"stats":{"Line":54}},{"line":115,"address":[],"length":0,"stats":{"Line":27}},{"line":116,"address":[],"length":0,"stats":{"Line":27}},{"line":117,"address":[],"length":0,"stats":{"Line":108}},{"line":118,"address":[],"length":0,"stats":{"Line":54}},{"line":119,"address":[],"length":0,"stats":{"Line":27}},{"line":120,"address":[],"length":0,"stats":{"Line":27}},{"line":121,"address":[],"length":0,"stats":{"Line":108}},{"line":122,"address":[],"length":0,"stats":{"Line":54}},{"line":123,"address":[],"length":0,"stats":{"Line":27}},{"line":124,"address":[],"length":0,"stats":{"Line":27}},{"line":127,"address":[],"length":0,"stats":{"Line":108}},{"line":128,"address":[],"length":0,"stats":{"Line":54}},{"line":129,"address":[],"length":0,"stats":{"Line":27}},{"line":130,"address":[],"length":0,"stats":{"Line":27}},{"line":133,"address":[],"length":0,"stats":{"Line":216}},{"line":134,"address":[],"length":0,"stats":{"Line":162}},{"line":135,"address":[],"length":0,"stats":{"Line":135}},{"line":136,"address":[],"length":0,"stats":{"Line":108}},{"line":137,"address":[],"length":0,"stats":{"Line":81}},{"line":138,"address":[],"length":0,"stats":{"Line":54}},{"line":139,"address":[],"length":0,"stats":{"Line":27}},{"line":142,"address":[],"length":0,"stats":{"Line":108}},{"line":143,"address":[],"length":0,"stats":{"Line":54}},{"line":144,"address":[],"length":0,"stats":{"Line":27}},{"line":145,"address":[],"length":0,"stats":{"Line":27}},{"line":146,"address":[],"length":0,"stats":{"Line":108}},{"line":147,"address":[],"length":0,"stats":{"Line":54}},{"line":148,"address":[],"length":0,"stats":{"Line":27}},{"line":149,"address":[],"length":0,"stats":{"Line":27}},{"line":151,"address":[],"length":0,"stats":{"Line":54}},{"line":155,"address":[],"length":0,"stats":{"Line":163}},{"line":156,"address":[],"length":0,"stats":{"Line":652}},{"line":157,"address":[],"length":0,"stats":{"Line":489}},{"line":161,"address":[],"length":0,"stats":{"Line":10}},{"line":162,"address":[],"length":0,"stats":{"Line":30}},{"line":165,"address":[],"length":0,"stats":{"Line":11}},{"line":166,"address":[],"length":0,"stats":{"Line":3}},{"line":167,"address":[],"length":0,"stats":{"Line":2}},{"line":172,"address":[],"length":0,"stats":{"Line":171}},{"line":173,"address":[],"length":0,"stats":{"Line":90}},{"line":175,"address":[],"length":0,"stats":{"Line":243}},{"line":179,"address":[],"length":0,"stats":{"Line":18}},{"line":180,"address":[],"length":0,"stats":{"Line":9}},{"line":181,"address":[],"length":0,"stats":{"Line":9}},{"line":184,"address":[],"length":0,"stats":{"Line":45}},{"line":185,"address":[],"length":0,"stats":{"Line":72}},{"line":186,"address":[],"length":0,"stats":{"Line":54}},{"line":191,"address":[],"length":0,"stats":{"Line":19}},{"line":192,"address":[],"length":0,"stats":{"Line":2}},{"line":194,"address":[],"length":0,"stats":{"Line":17}},{"line":195,"address":[],"length":0,"stats":{"Line":2}},{"line":197,"address":[],"length":0,"stats":{"Line":15}},{"line":198,"address":[],"length":0,"stats":{"Line":2}},{"line":201,"address":[],"length":0,"stats":{"Line":12}},{"line":205,"address":[],"length":0,"stats":{"Line":29}},{"line":206,"address":[],"length":0,"stats":{"Line":67}},{"line":208,"address":[],"length":0,"stats":{"Line":9}},{"line":210,"address":[],"length":0,"stats":{"Line":18}},{"line":212,"address":[],"length":0,"stats":{"Line":22}},{"line":214,"address":[],"length":0,"stats":{"Line":2}},{"line":216,"address":[],"length":0,"stats":{"Line":4}},{"line":220,"address":[],"length":0,"stats":{"Line":18}},{"line":222,"address":[],"length":0,"stats":{"Line":36}},{"line":223,"address":[],"length":0,"stats":{"Line":36}},{"line":227,"address":[],"length":0,"stats":{"Line":58}},{"line":229,"address":[],"length":0,"stats":{"Line":116}},{"line":230,"address":[],"length":0,"stats":{"Line":71}},{"line":234,"address":[],"length":0,"stats":{"Line":3}},{"line":235,"address":[],"length":0,"stats":{"Line":12}},{"line":237,"address":[],"length":0,"stats":{"Line":6}},{"line":238,"address":[],"length":0,"stats":{"Line":16}},{"line":239,"address":[],"length":0,"stats":{"Line":42}},{"line":240,"address":[],"length":0,"stats":{"Line":49}},{"line":243,"address":[],"length":0,"stats":{"Line":14}},{"line":244,"address":[],"length":0,"stats":{"Line":14}},{"line":245,"address":[],"length":0,"stats":{"Line":12}},{"line":246,"address":[],"length":0,"stats":{"Line":10}},{"line":248,"address":[],"length":0,"stats":{"Line":3}},{"line":251,"address":[],"length":0,"stats":{"Line":16}},{"line":254,"address":[],"length":0,"stats":{"Line":6}},{"line":258,"address":[],"length":0,"stats":{"Line":3}},{"line":259,"address":[],"length":0,"stats":{"Line":6}},{"line":260,"address":[],"length":0,"stats":{"Line":12}},{"line":262,"address":[],"length":0,"stats":{"Line":39}},{"line":263,"address":[],"length":0,"stats":{"Line":72}},{"line":265,"address":[],"length":0,"stats":{"Line":58}},{"line":266,"address":[],"length":0,"stats":{"Line":24}},{"line":268,"address":[],"length":0,"stats":{"Line":16}},{"line":270,"address":[],"length":0,"stats":{"Line":8}},{"line":271,"address":[],"length":0,"stats":{"Line":20}},{"line":272,"address":[],"length":0,"stats":{"Line":24}},{"line":277,"address":[],"length":0,"stats":{"Line":6}},{"line":281,"address":[],"length":0,"stats":{"Line":6}},{"line":282,"address":[],"length":0,"stats":{"Line":24}},{"line":283,"address":[],"length":0,"stats":{"Line":24}},{"line":285,"address":[],"length":0,"stats":{"Line":12}},{"line":286,"address":[],"length":0,"stats":{"Line":12}},{"line":287,"address":[],"length":0,"stats":{"Line":12}},{"line":289,"address":[],"length":0,"stats":{"Line":60}},{"line":290,"address":[],"length":0,"stats":{"Line":81}},{"line":291,"address":[],"length":0,"stats":{"Line":54}},{"line":292,"address":[],"length":0,"stats":{"Line":10}},{"line":296,"address":[],"length":0,"stats":{"Line":34}},{"line":297,"address":[],"length":0,"stats":{"Line":8}},{"line":298,"address":[],"length":0,"stats":{"Line":2}},{"line":302,"address":[],"length":0,"stats":{"Line":15}},{"line":303,"address":[],"length":0,"stats":{"Line":52}},{"line":304,"address":[],"length":0,"stats":{"Line":35}},{"line":305,"address":[],"length":0,"stats":{"Line":11}},{"line":310,"address":[],"length":0,"stats":{"Line":12}}],"covered":147,"coverable":175},{"path":["/","Users","chi","Projects","hu","src","utils","fetch_html","tests.rs"],"content":"use super::*;\n\n#[test]\nfn html_to_markdown_headings() {\n    let html = \"\u003ch1\u003eTitle\u003c/h1\u003e\u003ch2\u003eSubtitle\u003c/h2\u003e\";\n    let md = html_to_markdown(html);\n    assert!(md.contains(\"# Title\"));\n    assert!(md.contains(\"## Subtitle\"));\n}\n\n#[test]\nfn html_to_markdown_links() {\n    let html = r#\"\u003ca href=\"https://example.com\"\u003eClick here\u003c/a\u003e\"#;\n    let md = html_to_markdown(html);\n    assert!(md.contains(\"[Click here](https://example.com)\"));\n}\n\n#[test]\nfn html_to_markdown_emphasis() {\n    let html = \"\u003cstrong\u003ebold\u003c/strong\u003e and \u003cem\u003eitalic\u003c/em\u003e\";\n    let md = html_to_markdown(html);\n    assert!(md.contains(\"**bold**\"));\n    assert!(md.contains(\"*italic*\"));\n}\n\n#[test]\nfn html_to_markdown_strips_scripts() {\n    let html = \"\u003cp\u003eText\u003c/p\u003e\u003cscript\u003ealert('x')\u003c/script\u003e\u003cp\u003eMore\u003c/p\u003e\";\n    let md = html_to_markdown(html);\n    assert!(!md.contains(\"alert\"));\n    assert!(md.contains(\"Text\"));\n    assert!(md.contains(\"More\"));\n}\n\n#[test]\nfn extract_links_basic() {\n    let html = r##\"\n            \u003ca href=\"https://a.com\"\u003eLink A\u003c/a\u003e\n            \u003ca href=\"https://b.com\"\u003eLink B\u003c/a\u003e\n            \u003ca href=\"#\"\u003eSkip\u003c/a\u003e\n        \"##;\n    let links = extract_links(html);\n    assert!(links.contains(\"[Link A](https://a.com)\"));\n    assert!(links.contains(\"[Link B](https://b.com)\"));\n    assert!(!links.contains(\"Skip\"));\n}\n\n#[test]\nfn extract_headings_basic() {\n    let html = \"\u003ch1\u003eMain\u003c/h1\u003e\u003ch2\u003eSub\u003c/h2\u003e\u003ch3\u003eDeep\u003c/h3\u003e\";\n    let headings = extract_headings(html);\n    assert!(headings.contains(\"# Main\"));\n    assert!(headings.contains(\"## Sub\"));\n    assert!(headings.contains(\"### Deep\"));\n}\n\n#[test]\nfn extract_by_selector_tag() {\n    let html = \"\u003cmain\u003e\u003cp\u003eContent\u003c/p\u003e\u003c/main\u003e\";\n    let content = extract_by_selector(html, \"main\");\n    assert!(content.is_some());\n    assert!(content.unwrap().contains(\"Content\"));\n}\n\n#[test]\nfn extract_by_selector_class() {\n    let html = r#\"\u003cdiv class=\"content\"\u003e\u003cp\u003eInner\u003c/p\u003e\u003c/div\u003e\"#;\n    let content = extract_by_selector(html, \".content\");\n    assert!(content.is_some());\n    assert!(content.unwrap().contains(\"Inner\"));\n}\n\n#[test]\nfn remove_tag_with_content_basic() {\n    let html = \"\u003cp\u003eKeep\u003c/p\u003e\u003cnav\u003eRemove\u003c/nav\u003e\u003cp\u003eAlso keep\u003c/p\u003e\";\n    let result = remove_tag_with_content(html, \"nav\");\n    assert!(result.contains(\"Keep\"));\n    assert!(result.contains(\"Also keep\"));\n    assert!(!result.contains(\"Remove\"));\n}\n\n#[test]\nfn extract_summary_limits_paragraphs() {\n    let html = \"\u003cp\u003ePara 1\u003c/p\u003e\u003cp\u003ePara 2\u003c/p\u003e\u003cp\u003ePara 3\u003c/p\u003e\u003cp\u003ePara 4\u003c/p\u003e\u003cp\u003ePara 5\u003c/p\u003e\";\n    let summary = extract_summary(html);\n    assert!(summary.contains(\"Para 1\"));\n    assert!(summary.contains(\"Para 2\"));\n    assert!(summary.contains(\"Para 3\"));\n    // Should be limited\n}\n\n#[test]\nfn html_to_markdown_inline_code() {\n    let html = \"\u003cp\u003eUse \u003ccode\u003efoo()\u003c/code\u003e method\u003c/p\u003e\";\n    let md = html_to_markdown(html);\n    assert!(md.contains(\"`foo()`\"));\n}\n\n#[test]\nfn html_to_markdown_lists() {\n    let html = \"\u003cul\u003e\u003cli\u003eItem 1\u003c/li\u003e\u003cli\u003eItem 2\u003c/li\u003e\u003c/ul\u003e\";\n    let md = html_to_markdown(html);\n    assert!(md.contains(\"- Item 1\"));\n    assert!(md.contains(\"- Item 2\"));\n}\n\n#[test]\nfn html_to_markdown_paragraphs() {\n    let html = \"\u003cp\u003eFirst paragraph\u003c/p\u003e\u003cp\u003eSecond paragraph\u003c/p\u003e\";\n    let md = html_to_markdown(html);\n    assert!(md.contains(\"First paragraph\"));\n    assert!(md.contains(\"Second paragraph\"));\n}\n\n#[test]\nfn html_to_markdown_br_tags() {\n    let html = \"Line 1\u003cbr/\u003eLine 2\u003cbr\u003eLine 3\";\n    let md = html_to_markdown(html);\n    assert!(md.contains(\"Line 1\"));\n    assert!(md.contains(\"Line 2\"));\n    assert!(md.contains(\"Line 3\"));\n}\n\n#[test]\nfn html_to_markdown_entities() {\n    let html = \"5 \u0026lt; 10 \u0026amp; 10 \u0026gt; 5\";\n    let md = html_to_markdown(html);\n    assert!(md.contains(\"5 \u003c 10 \u0026 10 \u003e 5\"));\n}\n\n#[test]\nfn html_to_markdown_b_and_i_tags() {\n    let html = \"\u003cb\u003ebold\u003c/b\u003e and \u003ci\u003eitalic\u003c/i\u003e\";\n    let md = html_to_markdown(html);\n    assert!(md.contains(\"**bold**\"));\n    assert!(md.contains(\"*italic*\"));\n}\n\n#[test]\nfn html_to_markdown_noscript() {\n    let html = \"\u003cp\u003eContent\u003c/p\u003e\u003cnoscript\u003eEnable JS\u003c/noscript\u003e\";\n    let md = html_to_markdown(html);\n    assert!(md.contains(\"Content\"));\n    assert!(!md.contains(\"Enable JS\"));\n}\n\n#[test]\nfn html_to_markdown_style() {\n    let html = \"\u003cstyle\u003ebody { color: red; }\u003c/style\u003e\u003cp\u003eText\u003c/p\u003e\";\n    let md = html_to_markdown(html);\n    assert!(!md.contains(\"color\"));\n    assert!(md.contains(\"Text\"));\n}\n\n#[test]\nfn extract_links_skips_javascript() {\n    let html = r#\"\u003ca href=\"javascript:void(0)\"\u003eJS Link\u003c/a\u003e\u003ca href=\"https://x.com\"\u003eReal\u003c/a\u003e\"#;\n    let links = extract_links(html);\n    assert!(!links.contains(\"JS Link\"));\n    assert!(links.contains(\"Real\"));\n}\n\n#[test]\nfn extract_links_skips_empty_text() {\n    let html = r#\"\u003ca href=\"https://x.com\"\u003e\u003c/a\u003e\u003ca href=\"https://y.com\"\u003eValid\u003c/a\u003e\"#;\n    let links = extract_links(html);\n    assert!(!links.contains(\"https://x.com\")); // skipped - empty text\n    assert!(links.contains(\"Valid\"));\n}\n\n#[test]\nfn extract_by_selector_id() {\n    let html = r#\"\u003cdiv id=\"main\"\u003e\u003cp\u003eMain content\u003c/p\u003e\u003c/div\u003e\"#;\n    let content = extract_by_selector(html, \"#main\");\n    assert!(content.is_some());\n    assert!(content.unwrap().contains(\"Main content\"));\n}\n\n#[test]\nfn extract_by_selector_not_found() {\n    let html = \"\u003cp\u003eJust text\u003c/p\u003e\";\n    let content = extract_by_selector(html, \"#nonexistent\");\n    assert!(content.is_none());\n}\n\n#[test]\nfn extract_content_with_selector() {\n    let html = r#\"\u003cnav\u003eSkip\u003c/nav\u003e\u003cdiv class=\"content\"\u003e\u003cp\u003eKeep\u003c/p\u003e\u003c/div\u003e\"#;\n    let content = extract_content(html, Some(\".content\"));\n    assert!(content.contains(\"Keep\"));\n    assert!(!content.contains(\"Skip\"));\n}\n\n#[test]\nfn extract_content_strips_noise_elements() {\n    let html = \"\u003cnav\u003eNav\u003c/nav\u003e\u003cscript\u003ealert()\u003c/script\u003e\u003cmain\u003e\u003cp\u003eMain\u003c/p\u003e\u003c/main\u003e\";\n    let content = extract_content(html, None);\n    assert!(content.contains(\"Main\"));\n    assert!(!content.contains(\"Nav\"));\n    assert!(!content.contains(\"alert\"));\n}\n\n#[test]\nfn extract_content_finds_article() {\n    let html = \"\u003cheader\u003eHeader\u003c/header\u003e\u003carticle\u003e\u003cp\u003eArticle\u003c/p\u003e\u003c/article\u003e\";\n    let content = extract_content(html, None);\n    assert!(content.contains(\"Article\"));\n}\n\n#[test]\nfn extract_content_finds_content_class() {\n    let html = r#\"\u003caside\u003eSide\u003c/aside\u003e\u003cdiv class=\"content\"\u003e\u003cp\u003eMain\u003c/p\u003e\u003c/div\u003e\"#;\n    let content = extract_content(html, None);\n    assert!(content.contains(\"Main\"));\n}\n\n#[test]\nfn extract_headings_strips_nested_tags() {\n    let html = \"\u003ch1\u003e\u003cspan class='icon'\u003e*\u003c/span\u003e Title\u003c/h1\u003e\";\n    let headings = extract_headings(html);\n    assert!(headings.contains(\"# * Title\") || headings.contains(\"# Title\"));\n}\n\n#[test]\nfn extract_headings_empty() {\n    let html = \"\u003cp\u003eNo headings\u003c/p\u003e\";\n    let headings = extract_headings(html);\n    assert!(headings.is_empty());\n}\n\n#[test]\nfn extract_summary_includes_headings() {\n    let html = \"\u003ch1\u003eTitle\u003c/h1\u003e\u003cp\u003ePara 1\u003c/p\u003e\u003ch2\u003eSection\u003c/h2\u003e\u003cp\u003ePara 2\u003c/p\u003e\";\n    let summary = extract_summary(html);\n    assert!(summary.contains(\"Title\"));\n    assert!(summary.contains(\"Section\"));\n}\n\n#[test]\nfn extract_summary_skips_empty_lines() {\n    let html = \"\u003cp\u003ePara 1\u003c/p\u003e\u003cp\u003e\u003c/p\u003e\u003cp\u003ePara 2\u003c/p\u003e\";\n    let summary = extract_summary(html);\n    assert!(summary.contains(\"Para 1\"));\n    assert!(summary.contains(\"Para 2\"));\n}\n\n#[test]\nfn extract_summary_handles_lists() {\n    let html = \"\u003cp\u003eIntro\u003c/p\u003e\u003cul\u003e\u003cli\u003eItem 1\u003c/li\u003e\u003cli\u003eItem 2\u003c/li\u003e\u003c/ul\u003e\u003cp\u003ePara 2\u003c/p\u003e\";\n    let summary = extract_summary(html);\n    // List items shouldn't count toward para limit\n    assert!(summary.contains(\"Intro\"));\n    assert!(summary.contains(\"Item 1\"));\n}\n\n#[test]\nfn html_to_markdown_h1_to_h6() {\n    let html = \"\u003ch1\u003eH1\u003c/h1\u003e\u003ch2\u003eH2\u003c/h2\u003e\u003ch3\u003eH3\u003c/h3\u003e\u003ch4\u003eH4\u003c/h4\u003e\u003ch5\u003eH5\u003c/h5\u003e\u003ch6\u003eH6\u003c/h6\u003e\";\n    let md = html_to_markdown(html);\n    assert!(md.contains(\"# H1\"));\n    assert!(md.contains(\"## H2\"));\n    assert!(md.contains(\"### H3\"));\n    assert!(md.contains(\"#### H4\"));\n    assert!(md.contains(\"##### H5\"));\n    assert!(md.contains(\"###### H6\"));\n}\n\n#[test]\nfn html_to_markdown_cleans_whitespace() {\n    let html = \"\u003cp\u003eText\u003c/p\u003e\\n\\n\\n\\n\u003cp\u003eMore\u003c/p\u003e\";\n    let md = html_to_markdown(html);\n    // Should not have excessive newlines\n    assert!(!md.contains(\"\\n\\n\\n\"));\n}\n\n#[test]\nfn html_to_markdown_nbsp_entity() {\n    let html = \"word\u0026nbsp;word\";\n    let md = html_to_markdown(html);\n    assert!(md.contains(\"word word\"));\n}\n\n#[test]\nfn html_to_markdown_quot_entity() {\n    let html = \"\u0026quot;quoted\u0026quot;\";\n    let md = html_to_markdown(html);\n    assert!(md.contains(\"\\\"quoted\\\"\"));\n}\n\n#[test]\nfn html_to_markdown_apos_entity() {\n    let html = \"it\u0026#39;s\";\n    let md = html_to_markdown(html);\n    assert!(md.contains(\"it's\"));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","utils","grep","mod.rs"],"content":"use anyhow::{Context, Result};\nuse regex::Regex;\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::Path;\n\nuse super::cli::GrepArgs;\nuse super::signature::extract_signature;\n\n#[cfg(test)]\nmod tests;\n\n/// A single grep match\n#[derive(Debug, Clone)]\npub struct GrepMatch {\n    pub file: String,\n    pub line_num: usize,\n    pub content: String,\n    pub match_count: usize,\n}\n\n/// Handle the `hu utils grep` command\npub fn run(args: GrepArgs) -\u003e Result\u003c()\u003e {\n    let matches = search_files(\u0026args)?;\n\n    if matches.is_empty() {\n        eprintln!(\"No matches found.\");\n        return Ok(());\n    }\n\n    let output = format_matches(\u0026matches, \u0026args);\n    println!(\"{}\", output);\n\n    Ok(())\n}\n\n/// Search files for pattern\npub fn search_files(args: \u0026GrepArgs) -\u003e Result\u003cVec\u003cGrepMatch\u003e\u003e {\n    let re = if args.ignore_case {\n        Regex::new(\u0026format!(\"(?i){}\", \u0026args.pattern))\n    } else {\n        Regex::new(\u0026args.pattern)\n    }\n    .with_context(|| format!(\"Invalid regex pattern: {}\", args.pattern))?;\n\n    let glob_pattern = args.glob.as_deref();\n    let mut matches = Vec::new();\n\n    collect_matches(\u0026args.path, \u0026re, glob_pattern, args.hidden, \u0026mut matches)?;\n\n    // Apply post-processing\n    let mut matches = if args.unique {\n        dedupe_matches(matches)\n    } else {\n        matches\n    };\n\n    if args.ranked {\n        rank_matches(\u0026mut matches);\n    }\n\n    if let Some(limit) = args.limit {\n        matches.truncate(limit);\n    }\n\n    Ok(matches)\n}\n\n/// Recursively collect matches from files\nfn collect_matches(\n    path: \u0026str,\n    re: \u0026Regex,\n    glob_pattern: Option\u003c\u0026str\u003e,\n    include_hidden: bool,\n    matches: \u0026mut Vec\u003cGrepMatch\u003e,\n) -\u003e Result\u003c()\u003e {\n    let path = Path::new(path);\n\n    if path.is_file() {\n        if should_search_file(path, glob_pattern) {\n            search_file(path, re, matches)?;\n        }\n        return Ok(());\n    }\n\n    if !path.is_dir() {\n        return Ok(());\n    }\n\n    let entries =\n        fs::read_dir(path).with_context(|| format!(\"Failed to read directory: {:?}\", path))?;\n\n    for entry in entries.flatten() {\n        let entry_path = entry.path();\n        let file_name = entry_path\n            .file_name()\n            .and_then(|n| n.to_str())\n            .unwrap_or(\"\");\n\n        // Skip hidden files unless requested\n        if !include_hidden \u0026\u0026 file_name.starts_with('.') {\n            continue;\n        }\n\n        // Skip common non-code directories\n        if entry_path.is_dir() \u0026\u0026 is_ignored_dir(file_name) {\n            continue;\n        }\n\n        if entry_path.is_dir() {\n            collect_matches(\n                entry_path.to_str().unwrap_or(\"\"),\n                re,\n                glob_pattern,\n                include_hidden,\n                matches,\n            )?;\n        } else if should_search_file(\u0026entry_path, glob_pattern) {\n            search_file(\u0026entry_path, re, matches)?;\n        }\n    }\n\n    Ok(())\n}\n\n/// Check if a directory should be ignored\nfn is_ignored_dir(name: \u0026str) -\u003e bool {\n    matches!(\n        name,\n        \"node_modules\"\n            | \"target\"\n            | \".git\"\n            | \".svn\"\n            | \".hg\"\n            | \"__pycache__\"\n            | \".mypy_cache\"\n            | \".pytest_cache\"\n            | \"venv\"\n            | \".venv\"\n            | \"dist\"\n            | \"build\"\n            | \".next\"\n            | \".nuxt\"\n    )\n}\n\n/// Check if a file matches the glob pattern\nfn should_search_file(path: \u0026Path, glob_pattern: Option\u003c\u0026str\u003e) -\u003e bool {\n    // Skip binary files\n    let ext = path.extension().and_then(|e| e.to_str()).unwrap_or(\"\");\n    if is_binary_extension(ext) {\n        return false;\n    }\n\n    // If no glob, search all text files\n    let Some(pattern) = glob_pattern else {\n        return true;\n    };\n\n    // Simple glob matching\n    let file_name = path.file_name().and_then(|n| n.to_str()).unwrap_or(\"\");\n    glob_matches(file_name, pattern)\n}\n\n/// Check if extension indicates binary file\nfn is_binary_extension(ext: \u0026str) -\u003e bool {\n    matches!(\n        ext.to_lowercase().as_str(),\n        \"png\"\n            | \"jpg\"\n            | \"jpeg\"\n            | \"gif\"\n            | \"ico\"\n            | \"webp\"\n            | \"bmp\"\n            | \"svg\"\n            | \"pdf\"\n            | \"zip\"\n            | \"tar\"\n            | \"gz\"\n            | \"bz2\"\n            | \"xz\"\n            | \"7z\"\n            | \"rar\"\n            | \"exe\"\n            | \"dll\"\n            | \"so\"\n            | \"dylib\"\n            | \"a\"\n            | \"o\"\n            | \"obj\"\n            | \"wasm\"\n            | \"class\"\n            | \"jar\"\n            | \"pyc\"\n            | \"pyo\"\n            | \"mp3\"\n            | \"mp4\"\n            | \"avi\"\n            | \"mkv\"\n            | \"mov\"\n            | \"wav\"\n            | \"flac\"\n            | \"ttf\"\n            | \"otf\"\n            | \"woff\"\n            | \"woff2\"\n            | \"eot\"\n            | \"sqlite\"\n            | \"db\"\n    )\n}\n\n/// Simple glob matching (supports * and ?)\npub fn glob_matches(name: \u0026str, pattern: \u0026str) -\u003e bool {\n    let pattern = pattern.trim_start_matches(\"**/\");\n\n    if let Some(ext) = pattern.strip_prefix(\"*.\") {\n        // Extension match: *.rs\n        name.ends_with(\u0026format!(\".{}\", ext))\n    } else if pattern.contains('*') {\n        // Convert glob to regex\n        let regex_pattern = pattern\n            .replace('.', \"\\\\.\")\n            .replace('*', \".*\")\n            .replace('?', \".\");\n        Regex::new(\u0026format!(\"^{}$\", regex_pattern))\n            .map(|re| re.is_match(name))\n            .unwrap_or(false)\n    } else {\n        // Exact match\n        name == pattern\n    }\n}\n\n/// Search a single file for matches\nfn search_file(path: \u0026Path, re: \u0026Regex, matches: \u0026mut Vec\u003cGrepMatch\u003e) -\u003e Result\u003c()\u003e {\n    let content = match fs::read_to_string(path) {\n        Ok(c) =\u003e c,\n        Err(_) =\u003e return Ok(()), // Skip unreadable files\n    };\n\n    let file_str = path.to_str().unwrap_or(\"\");\n\n    for (line_num, line) in content.lines().enumerate() {\n        let match_count = re.find_iter(line).count();\n        if match_count \u003e 0 {\n            matches.push(GrepMatch {\n                file: file_str.to_string(),\n                line_num: line_num + 1,\n                content: line.to_string(),\n                match_count,\n            });\n        }\n    }\n\n    Ok(())\n}\n\n/// Deduplicate similar matches\nfn dedupe_matches(matches: Vec\u003cGrepMatch\u003e) -\u003e Vec\u003cGrepMatch\u003e {\n    let mut seen: HashMap\u003cString, GrepMatch\u003e = HashMap::new();\n\n    for m in matches {\n        // Normalize content for comparison (trim, collapse whitespace)\n        let normalized = m.content.split_whitespace().collect::\u003cVec\u003c_\u003e\u003e().join(\" \");\n\n        seen.entry(normalized)\n            .and_modify(|existing| existing.match_count += m.match_count)\n            .or_insert(m);\n    }\n\n    seen.into_values().collect()\n}\n\n/// Rank matches by relevance (match density)\nfn rank_matches(matches: \u0026mut [GrepMatch]) {\n    matches.sort_by(|a, b| {\n        // Higher match count first\n        b.match_count\n            .cmp(\u0026a.match_count)\n            // Then shorter content (more focused)\n            .then_with(|| a.content.len().cmp(\u0026b.content.len()))\n    });\n}\n\n/// Format matches for output\npub fn format_matches(matches: \u0026[GrepMatch], args: \u0026GrepArgs) -\u003e String {\n    let mut output = Vec::new();\n\n    for m in matches {\n        if args.refs {\n            // Just file:line reference\n            output.push(format!(\"{}:{}\", m.file, m.line_num));\n        } else if args.signature {\n            // Try to extract function signature\n            if let Some(sig) = extract_signature(\u0026m.content, \u0026m.file) {\n                output.push(format!(\"{}:{}: {}\", m.file, m.line_num, sig));\n            } else {\n                output.push(format!(\"{}:{}: {}\", m.file, m.line_num, m.content.trim()));\n            }\n        } else {\n            // Full match with content\n            output.push(format!(\"{}:{}: {}\", m.file, m.line_num, m.content.trim()));\n        }\n    }\n\n    output.join(\"\\n\")\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":2}},{"line":24,"address":[],"length":0,"stats":{"Line":6}},{"line":26,"address":[],"length":0,"stats":{"Line":4}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":8}},{"line":32,"address":[],"length":0,"stats":{"Line":4}},{"line":34,"address":[],"length":0,"stats":{"Line":2}},{"line":38,"address":[],"length":0,"stats":{"Line":14}},{"line":39,"address":[],"length":0,"stats":{"Line":27}},{"line":40,"address":[],"length":0,"stats":{"Line":3}},{"line":42,"address":[],"length":0,"stats":{"Line":26}},{"line":44,"address":[],"length":0,"stats":{"Line":17}},{"line":46,"address":[],"length":0,"stats":{"Line":39}},{"line":47,"address":[],"length":0,"stats":{"Line":26}},{"line":49,"address":[],"length":0,"stats":{"Line":78}},{"line":52,"address":[],"length":0,"stats":{"Line":26}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[],"length":0,"stats":{"Line":12}},{"line":58,"address":[],"length":0,"stats":{"Line":14}},{"line":59,"address":[],"length":0,"stats":{"Line":1}},{"line":62,"address":[],"length":0,"stats":{"Line":15}},{"line":63,"address":[],"length":0,"stats":{"Line":2}},{"line":66,"address":[],"length":0,"stats":{"Line":13}},{"line":70,"address":[],"length":0,"stats":{"Line":13}},{"line":77,"address":[],"length":0,"stats":{"Line":39}},{"line":79,"address":[],"length":0,"stats":{"Line":26}},{"line":80,"address":[],"length":0,"stats":{"Line":9}},{"line":81,"address":[],"length":0,"stats":{"Line":12}},{"line":83,"address":[],"length":0,"stats":{"Line":3}},{"line":86,"address":[],"length":0,"stats":{"Line":10}},{"line":87,"address":[],"length":0,"stats":{"Line":1}},{"line":90,"address":[],"length":0,"stats":{"Line":9}},{"line":91,"address":[],"length":0,"stats":{"Line":27}},{"line":93,"address":[],"length":0,"stats":{"Line":34}},{"line":94,"address":[],"length":0,"stats":{"Line":48}},{"line":95,"address":[],"length":0,"stats":{"Line":32}},{"line":97,"address":[],"length":0,"stats":{"Line":48}},{"line":101,"address":[],"length":0,"stats":{"Line":44}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":106,"address":[],"length":0,"stats":{"Line":17}},{"line":107,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":14}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":42}},{"line":119,"address":[],"length":0,"stats":{"Line":52}},{"line":123,"address":[],"length":0,"stats":{"Line":9}},{"line":127,"address":[],"length":0,"stats":{"Line":6}},{"line":128,"address":[],"length":0,"stats":{"Line":4}},{"line":129,"address":[],"length":0,"stats":{"Line":6}},{"line":148,"address":[],"length":0,"stats":{"Line":19}},{"line":150,"address":[],"length":0,"stats":{"Line":152}},{"line":151,"address":[],"length":0,"stats":{"Line":38}},{"line":152,"address":[],"length":0,"stats":{"Line":1}},{"line":156,"address":[],"length":0,"stats":{"Line":20}},{"line":157,"address":[],"length":0,"stats":{"Line":16}},{"line":161,"address":[],"length":0,"stats":{"Line":16}},{"line":162,"address":[],"length":0,"stats":{"Line":6}},{"line":166,"address":[],"length":0,"stats":{"Line":28}},{"line":167,"address":[],"length":0,"stats":{"Line":7}},{"line":168,"address":[],"length":0,"stats":{"Line":28}},{"line":215,"address":[],"length":0,"stats":{"Line":10}},{"line":216,"address":[],"length":0,"stats":{"Line":30}},{"line":218,"address":[],"length":0,"stats":{"Line":16}},{"line":220,"address":[],"length":0,"stats":{"Line":18}},{"line":221,"address":[],"length":0,"stats":{"Line":8}},{"line":223,"address":[],"length":0,"stats":{"Line":10}},{"line":227,"address":[],"length":0,"stats":{"Line":4}},{"line":228,"address":[],"length":0,"stats":{"Line":8}},{"line":232,"address":[],"length":0,"stats":{"Line":2}},{"line":237,"address":[],"length":0,"stats":{"Line":16}},{"line":238,"address":[],"length":0,"stats":{"Line":32}},{"line":239,"address":[],"length":0,"stats":{"Line":32}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":80}},{"line":245,"address":[],"length":0,"stats":{"Line":710}},{"line":246,"address":[],"length":0,"stats":{"Line":1695}},{"line":247,"address":[],"length":0,"stats":{"Line":361}},{"line":248,"address":[],"length":0,"stats":{"Line":66}},{"line":249,"address":[],"length":0,"stats":{"Line":66}},{"line":250,"address":[],"length":0,"stats":{"Line":44}},{"line":251,"address":[],"length":0,"stats":{"Line":44}},{"line":252,"address":[],"length":0,"stats":{"Line":22}},{"line":257,"address":[],"length":0,"stats":{"Line":16}},{"line":261,"address":[],"length":0,"stats":{"Line":2}},{"line":262,"address":[],"length":0,"stats":{"Line":6}},{"line":264,"address":[],"length":0,"stats":{"Line":10}},{"line":266,"address":[],"length":0,"stats":{"Line":12}},{"line":268,"address":[],"length":0,"stats":{"Line":12}},{"line":269,"address":[],"length":0,"stats":{"Line":6}},{"line":270,"address":[],"length":0,"stats":{"Line":8}},{"line":273,"address":[],"length":0,"stats":{"Line":6}},{"line":277,"address":[],"length":0,"stats":{"Line":2}},{"line":278,"address":[],"length":0,"stats":{"Line":6}},{"line":280,"address":[],"length":0,"stats":{"Line":2}},{"line":281,"address":[],"length":0,"stats":{"Line":4}},{"line":283,"address":[],"length":0,"stats":{"Line":2}},{"line":288,"address":[],"length":0,"stats":{"Line":6}},{"line":289,"address":[],"length":0,"stats":{"Line":12}},{"line":291,"address":[],"length":0,"stats":{"Line":28}},{"line":292,"address":[],"length":0,"stats":{"Line":18}},{"line":294,"address":[],"length":0,"stats":{"Line":21}},{"line":295,"address":[],"length":0,"stats":{"Line":11}},{"line":297,"address":[],"length":0,"stats":{"Line":6}},{"line":298,"address":[],"length":0,"stats":{"Line":3}},{"line":300,"address":[],"length":0,"stats":{"Line":5}},{"line":304,"address":[],"length":0,"stats":{"Line":10}},{"line":308,"address":[],"length":0,"stats":{"Line":12}}],"covered":104,"coverable":112},{"path":["/","Users","chi","Projects","hu","src","utils","grep","tests.rs"],"content":"use super::*;\n\n#[test]\nfn glob_matches_extension() {\n    assert!(glob_matches(\"foo.rs\", \"*.rs\"));\n    assert!(glob_matches(\"bar.rs\", \"*.rs\"));\n    assert!(!glob_matches(\"foo.py\", \"*.rs\"));\n}\n\n#[test]\nfn glob_matches_recursive() {\n    assert!(glob_matches(\"foo.rs\", \"**/*.rs\"));\n}\n\n#[test]\nfn glob_matches_exact() {\n    assert!(glob_matches(\"Cargo.toml\", \"Cargo.toml\"));\n    assert!(!glob_matches(\"cargo.toml\", \"Cargo.toml\"));\n}\n\n#[test]\nfn glob_matches_wildcard() {\n    assert!(glob_matches(\"test_foo.rs\", \"test_*.rs\"));\n    assert!(!glob_matches(\"foo_test.rs\", \"test_*.rs\"));\n}\n\n#[test]\nfn is_ignored_dir_common() {\n    assert!(is_ignored_dir(\"node_modules\"));\n    assert!(is_ignored_dir(\"target\"));\n    assert!(is_ignored_dir(\".git\"));\n    assert!(!is_ignored_dir(\"src\"));\n    assert!(!is_ignored_dir(\"lib\"));\n}\n\n#[test]\nfn is_binary_extension_images() {\n    assert!(is_binary_extension(\"png\"));\n    assert!(is_binary_extension(\"jpg\"));\n    assert!(is_binary_extension(\"gif\"));\n}\n\n#[test]\nfn is_binary_extension_archives() {\n    assert!(is_binary_extension(\"zip\"));\n    assert!(is_binary_extension(\"tar\"));\n    assert!(is_binary_extension(\"gz\"));\n}\n\n#[test]\nfn is_binary_extension_code() {\n    assert!(!is_binary_extension(\"rs\"));\n    assert!(!is_binary_extension(\"py\"));\n    assert!(!is_binary_extension(\"js\"));\n}\n\n#[test]\nfn format_matches_refs_mode() {\n    let matches = vec![GrepMatch {\n        file: \"src/main.rs\".to_string(),\n        line_num: 42,\n        content: \"    let x = 1;\".to_string(),\n        match_count: 1,\n    }];\n    let args = GrepArgs {\n        pattern: \"x\".to_string(),\n        path: \".\".to_string(),\n        refs: true,\n        unique: false,\n        ranked: false,\n        limit: None,\n        signature: false,\n        glob: None,\n        ignore_case: false,\n        hidden: false,\n    };\n    let output = format_matches(\u0026matches, \u0026args);\n    assert_eq!(output, \"src/main.rs:42\");\n}\n\n#[test]\nfn format_matches_full_mode() {\n    let matches = vec![GrepMatch {\n        file: \"src/main.rs\".to_string(),\n        line_num: 42,\n        content: \"    let x = 1;\".to_string(),\n        match_count: 1,\n    }];\n    let args = GrepArgs {\n        pattern: \"x\".to_string(),\n        path: \".\".to_string(),\n        refs: false,\n        unique: false,\n        ranked: false,\n        limit: None,\n        signature: false,\n        glob: None,\n        ignore_case: false,\n        hidden: false,\n    };\n    let output = format_matches(\u0026matches, \u0026args);\n    assert_eq!(output, \"src/main.rs:42: let x = 1;\");\n}\n\n#[test]\nfn dedupe_matches_combines_counts() {\n    let matches = vec![\n        GrepMatch {\n            file: \"a.rs\".to_string(),\n            line_num: 1,\n            content: \"let x = 1;\".to_string(),\n            match_count: 1,\n        },\n        GrepMatch {\n            file: \"b.rs\".to_string(),\n            line_num: 5,\n            content: \"let x = 1;\".to_string(),\n            match_count: 2,\n        },\n    ];\n    let deduped = dedupe_matches(matches);\n    assert_eq!(deduped.len(), 1);\n    assert_eq!(deduped[0].match_count, 3); // 1 + 2\n}\n\n#[test]\nfn rank_matches_by_count() {\n    let mut matches = vec![\n        GrepMatch {\n            file: \"a.rs\".to_string(),\n            line_num: 1,\n            content: \"one match\".to_string(),\n            match_count: 1,\n        },\n        GrepMatch {\n            file: \"b.rs\".to_string(),\n            line_num: 2,\n            content: \"three matches\".to_string(),\n            match_count: 3,\n        },\n    ];\n    rank_matches(\u0026mut matches);\n    assert_eq!(matches[0].match_count, 3); // Higher count first\n}\n\n#[test]\nfn search_files_respects_limit() {\n    let temp_dir = std::env::temp_dir().join(\"hu_grep_test\");\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n    std::fs::create_dir_all(\u0026temp_dir).unwrap();\n\n    std::fs::write(temp_dir.join(\"a.txt\"), \"test line 1\\ntest line 2\\n\").unwrap();\n    std::fs::write(temp_dir.join(\"b.txt\"), \"test line 3\\n\").unwrap();\n\n    let args = GrepArgs {\n        pattern: \"test\".to_string(),\n        path: temp_dir.to_str().unwrap().to_string(),\n        refs: false,\n        unique: false,\n        ranked: false,\n        limit: Some(2),\n        signature: false,\n        glob: None,\n        ignore_case: false,\n        hidden: false,\n    };\n\n    let matches = search_files(\u0026args).unwrap();\n    assert_eq!(matches.len(), 2);\n\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n}\n\n#[test]\nfn search_files_respects_glob() {\n    let temp_dir = std::env::temp_dir().join(\"hu_grep_glob_test\");\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n    std::fs::create_dir_all(\u0026temp_dir).unwrap();\n\n    std::fs::write(temp_dir.join(\"foo.rs\"), \"test\\n\").unwrap();\n    std::fs::write(temp_dir.join(\"bar.py\"), \"test\\n\").unwrap();\n\n    let args = GrepArgs {\n        pattern: \"test\".to_string(),\n        path: temp_dir.to_str().unwrap().to_string(),\n        refs: false,\n        unique: false,\n        ranked: false,\n        limit: None,\n        signature: false,\n        glob: Some(\"*.rs\".to_string()),\n        ignore_case: false,\n        hidden: false,\n    };\n\n    let matches = search_files(\u0026args).unwrap();\n    assert_eq!(matches.len(), 1);\n    assert!(matches[0].file.ends_with(\"foo.rs\"));\n\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n}\n\n#[test]\nfn format_matches_signature_mode() {\n    let matches = vec![GrepMatch {\n        file: \"src/main.rs\".to_string(),\n        line_num: 42,\n        content: \"pub fn process() {\".to_string(),\n        match_count: 1,\n    }];\n    let args = GrepArgs {\n        pattern: \"process\".to_string(),\n        path: \".\".to_string(),\n        refs: false,\n        unique: false,\n        ranked: false,\n        limit: None,\n        signature: true,\n        glob: None,\n        ignore_case: false,\n        hidden: false,\n    };\n    let output = format_matches(\u0026matches, \u0026args);\n    assert!(output.contains(\"pub fn process()\"));\n    assert!(!output.contains(\"{\")); // signature strips the brace\n}\n\n#[test]\nfn format_matches_signature_no_match() {\n    // When line doesn't match signature pattern, falls back to trimmed content\n    let matches = vec![GrepMatch {\n        file: \"src/main.rs\".to_string(),\n        line_num: 42,\n        content: \"    let x = 1;\".to_string(),\n        match_count: 1,\n    }];\n    let args = GrepArgs {\n        pattern: \"x\".to_string(),\n        path: \".\".to_string(),\n        refs: false,\n        unique: false,\n        ranked: false,\n        limit: None,\n        signature: true,\n        glob: None,\n        ignore_case: false,\n        hidden: false,\n    };\n    let output = format_matches(\u0026matches, \u0026args);\n    assert!(output.contains(\"let x = 1;\"));\n}\n\n#[test]\nfn grep_match_debug() {\n    let m = GrepMatch {\n        file: \"test.rs\".to_string(),\n        line_num: 1,\n        content: \"test\".to_string(),\n        match_count: 1,\n    };\n    let debug = format!(\"{:?}\", m);\n    assert!(debug.contains(\"GrepMatch\"));\n}\n\n#[test]\nfn grep_match_clone() {\n    let m = GrepMatch {\n        file: \"test.rs\".to_string(),\n        line_num: 1,\n        content: \"test\".to_string(),\n        match_count: 1,\n    };\n    let cloned = m.clone();\n    assert_eq!(cloned.file, m.file);\n    assert_eq!(cloned.line_num, m.line_num);\n}\n\n#[test]\nfn search_files_with_unique() {\n    let temp_dir = std::env::temp_dir().join(\"hu_grep_unique_test\");\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n    std::fs::create_dir_all(\u0026temp_dir).unwrap();\n\n    std::fs::write(temp_dir.join(\"a.txt\"), \"let x = 1;\\n\").unwrap();\n    std::fs::write(temp_dir.join(\"b.txt\"), \"let x = 1;\\n\").unwrap();\n\n    let args = GrepArgs {\n        pattern: \"let\".to_string(),\n        path: temp_dir.to_str().unwrap().to_string(),\n        refs: false,\n        unique: true,\n        ranked: false,\n        limit: None,\n        signature: false,\n        glob: None,\n        ignore_case: false,\n        hidden: false,\n    };\n\n    let matches = search_files(\u0026args).unwrap();\n    assert_eq!(matches.len(), 1);\n    assert_eq!(matches[0].match_count, 2);\n\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n}\n\n#[test]\nfn search_files_with_ranked() {\n    let temp_dir = std::env::temp_dir().join(\"hu_grep_ranked_test\");\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n    std::fs::create_dir_all(\u0026temp_dir).unwrap();\n\n    std::fs::write(temp_dir.join(\"a.txt\"), \"test\\n\").unwrap();\n    std::fs::write(temp_dir.join(\"b.txt\"), \"test test test\\n\").unwrap();\n\n    let args = GrepArgs {\n        pattern: \"test\".to_string(),\n        path: temp_dir.to_str().unwrap().to_string(),\n        refs: false,\n        unique: false,\n        ranked: true,\n        limit: None,\n        signature: false,\n        glob: None,\n        ignore_case: false,\n        hidden: false,\n    };\n\n    let matches = search_files(\u0026args).unwrap();\n    assert!(matches[0].match_count \u003e= matches[1].match_count);\n\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n}\n\n#[test]\nfn collect_matches_skips_hidden() {\n    let temp_dir = std::env::temp_dir().join(\"hu_grep_hidden_test\");\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n    std::fs::create_dir_all(\u0026temp_dir).unwrap();\n    std::fs::create_dir_all(temp_dir.join(\".hidden\")).unwrap();\n\n    std::fs::write(temp_dir.join(\"visible.txt\"), \"test\\n\").unwrap();\n    std::fs::write(temp_dir.join(\".hidden\").join(\"secret.txt\"), \"test\\n\").unwrap();\n\n    let args = GrepArgs {\n        pattern: \"test\".to_string(),\n        path: temp_dir.to_str().unwrap().to_string(),\n        refs: false,\n        unique: false,\n        ranked: false,\n        limit: None,\n        signature: false,\n        glob: None,\n        ignore_case: false,\n        hidden: false,\n    };\n\n    let matches = search_files(\u0026args).unwrap();\n    assert_eq!(matches.len(), 1);\n    assert!(matches[0].file.contains(\"visible\"));\n\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n}\n\n#[test]\nfn collect_matches_includes_hidden_when_requested() {\n    let temp_dir = std::env::temp_dir().join(\"hu_grep_hidden_incl_test\");\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n    std::fs::create_dir_all(\u0026temp_dir).unwrap();\n\n    std::fs::write(temp_dir.join(\".hidden_file.txt\"), \"test\\n\").unwrap();\n    std::fs::write(temp_dir.join(\"visible.txt\"), \"test\\n\").unwrap();\n\n    let args = GrepArgs {\n        pattern: \"test\".to_string(),\n        path: temp_dir.to_str().unwrap().to_string(),\n        refs: false,\n        unique: false,\n        ranked: false,\n        limit: None,\n        signature: false,\n        glob: None,\n        ignore_case: false,\n        hidden: true,\n    };\n\n    let matches = search_files(\u0026args).unwrap();\n    assert_eq!(matches.len(), 2);\n\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n}\n\n#[test]\nfn search_files_skips_ignored_dirs() {\n    let temp_dir = std::env::temp_dir().join(\"hu_grep_ignored_test\");\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n    std::fs::create_dir_all(\u0026temp_dir).unwrap();\n    std::fs::create_dir_all(temp_dir.join(\"node_modules\")).unwrap();\n\n    std::fs::write(temp_dir.join(\"app.js\"), \"test\\n\").unwrap();\n    std::fs::write(temp_dir.join(\"node_modules\").join(\"dep.js\"), \"test\\n\").unwrap();\n\n    let args = GrepArgs {\n        pattern: \"test\".to_string(),\n        path: temp_dir.to_str().unwrap().to_string(),\n        refs: false,\n        unique: false,\n        ranked: false,\n        limit: None,\n        signature: false,\n        glob: None,\n        ignore_case: false,\n        hidden: false,\n    };\n\n    let matches = search_files(\u0026args).unwrap();\n    assert_eq!(matches.len(), 1);\n    assert!(matches[0].file.contains(\"app.js\"));\n\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n}\n\n#[test]\nfn search_files_single_file_path() {\n    let temp_dir = std::env::temp_dir().join(\"hu_grep_single_file_test\");\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n    std::fs::create_dir_all(\u0026temp_dir).unwrap();\n\n    let file_path = temp_dir.join(\"single.txt\");\n    std::fs::write(\u0026file_path, \"test line\\n\").unwrap();\n\n    let args = GrepArgs {\n        pattern: \"test\".to_string(),\n        path: file_path.to_str().unwrap().to_string(),\n        refs: false,\n        unique: false,\n        ranked: false,\n        limit: None,\n        signature: false,\n        glob: None,\n        ignore_case: false,\n        hidden: false,\n    };\n\n    let matches = search_files(\u0026args).unwrap();\n    assert_eq!(matches.len(), 1);\n\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n}\n\n#[test]\nfn search_files_nonexistent_path() {\n    let args = GrepArgs {\n        pattern: \"test\".to_string(),\n        path: \"/nonexistent/path/12345\".to_string(),\n        refs: false,\n        unique: false,\n        ranked: false,\n        limit: None,\n        signature: false,\n        glob: None,\n        ignore_case: false,\n        hidden: false,\n    };\n\n    let matches = search_files(\u0026args).unwrap();\n    assert!(matches.is_empty());\n}\n\n#[test]\nfn search_files_invalid_regex() {\n    let args = GrepArgs {\n        pattern: \"[invalid\".to_string(),\n        path: \".\".to_string(),\n        refs: false,\n        unique: false,\n        ranked: false,\n        limit: None,\n        signature: false,\n        glob: None,\n        ignore_case: false,\n        hidden: false,\n    };\n\n    let result = search_files(\u0026args);\n    assert!(result.is_err());\n}\n\n#[test]\nfn search_files_case_insensitive() {\n    let temp_dir = std::env::temp_dir().join(\"hu_grep_case_test\");\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n    std::fs::create_dir_all(\u0026temp_dir).unwrap();\n\n    std::fs::write(temp_dir.join(\"test.txt\"), \"Hello HELLO hello\\n\").unwrap();\n\n    let args_sensitive = GrepArgs {\n        pattern: \"Hello\".to_string(),\n        path: temp_dir.to_str().unwrap().to_string(),\n        refs: false,\n        unique: false,\n        ranked: false,\n        limit: None,\n        signature: false,\n        glob: None,\n        ignore_case: false,\n        hidden: false,\n    };\n\n    let matches_sensitive = search_files(\u0026args_sensitive).unwrap();\n    assert_eq!(matches_sensitive[0].match_count, 1);\n\n    let args_insensitive = GrepArgs {\n        pattern: \"Hello\".to_string(),\n        path: temp_dir.to_str().unwrap().to_string(),\n        refs: false,\n        unique: false,\n        ranked: false,\n        limit: None,\n        signature: false,\n        glob: None,\n        ignore_case: true,\n        hidden: false,\n    };\n\n    let matches_insensitive = search_files(\u0026args_insensitive).unwrap();\n    assert_eq!(matches_insensitive[0].match_count, 3);\n\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n}\n\n#[test]\nfn should_search_file_binary_extension() {\n    let path = std::path::Path::new(\"image.png\");\n    assert!(!should_search_file(path, None));\n}\n\n#[test]\nfn should_search_file_text_no_glob() {\n    let path = std::path::Path::new(\"file.txt\");\n    assert!(should_search_file(path, None));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","utils","mod.rs"],"content":"mod cli;\nmod docs_index;\nmod docs_search;\nmod docs_section;\nmod fetch_html;\nmod grep;\nmod signature;\nmod web_search;\n\npub use cli::UtilsCommand;\n\nuse anyhow::Result;\n\n/// Run a utils subcommand\npub async fn run_command(cmd: UtilsCommand) -\u003e Result\u003c()\u003e {\n    match cmd {\n        UtilsCommand::FetchHtml(args) =\u003e fetch_html::run(args).await,\n        UtilsCommand::Grep(args) =\u003e grep::run(args),\n        UtilsCommand::WebSearch(args) =\u003e web_search::run(args).await,\n        UtilsCommand::DocsIndex(args) =\u003e run_docs_index(args),\n        UtilsCommand::DocsSearch(args) =\u003e run_docs_search(args),\n        UtilsCommand::DocsSection(args) =\u003e run_docs_section(args),\n    }\n}\n\nuse cli::{DocsIndexArgs, DocsSearchArgs, DocsSectionArgs};\n\nfn run_docs_index(args: DocsIndexArgs) -\u003e Result\u003c()\u003e {\n    let index = docs_index::build_index(\u0026args.path)?;\n\n    if let Some(output) = args.output {\n        docs_index::save_index(\u0026index, \u0026output)?;\n        println!(\"Index saved to {}\", output);\n    } else {\n        println!(\n            \"Indexed {} files, {} sections\",\n            index.file_count(),\n            index.section_count()\n        );\n        for (path, file) in \u0026index.files {\n            println!(\"\\n{}:\", path);\n            for section in \u0026file.sections {\n                let indent = \"  \".repeat((section.level - 1) as usize);\n                println!(\n                    \"  {}{} (L{}-{})\",\n                    indent, section.heading, section.start_line, section.end_line\n                );\n            }\n        }\n    }\n\n    Ok(())\n}\n\nfn run_docs_search(args: DocsSearchArgs) -\u003e Result\u003c()\u003e {\n    let index = docs_index::load_index(\u0026args.index)?;\n    let results = docs_search::search_index(\u0026index, \u0026args.query);\n    let output = docs_search::format_results(\u0026results, args.limit);\n    println!(\"{}\", output);\n    Ok(())\n}\n\nfn run_docs_section(args: DocsSectionArgs) -\u003e Result\u003c()\u003e {\n    let content = docs_section::extract_section_from_file(\u0026args.file, \u0026args.heading)?;\n    println!(\"{}\", content);\n    Ok(())\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":4}},{"line":16,"address":[],"length":0,"stats":{"Line":2}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":6}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}}],"covered":3,"coverable":35},{"path":["/","Users","chi","Projects","hu","src","utils","signature.rs"],"content":"//! Language-specific signature extraction for code search results.\n//!\n//! Extracts function/class/struct signatures from source code lines\n//! to provide cleaner search output.\n\nuse regex::Regex;\nuse std::path::Path;\n\n/// Try to extract function/method signature from a line based on file extension.\npub fn extract_signature(line: \u0026str, file: \u0026str) -\u003e Option\u003cString\u003e {\n    let trimmed = line.trim();\n    let ext = Path::new(file)\n        .extension()\n        .and_then(|e| e.to_str())\n        .unwrap_or(\"\");\n\n    match ext {\n        \"rs\" =\u003e extract_rust_signature(trimmed),\n        \"py\" =\u003e extract_python_signature(trimmed),\n        \"js\" | \"ts\" | \"jsx\" | \"tsx\" =\u003e extract_js_signature(trimmed),\n        \"rb\" =\u003e extract_ruby_signature(trimmed),\n        \"go\" =\u003e extract_go_signature(trimmed),\n        _ =\u003e None,\n    }\n}\n\n/// Extract Rust function/struct signature\nfn extract_rust_signature(line: \u0026str) -\u003e Option\u003cString\u003e {\n    // fn name(...) -\u003e Type\n    if let Some(caps) =\n        Regex::new(r\"^(pub\\s+)?(async\\s+)?fn\\s+(\\w+)\\s*(\u003c[^\u003e]+\u003e)?\\s*\\([^)]*\\)(\\s*-\u003e\\s*[^{]+)?\")\n            .ok()?\n            .captures(line)\n    {\n        return Some(\n            caps.get(0)?\n                .as_str()\n                .trim_end_matches('{')\n                .trim()\n                .to_string(),\n        );\n    }\n\n    // struct/enum/impl\n    if let Some(caps) = Regex::new(r\"^(pub\\s+)?(struct|enum|impl|trait)\\s+(\\w+)(\u003c[^\u003e]+\u003e)?\")\n        .ok()?\n        .captures(line)\n    {\n        return Some(caps.get(0)?.as_str().to_string());\n    }\n\n    None\n}\n\n/// Extract Python function/class signature\nfn extract_python_signature(line: \u0026str) -\u003e Option\u003cString\u003e {\n    // def name(...):\n    if let Some(caps) = Regex::new(r\"^(async\\s+)?def\\s+(\\w+)\\s*\\([^)]*\\)(\\s*-\u003e\\s*[^:]+)?:\")\n        .ok()?\n        .captures(line)\n    {\n        return Some(caps.get(0)?.as_str().trim_end_matches(':').to_string());\n    }\n\n    // class Name:\n    if let Some(caps) = Regex::new(r\"^class\\s+(\\w+)(\\([^)]*\\))?:\")\n        .ok()?\n        .captures(line)\n    {\n        return Some(caps.get(0)?.as_str().trim_end_matches(':').to_string());\n    }\n\n    None\n}\n\n/// Extract JavaScript/TypeScript function signature\nfn extract_js_signature(line: \u0026str) -\u003e Option\u003cString\u003e {\n    // function name(...)\n    if let Some(caps) =\n        Regex::new(r\"^(export\\s+)?(async\\s+)?function\\s+(\\w+)\\s*(\u003c[^\u003e]+\u003e)?\\s*\\([^)]*\\)\")\n            .ok()?\n            .captures(line)\n    {\n        return Some(caps.get(0)?.as_str().to_string());\n    }\n\n    // const name = (...) =\u003e\n    if let Some(caps) =\n        Regex::new(r\"^(export\\s+)?(const|let|var)\\s+(\\w+)\\s*=\\s*(async\\s+)?\\([^)]*\\)\\s*=\u003e\")\n            .ok()?\n            .captures(line)\n    {\n        return Some(\n            caps.get(0)?\n                .as_str()\n                .trim_end_matches(\"=\u003e\")\n                .trim()\n                .to_string(),\n        );\n    }\n\n    // class Name\n    if let Some(caps) = Regex::new(r\"^(export\\s+)?class\\s+(\\w+)(\\s+extends\\s+\\w+)?\")\n        .ok()?\n        .captures(line)\n    {\n        return Some(caps.get(0)?.as_str().to_string());\n    }\n\n    None\n}\n\n/// Extract Ruby method/class signature\nfn extract_ruby_signature(line: \u0026str) -\u003e Option\u003cString\u003e {\n    // def name(...)\n    if let Some(caps) = Regex::new(r\"^def\\s+(\\w+[?!=]?)(\\([^)]*\\))?\")\n        .ok()?\n        .captures(line)\n    {\n        return Some(caps.get(0)?.as_str().to_string());\n    }\n\n    // class Name\n    if let Some(caps) = Regex::new(r\"^class\\s+(\\w+)(\\s*\u003c\\s*\\w+)?\")\n        .ok()?\n        .captures(line)\n    {\n        return Some(caps.get(0)?.as_str().to_string());\n    }\n\n    None\n}\n\n/// Extract Go function signature\nfn extract_go_signature(line: \u0026str) -\u003e Option\u003cString\u003e {\n    // func name(...)\n    if let Some(caps) =\n        Regex::new(r\"^func\\s+(\\([^)]+\\)\\s+)?(\\w+)\\s*\\([^)]*\\)(\\s*\\([^)]*\\)|\\s*\\w+)?\")\n            .ok()?\n            .captures(line)\n    {\n        return Some(caps.get(0)?.as_str().to_string());\n    }\n\n    // type Name struct/interface\n    if let Some(caps) = Regex::new(r\"^type\\s+(\\w+)\\s+(struct|interface)\")\n        .ok()?\n        .captures(line)\n    {\n        return Some(caps.get(0)?.as_str().to_string());\n    }\n\n    None\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn extract_rust_fn_signature() {\n        let sig = extract_rust_signature(\"pub fn foo(x: i32) -\u003e String {\").unwrap();\n        assert_eq!(sig, \"pub fn foo(x: i32) -\u003e String\");\n    }\n\n    #[test]\n    fn extract_rust_async_fn_signature() {\n        let sig = extract_rust_signature(\"pub async fn fetch() -\u003e Result\u003c()\u003e {\").unwrap();\n        assert_eq!(sig, \"pub async fn fetch() -\u003e Result\u003c()\u003e\");\n    }\n\n    #[test]\n    fn extract_rust_struct_signature() {\n        let sig = extract_rust_signature(\"pub struct Config\u003cT\u003e {\").unwrap();\n        assert_eq!(sig, \"pub struct Config\u003cT\u003e\");\n    }\n\n    #[test]\n    fn extract_python_def_signature() {\n        let sig = extract_python_signature(\"def process(data: list) -\u003e dict:\").unwrap();\n        assert_eq!(sig, \"def process(data: list) -\u003e dict\");\n    }\n\n    #[test]\n    fn extract_python_class_signature() {\n        let sig = extract_python_signature(\"class Handler(BaseHandler):\").unwrap();\n        assert_eq!(sig, \"class Handler(BaseHandler)\");\n    }\n\n    #[test]\n    fn extract_python_async_def() {\n        let sig = extract_python_signature(\"async def fetch_data(url: str) -\u003e dict:\").unwrap();\n        assert!(sig.contains(\"async def fetch_data\"));\n    }\n\n    #[test]\n    fn extract_python_signature_no_match() {\n        let result = extract_python_signature(\"just some regular text\");\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn extract_js_function_signature() {\n        let sig = extract_js_signature(\"export async function fetchData(url) {\").unwrap();\n        assert_eq!(sig, \"export async function fetchData(url)\");\n    }\n\n    #[test]\n    fn extract_js_arrow_signature() {\n        let sig = extract_js_signature(\"const handler = async (req, res) =\u003e\").unwrap();\n        assert_eq!(sig, \"const handler = async (req, res)\");\n    }\n\n    #[test]\n    fn extract_js_class_signature() {\n        let sig = extract_js_signature(\"export class UserService extends BaseService {\").unwrap();\n        assert!(sig.contains(\"class UserService\"));\n        assert!(sig.contains(\"extends BaseService\"));\n    }\n\n    #[test]\n    fn extract_js_signature_no_match() {\n        let result = extract_js_signature(\"console.log('hello')\");\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn extract_ruby_def_signature() {\n        let sig = extract_ruby_signature(\"def process(data)\").unwrap();\n        assert_eq!(sig, \"def process(data)\");\n    }\n\n    #[test]\n    fn extract_ruby_predicate_signature() {\n        let sig = extract_ruby_signature(\"def valid?\").unwrap();\n        assert_eq!(sig, \"def valid?\");\n    }\n\n    #[test]\n    fn extract_ruby_class_with_inheritance() {\n        let sig = extract_ruby_signature(\"class User \u003c ActiveRecord::Base\").unwrap();\n        assert!(sig.contains(\"class User\"));\n    }\n\n    #[test]\n    fn extract_ruby_signature_no_match() {\n        let result = extract_ruby_signature(\"puts 'hello world'\");\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn extract_go_func_signature() {\n        let sig =\n            extract_go_signature(\"func (s *Server) Handle(w http.ResponseWriter, r *http.Request)\")\n                .unwrap();\n        assert!(sig.contains(\"func\"));\n        assert!(sig.contains(\"Handle\"));\n    }\n\n    #[test]\n    fn extract_go_type_interface() {\n        let sig = extract_go_signature(\"type Handler interface {\").unwrap();\n        assert_eq!(sig, \"type Handler interface\");\n    }\n\n    #[test]\n    fn extract_go_signature_no_match() {\n        let result = extract_go_signature(\"fmt.Println(\\\"hello\\\")\");\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn extract_signature_by_extension() {\n        let sig = extract_signature(\"pub fn test() {\", \"foo.rs\").unwrap();\n        assert!(sig.contains(\"fn test\"));\n\n        let sig = extract_signature(\"def test():\", \"foo.py\").unwrap();\n        assert!(sig.contains(\"def test\"));\n    }\n\n    #[test]\n    fn extract_signature_unknown_extension() {\n        let result = extract_signature(\"some random line\", \"file.xyz\");\n        assert!(result.is_none());\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":5}},{"line":11,"address":[],"length":0,"stats":{"Line":15}},{"line":12,"address":[],"length":0,"stats":{"Line":10}},{"line":14,"address":[],"length":0,"stats":{"Line":15}},{"line":17,"address":[],"length":0,"stats":{"Line":5}},{"line":18,"address":[],"length":0,"stats":{"Line":11}},{"line":19,"address":[],"length":0,"stats":{"Line":4}},{"line":20,"address":[],"length":0,"stats":{"Line":4}},{"line":21,"address":[],"length":0,"stats":{"Line":1}},{"line":22,"address":[],"length":0,"stats":{"Line":1}},{"line":23,"address":[],"length":0,"stats":{"Line":1}},{"line":28,"address":[],"length":0,"stats":{"Line":6}},{"line":30,"address":[],"length":0,"stats":{"Line":4}},{"line":31,"address":[],"length":0,"stats":{"Line":12}},{"line":33,"address":[],"length":0,"stats":{"Line":12}},{"line":36,"address":[],"length":0,"stats":{"Line":8}},{"line":37,"address":[],"length":0,"stats":{"Line":4}},{"line":38,"address":[],"length":0,"stats":{"Line":4}},{"line":39,"address":[],"length":0,"stats":{"Line":4}},{"line":40,"address":[],"length":0,"stats":{"Line":4}},{"line":45,"address":[],"length":0,"stats":{"Line":5}},{"line":47,"address":[],"length":0,"stats":{"Line":4}},{"line":49,"address":[],"length":0,"stats":{"Line":4}},{"line":52,"address":[],"length":0,"stats":{"Line":1}},{"line":56,"address":[],"length":0,"stats":{"Line":5}},{"line":58,"address":[],"length":0,"stats":{"Line":13}},{"line":60,"address":[],"length":0,"stats":{"Line":10}},{"line":62,"address":[],"length":0,"stats":{"Line":15}},{"line":66,"address":[],"length":0,"stats":{"Line":5}},{"line":68,"address":[],"length":0,"stats":{"Line":4}},{"line":70,"address":[],"length":0,"stats":{"Line":5}},{"line":73,"address":[],"length":0,"stats":{"Line":1}},{"line":77,"address":[],"length":0,"stats":{"Line":4}},{"line":79,"address":[],"length":0,"stats":{"Line":1}},{"line":80,"address":[],"length":0,"stats":{"Line":8}},{"line":82,"address":[],"length":0,"stats":{"Line":8}},{"line":84,"address":[],"length":0,"stats":{"Line":4}},{"line":88,"address":[],"length":0,"stats":{"Line":1}},{"line":89,"address":[],"length":0,"stats":{"Line":6}},{"line":91,"address":[],"length":0,"stats":{"Line":6}},{"line":94,"address":[],"length":0,"stats":{"Line":2}},{"line":95,"address":[],"length":0,"stats":{"Line":1}},{"line":96,"address":[],"length":0,"stats":{"Line":1}},{"line":97,"address":[],"length":0,"stats":{"Line":1}},{"line":98,"address":[],"length":0,"stats":{"Line":1}},{"line":103,"address":[],"length":0,"stats":{"Line":5}},{"line":105,"address":[],"length":0,"stats":{"Line":4}},{"line":107,"address":[],"length":0,"stats":{"Line":4}},{"line":110,"address":[],"length":0,"stats":{"Line":1}},{"line":114,"address":[],"length":0,"stats":{"Line":4}},{"line":116,"address":[],"length":0,"stats":{"Line":10}},{"line":118,"address":[],"length":0,"stats":{"Line":8}},{"line":120,"address":[],"length":0,"stats":{"Line":8}},{"line":124,"address":[],"length":0,"stats":{"Line":5}},{"line":126,"address":[],"length":0,"stats":{"Line":4}},{"line":128,"address":[],"length":0,"stats":{"Line":4}},{"line":131,"address":[],"length":0,"stats":{"Line":1}},{"line":135,"address":[],"length":0,"stats":{"Line":3}},{"line":137,"address":[],"length":0,"stats":{"Line":1}},{"line":138,"address":[],"length":0,"stats":{"Line":6}},{"line":140,"address":[],"length":0,"stats":{"Line":6}},{"line":142,"address":[],"length":0,"stats":{"Line":4}},{"line":146,"address":[],"length":0,"stats":{"Line":5}},{"line":148,"address":[],"length":0,"stats":{"Line":4}},{"line":150,"address":[],"length":0,"stats":{"Line":4}},{"line":153,"address":[],"length":0,"stats":{"Line":1}}],"covered":66,"coverable":66},{"path":["/","Users","chi","Projects","hu","src","utils","web_search","mod.rs"],"content":"use anyhow::{bail, Context, Result};\nuse serde::Deserialize;\nuse std::fs;\n\nuse super::cli::WebSearchArgs;\nuse super::fetch_html::extract_summary;\nuse crate::util::{load_credentials, BraveCredentials};\n\n#[cfg(test)]\nmod tests;\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/// A single search result from Brave API\n#[derive(Debug, Clone, Deserialize)]\npub struct SearchResult {\n    pub title: String,\n    pub url: String,\n    #[serde(default)]\n    pub description: String,\n}\n\n/// Web results container from Brave API\n#[derive(Debug, Deserialize)]\npub struct WebResults {\n    #[serde(default)]\n    pub results: Vec\u003cSearchResult\u003e,\n}\n\n/// Top-level Brave API response\n#[derive(Debug, Deserialize)]\npub struct BraveSearchResponse {\n    #[serde(default)]\n    pub web: Option\u003cWebResults\u003e,\n}\n\n/// Fetched content for a search result\n#[derive(Debug)]\npub struct FetchedResult {\n    pub title: String,\n    pub url: String,\n    pub description: String,\n    pub content: Option\u003cString\u003e,\n}\n\n// ============================================================================\n// Client trait\n// ============================================================================\n\n/// Trait for Brave Search API operations\n#[async_trait::async_trait]\npub trait BraveSearchApi {\n    async fn search(\u0026self, query: \u0026str, count: usize) -\u003e Result\u003cVec\u003cSearchResult\u003e\u003e;\n}\n\n/// Production client for Brave Search\npub struct BraveSearchClient {\n    api_key: String,\n    http: reqwest::Client,\n}\n\nimpl BraveSearchClient {\n    pub fn new(api_key: String) -\u003e Self {\n        let http = reqwest::Client::builder()\n            .user_agent(\"hu-cli/0.1\")\n            .build()\n            .expect(\"Failed to build HTTP client\");\n        Self { api_key, http }\n    }\n\n    pub fn from_credentials(creds: \u0026BraveCredentials) -\u003e Self {\n        Self::new(creds.api_key.clone())\n    }\n}\n\n#[async_trait::async_trait]\nimpl BraveSearchApi for BraveSearchClient {\n    async fn search(\u0026self, query: \u0026str, count: usize) -\u003e Result\u003cVec\u003cSearchResult\u003e\u003e {\n        let url = format!(\n            \"https://api.search.brave.com/res/v1/web/search?q={}\u0026count={}\",\n            urlencoding::encode(query),\n            count\n        );\n\n        let response = self\n            .http\n            .get(\u0026url)\n            .header(\"Accept\", \"application/json\")\n            .header(\"X-Subscription-Token\", \u0026self.api_key)\n            .send()\n            .await\n            .context(\"Failed to call Brave Search API\")?;\n\n        if !response.status().is_success() {\n            let status = response.status();\n            let body = response.text().await.unwrap_or_default();\n            bail!(\"Brave API error {}: {}\", status, body);\n        }\n\n        let data: BraveSearchResponse = response\n            .json()\n            .await\n            .context(\"Failed to parse Brave API response\")?;\n\n        Ok(data.web.map(|w| w.results).unwrap_or_default())\n    }\n}\n\n// ============================================================================\n// HTTP fetcher trait\n// ============================================================================\n\n/// Trait for fetching URL content\n#[async_trait::async_trait]\npub trait HttpFetcher {\n    async fn fetch(\u0026self, url: \u0026str) -\u003e Result\u003cString\u003e;\n}\n\n/// Production HTTP fetcher\npub struct DefaultHttpFetcher {\n    http: reqwest::Client,\n}\n\nimpl Default for DefaultHttpFetcher {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl DefaultHttpFetcher {\n    pub fn new() -\u003e Self {\n        let http = reqwest::Client::builder()\n            .user_agent(\"hu-cli/0.1\")\n            .timeout(std::time::Duration::from_secs(10))\n            .build()\n            .expect(\"Failed to build HTTP client\");\n        Self { http }\n    }\n}\n\n#[async_trait::async_trait]\nimpl HttpFetcher for DefaultHttpFetcher {\n    async fn fetch(\u0026self, url: \u0026str) -\u003e Result\u003cString\u003e {\n        let response = self\n            .http\n            .get(url)\n            .send()\n            .await\n            .with_context(|| format!(\"Failed to fetch {}\", url))?;\n\n        response\n            .text()\n            .await\n            .with_context(|| format!(\"Failed to read response from {}\", url))\n    }\n}\n\n// ============================================================================\n// Service\n// ============================================================================\n\n/// Search and optionally fetch content from results\npub async fn search_and_fetch(\n    api: \u0026impl BraveSearchApi,\n    fetcher: \u0026impl HttpFetcher,\n    query: \u0026str,\n    count: usize,\n    fetch_content: bool,\n) -\u003e Result\u003cVec\u003cFetchedResult\u003e\u003e {\n    let results = api.search(query, count).await?;\n\n    let mut fetched = Vec::new();\n    for result in results.into_iter().take(count) {\n        let content = if fetch_content {\n            match fetcher.fetch(\u0026result.url).await {\n                Ok(html) =\u003e Some(extract_summary(\u0026html)),\n                Err(_) =\u003e None,\n            }\n        } else {\n            None\n        };\n\n        fetched.push(FetchedResult {\n            title: result.title,\n            url: result.url,\n            description: result.description,\n            content,\n        });\n    }\n\n    Ok(fetched)\n}\n\n/// Format results as markdown\npub fn format_results(results: \u0026[FetchedResult], include_content: bool) -\u003e String {\n    let mut output = String::new();\n\n    for (i, result) in results.iter().enumerate() {\n        output.push_str(\u0026format!(\"## {}. {}\\n\", i + 1, result.title));\n        output.push_str(\u0026format!(\"**URL:** {}\\n\\n\", result.url));\n\n        if !result.description.is_empty() {\n            output.push_str(\u0026format!(\"\u003e {}\\n\\n\", result.description));\n        }\n\n        if include_content {\n            if let Some(content) = \u0026result.content {\n                output.push_str(\"### Content\\n\\n\");\n                output.push_str(content);\n                output.push_str(\"\\n\\n\");\n            } else {\n                output.push_str(\"*Content unavailable*\\n\\n\");\n            }\n        }\n\n        output.push_str(\"---\\n\\n\");\n    }\n\n    output.trim_end().to_string()\n}\n\n// ============================================================================\n// Handler\n// ============================================================================\n\n/// Handle the `hu utils web-search` command\npub async fn run(args: WebSearchArgs) -\u003e Result\u003c()\u003e {\n    let creds = load_credentials()?;\n    let brave = creds\n        .brave\n        .context(\"Brave API key not configured. Add [brave] section to credentials.toml\")?;\n\n    let client = BraveSearchClient::from_credentials(\u0026brave);\n    let fetcher = DefaultHttpFetcher::new();\n\n    let fetch_content = !args.list;\n    let results =\n        search_and_fetch(\u0026client, \u0026fetcher, \u0026args.query, args.results, fetch_content).await?;\n\n    let output = format_results(\u0026results, fetch_content);\n\n    if let Some(path) = args.output {\n        fs::write(\u0026path, \u0026output).with_context(|| format!(\"Failed to write to {}\", path))?;\n        eprintln!(\"Written to {}\", path);\n    } else {\n        println!(\"{}\", output);\n    }\n\n    Ok(())\n}\n\n// ============================================================================\n// Tests\n// ============================================================================\n","traces":[{"line":65,"address":[],"length":0,"stats":{"Line":2}},{"line":66,"address":[],"length":0,"stats":{"Line":4}},{"line":73,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":3}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":1}},{"line":128,"address":[],"length":0,"stats":{"Line":1}},{"line":133,"address":[],"length":0,"stats":{"Line":2}},{"line":134,"address":[],"length":0,"stats":{"Line":4}},{"line":136,"address":[],"length":0,"stats":{"Line":4}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":4}},{"line":172,"address":[],"length":0,"stats":{"Line":20}},{"line":174,"address":[],"length":0,"stats":{"Line":8}},{"line":175,"address":[],"length":0,"stats":{"Line":23}},{"line":176,"address":[],"length":0,"stats":{"Line":14}},{"line":177,"address":[],"length":0,"stats":{"Line":16}},{"line":178,"address":[],"length":0,"stats":{"Line":4}},{"line":179,"address":[],"length":0,"stats":{"Line":2}},{"line":182,"address":[],"length":0,"stats":{"Line":3}},{"line":185,"address":[],"length":0,"stats":{"Line":21}},{"line":186,"address":[],"length":0,"stats":{"Line":14}},{"line":187,"address":[],"length":0,"stats":{"Line":14}},{"line":188,"address":[],"length":0,"stats":{"Line":7}},{"line":189,"address":[],"length":0,"stats":{"Line":7}},{"line":193,"address":[],"length":0,"stats":{"Line":4}},{"line":197,"address":[],"length":0,"stats":{"Line":4}},{"line":198,"address":[],"length":0,"stats":{"Line":8}},{"line":200,"address":[],"length":0,"stats":{"Line":20}},{"line":201,"address":[],"length":0,"stats":{"Line":16}},{"line":202,"address":[],"length":0,"stats":{"Line":12}},{"line":204,"address":[],"length":0,"stats":{"Line":7}},{"line":205,"address":[],"length":0,"stats":{"Line":9}},{"line":208,"address":[],"length":0,"stats":{"Line":4}},{"line":209,"address":[],"length":0,"stats":{"Line":4}},{"line":210,"address":[],"length":0,"stats":{"Line":4}},{"line":211,"address":[],"length":0,"stats":{"Line":4}},{"line":212,"address":[],"length":0,"stats":{"Line":2}},{"line":214,"address":[],"length":0,"stats":{"Line":2}},{"line":218,"address":[],"length":0,"stats":{"Line":12}},{"line":221,"address":[],"length":0,"stats":{"Line":8}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}}],"covered":39,"coverable":58},{"path":["/","Users","chi","Projects","hu","src","utils","web_search","tests.rs"],"content":"use super::*;\n\n// Mock implementations for testing\nstruct MockBraveApi {\n    results: Vec\u003cSearchResult\u003e,\n}\n\n#[async_trait::async_trait]\nimpl BraveSearchApi for MockBraveApi {\n    async fn search(\u0026self, _query: \u0026str, count: usize) -\u003e Result\u003cVec\u003cSearchResult\u003e\u003e {\n        Ok(self.results.iter().take(count).cloned().collect())\n    }\n}\n\nstruct MockFetcher {\n    content: String,\n}\n\n#[async_trait::async_trait]\nimpl HttpFetcher for MockFetcher {\n    async fn fetch(\u0026self, _url: \u0026str) -\u003e Result\u003cString\u003e {\n        Ok(self.content.clone())\n    }\n}\n\nstruct FailingFetcher;\n\n#[async_trait::async_trait]\nimpl HttpFetcher for FailingFetcher {\n    async fn fetch(\u0026self, url: \u0026str) -\u003e Result\u003cString\u003e {\n        bail!(\"Failed to fetch {}\", url)\n    }\n}\n\nfn sample_results() -\u003e Vec\u003cSearchResult\u003e {\n    vec![\n        SearchResult {\n            title: \"Result One\".to_string(),\n            url: \"https://example.com/one\".to_string(),\n            description: \"First result description\".to_string(),\n        },\n        SearchResult {\n            title: \"Result Two\".to_string(),\n            url: \"https://example.com/two\".to_string(),\n            description: \"Second result description\".to_string(),\n        },\n        SearchResult {\n            title: \"Result Three\".to_string(),\n            url: \"https://example.com/three\".to_string(),\n            description: \"\".to_string(),\n        },\n    ]\n}\n\n#[test]\nfn search_result_debug() {\n    let result = SearchResult {\n        title: \"Test\".to_string(),\n        url: \"https://test.com\".to_string(),\n        description: \"Desc\".to_string(),\n    };\n    let debug = format!(\"{:?}\", result);\n    assert!(debug.contains(\"SearchResult\"));\n    assert!(debug.contains(\"Test\"));\n}\n\n#[test]\nfn search_result_clone() {\n    let result = SearchResult {\n        title: \"Test\".to_string(),\n        url: \"https://test.com\".to_string(),\n        description: \"Desc\".to_string(),\n    };\n    let cloned = result.clone();\n    assert_eq!(cloned.title, result.title);\n    assert_eq!(cloned.url, result.url);\n}\n\n#[test]\nfn web_results_debug() {\n    let results = WebResults { results: vec![] };\n    let debug = format!(\"{:?}\", results);\n    assert!(debug.contains(\"WebResults\"));\n}\n\n#[test]\nfn brave_search_response_debug() {\n    let response = BraveSearchResponse { web: None };\n    let debug = format!(\"{:?}\", response);\n    assert!(debug.contains(\"BraveSearchResponse\"));\n}\n\n#[test]\nfn fetched_result_debug() {\n    let result = FetchedResult {\n        title: \"Test\".to_string(),\n        url: \"https://test.com\".to_string(),\n        description: \"Desc\".to_string(),\n        content: Some(\"Content\".to_string()),\n    };\n    let debug = format!(\"{:?}\", result);\n    assert!(debug.contains(\"FetchedResult\"));\n}\n\n#[test]\nfn brave_client_new() {\n    let client = BraveSearchClient::new(\"test_key\".to_string());\n    assert_eq!(client.api_key, \"test_key\");\n}\n\n#[test]\nfn brave_client_from_credentials() {\n    let creds = BraveCredentials {\n        api_key: \"creds_key\".to_string(),\n    };\n    let client = BraveSearchClient::from_credentials(\u0026creds);\n    assert_eq!(client.api_key, \"creds_key\");\n}\n\n#[test]\nfn default_http_fetcher_new() {\n    let fetcher = DefaultHttpFetcher::new();\n    let _ = format!(\"{:?}\", fetcher.http);\n}\n\n#[test]\nfn default_http_fetcher_default() {\n    let fetcher = DefaultHttpFetcher::default();\n    let _ = format!(\"{:?}\", fetcher.http);\n}\n\n#[tokio::test]\nasync fn search_and_fetch_without_content() {\n    let api = MockBraveApi {\n        results: sample_results(),\n    };\n    let fetcher = MockFetcher {\n        content: \"\u003cp\u003eTest\u003c/p\u003e\".to_string(),\n    };\n\n    let results = search_and_fetch(\u0026api, \u0026fetcher, \"test\", 2, false)\n        .await\n        .unwrap();\n\n    assert_eq!(results.len(), 2);\n    assert_eq!(results[0].title, \"Result One\");\n    assert!(results[0].content.is_none());\n}\n\n#[tokio::test]\nasync fn search_and_fetch_with_content() {\n    let api = MockBraveApi {\n        results: sample_results(),\n    };\n    let fetcher = MockFetcher {\n        content: \"\u003cp\u003eFetched content here\u003c/p\u003e\".to_string(),\n    };\n\n    let results = search_and_fetch(\u0026api, \u0026fetcher, \"test\", 2, true)\n        .await\n        .unwrap();\n\n    assert_eq!(results.len(), 2);\n    assert!(results[0].content.is_some());\n    assert!(results[0].content.as_ref().unwrap().contains(\"Fetched\"));\n}\n\n#[tokio::test]\nasync fn search_and_fetch_handles_fetch_failure() {\n    let api = MockBraveApi {\n        results: sample_results(),\n    };\n    let fetcher = FailingFetcher;\n\n    let results = search_and_fetch(\u0026api, \u0026fetcher, \"test\", 2, true)\n        .await\n        .unwrap();\n\n    assert_eq!(results.len(), 2);\n    assert!(results[0].content.is_none());\n}\n\n#[tokio::test]\nasync fn search_and_fetch_limits_results() {\n    let api = MockBraveApi {\n        results: sample_results(),\n    };\n    let fetcher = MockFetcher {\n        content: \"\u003cp\u003eTest\u003c/p\u003e\".to_string(),\n    };\n\n    let results = search_and_fetch(\u0026api, \u0026fetcher, \"test\", 1, false)\n        .await\n        .unwrap();\n\n    assert_eq!(results.len(), 1);\n}\n\n#[test]\nfn format_results_list_mode() {\n    let results = vec![\n        FetchedResult {\n            title: \"Title One\".to_string(),\n            url: \"https://one.com\".to_string(),\n            description: \"Description one\".to_string(),\n            content: None,\n        },\n        FetchedResult {\n            title: \"Title Two\".to_string(),\n            url: \"https://two.com\".to_string(),\n            description: \"\".to_string(),\n            content: None,\n        },\n    ];\n\n    let output = format_results(\u0026results, false);\n    assert!(output.contains(\"## 1. Title One\"));\n    assert!(output.contains(\"**URL:** https://one.com\"));\n    assert!(output.contains(\"\u003e Description one\"));\n    assert!(output.contains(\"## 2. Title Two\"));\n    assert!(!output.contains(\"### Content\"));\n}\n\n#[test]\nfn format_results_with_content() {\n    let results = vec![FetchedResult {\n        title: \"Title\".to_string(),\n        url: \"https://test.com\".to_string(),\n        description: \"Desc\".to_string(),\n        content: Some(\"The actual content\".to_string()),\n    }];\n\n    let output = format_results(\u0026results, true);\n    assert!(output.contains(\"### Content\"));\n    assert!(output.contains(\"The actual content\"));\n}\n\n#[test]\nfn format_results_content_unavailable() {\n    let results = vec![FetchedResult {\n        title: \"Title\".to_string(),\n        url: \"https://test.com\".to_string(),\n        description: \"Desc\".to_string(),\n        content: None,\n    }];\n\n    let output = format_results(\u0026results, true);\n    assert!(output.contains(\"*Content unavailable*\"));\n}\n\n#[test]\nfn format_results_empty() {\n    let results: Vec\u003cFetchedResult\u003e = vec![];\n    let output = format_results(\u0026results, false);\n    assert!(output.is_empty());\n}\n\n#[test]\nfn brave_search_response_deserialize() {\n    let json =\n        r#\"{\"web\": {\"results\": [{\"title\": \"Test\", \"url\": \"https://t.com\", \"description\": \"D\"}]}}\"#;\n    let response: BraveSearchResponse = serde_json::from_str(json).unwrap();\n    assert!(response.web.is_some());\n    let web = response.web.unwrap();\n    assert_eq!(web.results.len(), 1);\n    assert_eq!(web.results[0].title, \"Test\");\n}\n\n#[test]\nfn brave_search_response_deserialize_empty() {\n    let json = r#\"{}\"#;\n    let response: BraveSearchResponse = serde_json::from_str(json).unwrap();\n    assert!(response.web.is_none());\n}\n\n#[test]\nfn brave_search_response_deserialize_empty_web() {\n    let json = r#\"{\"web\": {\"results\": []}}\"#;\n    let response: BraveSearchResponse = serde_json::from_str(json).unwrap();\n    assert!(response.web.is_some());\n    assert!(response.web.unwrap().results.is_empty());\n}\n\n#[test]\nfn search_result_deserialize_missing_description() {\n    let json = r#\"{\"title\": \"Test\", \"url\": \"https://t.com\"}\"#;\n    let result: SearchResult = serde_json::from_str(json).unwrap();\n    assert_eq!(result.title, \"Test\");\n    assert_eq!(result.description, \"\");\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":4}},{"line":21,"address":[],"length":0,"stats":{"Line":2}},{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":35,"address":[],"length":0,"stats":{"Line":4}},{"line":36,"address":[],"length":0,"stats":{"Line":4}},{"line":37,"address":[],"length":0,"stats":{"Line":4}},{"line":38,"address":[],"length":0,"stats":{"Line":12}},{"line":39,"address":[],"length":0,"stats":{"Line":12}},{"line":40,"address":[],"length":0,"stats":{"Line":4}},{"line":42,"address":[],"length":0,"stats":{"Line":4}},{"line":43,"address":[],"length":0,"stats":{"Line":12}},{"line":44,"address":[],"length":0,"stats":{"Line":12}},{"line":45,"address":[],"length":0,"stats":{"Line":4}},{"line":47,"address":[],"length":0,"stats":{"Line":4}},{"line":48,"address":[],"length":0,"stats":{"Line":12}},{"line":49,"address":[],"length":0,"stats":{"Line":12}},{"line":50,"address":[],"length":0,"stats":{"Line":4}}],"covered":17,"coverable":17}]};
        var previousData = {"files":[{"path":["/","Users","chi","Projects","hu","src","cli.rs"],"content":"use clap::{Parser, Subcommand};\n\nuse crate::context::ContextCommand;\nuse crate::data::DataCommand;\nuse crate::docs::DocsCommand;\nuse crate::eks::EksCommand;\nuse crate::gh::GhCommand;\nuse crate::install::InstallCommand;\nuse crate::jira::JiraCommand;\nuse crate::newrelic::NewRelicCommand;\nuse crate::pagerduty::PagerDutyCommand;\nuse crate::pipeline::PipelineCommand;\nuse crate::read::ReadArgs;\nuse crate::sentry::SentryCommand;\nuse crate::slack::SlackCommands;\nuse crate::utils::UtilsCommand;\n\n#[derive(Parser)]\n#[command(name = \"hu\")]\n#[command(about = \"Dev workflow CLI\", long_about = None)]\n#[command(version)]\npub struct Cli {\n    #[command(subcommand)]\n    pub command: Option\u003cCommand\u003e,\n}\n\n#[derive(Subcommand)]\npub enum Command {\n    /// Jira operations (tickets, sprint, search)\n    Jira {\n        #[command(subcommand)]\n        cmd: Option\u003cJiraCommand\u003e,\n    },\n\n    /// GitHub operations (prs, runs, failures)\n    Gh {\n        #[command(subcommand)]\n        cmd: Option\u003cGhCommand\u003e,\n    },\n\n    /// Slack operations (messages, channels)\n    Slack {\n        #[command(subcommand)]\n        cmd: Option\u003cSlackCommands\u003e,\n    },\n\n    /// PagerDuty (oncall, alerts)\n    #[command(name = \"pagerduty\", alias = \"pd\")]\n    PagerDuty {\n        #[command(subcommand)]\n        cmd: Option\u003cPagerDutyCommand\u003e,\n    },\n\n    /// Sentry (issues, errors)\n    Sentry {\n        #[command(subcommand)]\n        cmd: Option\u003cSentryCommand\u003e,\n    },\n\n    /// NewRelic (incidents, queries)\n    #[command(name = \"newrelic\", alias = \"nr\")]\n    NewRelic {\n        #[command(subcommand)]\n        cmd: Option\u003cNewRelicCommand\u003e,\n    },\n\n    /// EKS pod access (list, exec, logs)\n    Eks {\n        #[command(subcommand)]\n        cmd: Option\u003cEksCommand\u003e,\n    },\n\n    /// CodePipeline status (read-only)\n    Pipeline {\n        #[command(subcommand)]\n        cmd: Option\u003cPipelineCommand\u003e,\n    },\n\n    /// Utility commands (fetch-html, grep)\n    Utils {\n        #[command(subcommand)]\n        cmd: Option\u003cUtilsCommand\u003e,\n    },\n\n    /// Session context tracking (prevent duplicate file reads)\n    Context {\n        #[command(subcommand)]\n        cmd: Option\u003cContextCommand\u003e,\n    },\n\n    /// Smart file reading (outline, interface, around, diff)\n    Read(ReadArgs),\n\n    /// Claude Code session data (sync, stats, search)\n    Data {\n        #[command(subcommand)]\n        cmd: Option\u003cDataCommand\u003e,\n    },\n\n    /// Install hu hooks and commands to Claude Code\n    Install {\n        #[command(subcommand)]\n        cmd: Option\u003cInstallCommand\u003e,\n    },\n\n    /// Documentation management (add, get, list, remove, sync)\n    Docs {\n        #[command(subcommand)]\n        cmd: Option\u003cDocsCommand\u003e,\n    },\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","context","cli.rs"],"content":"use clap::{Args, Subcommand};\n\n#[derive(Debug, Subcommand)]\npub enum ContextCommand {\n    /// Track a file as loaded in context\n    Track(TrackArgs),\n    /// Check if a file is in context\n    Check(CheckArgs),\n    /// Show summary of all tracked files\n    Summary,\n    /// Clear all tracked files\n    Clear,\n}\n\n#[derive(Debug, Args)]\npub struct TrackArgs {\n    /// File path(s) to track\n    #[arg(required = true)]\n    pub paths: Vec\u003cString\u003e,\n}\n\n#[derive(Debug, Args)]\npub struct CheckArgs {\n    /// File path(s) to check\n    #[arg(required = true)]\n    pub paths: Vec\u003cString\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use clap::Parser;\n\n    #[derive(Parser)]\n    struct TestCli {\n        #[command(subcommand)]\n        cmd: ContextCommand,\n    }\n\n    #[test]\n    fn parse_track_single() {\n        let cli = TestCli::try_parse_from([\"test\", \"track\", \"file.rs\"]).unwrap();\n        if let ContextCommand::Track(args) = cli.cmd {\n            assert_eq!(args.paths, vec![\"file.rs\"]);\n        } else {\n            panic!(\"Expected Track\");\n        }\n    }\n\n    #[test]\n    fn parse_track_multiple() {\n        let cli = TestCli::try_parse_from([\"test\", \"track\", \"a.rs\", \"b.rs\", \"c.rs\"]).unwrap();\n        if let ContextCommand::Track(args) = cli.cmd {\n            assert_eq!(args.paths, vec![\"a.rs\", \"b.rs\", \"c.rs\"]);\n        } else {\n            panic!(\"Expected Track\");\n        }\n    }\n\n    #[test]\n    fn parse_check_single() {\n        let cli = TestCli::try_parse_from([\"test\", \"check\", \"file.rs\"]).unwrap();\n        if let ContextCommand::Check(args) = cli.cmd {\n            assert_eq!(args.paths, vec![\"file.rs\"]);\n        } else {\n            panic!(\"Expected Check\");\n        }\n    }\n\n    #[test]\n    fn parse_check_multiple() {\n        let cli = TestCli::try_parse_from([\"test\", \"check\", \"a.rs\", \"b.rs\"]).unwrap();\n        if let ContextCommand::Check(args) = cli.cmd {\n            assert_eq!(args.paths, vec![\"a.rs\", \"b.rs\"]);\n        } else {\n            panic!(\"Expected Check\");\n        }\n    }\n\n    #[test]\n    fn parse_summary() {\n        let cli = TestCli::try_parse_from([\"test\", \"summary\"]).unwrap();\n        assert!(matches!(cli.cmd, ContextCommand::Summary));\n    }\n\n    #[test]\n    fn parse_clear() {\n        let cli = TestCli::try_parse_from([\"test\", \"clear\"]).unwrap();\n        assert!(matches!(cli.cmd, ContextCommand::Clear));\n    }\n\n    #[test]\n    fn track_requires_path() {\n        let result = TestCli::try_parse_from([\"test\", \"track\"]);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn check_requires_path() {\n        let result = TestCli::try_parse_from([\"test\", \"check\"]);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn track_args_debug() {\n        let args = TrackArgs {\n            paths: vec![\"a.rs\".to_string()],\n        };\n        let debug = format!(\"{:?}\", args);\n        assert!(debug.contains(\"TrackArgs\"));\n    }\n\n    #[test]\n    fn check_args_debug() {\n        let args = CheckArgs {\n            paths: vec![\"a.rs\".to_string()],\n        };\n        let debug = format!(\"{:?}\", args);\n        assert!(debug.contains(\"CheckArgs\"));\n    }\n\n    #[test]\n    fn context_command_debug() {\n        let cmd = ContextCommand::Summary;\n        let debug = format!(\"{:?}\", cmd);\n        assert!(debug.contains(\"Summary\"));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","context","mod.rs"],"content":"mod cli;\nmod service;\nmod store;\nmod types;\n\npub use cli::ContextCommand;\n\nuse anyhow::Result;\n\n/// Run a context subcommand\npub async fn run_command(cmd: ContextCommand) -\u003e Result\u003c()\u003e {\n    match cmd {\n        ContextCommand::Track(args) =\u003e service::track(\u0026args.paths).await,\n        ContextCommand::Check(args) =\u003e service::check(\u0026args.paths).await,\n        ContextCommand::Summary =\u003e service::summary().await,\n        ContextCommand::Clear =\u003e service::clear().await,\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["/","Users","chi","Projects","hu","src","context","service","mod.rs"],"content":"use anyhow::{Context, Result};\nuse std::fs;\nuse std::io::BufRead;\nuse std::path::PathBuf;\nuse std::time::SystemTime;\n\nuse super::store::{default_store, ContextStore};\nuse super::types::{ContextEntry, ContextState, FileStatus};\n\n#[cfg(test)]\nmod tests;\n\n/// Track file(s) as loaded in context\npub async fn track(paths: \u0026[String]) -\u003e Result\u003c()\u003e {\n    let store = default_store()?;\n    track_with_store(\u0026store, paths)\n}\n\n/// Track files using a specific store (for testing)\npub fn track_with_store(store: \u0026impl ContextStore, paths: \u0026[String]) -\u003e Result\u003c()\u003e {\n    let mut state = store.load()?;\n\n    for path_str in paths {\n        let path = resolve_path(path_str)?;\n        let (size, line_count) = get_file_info(\u0026path)?;\n        let entry = ContextEntry::new(path.clone(), size, line_count);\n        state.track(entry);\n        println!(\n            \"Tracked: {} ({} lines, {} bytes)\",\n            path.display(),\n            line_count,\n            size\n        );\n    }\n\n    store.save(\u0026state)?;\n    Ok(())\n}\n\n/// Check if file(s) are in context\npub async fn check(paths: \u0026[String]) -\u003e Result\u003c()\u003e {\n    let store = default_store()?;\n    check_with_store(\u0026store, paths)\n}\n\n/// Check files using a specific store (for testing)\npub fn check_with_store(store: \u0026impl ContextStore, paths: \u0026[String]) -\u003e Result\u003c()\u003e {\n    let state = store.load()?;\n    let now = current_timestamp();\n\n    for path_str in paths {\n        let path = resolve_path(path_str)?;\n        let status = get_file_status(\u0026state, \u0026path, now)?;\n        print_file_status(\u0026status);\n    }\n\n    Ok(())\n}\n\n/// Show summary of all tracked files\npub async fn summary() -\u003e Result\u003c()\u003e {\n    let store = default_store()?;\n    summary_with_store(\u0026store)\n}\n\n/// Show summary using a specific store (for testing)\npub fn summary_with_store(store: \u0026impl ContextStore) -\u003e Result\u003c()\u003e {\n    let state = store.load()?;\n    let now = current_timestamp();\n\n    if state.file_count() == 0 {\n        println!(\"No files tracked in context\");\n        return Ok(());\n    }\n\n    println!(\"Session: {}\", state.session_id);\n    println!();\n\n    let mut entries: Vec\u003c_\u003e = state.all_entries().into_iter().collect();\n    entries.sort_by(|a, b| b.tracked_at.cmp(\u0026a.tracked_at));\n\n    for entry in \u0026entries {\n        let age = format_age(now.saturating_sub(entry.tracked_at));\n        println!(\n            \"  {} ({} lines, {}) - {}\",\n            entry.path.display(),\n            entry.line_count,\n            format_bytes(entry.size),\n            age\n        );\n    }\n\n    println!();\n    println!(\n        \"Total: {} files, {} lines, {}\",\n        state.file_count(),\n        state.total_lines(),\n        format_bytes(state.total_bytes())\n    );\n\n    Ok(())\n}\n\n/// Clear all tracked files\npub async fn clear() -\u003e Result\u003c()\u003e {\n    let store = default_store()?;\n    clear_with_store(\u0026store)\n}\n\n/// Clear using a specific store (for testing)\npub fn clear_with_store(store: \u0026impl ContextStore) -\u003e Result\u003c()\u003e {\n    store.delete()?;\n    println!(\"Context cleared\");\n    Ok(())\n}\n\n/// Get file status relative to current context\npub fn get_file_status(state: \u0026ContextState, path: \u0026PathBuf, now: u64) -\u003e Result\u003cFileStatus\u003e {\n    if let Some(entry) = state.get(path) {\n        let age_secs = now.saturating_sub(entry.tracked_at);\n        Ok(FileStatus::Loaded {\n            entry: entry.clone(),\n            age_secs,\n        })\n    } else {\n        let (size, line_count) = get_file_info(path)?;\n        Ok(FileStatus::NotLoaded {\n            path: path.clone(),\n            size,\n            line_count,\n        })\n    }\n}\n\n/// Resolve a path string to an absolute path\nfn resolve_path(path_str: \u0026str) -\u003e Result\u003cPathBuf\u003e {\n    let path = PathBuf::from(path_str);\n    let resolved = if path.is_absolute() {\n        path\n    } else {\n        std::env::current_dir()\n            .context(\"Failed to get current directory\")?\n            .join(path)\n    };\n\n    resolved\n        .canonicalize()\n        .with_context(|| format!(\"Path not found: {}\", path_str))\n}\n\n/// Get file size and line count\nfn get_file_info(path: \u0026PathBuf) -\u003e Result\u003c(u64, usize)\u003e {\n    let metadata = fs::metadata(path)\n        .with_context(|| format!(\"Failed to read metadata for {}\", path.display()))?;\n    let size = metadata.len();\n\n    let file =\n        fs::File::open(path).with_context(|| format!(\"Failed to open {}\", path.display()))?;\n    let reader = std::io::BufReader::new(file);\n    let line_count = reader.lines().count();\n\n    Ok((size, line_count))\n}\n\n/// Get current Unix timestamp\nfn current_timestamp() -\u003e u64 {\n    SystemTime::now()\n        .duration_since(SystemTime::UNIX_EPOCH)\n        .map(|d| d.as_secs())\n        .unwrap_or(0)\n}\n\n/// Print file status to stdout\nfn print_file_status(status: \u0026FileStatus) {\n    match status {\n        FileStatus::Loaded { entry, age_secs } =\u003e {\n            let age = format_age(*age_secs);\n            println!(\n                \"{}: loaded {} ({} lines)\",\n                entry.path.display(),\n                age,\n                entry.line_count\n            );\n        }\n        FileStatus::NotLoaded {\n            path,\n            size: _,\n            line_count,\n        } =\u003e {\n            println!(\"{}: not loaded ({} lines)\", path.display(), line_count);\n        }\n    }\n}\n\n/// Format seconds as human-readable age\nfn format_age(secs: u64) -\u003e String {\n    if secs \u003c 60 {\n        format!(\"{}s ago\", secs)\n    } else if secs \u003c 3600 {\n        format!(\"{}m ago\", secs / 60)\n    } else if secs \u003c 86400 {\n        format!(\"{}h ago\", secs / 3600)\n    } else {\n        format!(\"{}d ago\", secs / 86400)\n    }\n}\n\n/// Format bytes as human-readable size\nfn format_bytes(bytes: u64) -\u003e String {\n    if bytes \u003c 1024 {\n        format!(\"{} B\", bytes)\n    } else if bytes \u003c 1024 * 1024 {\n        format!(\"{:.1} KB\", bytes as f64 / 1024.0)\n    } else {\n        format!(\"{:.1} MB\", bytes as f64 / (1024.0 * 1024.0))\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":1}},{"line":21,"address":[],"length":0,"stats":{"Line":3}},{"line":23,"address":[],"length":0,"stats":{"Line":3}},{"line":24,"address":[],"length":0,"stats":{"Line":3}},{"line":25,"address":[],"length":0,"stats":{"Line":4}},{"line":26,"address":[],"length":0,"stats":{"Line":6}},{"line":27,"address":[],"length":0,"stats":{"Line":3}},{"line":28,"address":[],"length":0,"stats":{"Line":1}},{"line":29,"address":[],"length":0,"stats":{"Line":1}},{"line":30,"address":[],"length":0,"stats":{"Line":1}},{"line":36,"address":[],"length":0,"stats":{"Line":3}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":1}},{"line":48,"address":[],"length":0,"stats":{"Line":3}},{"line":49,"address":[],"length":0,"stats":{"Line":2}},{"line":51,"address":[],"length":0,"stats":{"Line":3}},{"line":52,"address":[],"length":0,"stats":{"Line":3}},{"line":53,"address":[],"length":0,"stats":{"Line":5}},{"line":54,"address":[],"length":0,"stats":{"Line":2}},{"line":57,"address":[],"length":0,"stats":{"Line":1}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":2}},{"line":68,"address":[],"length":0,"stats":{"Line":6}},{"line":69,"address":[],"length":0,"stats":{"Line":4}},{"line":71,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":2}},{"line":77,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":6}},{"line":80,"address":[],"length":0,"stats":{"Line":5}},{"line":82,"address":[],"length":0,"stats":{"Line":7}},{"line":83,"address":[],"length":0,"stats":{"Line":12}},{"line":84,"address":[],"length":0,"stats":{"Line":4}},{"line":85,"address":[],"length":0,"stats":{"Line":4}},{"line":86,"address":[],"length":0,"stats":{"Line":4}},{"line":87,"address":[],"length":0,"stats":{"Line":2}},{"line":88,"address":[],"length":0,"stats":{"Line":2}},{"line":89,"address":[],"length":0,"stats":{"Line":2}},{"line":93,"address":[],"length":0,"stats":{"Line":1}},{"line":94,"address":[],"length":0,"stats":{"Line":1}},{"line":95,"address":[],"length":0,"stats":{"Line":1}},{"line":96,"address":[],"length":0,"stats":{"Line":2}},{"line":97,"address":[],"length":0,"stats":{"Line":2}},{"line":98,"address":[],"length":0,"stats":{"Line":3}},{"line":101,"address":[],"length":0,"stats":{"Line":1}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":1}},{"line":112,"address":[],"length":0,"stats":{"Line":2}},{"line":113,"address":[],"length":0,"stats":{"Line":2}},{"line":114,"address":[],"length":0,"stats":{"Line":1}},{"line":118,"address":[],"length":0,"stats":{"Line":3}},{"line":119,"address":[],"length":0,"stats":{"Line":8}},{"line":120,"address":[],"length":0,"stats":{"Line":8}},{"line":121,"address":[],"length":0,"stats":{"Line":2}},{"line":122,"address":[],"length":0,"stats":{"Line":4}},{"line":123,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":4}},{"line":127,"address":[],"length":0,"stats":{"Line":1}},{"line":128,"address":[],"length":0,"stats":{"Line":3}},{"line":129,"address":[],"length":0,"stats":{"Line":1}},{"line":130,"address":[],"length":0,"stats":{"Line":1}},{"line":136,"address":[],"length":0,"stats":{"Line":5}},{"line":137,"address":[],"length":0,"stats":{"Line":15}},{"line":138,"address":[],"length":0,"stats":{"Line":10}},{"line":139,"address":[],"length":0,"stats":{"Line":4}},{"line":141,"address":[],"length":0,"stats":{"Line":1}},{"line":143,"address":[],"length":0,"stats":{"Line":2}},{"line":146,"address":[],"length":0,"stats":{"Line":5}},{"line":148,"address":[],"length":0,"stats":{"Line":7}},{"line":152,"address":[],"length":0,"stats":{"Line":4}},{"line":153,"address":[],"length":0,"stats":{"Line":11}},{"line":154,"address":[],"length":0,"stats":{"Line":8}},{"line":155,"address":[],"length":0,"stats":{"Line":9}},{"line":157,"address":[],"length":0,"stats":{"Line":3}},{"line":158,"address":[],"length":0,"stats":{"Line":9}},{"line":159,"address":[],"length":0,"stats":{"Line":9}},{"line":160,"address":[],"length":0,"stats":{"Line":12}},{"line":162,"address":[],"length":0,"stats":{"Line":3}},{"line":166,"address":[],"length":0,"stats":{"Line":5}},{"line":167,"address":[],"length":0,"stats":{"Line":5}},{"line":168,"address":[],"length":0,"stats":{"Line":5}},{"line":169,"address":[],"length":0,"stats":{"Line":15}},{"line":174,"address":[],"length":0,"stats":{"Line":3}},{"line":175,"address":[],"length":0,"stats":{"Line":3}},{"line":176,"address":[],"length":0,"stats":{"Line":6}},{"line":177,"address":[],"length":0,"stats":{"Line":8}},{"line":178,"address":[],"length":0,"stats":{"Line":4}},{"line":179,"address":[],"length":0,"stats":{"Line":4}},{"line":180,"address":[],"length":0,"stats":{"Line":2}},{"line":181,"address":[],"length":0,"stats":{"Line":2}},{"line":182,"address":[],"length":0,"stats":{"Line":2}},{"line":186,"address":[],"length":0,"stats":{"Line":1}},{"line":188,"address":[],"length":0,"stats":{"Line":1}},{"line":189,"address":[],"length":0,"stats":{"Line":1}},{"line":190,"address":[],"length":0,"stats":{"Line":3}},{"line":196,"address":[],"length":0,"stats":{"Line":15}},{"line":197,"address":[],"length":0,"stats":{"Line":15}},{"line":198,"address":[],"length":0,"stats":{"Line":6}},{"line":199,"address":[],"length":0,"stats":{"Line":12}},{"line":200,"address":[],"length":0,"stats":{"Line":15}},{"line":201,"address":[],"length":0,"stats":{"Line":7}},{"line":202,"address":[],"length":0,"stats":{"Line":9}},{"line":204,"address":[],"length":0,"stats":{"Line":12}},{"line":209,"address":[],"length":0,"stats":{"Line":11}},{"line":210,"address":[],"length":0,"stats":{"Line":11}},{"line":211,"address":[],"length":0,"stats":{"Line":12}},{"line":212,"address":[],"length":0,"stats":{"Line":5}},{"line":213,"address":[],"length":0,"stats":{"Line":9}},{"line":215,"address":[],"length":0,"stats":{"Line":6}}],"covered":108,"coverable":120},{"path":["/","Users","chi","Projects","hu","src","context","service","tests.rs"],"content":"use super::*;\nuse std::cell::RefCell;\n\n/// Mock store for testing\nstruct MockStore {\n    state: RefCell\u003cContextState\u003e,\n    session_id: String,\n    deleted: RefCell\u003cbool\u003e,\n}\n\nimpl MockStore {\n    fn new() -\u003e Self {\n        Self {\n            state: RefCell::new(ContextState::new(\"mock-session\".to_string())),\n            session_id: \"mock-session\".to_string(),\n            deleted: RefCell::new(false),\n        }\n    }\n\n    fn with_state(state: ContextState) -\u003e Self {\n        let session_id = state.session_id.clone();\n        Self {\n            state: RefCell::new(state),\n            session_id,\n            deleted: RefCell::new(false),\n        }\n    }\n}\n\nimpl ContextStore for MockStore {\n    fn load(\u0026self) -\u003e Result\u003cContextState\u003e {\n        Ok(self.state.borrow().clone())\n    }\n\n    fn save(\u0026self, state: \u0026ContextState) -\u003e Result\u003c()\u003e {\n        *self.state.borrow_mut() = state.clone();\n        Ok(())\n    }\n\n    fn delete(\u0026self) -\u003e Result\u003c()\u003e {\n        *self.deleted.borrow_mut() = true;\n        Ok(())\n    }\n}\n\n#[test]\nfn format_age_seconds() {\n    assert_eq!(format_age(0), \"0s ago\");\n    assert_eq!(format_age(30), \"30s ago\");\n    assert_eq!(format_age(59), \"59s ago\");\n}\n\n#[test]\nfn format_age_minutes() {\n    assert_eq!(format_age(60), \"1m ago\");\n    assert_eq!(format_age(120), \"2m ago\");\n    assert_eq!(format_age(3599), \"59m ago\");\n}\n\n#[test]\nfn format_age_hours() {\n    assert_eq!(format_age(3600), \"1h ago\");\n    assert_eq!(format_age(7200), \"2h ago\");\n    assert_eq!(format_age(86399), \"23h ago\");\n}\n\n#[test]\nfn format_age_days() {\n    assert_eq!(format_age(86400), \"1d ago\");\n    assert_eq!(format_age(172800), \"2d ago\");\n}\n\n#[test]\nfn format_bytes_b() {\n    assert_eq!(format_bytes(0), \"0 B\");\n    assert_eq!(format_bytes(512), \"512 B\");\n    assert_eq!(format_bytes(1023), \"1023 B\");\n}\n\n#[test]\nfn format_bytes_kb() {\n    assert_eq!(format_bytes(1024), \"1.0 KB\");\n    assert_eq!(format_bytes(2048), \"2.0 KB\");\n    assert_eq!(format_bytes(1536), \"1.5 KB\");\n}\n\n#[test]\nfn format_bytes_mb() {\n    assert_eq!(format_bytes(1024 * 1024), \"1.0 MB\");\n    assert_eq!(format_bytes(2 * 1024 * 1024), \"2.0 MB\");\n}\n\n#[test]\nfn get_file_status_loaded() {\n    let mut state = ContextState::new(\"s\".to_string());\n    state.track(ContextEntry::with_timestamp(\n        PathBuf::from(\"/test.rs\"),\n        100,\n        10,\n        1000,\n    ));\n\n    let status = get_file_status(\u0026state, \u0026PathBuf::from(\"/test.rs\"), 1060).unwrap();\n    if let FileStatus::Loaded { entry, age_secs } = status {\n        assert_eq!(entry.size, 100);\n        assert_eq!(entry.line_count, 10);\n        assert_eq!(age_secs, 60);\n    } else {\n        panic!(\"Expected Loaded\");\n    }\n}\n\n#[test]\nfn get_file_status_not_loaded() {\n    let state = ContextState::new(\"s\".to_string());\n    // Use Cargo.toml which we know exists\n    let path = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\")).join(\"Cargo.toml\");\n    let status = get_file_status(\u0026state, \u0026path, 1000).unwrap();\n    assert!(matches!(status, FileStatus::NotLoaded { .. }));\n}\n\n#[test]\nfn clear_with_store_deletes() {\n    let store = MockStore::new();\n    clear_with_store(\u0026store).unwrap();\n    assert!(*store.deleted.borrow());\n}\n\n#[test]\nfn summary_with_store_empty() {\n    let store = MockStore::new();\n    // Just verify it doesn't panic\n    summary_with_store(\u0026store).unwrap();\n}\n\n#[test]\nfn summary_with_store_with_entries() {\n    let mut state = ContextState::new(\"test\".to_string());\n    state.track(ContextEntry::with_timestamp(\n        PathBuf::from(\"/a.rs\"),\n        100,\n        10,\n        1000,\n    ));\n    state.track(ContextEntry::with_timestamp(\n        PathBuf::from(\"/b.rs\"),\n        200,\n        20,\n        2000,\n    ));\n    let store = MockStore::with_state(state);\n    summary_with_store(\u0026store).unwrap();\n}\n\n#[test]\nfn track_with_store_real_file() {\n    let store = MockStore::new();\n    let cargo_toml = env!(\"CARGO_MANIFEST_DIR\").to_string() + \"/Cargo.toml\";\n    track_with_store(\u0026store, \u0026[cargo_toml]).unwrap();\n\n    let state = store.load().unwrap();\n    assert_eq!(state.file_count(), 1);\n}\n\n#[test]\nfn check_with_store_real_file() {\n    let mut state = ContextState::new(\"test\".to_string());\n    let cargo_path = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\")).join(\"Cargo.toml\");\n    state.track(ContextEntry::with_timestamp(\n        cargo_path.clone(),\n        100,\n        10,\n        current_timestamp() - 60,\n    ));\n    let store = MockStore::with_state(state);\n\n    check_with_store(\u0026store, \u0026[cargo_path.to_string_lossy().to_string()]).unwrap();\n}\n\n#[test]\nfn resolve_path_absolute() {\n    let result = resolve_path(\"/tmp\").unwrap();\n    assert!(result.is_absolute());\n}\n\n#[test]\nfn resolve_path_relative() {\n    // Cargo.toml should exist in project root\n    let result = resolve_path(\"Cargo.toml\").unwrap();\n    assert!(result.is_absolute());\n    assert!(result.to_string_lossy().ends_with(\"Cargo.toml\"));\n}\n\n#[test]\nfn resolve_path_not_found() {\n    let result = resolve_path(\"/nonexistent/path/to/file.xyz\");\n    assert!(result.is_err());\n}\n\n#[test]\nfn get_file_info_real_file() {\n    let path = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\")).join(\"Cargo.toml\");\n    let (size, line_count) = get_file_info(\u0026path).unwrap();\n    assert!(size \u003e 0);\n    assert!(line_count \u003e 0);\n}\n\n#[test]\nfn get_file_info_missing_file() {\n    let path = PathBuf::from(\"/nonexistent/file.txt\");\n    let result = get_file_info(\u0026path);\n    assert!(result.is_err());\n}\n\n#[test]\nfn current_timestamp_returns_value() {\n    let ts = current_timestamp();\n    // Should be a reasonable Unix timestamp (after 2020)\n    assert!(ts \u003e 1577836800);\n}\n\n#[test]\nfn mock_store_load_save() {\n    let store = MockStore::new();\n    let mut state = store.load().unwrap();\n    state.track(ContextEntry::new(PathBuf::from(\"/test.rs\"), 100, 10));\n    store.save(\u0026state).unwrap();\n\n    let loaded = store.load().unwrap();\n    assert_eq!(loaded.file_count(), 1);\n}\n\n#[test]\nfn mock_store_session_id() {\n    let store = MockStore::new();\n    assert_eq!(store.session_id, \"mock-session\");\n}\n\n#[test]\nfn print_file_status_loaded() {\n    let entry = ContextEntry::with_timestamp(PathBuf::from(\"/test.rs\"), 100, 10, 1000);\n    let status = FileStatus::Loaded {\n        entry,\n        age_secs: 60,\n    };\n    // Just verify it doesn't panic - output goes to stdout\n    print_file_status(\u0026status);\n}\n\n#[test]\nfn print_file_status_not_loaded() {\n    let status = FileStatus::NotLoaded {\n        path: PathBuf::from(\"/test.rs\"),\n        size: 100,\n        line_count: 10,\n    };\n    // Just verify it doesn't panic - output goes to stdout\n    print_file_status(\u0026status);\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":5}},{"line":14,"address":[],"length":0,"stats":{"Line":25}},{"line":15,"address":[],"length":0,"stats":{"Line":10}},{"line":16,"address":[],"length":0,"stats":{"Line":5}},{"line":20,"address":[],"length":0,"stats":{"Line":2}},{"line":21,"address":[],"length":0,"stats":{"Line":6}},{"line":23,"address":[],"length":0,"stats":{"Line":6}},{"line":25,"address":[],"length":0,"stats":{"Line":2}},{"line":31,"address":[],"length":0,"stats":{"Line":7}},{"line":32,"address":[],"length":0,"stats":{"Line":7}},{"line":35,"address":[],"length":0,"stats":{"Line":2}},{"line":36,"address":[],"length":0,"stats":{"Line":6}},{"line":37,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":1}},{"line":41,"address":[],"length":0,"stats":{"Line":1}},{"line":42,"address":[],"length":0,"stats":{"Line":1}}],"covered":16,"coverable":16},{"path":["/","Users","chi","Projects","hu","src","context","store.rs"],"content":"use anyhow::{Context, Result};\nuse std::env;\nuse std::fs;\nuse std::path::PathBuf;\n\nuse super::types::ContextState;\n\n/// Trait for context storage (enables mocking in tests)\npub trait ContextStore {\n    fn load(\u0026self) -\u003e Result\u003cContextState\u003e;\n    fn save(\u0026self, state: \u0026ContextState) -\u003e Result\u003c()\u003e;\n    fn delete(\u0026self) -\u003e Result\u003c()\u003e;\n}\n\n/// File-based context store\npub struct FileContextStore {\n    path: PathBuf,\n    session_id: String,\n}\n\nimpl FileContextStore {\n    /// Create a new file context store\n    pub fn new() -\u003e Result\u003cSelf\u003e {\n        let session_id = get_session_id();\n        let path = context_file_path(\u0026session_id);\n        Ok(Self { path, session_id })\n    }\n\n    /// Create with explicit path (for testing)\n    #[cfg(test)]\n    pub fn with_path(path: PathBuf, session_id: String) -\u003e Self {\n        Self { path, session_id }\n    }\n}\n\nimpl ContextStore for FileContextStore {\n    fn load(\u0026self) -\u003e Result\u003cContextState\u003e {\n        if !self.path.exists() {\n            return Ok(ContextState::new(self.session_id.clone()));\n        }\n\n        let contents = fs::read_to_string(\u0026self.path)\n            .with_context(|| format!(\"Failed to read {}\", self.path.display()))?;\n\n        serde_json::from_str(\u0026contents)\n            .with_context(|| format!(\"Failed to parse {}\", self.path.display()))\n    }\n\n    fn save(\u0026self, state: \u0026ContextState) -\u003e Result\u003c()\u003e {\n        if let Some(dir) = self.path.parent() {\n            fs::create_dir_all(dir)\n                .with_context(|| format!(\"Failed to create directory {}\", dir.display()))?;\n        }\n\n        let contents =\n            serde_json::to_string_pretty(state).context(\"Failed to serialize context state\")?;\n\n        fs::write(\u0026self.path, contents)\n            .with_context(|| format!(\"Failed to write {}\", self.path.display()))?;\n\n        Ok(())\n    }\n\n    fn delete(\u0026self) -\u003e Result\u003c()\u003e {\n        if self.path.exists() {\n            fs::remove_file(\u0026self.path)\n                .with_context(|| format!(\"Failed to delete {}\", self.path.display()))?;\n        }\n        Ok(())\n    }\n}\n\n/// Get session ID from environment or generate one\nfn get_session_id() -\u003e String {\n    env::var(\"CLAUDE_SESSION_ID\").unwrap_or_else(|_| {\n        // Use a stable ID based on process ID and start time\n        // This gives same ID within a session but different across sessions\n        format!(\"hu-{}\", std::process::id())\n    })\n}\n\n/// Get path to context file for a session\nfn context_file_path(session_id: \u0026str) -\u003e PathBuf {\n    let tmp = env::temp_dir();\n    tmp.join(format!(\"hu-context-{}.json\", session_id))\n}\n\n/// Get the default store instance\npub fn default_store() -\u003e Result\u003cFileContextStore\u003e {\n    FileContextStore::new()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::context::types::ContextEntry;\n\n    fn temp_store() -\u003e (FileContextStore, PathBuf) {\n        let tmp_dir = std::env::temp_dir().join(format!(\"hu_store_test_{}\", rand_suffix()));\n        let _ = std::fs::create_dir_all(\u0026tmp_dir);\n        let path = tmp_dir.join(\"context.json\");\n        let store = FileContextStore::with_path(path.clone(), \"test-session\".to_string());\n        (store, tmp_dir)\n    }\n\n    fn rand_suffix() -\u003e u64 {\n        use std::time::{SystemTime, UNIX_EPOCH};\n        SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .unwrap()\n            .as_nanos() as u64\n    }\n\n    #[test]\n    fn file_context_store_new() {\n        let store = FileContextStore::new().unwrap();\n        assert!(!store.session_id.is_empty());\n    }\n\n    #[test]\n    fn file_context_store_with_path() {\n        let store = FileContextStore::with_path(PathBuf::from(\"/test/path\"), \"sid\".to_string());\n        assert_eq!(store.path, PathBuf::from(\"/test/path\"));\n        assert_eq!(store.session_id, \"sid\");\n    }\n\n    #[test]\n    fn store_session_id() {\n        let store = FileContextStore::with_path(PathBuf::from(\"/tmp/x\"), \"my-session\".to_string());\n        assert_eq!(store.session_id, \"my-session\");\n    }\n\n    #[test]\n    fn store_load_missing_file() {\n        let (store, tmp_dir) = temp_store();\n        let state = store.load().unwrap();\n        assert_eq!(state.session_id, \"test-session\");\n        assert!(state.entries.is_empty());\n        let _ = std::fs::remove_dir_all(\u0026tmp_dir);\n    }\n\n    #[test]\n    fn store_save_and_load() {\n        let (store, tmp_dir) = temp_store();\n\n        let mut state = ContextState::new(\"test-session\".to_string());\n        state.track(ContextEntry::with_timestamp(\n            PathBuf::from(\"/test.rs\"),\n            100,\n            10,\n            123,\n        ));\n\n        store.save(\u0026state).unwrap();\n        assert!(store.path.exists());\n\n        let loaded = store.load().unwrap();\n        assert_eq!(loaded.session_id, \"test-session\");\n        assert_eq!(loaded.file_count(), 1);\n\n        let _ = std::fs::remove_dir_all(\u0026tmp_dir);\n    }\n\n    #[test]\n    fn store_delete() {\n        let (store, tmp_dir) = temp_store();\n\n        let state = ContextState::new(\"test-session\".to_string());\n        store.save(\u0026state).unwrap();\n        assert!(store.path.exists());\n\n        store.delete().unwrap();\n        assert!(!store.path.exists());\n\n        let _ = std::fs::remove_dir_all(\u0026tmp_dir);\n    }\n\n    #[test]\n    fn store_delete_missing_file() {\n        let (store, tmp_dir) = temp_store();\n        // Delete should succeed even if file doesn't exist\n        store.delete().unwrap();\n        let _ = std::fs::remove_dir_all(\u0026tmp_dir);\n    }\n\n    #[test]\n    fn store_save_creates_parent_dirs() {\n        let tmp_dir = std::env::temp_dir().join(format!(\"hu_nested_{}/a/b\", rand_suffix()));\n        let path = tmp_dir.join(\"context.json\");\n        let store = FileContextStore::with_path(path.clone(), \"s\".to_string());\n\n        let state = ContextState::new(\"s\".to_string());\n        store.save(\u0026state).unwrap();\n        assert!(path.exists());\n\n        let _ = std::fs::remove_dir_all(\n            std::env::temp_dir().join(format!(\"hu_nested_{}\", rand_suffix())),\n        );\n    }\n\n    #[test]\n    fn store_overwrites_existing() {\n        let (store, tmp_dir) = temp_store();\n\n        let mut state1 = ContextState::new(\"test-session\".to_string());\n        state1.track(ContextEntry::with_timestamp(\n            PathBuf::from(\"/old.rs\"),\n            1,\n            1,\n            1,\n        ));\n        store.save(\u0026state1).unwrap();\n\n        let mut state2 = ContextState::new(\"test-session\".to_string());\n        state2.track(ContextEntry::with_timestamp(\n            PathBuf::from(\"/new.rs\"),\n            2,\n            2,\n            2,\n        ));\n        store.save(\u0026state2).unwrap();\n\n        let loaded = store.load().unwrap();\n        assert_eq!(loaded.file_count(), 1);\n        assert!(loaded.is_tracked(\u0026PathBuf::from(\"/new.rs\")));\n        assert!(!loaded.is_tracked(\u0026PathBuf::from(\"/old.rs\")));\n\n        let _ = std::fs::remove_dir_all(\u0026tmp_dir);\n    }\n\n    #[test]\n    fn get_session_id_from_env() {\n        // This test just verifies the function runs\n        let id = get_session_id();\n        assert!(!id.is_empty());\n    }\n\n    #[test]\n    fn context_file_path_format() {\n        let path = context_file_path(\"my-session-123\");\n        let path_str = path.to_string_lossy();\n        assert!(path_str.contains(\"hu-context-my-session-123.json\"));\n    }\n\n    #[test]\n    fn default_store_creates() {\n        let store = default_store().unwrap();\n        assert!(!store.session_id.is_empty());\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":2}},{"line":24,"address":[],"length":0,"stats":{"Line":4}},{"line":25,"address":[],"length":0,"stats":{"Line":6}},{"line":26,"address":[],"length":0,"stats":{"Line":2}},{"line":31,"address":[],"length":0,"stats":{"Line":8}},{"line":37,"address":[],"length":0,"stats":{"Line":3}},{"line":38,"address":[],"length":0,"stats":{"Line":3}},{"line":39,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":6}},{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":4}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":5}},{"line":50,"address":[],"length":0,"stats":{"Line":10}},{"line":51,"address":[],"length":0,"stats":{"Line":10}},{"line":52,"address":[],"length":0,"stats":{"Line":5}},{"line":55,"address":[],"length":0,"stats":{"Line":5}},{"line":56,"address":[],"length":0,"stats":{"Line":15}},{"line":58,"address":[],"length":0,"stats":{"Line":15}},{"line":59,"address":[],"length":0,"stats":{"Line":5}},{"line":61,"address":[],"length":0,"stats":{"Line":5}},{"line":64,"address":[],"length":0,"stats":{"Line":2}},{"line":65,"address":[],"length":0,"stats":{"Line":2}},{"line":66,"address":[],"length":0,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":1}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":74,"address":[],"length":0,"stats":{"Line":3}},{"line":75,"address":[],"length":0,"stats":{"Line":9}},{"line":78,"address":[],"length":0,"stats":{"Line":9}},{"line":83,"address":[],"length":0,"stats":{"Line":3}},{"line":84,"address":[],"length":0,"stats":{"Line":6}},{"line":85,"address":[],"length":0,"stats":{"Line":9}},{"line":89,"address":[],"length":0,"stats":{"Line":1}},{"line":90,"address":[],"length":0,"stats":{"Line":1}}],"covered":34,"coverable":34},{"path":["/","Users","chi","Projects","hu","src","context","types.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::path::{Path, PathBuf};\nuse std::time::SystemTime;\n\n/// Entry for a tracked file in the context\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct ContextEntry {\n    /// Absolute path to the file\n    pub path: PathBuf,\n    /// File size in bytes\n    pub size: u64,\n    /// Number of lines in the file\n    pub line_count: usize,\n    /// When the file was tracked (Unix timestamp)\n    pub tracked_at: u64,\n}\n\nimpl ContextEntry {\n    /// Create a new context entry from file metadata\n    pub fn new(path: PathBuf, size: u64, line_count: usize) -\u003e Self {\n        let tracked_at = SystemTime::now()\n            .duration_since(SystemTime::UNIX_EPOCH)\n            .map(|d| d.as_secs())\n            .unwrap_or(0);\n\n        Self {\n            path,\n            size,\n            line_count,\n            tracked_at,\n        }\n    }\n\n    /// Create entry with explicit timestamp (for testing)\n    #[cfg(test)]\n    pub fn with_timestamp(path: PathBuf, size: u64, line_count: usize, tracked_at: u64) -\u003e Self {\n        Self {\n            path,\n            size,\n            line_count,\n            tracked_at,\n        }\n    }\n}\n\n/// Complete context state for a session\n#[derive(Debug, Clone, Serialize, Deserialize, Default, PartialEq)]\npub struct ContextState {\n    /// Session ID this context belongs to\n    pub session_id: String,\n    /// Map of canonical path string to entry\n    pub entries: HashMap\u003cString, ContextEntry\u003e,\n}\n\nimpl ContextState {\n    /// Create a new empty context state\n    pub fn new(session_id: String) -\u003e Self {\n        Self {\n            session_id,\n            entries: HashMap::new(),\n        }\n    }\n\n    /// Add or update an entry\n    pub fn track(\u0026mut self, entry: ContextEntry) {\n        let key = entry.path.to_string_lossy().to_string();\n        self.entries.insert(key, entry);\n    }\n\n    /// Get an entry by path\n    pub fn get(\u0026self, path: \u0026Path) -\u003e Option\u003c\u0026ContextEntry\u003e {\n        let key = path.to_string_lossy().to_string();\n        self.entries.get(\u0026key)\n    }\n\n    /// Check if a path is tracked\n    #[cfg(test)]\n    pub fn is_tracked(\u0026self, path: \u0026Path) -\u003e bool {\n        let key = path.to_string_lossy().to_string();\n        self.entries.contains_key(\u0026key)\n    }\n\n    /// Get all entries\n    pub fn all_entries(\u0026self) -\u003e Vec\u003c\u0026ContextEntry\u003e {\n        self.entries.values().collect()\n    }\n\n    /// Clear all entries\n    #[cfg(test)]\n    pub fn clear(\u0026mut self) {\n        self.entries.clear();\n    }\n\n    /// Total tracked files\n    pub fn file_count(\u0026self) -\u003e usize {\n        self.entries.len()\n    }\n\n    /// Total bytes tracked\n    pub fn total_bytes(\u0026self) -\u003e u64 {\n        self.entries.values().map(|e| e.size).sum()\n    }\n\n    /// Total lines tracked\n    pub fn total_lines(\u0026self) -\u003e usize {\n        self.entries.values().map(|e| e.line_count).sum()\n    }\n}\n\n/// Result of checking a file's status\n#[derive(Debug, Clone, PartialEq)]\npub enum FileStatus {\n    /// File is already in context\n    Loaded { entry: ContextEntry, age_secs: u64 },\n    /// File is not in context\n    NotLoaded {\n        path: PathBuf,\n        size: u64,\n        line_count: usize,\n    },\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn context_entry_new() {\n        let entry = ContextEntry::new(PathBuf::from(\"/test/file.rs\"), 1024, 50);\n        assert_eq!(entry.path, PathBuf::from(\"/test/file.rs\"));\n        assert_eq!(entry.size, 1024);\n        assert_eq!(entry.line_count, 50);\n        assert!(entry.tracked_at \u003e 0);\n    }\n\n    #[test]\n    fn context_entry_with_timestamp() {\n        let entry = ContextEntry::with_timestamp(PathBuf::from(\"/test.rs\"), 512, 25, 1000);\n        assert_eq!(entry.tracked_at, 1000);\n    }\n\n    #[test]\n    fn context_entry_clone() {\n        let entry = ContextEntry::new(PathBuf::from(\"/test.rs\"), 100, 10);\n        let cloned = entry.clone();\n        assert_eq!(entry, cloned);\n    }\n\n    #[test]\n    fn context_entry_debug() {\n        let entry = ContextEntry::new(PathBuf::from(\"/test.rs\"), 100, 10);\n        let debug = format!(\"{:?}\", entry);\n        assert!(debug.contains(\"ContextEntry\"));\n    }\n\n    #[test]\n    fn context_entry_serialize_deserialize() {\n        let entry = ContextEntry::with_timestamp(PathBuf::from(\"/test.rs\"), 100, 10, 12345);\n        let json = serde_json::to_string(\u0026entry).unwrap();\n        let parsed: ContextEntry = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(entry, parsed);\n    }\n\n    #[test]\n    fn context_state_new() {\n        let state = ContextState::new(\"session123\".to_string());\n        assert_eq!(state.session_id, \"session123\");\n        assert!(state.entries.is_empty());\n    }\n\n    #[test]\n    fn context_state_default() {\n        let state = ContextState::default();\n        assert_eq!(state.session_id, \"\");\n        assert!(state.entries.is_empty());\n    }\n\n    #[test]\n    fn context_state_track() {\n        let mut state = ContextState::new(\"s1\".to_string());\n        let entry = ContextEntry::new(PathBuf::from(\"/a.rs\"), 100, 10);\n        state.track(entry.clone());\n\n        assert_eq!(state.file_count(), 1);\n        assert!(state.is_tracked(\u0026PathBuf::from(\"/a.rs\")));\n    }\n\n    #[test]\n    fn context_state_get() {\n        let mut state = ContextState::new(\"s1\".to_string());\n        let entry = ContextEntry::with_timestamp(PathBuf::from(\"/a.rs\"), 100, 10, 500);\n        state.track(entry);\n\n        let got = state.get(\u0026PathBuf::from(\"/a.rs\")).unwrap();\n        assert_eq!(got.size, 100);\n        assert_eq!(got.line_count, 10);\n    }\n\n    #[test]\n    fn context_state_get_missing() {\n        let state = ContextState::new(\"s1\".to_string());\n        assert!(state.get(\u0026PathBuf::from(\"/missing.rs\")).is_none());\n    }\n\n    #[test]\n    fn context_state_is_tracked() {\n        let mut state = ContextState::new(\"s1\".to_string());\n        state.track(ContextEntry::new(PathBuf::from(\"/yes.rs\"), 1, 1));\n\n        assert!(state.is_tracked(\u0026PathBuf::from(\"/yes.rs\")));\n        assert!(!state.is_tracked(\u0026PathBuf::from(\"/no.rs\")));\n    }\n\n    #[test]\n    fn context_state_all_entries() {\n        let mut state = ContextState::new(\"s1\".to_string());\n        state.track(ContextEntry::new(PathBuf::from(\"/a.rs\"), 100, 10));\n        state.track(ContextEntry::new(PathBuf::from(\"/b.rs\"), 200, 20));\n\n        let entries = state.all_entries();\n        assert_eq!(entries.len(), 2);\n    }\n\n    #[test]\n    fn context_state_clear() {\n        let mut state = ContextState::new(\"s1\".to_string());\n        state.track(ContextEntry::new(PathBuf::from(\"/a.rs\"), 100, 10));\n        assert_eq!(state.file_count(), 1);\n\n        state.clear();\n        assert_eq!(state.file_count(), 0);\n    }\n\n    #[test]\n    fn context_state_totals() {\n        let mut state = ContextState::new(\"s1\".to_string());\n        state.track(ContextEntry::new(PathBuf::from(\"/a.rs\"), 100, 10));\n        state.track(ContextEntry::new(PathBuf::from(\"/b.rs\"), 200, 20));\n\n        assert_eq!(state.total_bytes(), 300);\n        assert_eq!(state.total_lines(), 30);\n    }\n\n    #[test]\n    fn context_state_update_existing() {\n        let mut state = ContextState::new(\"s1\".to_string());\n        state.track(ContextEntry::with_timestamp(\n            PathBuf::from(\"/a.rs\"),\n            100,\n            10,\n            1,\n        ));\n        state.track(ContextEntry::with_timestamp(\n            PathBuf::from(\"/a.rs\"),\n            200,\n            20,\n            2,\n        ));\n\n        assert_eq!(state.file_count(), 1);\n        let entry = state.get(\u0026PathBuf::from(\"/a.rs\")).unwrap();\n        assert_eq!(entry.size, 200);\n        assert_eq!(entry.tracked_at, 2);\n    }\n\n    #[test]\n    fn context_state_serialize_deserialize() {\n        let mut state = ContextState::new(\"session\".to_string());\n        state.track(ContextEntry::with_timestamp(\n            PathBuf::from(\"/test.rs\"),\n            100,\n            10,\n            123,\n        ));\n\n        let json = serde_json::to_string(\u0026state).unwrap();\n        let parsed: ContextState = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(state, parsed);\n    }\n\n    #[test]\n    fn context_state_clone() {\n        let mut state = ContextState::new(\"s1\".to_string());\n        state.track(ContextEntry::new(PathBuf::from(\"/a.rs\"), 100, 10));\n\n        let cloned = state.clone();\n        assert_eq!(state, cloned);\n    }\n\n    #[test]\n    fn context_state_debug() {\n        let state = ContextState::new(\"s1\".to_string());\n        let debug = format!(\"{:?}\", state);\n        assert!(debug.contains(\"ContextState\"));\n    }\n\n    #[test]\n    fn file_status_loaded() {\n        let entry = ContextEntry::with_timestamp(PathBuf::from(\"/a.rs\"), 100, 10, 1);\n        let status = FileStatus::Loaded {\n            entry: entry.clone(),\n            age_secs: 60,\n        };\n        if let FileStatus::Loaded { entry: e, age_secs } = status {\n            assert_eq!(e.path, PathBuf::from(\"/a.rs\"));\n            assert_eq!(age_secs, 60);\n        } else {\n            panic!(\"Expected Loaded\");\n        }\n    }\n\n    #[test]\n    fn file_status_not_loaded() {\n        let status = FileStatus::NotLoaded {\n            path: PathBuf::from(\"/b.rs\"),\n            size: 500,\n            line_count: 50,\n        };\n        if let FileStatus::NotLoaded {\n            path,\n            size,\n            line_count,\n        } = status\n        {\n            assert_eq!(path, PathBuf::from(\"/b.rs\"));\n            assert_eq!(size, 500);\n            assert_eq!(line_count, 50);\n        } else {\n            panic!(\"Expected NotLoaded\");\n        }\n    }\n\n    #[test]\n    fn file_status_clone() {\n        let status = FileStatus::NotLoaded {\n            path: PathBuf::from(\"/a.rs\"),\n            size: 100,\n            line_count: 10,\n        };\n        let cloned = status.clone();\n        assert_eq!(status, cloned);\n    }\n\n    #[test]\n    fn file_status_debug() {\n        let status = FileStatus::NotLoaded {\n            path: PathBuf::from(\"/a.rs\"),\n            size: 100,\n            line_count: 10,\n        };\n        let debug = format!(\"{:?}\", status);\n        assert!(debug.contains(\"NotLoaded\"));\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":13}},{"line":22,"address":[],"length":0,"stats":{"Line":26}},{"line":23,"address":[],"length":0,"stats":{"Line":13}},{"line":24,"address":[],"length":0,"stats":{"Line":39}},{"line":37,"address":[],"length":0,"stats":{"Line":15}},{"line":58,"address":[],"length":0,"stats":{"Line":27}},{"line":61,"address":[],"length":0,"stats":{"Line":27}},{"line":66,"address":[],"length":0,"stats":{"Line":21}},{"line":67,"address":[],"length":0,"stats":{"Line":63}},{"line":68,"address":[],"length":0,"stats":{"Line":84}},{"line":72,"address":[],"length":0,"stats":{"Line":6}},{"line":73,"address":[],"length":0,"stats":{"Line":18}},{"line":74,"address":[],"length":0,"stats":{"Line":18}},{"line":79,"address":[],"length":0,"stats":{"Line":5}},{"line":80,"address":[],"length":0,"stats":{"Line":15}},{"line":81,"address":[],"length":0,"stats":{"Line":15}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":6}},{"line":91,"address":[],"length":0,"stats":{"Line":1}},{"line":92,"address":[],"length":0,"stats":{"Line":2}},{"line":96,"address":[],"length":0,"stats":{"Line":11}},{"line":97,"address":[],"length":0,"stats":{"Line":22}},{"line":101,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":8}},{"line":106,"address":[],"length":0,"stats":{"Line":2}},{"line":107,"address":[],"length":0,"stats":{"Line":8}}],"covered":26,"coverable":26},{"path":["/","Users","chi","Projects","hu","src","data","cli.rs"],"content":"use clap::Subcommand;\n\n#[derive(Subcommand, Debug)]\npub enum DataCommand {\n    /// Sync Claude Code data to local database\n    Sync {\n        /// Force full resync\n        #[arg(short, long)]\n        force: bool,\n\n        /// Quiet output\n        #[arg(short, long)]\n        quiet: bool,\n    },\n\n    /// Show data configuration\n    Config {\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n    },\n\n    /// Session operations\n    Session {\n        #[command(subcommand)]\n        cmd: SessionCommand,\n    },\n\n    /// Usage statistics\n    Stats {\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n\n        /// Today only\n        #[arg(short, long)]\n        today: bool,\n    },\n\n    /// Todo operations\n    Todos {\n        #[command(subcommand)]\n        cmd: TodosCommand,\n    },\n\n    /// Search messages\n    Search {\n        /// Search query\n        query: String,\n\n        /// Max results\n        #[arg(short = 'n', long, default_value = \"20\")]\n        limit: i64,\n\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n    },\n\n    /// Tool usage statistics\n    Tools {\n        /// Show detail for specific tool\n        #[arg(short, long)]\n        tool: Option\u003cString\u003e,\n\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n    },\n\n    /// Extract errors from debug logs\n    Errors {\n        /// Days to look back\n        #[arg(short, long, default_value = \"7\")]\n        recent: u32,\n\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n    },\n\n    /// Pricing analysis\n    Pricing {\n        /// Subscription tier\n        #[arg(short, long, default_value = \"max20x\")]\n        subscription: String,\n\n        /// Billing day of month\n        #[arg(short, long, default_value = \"6\")]\n        billing_day: u32,\n\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n    },\n\n    /// Branch activity statistics\n    Branches {\n        /// Filter by branch name\n        #[arg(short, long)]\n        branch: Option\u003cString\u003e,\n\n        /// Max results\n        #[arg(short, long, default_value = \"20\")]\n        limit: i64,\n\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n    },\n}\n\n#[derive(Subcommand, Debug)]\npub enum SessionCommand {\n    /// List sessions\n    List {\n        /// Filter by project\n        #[arg(short, long)]\n        project: Option\u003cString\u003e,\n\n        /// Max results\n        #[arg(short = 'n', long, default_value = \"20\")]\n        limit: i64,\n\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n    },\n\n    /// Read session messages\n    Read {\n        /// Session ID (or prefix)\n        id: String,\n\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n    },\n\n    /// Show current session\n    Current {\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n    },\n}\n\n#[derive(Subcommand, Debug)]\npub enum TodosCommand {\n    /// List all todos\n    List {\n        /// Filter by status\n        #[arg(short, long)]\n        status: Option\u003cString\u003e,\n\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n    },\n\n    /// Show pending todos\n    Pending {\n        /// Filter by project\n        #[arg(short, long)]\n        project: Option\u003cString\u003e,\n\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n    },\n}\n\n#[cfg(test)]\nmod tests {\n    use clap::Parser;\n\n    #[derive(Parser)]\n    struct TestCli {\n        #[command(subcommand)]\n        cmd: super::DataCommand,\n    }\n\n    #[test]\n    fn parse_sync() {\n        let cli = TestCli::try_parse_from([\"test\", \"sync\"]).unwrap();\n        assert!(matches!(\n            cli.cmd,\n            super::DataCommand::Sync {\n                force: false,\n                quiet: false\n            }\n        ));\n    }\n\n    #[test]\n    fn parse_sync_force() {\n        let cli = TestCli::try_parse_from([\"test\", \"sync\", \"-f\"]).unwrap();\n        assert!(matches!(\n            cli.cmd,\n            super::DataCommand::Sync { force: true, .. }\n        ));\n    }\n\n    #[test]\n    fn parse_config() {\n        let cli = TestCli::try_parse_from([\"test\", \"config\"]).unwrap();\n        assert!(matches!(\n            cli.cmd,\n            super::DataCommand::Config { json: false }\n        ));\n    }\n\n    #[test]\n    fn parse_config_json() {\n        let cli = TestCli::try_parse_from([\"test\", \"config\", \"-j\"]).unwrap();\n        assert!(matches!(cli.cmd, super::DataCommand::Config { json: true }));\n    }\n\n    #[test]\n    fn parse_session_list() {\n        let cli = TestCli::try_parse_from([\"test\", \"session\", \"list\"]).unwrap();\n        assert!(matches!(\n            cli.cmd,\n            super::DataCommand::Session {\n                cmd: super::SessionCommand::List { .. }\n            }\n        ));\n    }\n\n    #[test]\n    fn parse_session_list_with_project() {\n        let cli = TestCli::try_parse_from([\"test\", \"session\", \"list\", \"-p\", \"myproj\"]).unwrap();\n        if let super::DataCommand::Session {\n            cmd: super::SessionCommand::List { project, .. },\n        } = cli.cmd\n        {\n            assert_eq!(project, Some(\"myproj\".to_string()));\n        } else {\n            panic!(\"wrong variant\");\n        }\n    }\n\n    #[test]\n    fn parse_session_read() {\n        let cli = TestCli::try_parse_from([\"test\", \"session\", \"read\", \"abc-123\"]).unwrap();\n        if let super::DataCommand::Session {\n            cmd: super::SessionCommand::Read { id, .. },\n        } = cli.cmd\n        {\n            assert_eq!(id, \"abc-123\");\n        } else {\n            panic!(\"wrong variant\");\n        }\n    }\n\n    #[test]\n    fn parse_session_current() {\n        let cli = TestCli::try_parse_from([\"test\", \"session\", \"current\"]).unwrap();\n        assert!(matches!(\n            cli.cmd,\n            super::DataCommand::Session {\n                cmd: super::SessionCommand::Current { .. }\n            }\n        ));\n    }\n\n    #[test]\n    fn parse_stats() {\n        let cli = TestCli::try_parse_from([\"test\", \"stats\"]).unwrap();\n        assert!(matches!(cli.cmd, super::DataCommand::Stats { .. }));\n    }\n\n    #[test]\n    fn parse_stats_today() {\n        let cli = TestCli::try_parse_from([\"test\", \"stats\", \"-t\"]).unwrap();\n        if let super::DataCommand::Stats { today, .. } = cli.cmd {\n            assert!(today);\n        } else {\n            panic!(\"wrong variant\");\n        }\n    }\n\n    #[test]\n    fn parse_todos_list() {\n        let cli = TestCli::try_parse_from([\"test\", \"todos\", \"list\"]).unwrap();\n        assert!(matches!(\n            cli.cmd,\n            super::DataCommand::Todos {\n                cmd: super::TodosCommand::List { .. }\n            }\n        ));\n    }\n\n    #[test]\n    fn parse_todos_pending() {\n        let cli = TestCli::try_parse_from([\"test\", \"todos\", \"pending\"]).unwrap();\n        assert!(matches!(\n            cli.cmd,\n            super::DataCommand::Todos {\n                cmd: super::TodosCommand::Pending { .. }\n            }\n        ));\n    }\n\n    #[test]\n    fn parse_search() {\n        let cli = TestCli::try_parse_from([\"test\", \"search\", \"hello\"]).unwrap();\n        if let super::DataCommand::Search { query, limit, .. } = cli.cmd {\n            assert_eq!(query, \"hello\");\n            assert_eq!(limit, 20);\n        } else {\n            panic!(\"wrong variant\");\n        }\n    }\n\n    #[test]\n    fn parse_search_with_limit() {\n        let cli = TestCli::try_parse_from([\"test\", \"search\", \"hello\", \"-n\", \"5\"]).unwrap();\n        if let super::DataCommand::Search { limit, .. } = cli.cmd {\n            assert_eq!(limit, 5);\n        } else {\n            panic!(\"wrong variant\");\n        }\n    }\n\n    #[test]\n    fn parse_tools() {\n        let cli = TestCli::try_parse_from([\"test\", \"tools\"]).unwrap();\n        assert!(matches!(\n            cli.cmd,\n            super::DataCommand::Tools { tool: None, .. }\n        ));\n    }\n\n    #[test]\n    fn parse_tools_specific() {\n        let cli = TestCli::try_parse_from([\"test\", \"tools\", \"-t\", \"Read\"]).unwrap();\n        if let super::DataCommand::Tools { tool, .. } = cli.cmd {\n            assert_eq!(tool, Some(\"Read\".to_string()));\n        } else {\n            panic!(\"wrong variant\");\n        }\n    }\n\n    #[test]\n    fn parse_errors() {\n        let cli = TestCli::try_parse_from([\"test\", \"errors\"]).unwrap();\n        if let super::DataCommand::Errors { recent, .. } = cli.cmd {\n            assert_eq!(recent, 7);\n        } else {\n            panic!(\"wrong variant\");\n        }\n    }\n\n    #[test]\n    fn parse_pricing() {\n        let cli = TestCli::try_parse_from([\"test\", \"pricing\"]).unwrap();\n        if let super::DataCommand::Pricing {\n            subscription,\n            billing_day,\n            ..\n        } = cli.cmd\n        {\n            assert_eq!(subscription, \"max20x\");\n            assert_eq!(billing_day, 6);\n        } else {\n            panic!(\"wrong variant\");\n        }\n    }\n\n    #[test]\n    fn parse_branches() {\n        let cli = TestCli::try_parse_from([\"test\", \"branches\"]).unwrap();\n        assert!(matches!(cli.cmd, super::DataCommand::Branches { .. }));\n    }\n\n    #[test]\n    fn parse_branches_with_filter() {\n        let cli = TestCli::try_parse_from([\"test\", \"branches\", \"-b\", \"feature\"]).unwrap();\n        if let super::DataCommand::Branches { branch, .. } = cli.cmd {\n            assert_eq!(branch, Some(\"feature\".to_string()));\n        } else {\n            panic!(\"wrong variant\");\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","data","config.rs"],"content":"use anyhow::Result;\nuse std::path::PathBuf;\n\n#[derive(Debug, Clone)]\npub struct DataConfig {\n    pub claude_dir: PathBuf,\n    pub database: PathBuf,\n    pub auto_sync_interval: u64,\n    pub sync_on_start: bool,\n}\n\nimpl Default for DataConfig {\n    fn default() -\u003e Self {\n        Self {\n            claude_dir: expand_path(\"~/.claude\"),\n            database: resolve_db_path(\"hu.db\"),\n            auto_sync_interval: 300,\n            sync_on_start: true,\n        }\n    }\n}\n\npub fn expand_path(path: \u0026str) -\u003e PathBuf {\n    if let Some(rest) = path.strip_prefix(\"~/\") {\n        if let Some(home) = dirs::home_dir() {\n            return home.join(rest);\n        }\n    }\n    if path == \"~\" {\n        if let Some(home) = dirs::home_dir() {\n            return home;\n        }\n    }\n    PathBuf::from(path)\n}\n\npub fn resolve_db_path(db: \u0026str) -\u003e PathBuf {\n    let path = PathBuf::from(db);\n    if path.is_absolute() {\n        return path;\n    }\n    if db.starts_with(\"~/\") {\n        return expand_path(db);\n    }\n    config_dir().join(db)\n}\n\nfn config_dir() -\u003e PathBuf {\n    config_dir_with_home(dirs::home_dir())\n}\n\nfn config_dir_with_home(home: Option\u003cPathBuf\u003e) -\u003e PathBuf {\n    match home {\n        Some(h) =\u003e h.join(\".config\").join(\"hu\"),\n        None =\u003e PathBuf::from(\".config/hu\"),\n    }\n}\n\n#[cfg(not(tarpaulin_include))]\npub fn load_data_config() -\u003e Result\u003cDataConfig\u003e {\n    let config_path = config_dir().join(\"settings.toml\");\n    if !config_path.exists() {\n        return Ok(DataConfig::default());\n    }\n\n    let content = std::fs::read_to_string(\u0026config_path)?;\n    load_from_toml(\u0026content)\n}\n\npub fn load_from_toml(content: \u0026str) -\u003e Result\u003cDataConfig\u003e {\n    let table: toml::Value = content.parse()?;\n    let mut config = DataConfig::default();\n\n    if let Some(general) = table.get(\"general\") {\n        if let Some(claude_dir) = general.get(\"claude_dir\").and_then(|v| v.as_str()) {\n            config.claude_dir = expand_path(claude_dir);\n        }\n        if let Some(database) = general.get(\"database\").and_then(|v| v.as_str()) {\n            config.database = resolve_db_path(database);\n        }\n    }\n\n    if let Some(sync) = table.get(\"sync\") {\n        if let Some(interval) = sync.get(\"auto_sync_interval\").and_then(|v| v.as_integer()) {\n            config.auto_sync_interval = interval as u64;\n        }\n        if let Some(on_start) = sync.get(\"sync_on_start\").and_then(|v| v.as_bool()) {\n            config.sync_on_start = on_start;\n        }\n    }\n\n    Ok(config)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn expand_tilde() {\n        let home = dirs::home_dir().unwrap();\n        assert_eq!(expand_path(\"~/foo\"), home.join(\"foo\"));\n        assert_eq!(expand_path(\"~\"), home);\n    }\n\n    #[test]\n    fn expand_absolute() {\n        assert_eq!(expand_path(\"/usr/bin\"), PathBuf::from(\"/usr/bin\"));\n    }\n\n    #[test]\n    fn expand_relative() {\n        assert_eq!(expand_path(\"foo/bar\"), PathBuf::from(\"foo/bar\"));\n    }\n\n    #[test]\n    fn resolve_db_absolute() {\n        assert_eq!(\n            resolve_db_path(\"/tmp/test.db\"),\n            PathBuf::from(\"/tmp/test.db\")\n        );\n    }\n\n    #[test]\n    fn resolve_db_tilde() {\n        let home = dirs::home_dir().unwrap();\n        assert_eq!(resolve_db_path(\"~/data.db\"), home.join(\"data.db\"));\n    }\n\n    #[test]\n    fn resolve_db_relative() {\n        let expected = config_dir().join(\"hu.db\");\n        assert_eq!(resolve_db_path(\"hu.db\"), expected);\n    }\n\n    #[test]\n    fn default_config() {\n        let config = DataConfig::default();\n        assert!(config.claude_dir.ends_with(\".claude\"));\n        assert!(config.database.ends_with(\"hu.db\"));\n        assert_eq!(config.auto_sync_interval, 300);\n        assert!(config.sync_on_start);\n    }\n\n    #[test]\n    fn load_from_empty_toml() {\n        let config = load_from_toml(\"\").unwrap();\n        assert_eq!(config.auto_sync_interval, 300);\n        assert!(config.sync_on_start);\n    }\n\n    #[test]\n    fn load_from_full_toml() {\n        let toml = r#\"\n[general]\nclaude_dir = \"/custom/.claude\"\ndatabase = \"/custom/data.db\"\n\n[sync]\nauto_sync_interval = 600\nsync_on_start = false\n\"#;\n        let config = load_from_toml(toml).unwrap();\n        assert_eq!(config.claude_dir, PathBuf::from(\"/custom/.claude\"));\n        assert_eq!(config.database, PathBuf::from(\"/custom/data.db\"));\n        assert_eq!(config.auto_sync_interval, 600);\n        assert!(!config.sync_on_start);\n    }\n\n    #[test]\n    fn load_partial_toml() {\n        let toml = r#\"\n[sync]\nauto_sync_interval = 0\n\"#;\n        let config = load_from_toml(toml).unwrap();\n        assert_eq!(config.auto_sync_interval, 0);\n        assert!(config.sync_on_start); // default preserved\n    }\n\n    #[test]\n    fn config_dir_with_home_some() {\n        let home = PathBuf::from(\"/home/user\");\n        let result = config_dir_with_home(Some(home));\n        assert_eq!(result, PathBuf::from(\"/home/user/.config/hu\"));\n    }\n\n    #[test]\n    fn config_dir_with_home_none() {\n        let result = config_dir_with_home(None);\n        assert_eq!(result, PathBuf::from(\".config/hu\"));\n    }\n\n    #[test]\n    fn load_invalid_toml() {\n        let result = load_from_toml(\"not valid toml {{{\");\n        assert!(result.is_err());\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":6}},{"line":15,"address":[],"length":0,"stats":{"Line":18}},{"line":16,"address":[],"length":0,"stats":{"Line":6}},{"line":23,"address":[],"length":0,"stats":{"Line":12}},{"line":24,"address":[],"length":0,"stats":{"Line":20}},{"line":25,"address":[],"length":0,"stats":{"Line":16}},{"line":26,"address":[],"length":0,"stats":{"Line":16}},{"line":29,"address":[],"length":0,"stats":{"Line":4}},{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":31,"address":[],"length":0,"stats":{"Line":1}},{"line":34,"address":[],"length":0,"stats":{"Line":6}},{"line":37,"address":[],"length":0,"stats":{"Line":10}},{"line":38,"address":[],"length":0,"stats":{"Line":30}},{"line":39,"address":[],"length":0,"stats":{"Line":10}},{"line":40,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":16}},{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":14}},{"line":48,"address":[],"length":0,"stats":{"Line":8}},{"line":49,"address":[],"length":0,"stats":{"Line":16}},{"line":52,"address":[],"length":0,"stats":{"Line":10}},{"line":53,"address":[],"length":0,"stats":{"Line":10}},{"line":54,"address":[],"length":0,"stats":{"Line":18}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":70,"address":[],"length":0,"stats":{"Line":4}},{"line":71,"address":[],"length":0,"stats":{"Line":15}},{"line":72,"address":[],"length":0,"stats":{"Line":6}},{"line":74,"address":[],"length":0,"stats":{"Line":4}},{"line":75,"address":[],"length":0,"stats":{"Line":7}},{"line":76,"address":[],"length":0,"stats":{"Line":2}},{"line":78,"address":[],"length":0,"stats":{"Line":7}},{"line":79,"address":[],"length":0,"stats":{"Line":2}},{"line":83,"address":[],"length":0,"stats":{"Line":5}},{"line":84,"address":[],"length":0,"stats":{"Line":14}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":87,"address":[],"length":0,"stats":{"Line":10}},{"line":88,"address":[],"length":0,"stats":{"Line":1}},{"line":92,"address":[],"length":0,"stats":{"Line":3}}],"covered":38,"coverable":38},{"path":["/","Users","chi","Projects","hu","src","data","db.rs"],"content":"use anyhow::Result;\nuse rusqlite::Connection;\nuse std::path::Path;\n\nuse super::schema::initialize_schema;\n\npub struct SqliteStore {\n    pub conn: Connection,\n}\n\nimpl SqliteStore {\n    pub fn open(path: \u0026Path) -\u003e Result\u003cSelf\u003e {\n        if let Some(parent) = path.parent() {\n            std::fs::create_dir_all(parent)?;\n        }\n        let conn = Connection::open(path)?;\n        Self::configure(\u0026conn)?;\n        Ok(Self { conn })\n    }\n\n    #[allow(dead_code)]\n    pub fn open_memory() -\u003e Result\u003cSelf\u003e {\n        let conn = Connection::open_in_memory()?;\n        Self::configure(\u0026conn)?;\n        Ok(Self { conn })\n    }\n\n    pub fn open_initialized(path: \u0026Path) -\u003e Result\u003cSelf\u003e {\n        let store = Self::open(path)?;\n        initialize_schema(\u0026store.conn)?;\n        Ok(store)\n    }\n\n    fn configure(conn: \u0026Connection) -\u003e Result\u003c()\u003e {\n        conn.execute_batch(\"PRAGMA journal_mode=WAL; PRAGMA foreign_keys=ON;\")?;\n        Ok(())\n    }\n}\n\n#[cfg(test)]\npub fn open_test_db() -\u003e SqliteStore {\n    let store = SqliteStore::open_memory().unwrap();\n    initialize_schema(\u0026store.conn).unwrap();\n    store\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn open_memory_works() {\n        let store = SqliteStore::open_memory().unwrap();\n        let result: i64 = store\n            .conn\n            .query_row(\"SELECT 1\", [], |row| row.get(0))\n            .unwrap();\n        assert_eq!(result, 1);\n    }\n\n    #[test]\n    fn open_test_db_has_schema() {\n        let store = open_test_db();\n        let version: i64 = store\n            .conn\n            .query_row(\n                \"SELECT COALESCE(MAX(version), 0) FROM schema_version\",\n                [],\n                |row| row.get(0),\n            )\n            .unwrap();\n        assert_eq!(version, 2);\n    }\n\n    #[test]\n    fn open_initialized_creates_file() {\n        let tmp = std::env::temp_dir().join(\"hu-test-db-init\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n        let db_path = tmp.join(\"test.db\");\n\n        let store = SqliteStore::open_initialized(\u0026db_path).unwrap();\n        let version: i64 = store\n            .conn\n            .query_row(\n                \"SELECT COALESCE(MAX(version), 0) FROM schema_version\",\n                [],\n                |row| row.get(0),\n            )\n            .unwrap();\n        assert_eq!(version, 2);\n        assert!(db_path.exists());\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn wal_mode_enabled() {\n        let store = open_test_db();\n        let mode: String = store\n            .conn\n            .query_row(\"PRAGMA journal_mode\", [], |row| row.get(0))\n            .unwrap();\n        // In-memory databases use \"memory\" mode, not WAL\n        assert!(mode == \"wal\" || mode == \"memory\");\n    }\n\n    #[test]\n    fn foreign_keys_enabled() {\n        let store = open_test_db();\n        let fk: i64 = store\n            .conn\n            .query_row(\"PRAGMA foreign_keys\", [], |row| row.get(0))\n            .unwrap();\n        assert_eq!(fk, 1);\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":1}},{"line":13,"address":[],"length":0,"stats":{"Line":2}},{"line":14,"address":[],"length":0,"stats":{"Line":2}},{"line":16,"address":[],"length":0,"stats":{"Line":3}},{"line":17,"address":[],"length":0,"stats":{"Line":2}},{"line":18,"address":[],"length":0,"stats":{"Line":1}},{"line":22,"address":[],"length":0,"stats":{"Line":62}},{"line":23,"address":[],"length":0,"stats":{"Line":124}},{"line":24,"address":[],"length":0,"stats":{"Line":124}},{"line":25,"address":[],"length":0,"stats":{"Line":62}},{"line":28,"address":[],"length":0,"stats":{"Line":1}},{"line":29,"address":[],"length":0,"stats":{"Line":3}},{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":31,"address":[],"length":0,"stats":{"Line":1}},{"line":34,"address":[],"length":0,"stats":{"Line":63}},{"line":35,"address":[],"length":0,"stats":{"Line":189}},{"line":36,"address":[],"length":0,"stats":{"Line":63}},{"line":41,"address":[],"length":0,"stats":{"Line":61}},{"line":42,"address":[],"length":0,"stats":{"Line":183}},{"line":43,"address":[],"length":0,"stats":{"Line":183}},{"line":44,"address":[],"length":0,"stats":{"Line":61}}],"covered":21,"coverable":21},{"path":["/","Users","chi","Projects","hu","src","data","display","mod.rs"],"content":"use anyhow::Result;\nuse comfy_table::presets::UTF8_FULL_CONDENSED;\nuse comfy_table::{Cell, Color, Table};\n\nuse super::pricing::{self, BillingCycle, ValueComparison};\nuse super::queries::{ModelTokenUsage, PeriodUsage};\nuse super::types::*;\n\n#[cfg(test)]\nmod tests;\n\n// --- Helper formatting ---\n\npub fn time_ago_ms(ms: i64) -\u003e String {\n    let now = chrono::Utc::now().timestamp_millis();\n    let diff = now - ms;\n    let secs = diff / 1000;\n\n    if secs \u003c 60 {\n        \"just now\".to_string()\n    } else if secs \u003c 3600 {\n        format!(\"{}m ago\", secs / 60)\n    } else if secs \u003c 86400 {\n        format!(\"{}h ago\", secs / 3600)\n    } else {\n        format!(\"{}d ago\", secs / 86400)\n    }\n}\n\npub fn truncate(s: \u0026str, max: usize) -\u003e String {\n    if s.len() \u003c= max {\n        s.to_string()\n    } else if max \u003c= 3 {\n        s[..max].to_string()\n    } else {\n        format!(\"{}...\", \u0026s[..max - 3])\n    }\n}\n\npub fn role_color(role: \u0026str) -\u003e Color {\n    match role {\n        \"user\" =\u003e Color::Cyan,\n        \"assistant\" =\u003e Color::Green,\n        _ =\u003e Color::White,\n    }\n}\n\npub fn status_color(status: \u0026str) -\u003e Color {\n    match status {\n        \"pending\" =\u003e Color::Yellow,\n        \"in_progress\" =\u003e Color::Cyan,\n        \"completed\" =\u003e Color::Green,\n        _ =\u003e Color::White,\n    }\n}\n\nfn format_tokens(tokens: i64) -\u003e String {\n    if tokens \u003e= 1_000_000 {\n        format!(\"{:.1}M\", tokens as f64 / 1_000_000.0)\n    } else if tokens \u003e= 1_000 {\n        format!(\"{:.1}K\", tokens as f64 / 1_000.0)\n    } else {\n        tokens.to_string()\n    }\n}\n\n// --- Output functions ---\n\npub fn output_sync(result: \u0026SyncResult, format: \u0026OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Json =\u003e {\n            println!(\"{}\", serde_json::to_string_pretty(result)?);\n        }\n        OutputFormat::Table =\u003e {\n            println!(\" Sync complete:\");\n            println!(\"  Sessions: {} new\", result.history);\n            println!(\"  Messages: {} new\", result.messages);\n            println!(\"  Todos: {} synced\", result.todos);\n        }\n    }\n    Ok(())\n}\n\npub fn output_config(config: \u0026super::config::DataConfig, format: \u0026OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Json =\u003e {\n            let json = serde_json::json!({\n                \"claude_dir\": config.claude_dir.display().to_string(),\n                \"database\": config.database.display().to_string(),\n                \"auto_sync_interval\": config.auto_sync_interval,\n                \"sync_on_start\": config.sync_on_start,\n            });\n            println!(\"{}\", serde_json::to_string_pretty(\u0026json)?);\n        }\n        OutputFormat::Table =\u003e {\n            println!(\"Claude dir: {}\", config.claude_dir.display());\n            println!(\"Database:   {}\", config.database.display());\n            println!(\"Sync interval: {}s\", config.auto_sync_interval);\n            println!(\"Sync on start: {}\", config.sync_on_start);\n        }\n    }\n    Ok(())\n}\n\npub fn output_sessions(sessions: \u0026[Session], format: \u0026OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Json =\u003e {\n            println!(\"{}\", serde_json::to_string_pretty(sessions)?);\n        }\n        OutputFormat::Table =\u003e {\n            if sessions.is_empty() {\n                println!(\"No sessions found.\");\n                return Ok(());\n            }\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_header(vec![\"ID\", \"Project\", \"Display\", \"Started\", \"Msgs\", \"Cost\"]);\n\n            for s in sessions {\n                table.add_row(vec![\n                    Cell::new(truncate(\u0026s.id, 12)),\n                    Cell::new(truncate(\u0026s.project, 30)),\n                    Cell::new(truncate(s.display.as_deref().unwrap_or(\"-\"), 25)),\n                    Cell::new(time_ago_ms(s.started_at)),\n                    Cell::new(s.message_count.to_string()),\n                    Cell::new(pricing::format_cost(s.total_cost_usd)),\n                ]);\n            }\n            println!(\"{table}\");\n        }\n    }\n    Ok(())\n}\n\npub fn output_session_messages(messages: \u0026[Message], format: \u0026OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Json =\u003e {\n            println!(\"{}\", serde_json::to_string_pretty(messages)?);\n        }\n        OutputFormat::Table =\u003e {\n            if messages.is_empty() {\n                println!(\"No messages found.\");\n                return Ok(());\n            }\n            for msg in messages {\n                let role = msg.role.as_str();\n                let content = msg.content.as_deref().unwrap_or(\"\");\n                let preview = truncate(content, 120);\n                let model_str = msg.model.as_deref().unwrap_or(\"\");\n                let tokens = match (msg.input_tokens, msg.output_tokens) {\n                    (Some(i), Some(o)) =\u003e format!(\" [{}+{}]\", format_tokens(i), format_tokens(o)),\n                    _ =\u003e String::new(),\n                };\n                let model_suffix = if model_str.is_empty() {\n                    String::new()\n                } else {\n                    format!(\" ({model_str})\")\n                };\n                println!(\"{role}{model_suffix} {preview}{tokens}\");\n            }\n        }\n    }\n    Ok(())\n}\n\npub fn output_search_results(results: \u0026[SearchResult], format: \u0026OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Json =\u003e {\n            println!(\"{}\", serde_json::to_string_pretty(results)?);\n        }\n        OutputFormat::Table =\u003e {\n            if results.is_empty() {\n                println!(\"No results found.\");\n                return Ok(());\n            }\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_header(vec![\"Role\", \"Content\", \"Project\", \"When\"]);\n\n            for r in results {\n                let content = r.content.as_deref().unwrap_or(\"\");\n                table.add_row(vec![\n                    Cell::new(\u0026r.role).fg(role_color(\u0026r.role)),\n                    Cell::new(truncate(content, 60)),\n                    Cell::new(truncate(\u0026r.project, 25)),\n                    Cell::new(time_ago_ms(r.created_at)),\n                ]);\n            }\n            println!(\"{table}\");\n        }\n    }\n    Ok(())\n}\n\npub fn output_stats(\n    stats: \u0026UsageStats,\n    model_usage: \u0026[ModelUsage],\n    format: \u0026OutputFormat,\n) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Json =\u003e {\n            let json = serde_json::json!({\n                \"stats\": stats,\n                \"model_usage\": model_usage,\n            });\n            println!(\"{}\", serde_json::to_string_pretty(\u0026json)?);\n        }\n        OutputFormat::Table =\u003e {\n            println!(\"Usage Statistics:\");\n            println!(\"  Sessions: {}\", stats.total_sessions);\n            println!(\"  Messages: {}\", stats.total_messages);\n            println!(\"  Total cost: {}\", pricing::format_cost(stats.total_cost));\n            println!(\n                \"  Input tokens: {}\",\n                format_tokens(stats.total_input_tokens)\n            );\n            println!(\n                \"  Output tokens: {}\",\n                format_tokens(stats.total_output_tokens)\n            );\n\n            if !model_usage.is_empty() {\n                println!(\"\\nBy Model:\");\n                let mut table = Table::new();\n                table.load_preset(UTF8_FULL_CONDENSED);\n                table.set_header(vec![\"Model\", \"Count\", \"Cost\", \"Input\", \"Output\"]);\n                for m in model_usage {\n                    table.add_row(vec![\n                        Cell::new(\u0026m.model),\n                        Cell::new(m.count.to_string()),\n                        Cell::new(pricing::format_cost(m.cost)),\n                        Cell::new(format_tokens(m.input_tokens)),\n                        Cell::new(format_tokens(m.output_tokens)),\n                    ]);\n                }\n                println!(\"{table}\");\n            }\n        }\n    }\n    Ok(())\n}\n\npub fn output_todos(todos: \u0026[Todo], format: \u0026OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Json =\u003e {\n            println!(\"{}\", serde_json::to_string_pretty(todos)?);\n        }\n        OutputFormat::Table =\u003e {\n            if todos.is_empty() {\n                println!(\"No todos found.\");\n                return Ok(());\n            }\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_header(vec![\"ID\", \"Status\", \"Content\", \"Session\"]);\n\n            for t in todos {\n                let icon = match t.status.as_str() {\n                    \"completed\" =\u003e \"\",\n                    \"in_progress\" =\u003e \"\",\n                    \"pending\" =\u003e \"\",\n                    _ =\u003e \"?\",\n                };\n                table.add_row(vec![\n                    Cell::new(t.id.to_string()),\n                    Cell::new(format!(\"{icon} {}\", t.status)).fg(status_color(\u0026t.status)),\n                    Cell::new(truncate(\u0026t.content, 50)),\n                    Cell::new(truncate(\u0026t.session_id, 12)),\n                ]);\n            }\n            println!(\"{table}\");\n        }\n    }\n    Ok(())\n}\n\npub fn output_pending_todos(todos: \u0026[TodoWithProject], format: \u0026OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Json =\u003e {\n            println!(\"{}\", serde_json::to_string_pretty(todos)?);\n        }\n        OutputFormat::Table =\u003e {\n            if todos.is_empty() {\n                println!(\"No pending todos found.\");\n                return Ok(());\n            }\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_header(vec![\"Status\", \"Content\", \"Project\"]);\n\n            for t in todos {\n                let icon = match t.status.as_str() {\n                    \"in_progress\" =\u003e \"\",\n                    \"pending\" =\u003e \"\",\n                    _ =\u003e \"?\",\n                };\n                table.add_row(vec![\n                    Cell::new(format!(\"{icon} {}\", t.status)).fg(status_color(\u0026t.status)),\n                    Cell::new(truncate(\u0026t.content, 50)),\n                    Cell::new(truncate(\u0026t.project, 30)),\n                ]);\n            }\n            println!(\"{table}\");\n        }\n    }\n    Ok(())\n}\n\npub fn output_tool_stats(stats: \u0026[ToolUsageStats], format: \u0026OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Json =\u003e {\n            println!(\"{}\", serde_json::to_string_pretty(stats)?);\n        }\n        OutputFormat::Table =\u003e {\n            if stats.is_empty() {\n                println!(\"No tool usage data.\");\n                return Ok(());\n            }\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_header(vec![\"Tool\", \"Count\", \"Last Used\"]);\n\n            for s in stats {\n                table.add_row(vec![\n                    Cell::new(\u0026s.tool_name),\n                    Cell::new(s.count.to_string()),\n                    Cell::new(time_ago_ms(s.last_used)),\n                ]);\n            }\n            println!(\"{table}\");\n        }\n    }\n    Ok(())\n}\n\npub fn output_tool_detail(detail: \u0026[ToolUsageDetail], format: \u0026OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Json =\u003e {\n            println!(\"{}\", serde_json::to_string_pretty(detail)?);\n        }\n        OutputFormat::Table =\u003e {\n            if detail.is_empty() {\n                println!(\"No usage found for this tool.\");\n                return Ok(());\n            }\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_header(vec![\"Tool\", \"Session\", \"Project\", \"When\"]);\n\n            for d in detail {\n                table.add_row(vec![\n                    Cell::new(\u0026d.tool_name),\n                    Cell::new(truncate(\u0026d.session_id, 12)),\n                    Cell::new(truncate(\u0026d.project, 30)),\n                    Cell::new(time_ago_ms(d.created_at)),\n                ]);\n            }\n            println!(\"{table}\");\n        }\n    }\n    Ok(())\n}\n\npub fn output_errors(errors: \u0026[DebugError], format: \u0026OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Json =\u003e {\n            println!(\"{}\", serde_json::to_string_pretty(errors)?);\n        }\n        OutputFormat::Table =\u003e {\n            if errors.is_empty() {\n                println!(\"No errors found.\");\n                return Ok(());\n            }\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_header(vec![\"File\", \"Line\", \"Content\"]);\n\n            for e in errors {\n                table.add_row(vec![\n                    Cell::new(truncate(\u0026e.file, 25)),\n                    Cell::new(e.line.to_string()),\n                    Cell::new(truncate(\u0026e.content, 60)).fg(Color::Red),\n                ]);\n            }\n            println!(\"{table}\");\n        }\n    }\n    Ok(())\n}\n\n// Helper types for pricing display\n\n#[derive(Debug, Clone, serde::Serialize)]\npub struct ModelUsageWithCost {\n    pub model: String,\n    pub input_tokens: i64,\n    pub output_tokens: i64,\n    pub cost: f64,\n}\n\n#[derive(Debug, Clone, serde::Serialize)]\npub struct PricingData {\n    pub subscription: String,\n    pub subscription_price: f64,\n    pub billing_cycle: BillingCycle,\n    pub period_usage: PeriodUsage,\n    pub model_costs: Vec\u003cModelUsageWithCost\u003e,\n    pub total_api_cost: f64,\n    pub projected_cost: f64,\n    pub break_even: pricing::BreakEvenAnalysis,\n    pub value_comparisons: Vec\u003cValueComparison\u003e,\n}\n\npub fn output_pricing(data: \u0026PricingData, format: \u0026OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Json =\u003e {\n            println!(\"{}\", serde_json::to_string_pretty(data)?);\n        }\n        OutputFormat::Table =\u003e {\n            println!(\n                \"Pricing Analysis ({} plan, ${}/mo):\",\n                data.subscription, data.subscription_price\n            );\n            println!(\n                \"  Billing cycle: {} days elapsed, {} remaining (of {})\",\n                data.billing_cycle.days_elapsed,\n                data.billing_cycle.days_remaining,\n                data.billing_cycle.total_days\n            );\n            println!();\n\n            println!(\"Current Period Usage:\");\n            println!(\"  Messages: {}\", data.period_usage.messages);\n            println!(\n                \"  Input tokens: {}\",\n                format_tokens(data.period_usage.input_tokens)\n            );\n            println!(\n                \"  Output tokens: {}\",\n                format_tokens(data.period_usage.output_tokens)\n            );\n            println!();\n\n            if !data.model_costs.is_empty() {\n                println!(\"API Cost by Model:\");\n                let mut table = Table::new();\n                table.load_preset(UTF8_FULL_CONDENSED);\n                table.set_header(vec![\"Model\", \"Input\", \"Output\", \"Cost\"]);\n                for m in \u0026data.model_costs {\n                    table.add_row(vec![\n                        Cell::new(\u0026m.model),\n                        Cell::new(format_tokens(m.input_tokens)),\n                        Cell::new(format_tokens(m.output_tokens)),\n                        Cell::new(pricing::format_cost(m.cost)),\n                    ]);\n                }\n                println!(\"{table}\");\n            }\n\n            println!(\n                \"Total API-equivalent cost: {}\",\n                pricing::format_cost(data.total_api_cost)\n            );\n            println!(\n                \"Projected cycle cost: {}\",\n                pricing::format_cost(data.projected_cost)\n            );\n            println!();\n\n            println!(\"Break-even Analysis (Opus 4.5 rates):\");\n            println!(\n                \"  Output tokens to break even: {}\",\n                format_tokens(data.break_even.break_even_output_tokens)\n            );\n            println!(\n                \"  Input tokens to break even: {}\",\n                format_tokens(data.break_even.break_even_input_tokens)\n            );\n\n            if !data.value_comparisons.is_empty() {\n                println!(\n                    \"\\nValue Comparison (vs API cost {}):\",\n                    pricing::format_cost(data.total_api_cost)\n                );\n                let mut table = Table::new();\n                table.load_preset(UTF8_FULL_CONDENSED);\n                table.set_header(vec![\"Service\", \"Plan\", \"Price\", \"Savings\"]);\n                for v in \u0026data.value_comparisons {\n                    let savings_str = if v.savings \u003e 0.0 {\n                        format!(\n                            \"{} ({:.0}%)\",\n                            pricing::format_cost(v.savings),\n                            v.savings_percent\n                        )\n                    } else {\n                        format!(\"-{}\", pricing::format_cost(-v.savings))\n                    };\n                    table.add_row(vec![\n                        Cell::new(\u0026v.service),\n                        Cell::new(\u0026v.plan),\n                        Cell::new(format!(\"${:.0}/mo\", v.price)),\n                        Cell::new(savings_str),\n                    ]);\n                }\n                println!(\"{table}\");\n            }\n        }\n    }\n    Ok(())\n}\n\n#[derive(Debug, Clone, serde::Serialize)]\npub struct BranchWithPr {\n    pub branch: BranchStats,\n    pub pr: Option\u003cPrInfo\u003e,\n}\n\n#[derive(Debug, Clone, serde::Serialize)]\npub struct PrInfo {\n    pub number: i64,\n    pub title: String,\n    pub state: String,\n    pub url: String,\n}\n\npub fn output_branches(branches: \u0026[BranchWithPr], format: \u0026OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Json =\u003e {\n            println!(\"{}\", serde_json::to_string_pretty(branches)?);\n        }\n        OutputFormat::Table =\u003e {\n            if branches.is_empty() {\n                println!(\"No branches found.\");\n                return Ok(());\n            }\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_header(vec![\n                \"Branch\",\n                \"Sessions\",\n                \"Msgs\",\n                \"Cost\",\n                \"Last Active\",\n                \"PR\",\n            ]);\n\n            for b in branches {\n                let pr_str = match \u0026b.pr {\n                    Some(pr) =\u003e format!(\"#{} ({})\", pr.number, pr.state),\n                    None =\u003e \"-\".to_string(),\n                };\n                table.add_row(vec![\n                    Cell::new(truncate(\u0026b.branch.git_branch, 30)),\n                    Cell::new(b.branch.session_count.to_string()),\n                    Cell::new(b.branch.total_messages.to_string()),\n                    Cell::new(pricing::format_cost(b.branch.total_cost)),\n                    Cell::new(time_ago_ms(b.branch.last_activity)),\n                    Cell::new(pr_str),\n                ]);\n            }\n            println!(\"{table}\");\n        }\n    }\n    Ok(())\n}\n\npub fn build_model_costs(model_usage: \u0026[ModelTokenUsage]) -\u003e Vec\u003cModelUsageWithCost\u003e {\n    model_usage\n        .iter()\n        .map(|m| {\n            let cost = pricing::calculate_cost(Some(\u0026m.model), m.input_tokens, m.output_tokens);\n            ModelUsageWithCost {\n                model: m.model.clone(),\n                input_tokens: m.input_tokens,\n                output_tokens: m.output_tokens,\n                cost,\n            }\n        })\n        .collect()\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":10}},{"line":15,"address":[],"length":0,"stats":{"Line":30}},{"line":16,"address":[],"length":0,"stats":{"Line":20}},{"line":17,"address":[],"length":0,"stats":{"Line":20}},{"line":19,"address":[],"length":0,"stats":{"Line":10}},{"line":20,"address":[],"length":0,"stats":{"Line":14}},{"line":21,"address":[],"length":0,"stats":{"Line":3}},{"line":22,"address":[],"length":0,"stats":{"Line":3}},{"line":23,"address":[],"length":0,"stats":{"Line":2}},{"line":24,"address":[],"length":0,"stats":{"Line":3}},{"line":26,"address":[],"length":0,"stats":{"Line":3}},{"line":30,"address":[],"length":0,"stats":{"Line":32}},{"line":31,"address":[],"length":0,"stats":{"Line":64}},{"line":32,"address":[],"length":0,"stats":{"Line":60}},{"line":33,"address":[],"length":0,"stats":{"Line":2}},{"line":34,"address":[],"length":0,"stats":{"Line":2}},{"line":36,"address":[],"length":0,"stats":{"Line":3}},{"line":40,"address":[],"length":0,"stats":{"Line":4}},{"line":41,"address":[],"length":0,"stats":{"Line":4}},{"line":42,"address":[],"length":0,"stats":{"Line":6}},{"line":43,"address":[],"length":0,"stats":{"Line":3}},{"line":44,"address":[],"length":0,"stats":{"Line":1}},{"line":48,"address":[],"length":0,"stats":{"Line":11}},{"line":49,"address":[],"length":0,"stats":{"Line":11}},{"line":50,"address":[],"length":0,"stats":{"Line":14}},{"line":51,"address":[],"length":0,"stats":{"Line":11}},{"line":52,"address":[],"length":0,"stats":{"Line":7}},{"line":53,"address":[],"length":0,"stats":{"Line":3}},{"line":57,"address":[],"length":0,"stats":{"Line":35}},{"line":58,"address":[],"length":0,"stats":{"Line":35}},{"line":59,"address":[],"length":0,"stats":{"Line":30}},{"line":60,"address":[],"length":0,"stats":{"Line":25}},{"line":61,"address":[],"length":0,"stats":{"Line":54}},{"line":63,"address":[],"length":0,"stats":{"Line":14}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":4}},{"line":74,"address":[],"length":0,"stats":{"Line":1}},{"line":75,"address":[],"length":0,"stats":{"Line":3}},{"line":76,"address":[],"length":0,"stats":{"Line":3}},{"line":77,"address":[],"length":0,"stats":{"Line":3}},{"line":78,"address":[],"length":0,"stats":{"Line":1}},{"line":81,"address":[],"length":0,"stats":{"Line":2}},{"line":84,"address":[],"length":0,"stats":{"Line":2}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":87,"address":[],"length":0,"stats":{"Line":2}},{"line":88,"address":[],"length":0,"stats":{"Line":3}},{"line":89,"address":[],"length":0,"stats":{"Line":3}},{"line":90,"address":[],"length":0,"stats":{"Line":1}},{"line":91,"address":[],"length":0,"stats":{"Line":1}},{"line":93,"address":[],"length":0,"stats":{"Line":4}},{"line":95,"address":[],"length":0,"stats":{"Line":1}},{"line":96,"address":[],"length":0,"stats":{"Line":4}},{"line":97,"address":[],"length":0,"stats":{"Line":4}},{"line":98,"address":[],"length":0,"stats":{"Line":3}},{"line":99,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":2}},{"line":105,"address":[],"length":0,"stats":{"Line":3}},{"line":106,"address":[],"length":0,"stats":{"Line":3}},{"line":108,"address":[],"length":0,"stats":{"Line":4}},{"line":111,"address":[],"length":0,"stats":{"Line":4}},{"line":112,"address":[],"length":0,"stats":{"Line":2}},{"line":113,"address":[],"length":0,"stats":{"Line":1}},{"line":115,"address":[],"length":0,"stats":{"Line":2}},{"line":116,"address":[],"length":0,"stats":{"Line":3}},{"line":117,"address":[],"length":0,"stats":{"Line":8}},{"line":119,"address":[],"length":0,"stats":{"Line":4}},{"line":120,"address":[],"length":0,"stats":{"Line":4}},{"line":121,"address":[],"length":0,"stats":{"Line":4}},{"line":122,"address":[],"length":0,"stats":{"Line":4}},{"line":123,"address":[],"length":0,"stats":{"Line":6}},{"line":124,"address":[],"length":0,"stats":{"Line":4}},{"line":125,"address":[],"length":0,"stats":{"Line":4}},{"line":126,"address":[],"length":0,"stats":{"Line":2}},{"line":129,"address":[],"length":0,"stats":{"Line":2}},{"line":132,"address":[],"length":0,"stats":{"Line":2}},{"line":135,"address":[],"length":0,"stats":{"Line":4}},{"line":136,"address":[],"length":0,"stats":{"Line":4}},{"line":138,"address":[],"length":0,"stats":{"Line":4}},{"line":141,"address":[],"length":0,"stats":{"Line":6}},{"line":142,"address":[],"length":0,"stats":{"Line":2}},{"line":143,"address":[],"length":0,"stats":{"Line":1}},{"line":145,"address":[],"length":0,"stats":{"Line":8}},{"line":146,"address":[],"length":0,"stats":{"Line":9}},{"line":147,"address":[],"length":0,"stats":{"Line":15}},{"line":148,"address":[],"length":0,"stats":{"Line":9}},{"line":149,"address":[],"length":0,"stats":{"Line":15}},{"line":150,"address":[],"length":0,"stats":{"Line":9}},{"line":151,"address":[],"length":0,"stats":{"Line":16}},{"line":152,"address":[],"length":0,"stats":{"Line":1}},{"line":154,"address":[],"length":0,"stats":{"Line":9}},{"line":155,"address":[],"length":0,"stats":{"Line":2}},{"line":157,"address":[],"length":0,"stats":{"Line":2}},{"line":159,"address":[],"length":0,"stats":{"Line":6}},{"line":163,"address":[],"length":0,"stats":{"Line":3}},{"line":166,"address":[],"length":0,"stats":{"Line":3}},{"line":167,"address":[],"length":0,"stats":{"Line":3}},{"line":169,"address":[],"length":0,"stats":{"Line":4}},{"line":172,"address":[],"length":0,"stats":{"Line":4}},{"line":173,"address":[],"length":0,"stats":{"Line":2}},{"line":174,"address":[],"length":0,"stats":{"Line":1}},{"line":176,"address":[],"length":0,"stats":{"Line":2}},{"line":177,"address":[],"length":0,"stats":{"Line":3}},{"line":178,"address":[],"length":0,"stats":{"Line":6}},{"line":180,"address":[],"length":0,"stats":{"Line":4}},{"line":181,"address":[],"length":0,"stats":{"Line":6}},{"line":182,"address":[],"length":0,"stats":{"Line":4}},{"line":183,"address":[],"length":0,"stats":{"Line":6}},{"line":184,"address":[],"length":0,"stats":{"Line":4}},{"line":185,"address":[],"length":0,"stats":{"Line":4}},{"line":186,"address":[],"length":0,"stats":{"Line":2}},{"line":189,"address":[],"length":0,"stats":{"Line":2}},{"line":192,"address":[],"length":0,"stats":{"Line":2}},{"line":195,"address":[],"length":0,"stats":{"Line":3}},{"line":200,"address":[],"length":0,"stats":{"Line":3}},{"line":202,"address":[],"length":0,"stats":{"Line":2}},{"line":203,"address":[],"length":0,"stats":{"Line":1}},{"line":204,"address":[],"length":0,"stats":{"Line":1}},{"line":206,"address":[],"length":0,"stats":{"Line":4}},{"line":209,"address":[],"length":0,"stats":{"Line":4}},{"line":210,"address":[],"length":0,"stats":{"Line":4}},{"line":211,"address":[],"length":0,"stats":{"Line":4}},{"line":212,"address":[],"length":0,"stats":{"Line":8}},{"line":213,"address":[],"length":0,"stats":{"Line":2}},{"line":214,"address":[],"length":0,"stats":{"Line":2}},{"line":215,"address":[],"length":0,"stats":{"Line":4}},{"line":217,"address":[],"length":0,"stats":{"Line":2}},{"line":218,"address":[],"length":0,"stats":{"Line":2}},{"line":219,"address":[],"length":0,"stats":{"Line":4}},{"line":222,"address":[],"length":0,"stats":{"Line":2}},{"line":223,"address":[],"length":0,"stats":{"Line":2}},{"line":224,"address":[],"length":0,"stats":{"Line":2}},{"line":225,"address":[],"length":0,"stats":{"Line":3}},{"line":226,"address":[],"length":0,"stats":{"Line":7}},{"line":227,"address":[],"length":0,"stats":{"Line":4}},{"line":228,"address":[],"length":0,"stats":{"Line":4}},{"line":229,"address":[],"length":0,"stats":{"Line":3}},{"line":230,"address":[],"length":0,"stats":{"Line":4}},{"line":231,"address":[],"length":0,"stats":{"Line":4}},{"line":232,"address":[],"length":0,"stats":{"Line":4}},{"line":233,"address":[],"length":0,"stats":{"Line":2}},{"line":236,"address":[],"length":0,"stats":{"Line":2}},{"line":240,"address":[],"length":0,"stats":{"Line":3}},{"line":243,"address":[],"length":0,"stats":{"Line":4}},{"line":244,"address":[],"length":0,"stats":{"Line":4}},{"line":246,"address":[],"length":0,"stats":{"Line":4}},{"line":249,"address":[],"length":0,"stats":{"Line":6}},{"line":250,"address":[],"length":0,"stats":{"Line":2}},{"line":251,"address":[],"length":0,"stats":{"Line":1}},{"line":253,"address":[],"length":0,"stats":{"Line":4}},{"line":254,"address":[],"length":0,"stats":{"Line":6}},{"line":255,"address":[],"length":0,"stats":{"Line":12}},{"line":257,"address":[],"length":0,"stats":{"Line":10}},{"line":258,"address":[],"length":0,"stats":{"Line":8}},{"line":259,"address":[],"length":0,"stats":{"Line":5}},{"line":260,"address":[],"length":0,"stats":{"Line":4}},{"line":261,"address":[],"length":0,"stats":{"Line":3}},{"line":262,"address":[],"length":0,"stats":{"Line":1}},{"line":264,"address":[],"length":0,"stats":{"Line":12}},{"line":265,"address":[],"length":0,"stats":{"Line":12}},{"line":266,"address":[],"length":0,"stats":{"Line":24}},{"line":267,"address":[],"length":0,"stats":{"Line":12}},{"line":268,"address":[],"length":0,"stats":{"Line":12}},{"line":271,"address":[],"length":0,"stats":{"Line":4}},{"line":274,"address":[],"length":0,"stats":{"Line":3}},{"line":277,"address":[],"length":0,"stats":{"Line":5}},{"line":278,"address":[],"length":0,"stats":{"Line":5}},{"line":280,"address":[],"length":0,"stats":{"Line":4}},{"line":283,"address":[],"length":0,"stats":{"Line":8}},{"line":284,"address":[],"length":0,"stats":{"Line":2}},{"line":285,"address":[],"length":0,"stats":{"Line":1}},{"line":287,"address":[],"length":0,"stats":{"Line":6}},{"line":288,"address":[],"length":0,"stats":{"Line":9}},{"line":289,"address":[],"length":0,"stats":{"Line":15}},{"line":291,"address":[],"length":0,"stats":{"Line":9}},{"line":292,"address":[],"length":0,"stats":{"Line":6}},{"line":293,"address":[],"length":0,"stats":{"Line":4}},{"line":294,"address":[],"length":0,"stats":{"Line":3}},{"line":295,"address":[],"length":0,"stats":{"Line":1}},{"line":297,"address":[],"length":0,"stats":{"Line":9}},{"line":298,"address":[],"length":0,"stats":{"Line":18}},{"line":299,"address":[],"length":0,"stats":{"Line":9}},{"line":300,"address":[],"length":0,"stats":{"Line":9}},{"line":303,"address":[],"length":0,"stats":{"Line":6}},{"line":306,"address":[],"length":0,"stats":{"Line":4}},{"line":309,"address":[],"length":0,"stats":{"Line":3}},{"line":310,"address":[],"length":0,"stats":{"Line":3}},{"line":312,"address":[],"length":0,"stats":{"Line":4}},{"line":315,"address":[],"length":0,"stats":{"Line":4}},{"line":316,"address":[],"length":0,"stats":{"Line":2}},{"line":317,"address":[],"length":0,"stats":{"Line":1}},{"line":319,"address":[],"length":0,"stats":{"Line":2}},{"line":320,"address":[],"length":0,"stats":{"Line":3}},{"line":321,"address":[],"length":0,"stats":{"Line":5}},{"line":323,"address":[],"length":0,"stats":{"Line":4}},{"line":324,"address":[],"length":0,"stats":{"Line":4}},{"line":325,"address":[],"length":0,"stats":{"Line":3}},{"line":326,"address":[],"length":0,"stats":{"Line":4}},{"line":327,"address":[],"length":0,"stats":{"Line":2}},{"line":330,"address":[],"length":0,"stats":{"Line":2}},{"line":333,"address":[],"length":0,"stats":{"Line":2}},{"line":336,"address":[],"length":0,"stats":{"Line":3}},{"line":337,"address":[],"length":0,"stats":{"Line":3}},{"line":339,"address":[],"length":0,"stats":{"Line":4}},{"line":342,"address":[],"length":0,"stats":{"Line":4}},{"line":343,"address":[],"length":0,"stats":{"Line":2}},{"line":344,"address":[],"length":0,"stats":{"Line":1}},{"line":346,"address":[],"length":0,"stats":{"Line":2}},{"line":347,"address":[],"length":0,"stats":{"Line":3}},{"line":348,"address":[],"length":0,"stats":{"Line":6}},{"line":350,"address":[],"length":0,"stats":{"Line":4}},{"line":351,"address":[],"length":0,"stats":{"Line":4}},{"line":352,"address":[],"length":0,"stats":{"Line":3}},{"line":353,"address":[],"length":0,"stats":{"Line":4}},{"line":354,"address":[],"length":0,"stats":{"Line":4}},{"line":355,"address":[],"length":0,"stats":{"Line":2}},{"line":358,"address":[],"length":0,"stats":{"Line":2}},{"line":361,"address":[],"length":0,"stats":{"Line":2}},{"line":364,"address":[],"length":0,"stats":{"Line":3}},{"line":365,"address":[],"length":0,"stats":{"Line":3}},{"line":367,"address":[],"length":0,"stats":{"Line":4}},{"line":370,"address":[],"length":0,"stats":{"Line":4}},{"line":371,"address":[],"length":0,"stats":{"Line":2}},{"line":372,"address":[],"length":0,"stats":{"Line":1}},{"line":374,"address":[],"length":0,"stats":{"Line":2}},{"line":375,"address":[],"length":0,"stats":{"Line":3}},{"line":376,"address":[],"length":0,"stats":{"Line":5}},{"line":378,"address":[],"length":0,"stats":{"Line":4}},{"line":379,"address":[],"length":0,"stats":{"Line":4}},{"line":380,"address":[],"length":0,"stats":{"Line":4}},{"line":381,"address":[],"length":0,"stats":{"Line":4}},{"line":382,"address":[],"length":0,"stats":{"Line":4}},{"line":385,"address":[],"length":0,"stats":{"Line":2}},{"line":388,"address":[],"length":0,"stats":{"Line":2}},{"line":414,"address":[],"length":0,"stats":{"Line":5}},{"line":415,"address":[],"length":0,"stats":{"Line":5}},{"line":417,"address":[],"length":0,"stats":{"Line":4}},{"line":420,"address":[],"length":0,"stats":{"Line":4}},{"line":421,"address":[],"length":0,"stats":{"Line":4}},{"line":424,"address":[],"length":0,"stats":{"Line":4}},{"line":425,"address":[],"length":0,"stats":{"Line":4}},{"line":430,"address":[],"length":0,"stats":{"Line":4}},{"line":432,"address":[],"length":0,"stats":{"Line":8}},{"line":433,"address":[],"length":0,"stats":{"Line":8}},{"line":434,"address":[],"length":0,"stats":{"Line":4}},{"line":435,"address":[],"length":0,"stats":{"Line":4}},{"line":436,"address":[],"length":0,"stats":{"Line":8}},{"line":438,"address":[],"length":0,"stats":{"Line":4}},{"line":439,"address":[],"length":0,"stats":{"Line":4}},{"line":440,"address":[],"length":0,"stats":{"Line":8}},{"line":442,"address":[],"length":0,"stats":{"Line":4}},{"line":444,"address":[],"length":0,"stats":{"Line":4}},{"line":445,"address":[],"length":0,"stats":{"Line":6}},{"line":446,"address":[],"length":0,"stats":{"Line":6}},{"line":447,"address":[],"length":0,"stats":{"Line":9}},{"line":448,"address":[],"length":0,"stats":{"Line":18}},{"line":449,"address":[],"length":0,"stats":{"Line":12}},{"line":450,"address":[],"length":0,"stats":{"Line":12}},{"line":451,"address":[],"length":0,"stats":{"Line":9}},{"line":452,"address":[],"length":0,"stats":{"Line":12}},{"line":453,"address":[],"length":0,"stats":{"Line":12}},{"line":454,"address":[],"length":0,"stats":{"Line":6}},{"line":457,"address":[],"length":0,"stats":{"Line":6}},{"line":460,"address":[],"length":0,"stats":{"Line":4}},{"line":461,"address":[],"length":0,"stats":{"Line":4}},{"line":462,"address":[],"length":0,"stats":{"Line":8}},{"line":464,"address":[],"length":0,"stats":{"Line":4}},{"line":465,"address":[],"length":0,"stats":{"Line":4}},{"line":466,"address":[],"length":0,"stats":{"Line":8}},{"line":468,"address":[],"length":0,"stats":{"Line":4}},{"line":470,"address":[],"length":0,"stats":{"Line":8}},{"line":471,"address":[],"length":0,"stats":{"Line":4}},{"line":472,"address":[],"length":0,"stats":{"Line":4}},{"line":473,"address":[],"length":0,"stats":{"Line":8}},{"line":475,"address":[],"length":0,"stats":{"Line":4}},{"line":476,"address":[],"length":0,"stats":{"Line":4}},{"line":477,"address":[],"length":0,"stats":{"Line":8}},{"line":480,"address":[],"length":0,"stats":{"Line":4}},{"line":481,"address":[],"length":0,"stats":{"Line":3}},{"line":482,"address":[],"length":0,"stats":{"Line":3}},{"line":483,"address":[],"length":0,"stats":{"Line":6}},{"line":485,"address":[],"length":0,"stats":{"Line":6}},{"line":486,"address":[],"length":0,"stats":{"Line":9}},{"line":487,"address":[],"length":0,"stats":{"Line":18}},{"line":488,"address":[],"length":0,"stats":{"Line":27}},{"line":489,"address":[],"length":0,"stats":{"Line":24}},{"line":490,"address":[],"length":0,"stats":{"Line":1}},{"line":492,"address":[],"length":0,"stats":{"Line":2}},{"line":496,"address":[],"length":0,"stats":{"Line":44}},{"line":498,"address":[],"length":0,"stats":{"Line":36}},{"line":499,"address":[],"length":0,"stats":{"Line":24}},{"line":500,"address":[],"length":0,"stats":{"Line":24}},{"line":501,"address":[],"length":0,"stats":{"Line":36}},{"line":502,"address":[],"length":0,"stats":{"Line":24}},{"line":505,"address":[],"length":0,"stats":{"Line":6}},{"line":509,"address":[],"length":0,"stats":{"Line":5}},{"line":526,"address":[],"length":0,"stats":{"Line":3}},{"line":527,"address":[],"length":0,"stats":{"Line":3}},{"line":529,"address":[],"length":0,"stats":{"Line":4}},{"line":532,"address":[],"length":0,"stats":{"Line":4}},{"line":533,"address":[],"length":0,"stats":{"Line":2}},{"line":534,"address":[],"length":0,"stats":{"Line":1}},{"line":536,"address":[],"length":0,"stats":{"Line":2}},{"line":537,"address":[],"length":0,"stats":{"Line":3}},{"line":538,"address":[],"length":0,"stats":{"Line":3}},{"line":540,"address":[],"length":0,"stats":{"Line":1}},{"line":541,"address":[],"length":0,"stats":{"Line":1}},{"line":542,"address":[],"length":0,"stats":{"Line":1}},{"line":543,"address":[],"length":0,"stats":{"Line":1}},{"line":544,"address":[],"length":0,"stats":{"Line":1}},{"line":547,"address":[],"length":0,"stats":{"Line":5}},{"line":548,"address":[],"length":0,"stats":{"Line":4}},{"line":549,"address":[],"length":0,"stats":{"Line":3}},{"line":550,"address":[],"length":0,"stats":{"Line":2}},{"line":552,"address":[],"length":0,"stats":{"Line":6}},{"line":553,"address":[],"length":0,"stats":{"Line":6}},{"line":554,"address":[],"length":0,"stats":{"Line":6}},{"line":555,"address":[],"length":0,"stats":{"Line":6}},{"line":556,"address":[],"length":0,"stats":{"Line":6}},{"line":557,"address":[],"length":0,"stats":{"Line":6}},{"line":558,"address":[],"length":0,"stats":{"Line":4}},{"line":561,"address":[],"length":0,"stats":{"Line":2}},{"line":564,"address":[],"length":0,"stats":{"Line":2}},{"line":567,"address":[],"length":0,"stats":{"Line":2}},{"line":568,"address":[],"length":0,"stats":{"Line":2}},{"line":570,"address":[],"length":0,"stats":{"Line":3}},{"line":571,"address":[],"length":0,"stats":{"Line":5}},{"line":572,"address":[],"length":0,"stats":{"Line":1}},{"line":573,"address":[],"length":0,"stats":{"Line":3}},{"line":574,"address":[],"length":0,"stats":{"Line":2}},{"line":575,"address":[],"length":0,"stats":{"Line":1}},{"line":576,"address":[],"length":0,"stats":{"Line":1}}],"covered":332,"coverable":332},{"path":["/","Users","chi","Projects","hu","src","data","display","tests.rs"],"content":"use super::*;\n\n#[test]\nfn time_ago_ms_just_now() {\n    let now = chrono::Utc::now().timestamp_millis();\n    assert_eq!(time_ago_ms(now), \"just now\");\n}\n\n#[test]\nfn time_ago_ms_minutes() {\n    let now = chrono::Utc::now().timestamp_millis();\n    let five_min_ago = now - 5 * 60 * 1000;\n    assert_eq!(time_ago_ms(five_min_ago), \"5m ago\");\n}\n\n#[test]\nfn time_ago_ms_hours() {\n    let now = chrono::Utc::now().timestamp_millis();\n    let two_hours_ago = now - 2 * 60 * 60 * 1000;\n    assert_eq!(time_ago_ms(two_hours_ago), \"2h ago\");\n}\n\n#[test]\nfn time_ago_ms_days() {\n    let now = chrono::Utc::now().timestamp_millis();\n    let three_days_ago = now - 3 * 24 * 60 * 60 * 1000;\n    assert_eq!(time_ago_ms(three_days_ago), \"3d ago\");\n}\n\n#[test]\nfn truncate_short() {\n    assert_eq!(truncate(\"hello\", 10), \"hello\");\n}\n\n#[test]\nfn truncate_exact() {\n    assert_eq!(truncate(\"hello\", 5), \"hello\");\n}\n\n#[test]\nfn truncate_long() {\n    assert_eq!(truncate(\"hello world\", 8), \"hello...\");\n}\n\n#[test]\nfn truncate_tiny_max() {\n    assert_eq!(truncate(\"hello\", 2), \"he\");\n}\n\n#[test]\nfn role_color_values() {\n    assert_eq!(role_color(\"user\"), Color::Cyan);\n    assert_eq!(role_color(\"assistant\"), Color::Green);\n    assert_eq!(role_color(\"system\"), Color::White);\n}\n\n#[test]\nfn status_color_values() {\n    assert_eq!(status_color(\"pending\"), Color::Yellow);\n    assert_eq!(status_color(\"in_progress\"), Color::Cyan);\n    assert_eq!(status_color(\"completed\"), Color::Green);\n    assert_eq!(status_color(\"other\"), Color::White);\n}\n\n#[test]\nfn format_tokens_small() {\n    assert_eq!(format_tokens(500), \"500\");\n}\n\n#[test]\nfn format_tokens_thousands() {\n    assert_eq!(format_tokens(1500), \"1.5K\");\n}\n\n#[test]\nfn format_tokens_millions() {\n    assert_eq!(format_tokens(2_500_000), \"2.5M\");\n}\n\n#[test]\nfn output_sync_table() {\n    let result = SyncResult {\n        history: 5,\n        messages: 100,\n        todos: 3,\n    };\n    assert!(output_sync(\u0026result, \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_sync_json() {\n    let result = SyncResult {\n        history: 0,\n        messages: 0,\n        todos: 0,\n    };\n    assert!(output_sync(\u0026result, \u0026OutputFormat::Json).is_ok());\n}\n\n#[test]\nfn output_config_table() {\n    let config = super::super::config::DataConfig::default();\n    assert!(output_config(\u0026config, \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_config_json() {\n    let config = super::super::config::DataConfig::default();\n    assert!(output_config(\u0026config, \u0026OutputFormat::Json).is_ok());\n}\n\nfn make_session() -\u003e Session {\n    Session {\n        id: \"abc-123-def\".to_string(),\n        project: \"/home/user/project\".to_string(),\n        display: Some(\"Test session\".to_string()),\n        started_at: chrono::Utc::now().timestamp_millis(),\n        message_count: 10,\n        total_cost_usd: 0.05,\n        git_branch: Some(\"main\".to_string()),\n    }\n}\n\n#[test]\nfn output_sessions_empty() {\n    assert!(output_sessions(\u0026[], \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_sessions_table() {\n    let sessions = vec![make_session()];\n    assert!(output_sessions(\u0026sessions, \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_sessions_json() {\n    let sessions = vec![make_session()];\n    assert!(output_sessions(\u0026sessions, \u0026OutputFormat::Json).is_ok());\n}\n\nfn make_message(role: \u0026str) -\u003e Message {\n    Message {\n        id: \"msg-1\".to_string(),\n        session_id: \"sess-1\".to_string(),\n        parent_id: None,\n        role: role.to_string(),\n        content: Some(\"Hello world\".to_string()),\n        model: if role == \"assistant\" {\n            Some(\"claude-sonnet-4-5-20251101\".to_string())\n        } else {\n            None\n        },\n        input_tokens: Some(100),\n        output_tokens: Some(200),\n        cost_usd: Some(0.001),\n        duration_ms: Some(500),\n        created_at: chrono::Utc::now().timestamp_millis(),\n    }\n}\n\n#[test]\nfn output_session_messages_empty() {\n    assert!(output_session_messages(\u0026[], \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_session_messages_table() {\n    let msgs = vec![make_message(\"user\"), make_message(\"assistant\")];\n    assert!(output_session_messages(\u0026msgs, \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_session_messages_json() {\n    let msgs = vec![make_message(\"user\")];\n    assert!(output_session_messages(\u0026msgs, \u0026OutputFormat::Json).is_ok());\n}\n\n#[test]\nfn output_session_messages_no_tokens() {\n    let msg = Message {\n        input_tokens: None,\n        output_tokens: None,\n        model: None,\n        ..make_message(\"user\")\n    };\n    assert!(output_session_messages(\u0026[msg], \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_search_results_empty() {\n    assert!(output_search_results(\u0026[], \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_search_results_table() {\n    let results = vec![SearchResult {\n        id: \"m1\".to_string(),\n        session_id: \"s1\".to_string(),\n        role: \"user\".to_string(),\n        content: Some(\"test query result\".to_string()),\n        model: None,\n        created_at: chrono::Utc::now().timestamp_millis(),\n        project: \"/home/user/proj\".to_string(),\n    }];\n    assert!(output_search_results(\u0026results, \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_search_results_json() {\n    assert!(output_search_results(\u0026[], \u0026OutputFormat::Json).is_ok());\n}\n\n#[test]\nfn output_stats_table() {\n    let stats = UsageStats {\n        total_sessions: 10,\n        total_messages: 100,\n        total_cost: 5.0,\n        total_input_tokens: 1_000_000,\n        total_output_tokens: 500_000,\n    };\n    let model_usage = vec![ModelUsage {\n        model: \"claude-sonnet-4-5-20251101\".to_string(),\n        count: 50,\n        cost: 3.0,\n        input_tokens: 800_000,\n        output_tokens: 400_000,\n    }];\n    assert!(output_stats(\u0026stats, \u0026model_usage, \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_stats_json() {\n    let stats = UsageStats::default();\n    assert!(output_stats(\u0026stats, \u0026[], \u0026OutputFormat::Json).is_ok());\n}\n\n#[test]\nfn output_stats_empty_models() {\n    let stats = UsageStats::default();\n    assert!(output_stats(\u0026stats, \u0026[], \u0026OutputFormat::Table).is_ok());\n}\n\nfn make_todo(status: \u0026str) -\u003e Todo {\n    Todo {\n        id: 1,\n        session_id: \"sess-1\".to_string(),\n        content: \"Fix the bug\".to_string(),\n        status: status.to_string(),\n        active_form: Some(\"Fixing bug\".to_string()),\n    }\n}\n\n#[test]\nfn output_todos_empty() {\n    assert!(output_todos(\u0026[], \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_todos_table() {\n    let todos = vec![\n        make_todo(\"pending\"),\n        make_todo(\"in_progress\"),\n        make_todo(\"completed\"),\n    ];\n    assert!(output_todos(\u0026todos, \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_todos_json() {\n    assert!(output_todos(\u0026[make_todo(\"pending\")], \u0026OutputFormat::Json).is_ok());\n}\n\n#[test]\nfn output_pending_todos_empty() {\n    assert!(output_pending_todos(\u0026[], \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_pending_todos_table() {\n    let todos = vec![TodoWithProject {\n        id: 1,\n        session_id: \"s1\".to_string(),\n        content: \"Review PR\".to_string(),\n        status: \"pending\".to_string(),\n        active_form: None,\n        project: \"/home/user/proj\".to_string(),\n    }];\n    assert!(output_pending_todos(\u0026todos, \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_pending_todos_json() {\n    assert!(output_pending_todos(\u0026[], \u0026OutputFormat::Json).is_ok());\n}\n\n#[test]\nfn output_tool_stats_empty() {\n    assert!(output_tool_stats(\u0026[], \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_tool_stats_table() {\n    let stats = vec![ToolUsageStats {\n        tool_name: \"Read\".to_string(),\n        count: 42,\n        last_used: chrono::Utc::now().timestamp_millis(),\n    }];\n    assert!(output_tool_stats(\u0026stats, \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_tool_stats_json() {\n    assert!(output_tool_stats(\u0026[], \u0026OutputFormat::Json).is_ok());\n}\n\n#[test]\nfn output_tool_detail_empty() {\n    assert!(output_tool_detail(\u0026[], \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_tool_detail_table() {\n    let detail = vec![ToolUsageDetail {\n        tool_name: \"Edit\".to_string(),\n        session_id: \"sess-1\".to_string(),\n        project: \"/home/user/proj\".to_string(),\n        created_at: chrono::Utc::now().timestamp_millis(),\n    }];\n    assert!(output_tool_detail(\u0026detail, \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_tool_detail_json() {\n    assert!(output_tool_detail(\u0026[], \u0026OutputFormat::Json).is_ok());\n}\n\n#[test]\nfn output_errors_empty() {\n    assert!(output_errors(\u0026[], \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_errors_table() {\n    let errors = vec![DebugError {\n        file: \"debug.log\".to_string(),\n        line: 10,\n        content: \"Error: something failed\".to_string(),\n        timestamp: chrono::Utc::now().timestamp(),\n    }];\n    assert!(output_errors(\u0026errors, \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_errors_json() {\n    assert!(output_errors(\u0026[], \u0026OutputFormat::Json).is_ok());\n}\n\nfn make_pricing_data() -\u003e PricingData {\n    PricingData {\n        subscription: \"max20x\".to_string(),\n        subscription_price: 200.0,\n        billing_cycle: pricing::calculate_billing_cycle(6, chrono::Utc::now().timestamp_millis()),\n        period_usage: PeriodUsage {\n            messages: 100,\n            input_tokens: 500_000,\n            output_tokens: 200_000,\n        },\n        model_costs: vec![ModelUsageWithCost {\n            model: \"claude-sonnet-4-5-20251101\".to_string(),\n            input_tokens: 500_000,\n            output_tokens: 200_000,\n            cost: 4.5,\n        }],\n        total_api_cost: 4.5,\n        projected_cost: 9.0,\n        break_even: pricing::calculate_break_even(200.0),\n        value_comparisons: pricing::get_value_comparison(4.5),\n    }\n}\n\n#[test]\nfn output_pricing_table() {\n    assert!(output_pricing(\u0026make_pricing_data(), \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_pricing_json() {\n    assert!(output_pricing(\u0026make_pricing_data(), \u0026OutputFormat::Json).is_ok());\n}\n\n#[test]\nfn output_pricing_empty_models() {\n    let mut data = make_pricing_data();\n    data.model_costs = vec![];\n    data.value_comparisons = vec![];\n    assert!(output_pricing(\u0026data, \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_branches_empty() {\n    assert!(output_branches(\u0026[], \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_branches_table() {\n    let branches = vec![\n        BranchWithPr {\n            branch: BranchStats {\n                git_branch: \"main\".to_string(),\n                session_count: 5,\n                session_ids: \"s1,s2,s3\".to_string(),\n                last_activity: chrono::Utc::now().timestamp_millis(),\n                total_messages: 50,\n                total_cost: 1.5,\n                project: \"/home/user/proj\".to_string(),\n            },\n            pr: Some(PrInfo {\n                number: 42,\n                title: \"Add feature\".to_string(),\n                state: \"OPEN\".to_string(),\n                url: \"https://github.com/org/repo/pull/42\".to_string(),\n            }),\n        },\n        BranchWithPr {\n            branch: BranchStats {\n                git_branch: \"feature/x\".to_string(),\n                session_count: 1,\n                session_ids: \"s4\".to_string(),\n                last_activity: chrono::Utc::now().timestamp_millis(),\n                total_messages: 10,\n                total_cost: 0.3,\n                project: \"/home/user/proj\".to_string(),\n            },\n            pr: None,\n        },\n    ];\n    assert!(output_branches(\u0026branches, \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_branches_json() {\n    assert!(output_branches(\u0026[], \u0026OutputFormat::Json).is_ok());\n}\n\n#[test]\nfn build_model_costs_empty() {\n    let costs = build_model_costs(\u0026[]);\n    assert!(costs.is_empty());\n}\n\n#[test]\nfn build_model_costs_calculates() {\n    let usage = vec![ModelTokenUsage {\n        model: \"claude-sonnet-4-5-20251101\".to_string(),\n        input_tokens: 1_000_000,\n        output_tokens: 1_000_000,\n    }];\n    let costs = build_model_costs(\u0026usage);\n    assert_eq!(costs.len(), 1);\n    assert!((costs[0].cost - 18.0).abs() \u003c 0.01);\n}\n\n#[test]\nfn output_pricing_negative_savings() {\n    let mut data = make_pricing_data();\n    data.total_api_cost = 5.0;\n    data.value_comparisons = vec![ValueComparison {\n        service: \"Test\".to_string(),\n        plan: \"Premium\".to_string(),\n        price: 200.0,\n        savings: -195.0,\n        savings_percent: -3900.0,\n    }];\n    assert!(output_pricing(\u0026data, \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_todos_unknown_status() {\n    let todo = Todo {\n        id: 1,\n        session_id: \"s1\".to_string(),\n        content: \"test\".to_string(),\n        status: \"unknown_status\".to_string(),\n        active_form: None,\n    };\n    assert!(output_todos(\u0026[todo], \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_pending_todos_unknown_status() {\n    let todo = TodoWithProject {\n        id: 1,\n        session_id: \"s1\".to_string(),\n        content: \"task\".to_string(),\n        status: \"weird_status\".to_string(),\n        active_form: None,\n        project: \"/proj\".to_string(),\n    };\n    assert!(output_pending_todos(\u0026[todo], \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_pricing_positive_savings() {\n    let mut data = make_pricing_data();\n    data.total_api_cost = 500.0;\n    data.value_comparisons = vec![ValueComparison {\n        service: \"Test\".to_string(),\n        plan: \"Basic\".to_string(),\n        price: 20.0,\n        savings: 480.0,\n        savings_percent: 96.0,\n    }];\n    assert!(output_pricing(\u0026data, \u0026OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_pending_in_progress() {\n    let todo = TodoWithProject {\n        id: 1,\n        session_id: \"s1\".to_string(),\n        content: \"task\".to_string(),\n        status: \"in_progress\".to_string(),\n        active_form: None,\n        project: \"/proj\".to_string(),\n    };\n    assert!(output_pending_todos(\u0026[todo], \u0026OutputFormat::Table).is_ok());\n}\n","traces":[{"line":112,"address":[],"length":0,"stats":{"Line":2}},{"line":114,"address":[],"length":0,"stats":{"Line":6}},{"line":115,"address":[],"length":0,"stats":{"Line":6}},{"line":116,"address":[],"length":0,"stats":{"Line":4}},{"line":117,"address":[],"length":0,"stats":{"Line":6}},{"line":120,"address":[],"length":0,"stats":{"Line":2}},{"line":141,"address":[],"length":0,"stats":{"Line":4}},{"line":143,"address":[],"length":0,"stats":{"Line":8}},{"line":144,"address":[],"length":0,"stats":{"Line":8}},{"line":146,"address":[],"length":0,"stats":{"Line":8}},{"line":147,"address":[],"length":0,"stats":{"Line":4}},{"line":148,"address":[],"length":0,"stats":{"Line":4}},{"line":153,"address":[],"length":0,"stats":{"Line":4}},{"line":154,"address":[],"length":0,"stats":{"Line":4}},{"line":155,"address":[],"length":0,"stats":{"Line":4}},{"line":156,"address":[],"length":0,"stats":{"Line":4}},{"line":157,"address":[],"length":0,"stats":{"Line":8}},{"line":244,"address":[],"length":0,"stats":{"Line":4}},{"line":247,"address":[],"length":0,"stats":{"Line":12}},{"line":248,"address":[],"length":0,"stats":{"Line":12}},{"line":249,"address":[],"length":0,"stats":{"Line":12}},{"line":250,"address":[],"length":0,"stats":{"Line":4}},{"line":359,"address":[],"length":0,"stats":{"Line":5}},{"line":361,"address":[],"length":0,"stats":{"Line":15}},{"line":363,"address":[],"length":0,"stats":{"Line":20}},{"line":364,"address":[],"length":0,"stats":{"Line":10}},{"line":369,"address":[],"length":0,"stats":{"Line":15}},{"line":377,"address":[],"length":0,"stats":{"Line":5}},{"line":378,"address":[],"length":0,"stats":{"Line":5}}],"covered":29,"coverable":29},{"path":["/","Users","chi","Projects","hu","src","data","mod.rs"],"content":"mod cli;\nmod config;\nmod db;\nmod display;\nmod paths;\nmod pricing;\nmod queries;\nmod schema;\nmod sync;\nmod types;\n\npub use cli::DataCommand;\n\nuse anyhow::{bail, Result};\nuse types::OutputFormat;\n\n#[cfg(not(tarpaulin_include))]\npub async fn run_command(cmd: DataCommand) -\u003e Result\u003c()\u003e {\n    match cmd {\n        DataCommand::Sync { force, quiet } =\u003e cmd_sync(force, quiet),\n        DataCommand::Config { json } =\u003e cmd_config(json),\n        DataCommand::Session { cmd } =\u003e cmd_session(cmd),\n        DataCommand::Stats { json, today } =\u003e cmd_stats(json, today),\n        DataCommand::Todos { cmd } =\u003e cmd_todos(cmd),\n        DataCommand::Search { query, limit, json } =\u003e cmd_search(\u0026query, limit, json),\n        DataCommand::Tools { tool, json } =\u003e cmd_tools(tool.as_deref(), json),\n        DataCommand::Errors { recent, json } =\u003e cmd_errors(recent, json),\n        DataCommand::Pricing {\n            subscription,\n            billing_day,\n            json,\n        } =\u003e cmd_pricing(\u0026subscription, billing_day, json),\n        DataCommand::Branches {\n            branch,\n            limit,\n            json,\n        } =\u003e cmd_branches(branch.as_deref(), limit, json).await,\n    }\n}\n\nfn get_format(json: bool) -\u003e OutputFormat {\n    if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    }\n}\n\n#[cfg(not(tarpaulin_include))]\nfn open_db() -\u003e Result\u003cdb::SqliteStore\u003e {\n    let cfg = config::load_data_config()?;\n    let store = db::SqliteStore::open_initialized(\u0026cfg.database)?;\n    Ok(store)\n}\n\n#[cfg(not(tarpaulin_include))]\nfn ensure_synced(store: \u0026db::SqliteStore) -\u003e Result\u003c()\u003e {\n    let cfg = config::load_data_config()?;\n    sync::sync_if_needed(\u0026store.conn, \u0026cfg.claude_dir, cfg.auto_sync_interval)?;\n    Ok(())\n}\n\n#[cfg(not(tarpaulin_include))]\nfn cmd_sync(force: bool, quiet: bool) -\u003e Result\u003c()\u003e {\n    let cfg = config::load_data_config()?;\n    let store = db::SqliteStore::open_initialized(\u0026cfg.database)?;\n\n    let result = if force {\n        sync::sync_all(\u0026store.conn, \u0026cfg.claude_dir)?\n    } else {\n        let synced = sync::sync_if_needed(\u0026store.conn, \u0026cfg.claude_dir, cfg.auto_sync_interval)?;\n        if !synced {\n            if !quiet {\n                println!(\"Already up to date. Use -f to force.\");\n            }\n            return Ok(());\n        }\n        sync::sync_all(\u0026store.conn, \u0026cfg.claude_dir)?\n    };\n\n    if !quiet {\n        display::output_sync(\u0026result, \u0026OutputFormat::Table)?;\n    }\n    Ok(())\n}\n\n#[cfg(not(tarpaulin_include))]\nfn cmd_config(json: bool) -\u003e Result\u003c()\u003e {\n    let cfg = config::load_data_config()?;\n    display::output_config(\u0026cfg, \u0026get_format(json))\n}\n\n#[cfg(not(tarpaulin_include))]\nfn cmd_session(cmd: cli::SessionCommand) -\u003e Result\u003c()\u003e {\n    let store = open_db()?;\n    ensure_synced(\u0026store)?;\n\n    match cmd {\n        cli::SessionCommand::List {\n            project,\n            limit,\n            json,\n        } =\u003e {\n            let sessions = queries::get_sessions(\u0026store.conn, project.as_deref(), limit)?;\n            display::output_sessions(\u0026sessions, \u0026get_format(json))\n        }\n        cli::SessionCommand::Read { id, json } =\u003e {\n            let session = queries::get_session_by_prefix(\u0026store.conn, \u0026id)?\n                .or_else(|| queries::get_session_by_id(\u0026store.conn, \u0026id).ok().flatten());\n\n            match session {\n                Some(s) =\u003e {\n                    let messages = queries::get_messages_by_session(\u0026store.conn, \u0026s.id)?;\n                    display::output_session_messages(\u0026messages, \u0026get_format(json))\n                }\n                None =\u003e bail!(\"Session not found: {id}\"),\n            }\n        }\n        cli::SessionCommand::Current { json } =\u003e {\n            let session_id = std::env::var(\"SESSION_ID\").unwrap_or_default();\n            if session_id.is_empty() {\n                bail!(\"SESSION_ID environment variable not set\");\n            }\n            let session = queries::get_session_by_id(\u0026store.conn, \u0026session_id)?;\n            match session {\n                Some(s) =\u003e {\n                    let messages = queries::get_messages_by_session(\u0026store.conn, \u0026s.id)?;\n                    display::output_session_messages(\u0026messages, \u0026get_format(json))\n                }\n                None =\u003e bail!(\"Current session not found: {session_id}\"),\n            }\n        }\n    }\n}\n\n#[cfg(not(tarpaulin_include))]\nfn cmd_stats(json: bool, today: bool) -\u003e Result\u003c()\u003e {\n    let store = open_db()?;\n    ensure_synced(\u0026store)?;\n\n    let since = if today {\n        Some(start_of_today_ms())\n    } else {\n        None\n    };\n\n    let stats = queries::get_usage_stats(\u0026store.conn, since)?;\n    let model_usage = queries::get_model_usage(\u0026store.conn, since)?;\n    display::output_stats(\u0026stats, \u0026model_usage, \u0026get_format(json))\n}\n\n#[cfg(not(tarpaulin_include))]\nfn cmd_todos(cmd: cli::TodosCommand) -\u003e Result\u003c()\u003e {\n    let store = open_db()?;\n    ensure_synced(\u0026store)?;\n\n    match cmd {\n        cli::TodosCommand::List { status, json } =\u003e {\n            let todos = queries::get_todos(\u0026store.conn, status.as_deref())?;\n            display::output_todos(\u0026todos, \u0026get_format(json))\n        }\n        cli::TodosCommand::Pending { project, json } =\u003e {\n            let todos = queries::get_pending_todos(\u0026store.conn, project.as_deref())?;\n            display::output_pending_todos(\u0026todos, \u0026get_format(json))\n        }\n    }\n}\n\n#[cfg(not(tarpaulin_include))]\nfn cmd_search(query: \u0026str, limit: i64, json: bool) -\u003e Result\u003c()\u003e {\n    let store = open_db()?;\n    ensure_synced(\u0026store)?;\n\n    let results = queries::search_messages(\u0026store.conn, query, limit)?;\n    display::output_search_results(\u0026results, \u0026get_format(json))\n}\n\n#[cfg(not(tarpaulin_include))]\nfn cmd_tools(tool: Option\u003c\u0026str\u003e, json: bool) -\u003e Result\u003c()\u003e {\n    let store = open_db()?;\n    ensure_synced(\u0026store)?;\n    let format = get_format(json);\n\n    match tool {\n        Some(name) =\u003e {\n            let detail = queries::get_tool_detail(\u0026store.conn, name)?;\n            display::output_tool_detail(\u0026detail, \u0026format)\n        }\n        None =\u003e {\n            let stats = queries::get_tool_stats(\u0026store.conn)?;\n            display::output_tool_stats(\u0026stats, \u0026format)\n        }\n    }\n}\n\n#[cfg(not(tarpaulin_include))]\nfn cmd_errors(recent_days: u32, json: bool) -\u003e Result\u003c()\u003e {\n    let cfg = config::load_data_config()?;\n    let errors = scan_debug_errors(\u0026cfg.claude_dir, recent_days)?;\n    display::output_errors(\u0026errors, \u0026get_format(json))\n}\n\nfn scan_debug_errors(\n    claude_dir: \u0026std::path::Path,\n    recent_days: u32,\n) -\u003e Result\u003cVec\u003ctypes::DebugError\u003e\u003e {\n    let dir = paths::debug_dir(claude_dir);\n    if !dir.exists() {\n        return Ok(vec![]);\n    }\n\n    let cutoff = chrono::Utc::now().timestamp() - (recent_days as i64 * 86400);\n    let error_patterns =\n        regex::Regex::new(r\"(?i)(error|failed|exception|warning|ENOENT|EACCES|EPERM)\")?;\n\n    let mut errors = Vec::new();\n    let mut seen = std::collections::HashSet::new();\n\n    for entry in std::fs::read_dir(\u0026dir)? {\n        let entry = entry?;\n        let path = entry.path();\n        if path.extension().and_then(|e| e.to_str()) != Some(\"txt\") {\n            continue;\n        }\n\n        let metadata = entry.metadata()?;\n        let modified = metadata\n            .modified()?\n            .duration_since(std::time::UNIX_EPOCH)?\n            .as_secs() as i64;\n\n        if modified \u003c cutoff {\n            continue;\n        }\n\n        let content = std::fs::read_to_string(\u0026path)?;\n        let filename = path\n            .file_name()\n            .unwrap_or_default()\n            .to_string_lossy()\n            .to_string();\n\n        for (i, line) in content.lines().enumerate() {\n            if error_patterns.is_match(line) \u0026\u0026 seen.insert(line.to_string()) {\n                errors.push(types::DebugError {\n                    file: filename.clone(),\n                    line: i + 1,\n                    content: line.to_string(),\n                    timestamp: modified,\n                });\n            }\n        }\n    }\n\n    errors.truncate(50);\n    Ok(errors)\n}\n\n#[cfg(not(tarpaulin_include))]\nfn cmd_pricing(subscription: \u0026str, billing_day: u32, json: bool) -\u003e Result\u003c()\u003e {\n    let store = open_db()?;\n    ensure_synced(\u0026store)?;\n\n    let now = chrono::Utc::now().timestamp_millis();\n    let cycle = pricing::calculate_billing_cycle(billing_day, now);\n    let sub_price = pricing::get_subscription_price(subscription);\n\n    let period_usage = queries::get_period_usage(\u0026store.conn, cycle.start_ms)?;\n    let model_usage = queries::get_period_model_usage(\u0026store.conn, cycle.start_ms)?;\n    let model_costs = display::build_model_costs(\u0026model_usage);\n    let total_api_cost: f64 = model_costs.iter().map(|m| m.cost).sum();\n    let projected =\n        pricing::project_cycle_cost(total_api_cost, cycle.days_elapsed, cycle.total_days);\n    let break_even = pricing::calculate_break_even(sub_price);\n    let comparisons = pricing::get_value_comparison(total_api_cost);\n\n    let data = display::PricingData {\n        subscription: subscription.to_string(),\n        subscription_price: sub_price,\n        billing_cycle: cycle,\n        period_usage,\n        model_costs,\n        total_api_cost,\n        projected_cost: projected,\n        break_even,\n        value_comparisons: comparisons,\n    };\n\n    display::output_pricing(\u0026data, \u0026get_format(json))\n}\n\n#[cfg(not(tarpaulin_include))]\nasync fn cmd_branches(branch: Option\u003c\u0026str\u003e, limit: i64, json: bool) -\u003e Result\u003c()\u003e {\n    let store = open_db()?;\n    ensure_synced(\u0026store)?;\n\n    let stats = queries::get_branch_stats(\u0026store.conn, branch, limit)?;\n    let mut branches = Vec::new();\n\n    for b in stats {\n        let pr = fetch_pr_info(\u0026b.git_branch).await;\n        branches.push(display::BranchWithPr { branch: b, pr });\n    }\n\n    display::output_branches(\u0026branches, \u0026get_format(json))\n}\n\n#[cfg(not(tarpaulin_include))]\nasync fn fetch_pr_info(branch: \u0026str) -\u003e Option\u003cdisplay::PrInfo\u003e {\n    let output: std::process::Output = tokio::process::Command::new(\"gh\")\n        .args([\n            \"pr\",\n            \"list\",\n            \"--head\",\n            branch,\n            \"--json\",\n            \"number,title,state,url\",\n            \"--limit\",\n            \"1\",\n        ])\n        .output()\n        .await\n        .ok()?;\n\n    if !output.status.success() {\n        return None;\n    }\n\n    let prs: Vec\u003cserde_json::Value\u003e = serde_json::from_slice(\u0026output.stdout).ok()?;\n    let pr = prs.first()?;\n\n    Some(display::PrInfo {\n        number: pr.get(\"number\")?.as_i64()?,\n        title: pr.get(\"title\")?.as_str()?.to_string(),\n        state: pr.get(\"state\")?.as_str()?.to_string(),\n        url: pr.get(\"url\")?.as_str()?.to_string(),\n    })\n}\n\nfn start_of_today_ms() -\u003e i64 {\n    let now = chrono::Utc::now();\n    now.date_naive()\n        .and_hms_opt(0, 0, 0)\n        .unwrap()\n        .and_utc()\n        .timestamp_millis()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn get_format_json() {\n        assert!(matches!(get_format(true), OutputFormat::Json));\n    }\n\n    #[test]\n    fn get_format_table() {\n        assert!(matches!(get_format(false), OutputFormat::Table));\n    }\n\n    #[test]\n    fn start_of_today_is_past() {\n        let ms = start_of_today_ms();\n        let now = chrono::Utc::now().timestamp_millis();\n        assert!(ms \u003c= now);\n        assert!(ms \u003e now - 86_400_000); // Within last 24h\n    }\n\n    #[test]\n    fn scan_debug_errors_missing_dir() {\n        let errors = scan_debug_errors(std::path::Path::new(\"/nonexistent\"), 7).unwrap();\n        assert!(errors.is_empty());\n    }\n\n    #[test]\n    fn scan_debug_errors_with_fixture() {\n        let tmp = std::env::temp_dir().join(\"hu-test-debug-errors\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n        let debug = tmp.join(\"debug\");\n        std::fs::create_dir_all(\u0026debug).unwrap();\n\n        std::fs::write(\n            debug.join(\"test.txt\"),\n            \"normal line\\nError: something broke\\nFailed to connect\\nanother normal line\\n\",\n        )\n        .unwrap();\n\n        let errors = scan_debug_errors(\u0026tmp, 7).unwrap();\n        assert_eq!(errors.len(), 2);\n        assert!(errors[0].content.contains(\"Error\"));\n        assert!(errors[1].content.contains(\"Failed\"));\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn scan_debug_errors_deduplication() {\n        let tmp = std::env::temp_dir().join(\"hu-test-debug-dedup\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n        let debug = tmp.join(\"debug\");\n        std::fs::create_dir_all(\u0026debug).unwrap();\n\n        std::fs::write(debug.join(\"a.txt\"), \"Error: same message\\n\").unwrap();\n        std::fs::write(debug.join(\"b.txt\"), \"Error: same message\\n\").unwrap();\n\n        let errors = scan_debug_errors(\u0026tmp, 7).unwrap();\n        assert_eq!(errors.len(), 1); // Deduplicated\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn scan_debug_errors_skips_non_txt() {\n        let tmp = std::env::temp_dir().join(\"hu-test-debug-skip\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n        let debug = tmp.join(\"debug\");\n        std::fs::create_dir_all(\u0026debug).unwrap();\n\n        std::fs::write(debug.join(\"test.log\"), \"Error: in log file\\n\").unwrap();\n\n        let errors = scan_debug_errors(\u0026tmp, 7).unwrap();\n        assert!(errors.is_empty()); // .log not .txt\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn scan_debug_errors_skips_old_files() {\n        let tmp = std::env::temp_dir().join(\"hu-test-debug-old\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n        let debug = tmp.join(\"debug\");\n        std::fs::create_dir_all(\u0026debug).unwrap();\n\n        let file_path = debug.join(\"old.txt\");\n        std::fs::write(\u0026file_path, \"Error: old error\\n\").unwrap();\n\n        // Set file modification time to 30 days ago\n        let old_time = std::time::SystemTime::now() - std::time::Duration::from_secs(30 * 86400);\n        let file = std::fs::File::options()\n            .write(true)\n            .open(\u0026file_path)\n            .unwrap();\n        file.set_times(std::fs::FileTimes::new().set_modified(old_time))\n            .unwrap();\n\n        // Only look at last 7 days - old file should be skipped\n        let errors = scan_debug_errors(\u0026tmp, 7).unwrap();\n        assert!(errors.is_empty());\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn scan_debug_errors_max_50() {\n        let tmp = std::env::temp_dir().join(\"hu-test-debug-max\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n        let debug = tmp.join(\"debug\");\n        std::fs::create_dir_all(\u0026debug).unwrap();\n\n        let mut content = String::new();\n        for i in 0..60 {\n            content.push_str(\u0026format!(\"Error: unique error {i}\\n\"));\n        }\n        std::fs::write(debug.join(\"many.txt\"), \u0026content).unwrap();\n\n        let errors = scan_debug_errors(\u0026tmp, 7).unwrap();\n        assert_eq!(errors.len(), 50); // Capped at 50\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n}\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":1}},{"line":45,"address":[],"length":0,"stats":{"Line":1}},{"line":203,"address":[],"length":0,"stats":{"Line":6}},{"line":207,"address":[],"length":0,"stats":{"Line":18}},{"line":208,"address":[],"length":0,"stats":{"Line":6}},{"line":209,"address":[],"length":0,"stats":{"Line":1}},{"line":212,"address":[],"length":0,"stats":{"Line":15}},{"line":213,"address":[],"length":0,"stats":{"Line":5}},{"line":214,"address":[],"length":0,"stats":{"Line":10}},{"line":216,"address":[],"length":0,"stats":{"Line":10}},{"line":217,"address":[],"length":0,"stats":{"Line":10}},{"line":219,"address":[],"length":0,"stats":{"Line":16}},{"line":220,"address":[],"length":0,"stats":{"Line":12}},{"line":221,"address":[],"length":0,"stats":{"Line":18}},{"line":222,"address":[],"length":0,"stats":{"Line":30}},{"line":223,"address":[],"length":0,"stats":{"Line":1}},{"line":226,"address":[],"length":0,"stats":{"Line":15}},{"line":227,"address":[],"length":0,"stats":{"Line":10}},{"line":228,"address":[],"length":0,"stats":{"Line":5}},{"line":229,"address":[],"length":0,"stats":{"Line":5}},{"line":230,"address":[],"length":0,"stats":{"Line":5}},{"line":232,"address":[],"length":0,"stats":{"Line":5}},{"line":233,"address":[],"length":0,"stats":{"Line":1}},{"line":236,"address":[],"length":0,"stats":{"Line":12}},{"line":237,"address":[],"length":0,"stats":{"Line":8}},{"line":243,"address":[],"length":0,"stats":{"Line":140}},{"line":244,"address":[],"length":0,"stats":{"Line":517}},{"line":245,"address":[],"length":0,"stats":{"Line":189}},{"line":246,"address":[],"length":0,"stats":{"Line":189}},{"line":247,"address":[],"length":0,"stats":{"Line":126}},{"line":248,"address":[],"length":0,"stats":{"Line":126}},{"line":249,"address":[],"length":0,"stats":{"Line":63}},{"line":255,"address":[],"length":0,"stats":{"Line":10}},{"line":256,"address":[],"length":0,"stats":{"Line":5}},{"line":340,"address":[],"length":0,"stats":{"Line":1}},{"line":341,"address":[],"length":0,"stats":{"Line":2}},{"line":342,"address":[],"length":0,"stats":{"Line":2}}],"covered":39,"coverable":39},{"path":["/","Users","chi","Projects","hu","src","data","paths.rs"],"content":"use anyhow::Result;\nuse serde::de::DeserializeOwned;\nuse std::path::{Path, PathBuf};\n\n#[allow(dead_code)]\npub fn encode_project_path(path: \u0026str) -\u003e String {\n    // Order matters: replace \"/.\" first (double dash), then \"/\" (single dash)\n    path.replace(\"/.\", \"--\").replace('/', \"-\")\n}\n\npub fn decode_project_path(encoded: \u0026str) -\u003e String {\n    // Order matters: replace \"--\" first (was \"/.\"), then \"-\" (was \"/\")\n    encoded.replace(\"--\", \"/.\").replace('-', \"/\")\n}\n\npub fn history_path(claude_dir: \u0026Path) -\u003e PathBuf {\n    claude_dir.join(\"history.jsonl\")\n}\n\npub fn projects_dir(claude_dir: \u0026Path) -\u003e PathBuf {\n    claude_dir.join(\"projects\")\n}\n\npub fn todos_dir(claude_dir: \u0026Path) -\u003e PathBuf {\n    claude_dir.join(\"todos\")\n}\n\npub fn debug_dir(claude_dir: \u0026Path) -\u003e PathBuf {\n    claude_dir.join(\"debug\")\n}\n\npub fn parse_jsonl\u003cT: DeserializeOwned\u003e(content: \u0026str) -\u003e Vec\u003cT\u003e {\n    content\n        .lines()\n        .filter(|line| !line.trim().is_empty())\n        .filter_map(|line| serde_json::from_str(line).ok())\n        .collect()\n}\n\npub fn list_project_dirs(claude_dir: \u0026Path) -\u003e Result\u003cVec\u003cProjectDir\u003e\u003e {\n    let dir = projects_dir(claude_dir);\n    if !dir.exists() {\n        return Ok(vec![]);\n    }\n    let mut projects = Vec::new();\n    for entry in std::fs::read_dir(\u0026dir)? {\n        let entry = entry?;\n        if entry.file_type()?.is_dir() {\n            let name = entry.file_name().to_string_lossy().to_string();\n            projects.push(ProjectDir {\n                path: decode_project_path(\u0026name),\n                encoded: name,\n                dir: entry.path(),\n            });\n        }\n    }\n    projects.sort_by(|a, b| a.encoded.cmp(\u0026b.encoded));\n    Ok(projects)\n}\n\n#[derive(Debug, Clone)]\npub struct ProjectDir {\n    pub encoded: String,\n    pub path: String,\n    pub dir: PathBuf,\n}\n\npub fn list_session_files(project_dir: \u0026Path) -\u003e Result\u003cVec\u003cSessionFile\u003e\u003e {\n    if !project_dir.exists() {\n        return Ok(vec![]);\n    }\n    let mut sessions = Vec::new();\n    for entry in std::fs::read_dir(project_dir)? {\n        let entry = entry?;\n        let name = entry.file_name().to_string_lossy().to_string();\n        if name.ends_with(\".jsonl\") {\n            let session_id = name.trim_end_matches(\".jsonl\").to_string();\n            sessions.push(SessionFile {\n                session_id,\n                path: entry.path(),\n            });\n        }\n    }\n    sessions.sort_by(|a, b| a.session_id.cmp(\u0026b.session_id));\n    Ok(sessions)\n}\n\n#[derive(Debug, Clone)]\npub struct SessionFile {\n    pub session_id: String,\n    pub path: PathBuf,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn encode_basic_path() {\n        assert_eq!(\n            encode_project_path(\"/Users/chi/project\"),\n            \"-Users-chi-project\"\n        );\n    }\n\n    #[test]\n    fn encode_dotfile_path() {\n        assert_eq!(\n            encode_project_path(\"/Users/chi/.claude\"),\n            \"-Users-chi--claude\"\n        );\n    }\n\n    #[test]\n    fn decode_basic_path() {\n        assert_eq!(\n            decode_project_path(\"-Users-chi-project\"),\n            \"/Users/chi/project\"\n        );\n    }\n\n    #[test]\n    fn decode_dotfile_path() {\n        assert_eq!(\n            decode_project_path(\"-Users-chi--claude\"),\n            \"/Users/chi/.claude\"\n        );\n    }\n\n    #[test]\n    fn encode_decode_roundtrip() {\n        let paths = vec![\n            \"/Users/chi/Projects/hu\",\n            \"/Users/chi/.claude\",\n            \"/home/user/.config/test\",\n            \"/tmp/a\",\n        ];\n        for path in paths {\n            let encoded = encode_project_path(path);\n            let decoded = decode_project_path(\u0026encoded);\n            assert_eq!(decoded, path, \"roundtrip failed for {path}\");\n        }\n    }\n\n    #[test]\n    fn encode_root() {\n        assert_eq!(encode_project_path(\"/\"), \"-\");\n    }\n\n    #[test]\n    fn decode_single_dash() {\n        assert_eq!(decode_project_path(\"-\"), \"/\");\n    }\n\n    #[test]\n    fn history_path_construction() {\n        let p = history_path(Path::new(\"/home/user/.claude\"));\n        assert_eq!(p, PathBuf::from(\"/home/user/.claude/history.jsonl\"));\n    }\n\n    #[test]\n    fn projects_dir_construction() {\n        let p = projects_dir(Path::new(\"/home/user/.claude\"));\n        assert_eq!(p, PathBuf::from(\"/home/user/.claude/projects\"));\n    }\n\n    #[test]\n    fn todos_dir_construction() {\n        let p = todos_dir(Path::new(\"/home/user/.claude\"));\n        assert_eq!(p, PathBuf::from(\"/home/user/.claude/todos\"));\n    }\n\n    #[test]\n    fn debug_dir_construction() {\n        let p = debug_dir(Path::new(\"/home/user/.claude\"));\n        assert_eq!(p, PathBuf::from(\"/home/user/.claude/debug\"));\n    }\n\n    #[test]\n    fn parse_jsonl_valid() {\n        let content = r#\"{\"name\":\"a\",\"value\":1}\n{\"name\":\"b\",\"value\":2}\n\"#;\n        #[derive(serde::Deserialize)]\n        struct Item {\n            name: String,\n            value: i32,\n        }\n        let items: Vec\u003cItem\u003e = parse_jsonl(content);\n        assert_eq!(items.len(), 2);\n        assert_eq!(items[0].name, \"a\");\n        assert_eq!(items[1].value, 2);\n    }\n\n    #[test]\n    fn parse_jsonl_skip_malformed() {\n        let content = r#\"{\"valid\":true}\nnot json at all\n{\"also_valid\":true}\n\"#;\n        #[derive(serde::Deserialize)]\n        #[allow(dead_code)]\n        struct Item {\n            valid: Option\u003cbool\u003e,\n            also_valid: Option\u003cbool\u003e,\n        }\n        let items: Vec\u003cItem\u003e = parse_jsonl(content);\n        assert_eq!(items.len(), 2);\n    }\n\n    #[test]\n    fn parse_jsonl_empty() {\n        let items: Vec\u003cserde_json::Value\u003e = parse_jsonl(\"\");\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn parse_jsonl_blank_lines() {\n        let content = \"\\n\\n{\\\"x\\\":1}\\n\\n{\\\"x\\\":2}\\n\\n\";\n        #[derive(serde::Deserialize)]\n        #[allow(dead_code)]\n        struct Item {\n            x: i32,\n        }\n        let items: Vec\u003cItem\u003e = parse_jsonl(content);\n        assert_eq!(items.len(), 2);\n    }\n\n    #[test]\n    fn list_project_dirs_missing() {\n        let dirs = list_project_dirs(Path::new(\"/nonexistent/path\")).unwrap();\n        assert!(dirs.is_empty());\n    }\n\n    #[test]\n    fn list_session_files_missing() {\n        let files = list_session_files(Path::new(\"/nonexistent/path\")).unwrap();\n        assert!(files.is_empty());\n    }\n\n    #[test]\n    fn list_project_dirs_real() {\n        let tmp = std::env::temp_dir().join(\"hu-test-projects\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n        std::fs::create_dir_all(tmp.join(\"projects\").join(\"-Users-chi-proj\")).unwrap();\n        std::fs::create_dir_all(tmp.join(\"projects\").join(\"-Users-chi--hidden\")).unwrap();\n\n        let dirs = list_project_dirs(\u0026tmp).unwrap();\n        assert_eq!(dirs.len(), 2);\n        // Sorted by encoded name\n        assert_eq!(dirs[0].encoded, \"-Users-chi--hidden\");\n        assert_eq!(dirs[0].path, \"/Users/chi/.hidden\");\n        assert_eq!(dirs[1].encoded, \"-Users-chi-proj\");\n        assert_eq!(dirs[1].path, \"/Users/chi/proj\");\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn list_session_files_real() {\n        let tmp = std::env::temp_dir().join(\"hu-test-sessions\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n        std::fs::create_dir_all(\u0026tmp).unwrap();\n        std::fs::write(tmp.join(\"abc-123.jsonl\"), \"\").unwrap();\n        std::fs::write(tmp.join(\"def-456.jsonl\"), \"\").unwrap();\n        std::fs::write(tmp.join(\"notes.txt\"), \"\").unwrap();\n\n        let files = list_session_files(\u0026tmp).unwrap();\n        assert_eq!(files.len(), 2);\n        assert_eq!(files[0].session_id, \"abc-123\");\n        assert_eq!(files[1].session_id, \"def-456\");\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":7}},{"line":8,"address":[],"length":0,"stats":{"Line":21}},{"line":11,"address":[],"length":0,"stats":{"Line":15}},{"line":13,"address":[],"length":0,"stats":{"Line":45}},{"line":16,"address":[],"length":0,"stats":{"Line":7}},{"line":17,"address":[],"length":0,"stats":{"Line":14}},{"line":20,"address":[],"length":0,"stats":{"Line":12}},{"line":21,"address":[],"length":0,"stats":{"Line":24}},{"line":24,"address":[],"length":0,"stats":{"Line":9}},{"line":25,"address":[],"length":0,"stats":{"Line":18}},{"line":28,"address":[],"length":0,"stats":{"Line":7}},{"line":29,"address":[],"length":0,"stats":{"Line":14}},{"line":32,"address":[],"length":0,"stats":{"Line":13}},{"line":33,"address":[],"length":0,"stats":{"Line":13}},{"line":35,"address":[],"length":0,"stats":{"Line":71}},{"line":36,"address":[],"length":0,"stats":{"Line":88}},{"line":40,"address":[],"length":0,"stats":{"Line":11}},{"line":41,"address":[],"length":0,"stats":{"Line":33}},{"line":42,"address":[],"length":0,"stats":{"Line":11}},{"line":43,"address":[],"length":0,"stats":{"Line":3}},{"line":45,"address":[],"length":0,"stats":{"Line":16}},{"line":46,"address":[],"length":0,"stats":{"Line":24}},{"line":47,"address":[],"length":0,"stats":{"Line":16}},{"line":48,"address":[],"length":0,"stats":{"Line":32}},{"line":49,"address":[],"length":0,"stats":{"Line":32}},{"line":50,"address":[],"length":0,"stats":{"Line":24}},{"line":51,"address":[],"length":0,"stats":{"Line":24}},{"line":52,"address":[],"length":0,"stats":{"Line":16}},{"line":53,"address":[],"length":0,"stats":{"Line":8}},{"line":57,"address":[],"length":0,"stats":{"Line":19}},{"line":58,"address":[],"length":0,"stats":{"Line":8}},{"line":68,"address":[],"length":0,"stats":{"Line":8}},{"line":69,"address":[],"length":0,"stats":{"Line":8}},{"line":70,"address":[],"length":0,"stats":{"Line":1}},{"line":72,"address":[],"length":0,"stats":{"Line":14}},{"line":73,"address":[],"length":0,"stats":{"Line":23}},{"line":74,"address":[],"length":0,"stats":{"Line":18}},{"line":75,"address":[],"length":0,"stats":{"Line":27}},{"line":76,"address":[],"length":0,"stats":{"Line":17}},{"line":77,"address":[],"length":0,"stats":{"Line":32}},{"line":78,"address":[],"length":0,"stats":{"Line":24}},{"line":79,"address":[],"length":0,"stats":{"Line":16}},{"line":80,"address":[],"length":0,"stats":{"Line":8}},{"line":84,"address":[],"length":0,"stats":{"Line":17}},{"line":85,"address":[],"length":0,"stats":{"Line":7}}],"covered":45,"coverable":45},{"path":["/","Users","chi","Projects","hu","src","data","pricing.rs"],"content":"use serde::Serialize;\n\n#[derive(Debug, Clone, Serialize)]\npub struct ModelPricing {\n    pub name: \u0026'static str,\n    pub display_name: \u0026'static str,\n    pub input_per_mtok: f64,\n    pub output_per_mtok: f64,\n    pub cache_write_per_mtok: Option\u003cf64\u003e,\n    pub cache_read_per_mtok: Option\u003cf64\u003e,\n}\n\nconst MODEL_PRICING: \u0026[(\u0026str, ModelPricing)] = \u0026[\n    (\n        \"claude-opus-4-5-20251101\",\n        ModelPricing {\n            name: \"claude-opus-4-5-20251101\",\n            display_name: \"Opus 4.5\",\n            input_per_mtok: 5.0,\n            output_per_mtok: 25.0,\n            cache_write_per_mtok: Some(6.25),\n            cache_read_per_mtok: Some(0.5),\n        },\n    ),\n    (\n        \"claude-sonnet-4-5-20251101\",\n        ModelPricing {\n            name: \"claude-sonnet-4-5-20251101\",\n            display_name: \"Sonnet 4.5\",\n            input_per_mtok: 3.0,\n            output_per_mtok: 15.0,\n            cache_write_per_mtok: Some(3.75),\n            cache_read_per_mtok: Some(0.3),\n        },\n    ),\n    (\n        \"claude-haiku-4-5-20251001\",\n        ModelPricing {\n            name: \"claude-haiku-4-5-20251001\",\n            display_name: \"Haiku 4.5\",\n            input_per_mtok: 1.0,\n            output_per_mtok: 5.0,\n            cache_write_per_mtok: Some(1.25),\n            cache_read_per_mtok: Some(0.1),\n        },\n    ),\n    (\n        \"claude-opus-4-20250514\",\n        ModelPricing {\n            name: \"claude-opus-4-20250514\",\n            display_name: \"Opus 4\",\n            input_per_mtok: 15.0,\n            output_per_mtok: 75.0,\n            cache_write_per_mtok: None,\n            cache_read_per_mtok: None,\n        },\n    ),\n    (\n        \"claude-sonnet-4-20250514\",\n        ModelPricing {\n            name: \"claude-sonnet-4-20250514\",\n            display_name: \"Sonnet 4\",\n            input_per_mtok: 3.0,\n            output_per_mtok: 15.0,\n            cache_write_per_mtok: None,\n            cache_read_per_mtok: None,\n        },\n    ),\n    (\n        \"claude-3-5-sonnet-20241022\",\n        ModelPricing {\n            name: \"claude-3-5-sonnet-20241022\",\n            display_name: \"Sonnet 3.5\",\n            input_per_mtok: 3.0,\n            output_per_mtok: 15.0,\n            cache_write_per_mtok: None,\n            cache_read_per_mtok: None,\n        },\n    ),\n    (\n        \"claude-3-haiku-20240307\",\n        ModelPricing {\n            name: \"claude-3-haiku-20240307\",\n            display_name: \"Haiku 3\",\n            input_per_mtok: 0.25,\n            output_per_mtok: 1.25,\n            cache_write_per_mtok: None,\n            cache_read_per_mtok: None,\n        },\n    ),\n];\n\nconst DEFAULT_PRICING: ModelPricing = ModelPricing {\n    name: \"unknown\",\n    display_name: \"Unknown Model\",\n    input_per_mtok: 3.0,\n    output_per_mtok: 15.0,\n    cache_write_per_mtok: None,\n    cache_read_per_mtok: None,\n};\n\npub fn get_model_pricing(model_name: Option\u003c\u0026str\u003e) -\u003e ModelPricing {\n    let name = match model_name {\n        Some(n) =\u003e n,\n        None =\u003e return DEFAULT_PRICING,\n    };\n\n    // Exact match\n    for (key, pricing) in MODEL_PRICING {\n        if *key == name {\n            return pricing.clone();\n        }\n    }\n\n    // Partial match: compare first 3 dash-separated segments\n    let name_lower = name.to_lowercase();\n    let name_prefix = first_n_segments(\u0026name_lower, 3);\n    for (key, pricing) in MODEL_PRICING {\n        let key_prefix = first_n_segments(key, 3);\n        if name_prefix == key_prefix {\n            return pricing.clone();\n        }\n    }\n\n    // Family match\n    if name_lower.contains(\"opus-4-5\") || name_lower.contains(\"opus-4.5\") {\n        return MODEL_PRICING[0].1.clone(); // Opus 4.5\n    }\n    if name_lower.contains(\"sonnet-4-5\") || name_lower.contains(\"sonnet-4.5\") {\n        return MODEL_PRICING[1].1.clone(); // Sonnet 4.5\n    }\n    if name_lower.contains(\"haiku-4-5\") || name_lower.contains(\"haiku-4.5\") {\n        return MODEL_PRICING[2].1.clone(); // Haiku 4.5\n    }\n    if name_lower.contains(\"opus\") {\n        return MODEL_PRICING[3].1.clone(); // Opus 4\n    }\n    if name_lower.contains(\"sonnet\") {\n        return MODEL_PRICING[4].1.clone(); // Sonnet 4\n    }\n    if name_lower.contains(\"haiku\") {\n        return MODEL_PRICING[6].1.clone(); // Haiku 3\n    }\n\n    DEFAULT_PRICING\n}\n\nfn first_n_segments(s: \u0026str, n: usize) -\u003e String {\n    s.split('-').take(n).collect::\u003cVec\u003c_\u003e\u003e().join(\"-\")\n}\n\npub fn calculate_cost(model_name: Option\u003c\u0026str\u003e, input_tokens: i64, output_tokens: i64) -\u003e f64 {\n    let pricing = get_model_pricing(model_name);\n    let input_cost = (input_tokens as f64 / 1_000_000.0) * pricing.input_per_mtok;\n    let output_cost = (output_tokens as f64 / 1_000_000.0) * pricing.output_per_mtok;\n    input_cost + output_cost\n}\n\npub fn format_cost(cost: f64) -\u003e String {\n    if cost \u003c 0.01 {\n        format!(\"${:.4}\", cost)\n    } else if cost \u003c 1.0 {\n        format!(\"${:.3}\", cost)\n    } else {\n        format!(\"${:.2}\", cost)\n    }\n}\n\n#[allow(dead_code)]\npub fn get_all_pricing() -\u003e Vec\u003cModelPricing\u003e {\n    MODEL_PRICING.iter().map(|(_, p)| p.clone()).collect()\n}\n\n// --- Subscription \u0026 Billing ---\n\nfn get_subscription_prices() -\u003e \u0026'static [(\u0026'static str, f64)] {\n    \u0026[\n        (\"free\", 0.0),\n        (\"pro\", 20.0),\n        (\"max5x\", 100.0),\n        (\"max20x\", 200.0),\n    ]\n}\n\npub fn get_subscription_price(tier: \u0026str) -\u003e f64 {\n    let normalized = tier.to_lowercase().replace(['-', ' '], \"\");\n    for (key, price) in get_subscription_prices() {\n        if *key == normalized {\n            return *price;\n        }\n    }\n    200.0\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct BillingCycle {\n    pub start_ms: i64,\n    pub end_ms: i64,\n    pub billing_day: u32,\n    pub total_days: i64,\n    pub days_elapsed: i64,\n    pub days_remaining: i64,\n}\n\npub fn calculate_billing_cycle(billing_day: u32, now_ms: i64) -\u003e BillingCycle {\n    use chrono::{Datelike, NaiveDate, TimeZone, Utc};\n\n    let now = Utc.timestamp_millis_opt(now_ms).unwrap();\n    let today = now.date_naive();\n\n    let (start_date, end_date) = if today.day() \u003c billing_day {\n        // Cycle started last month\n        let start = prev_month_date(today, billing_day);\n        let end = NaiveDate::from_ymd_opt(today.year(), today.month(), billing_day)\n            .unwrap_or_else(|| last_day_of_month(today.year(), today.month()));\n        (start, end)\n    } else {\n        // Cycle started this month\n        let start = NaiveDate::from_ymd_opt(today.year(), today.month(), billing_day)\n            .unwrap_or_else(|| last_day_of_month(today.year(), today.month()));\n        let end = next_month_date(today, billing_day);\n        (start, end)\n    };\n\n    let start_ms = start_date\n        .and_hms_opt(0, 0, 0)\n        .unwrap()\n        .and_utc()\n        .timestamp_millis();\n    let end_ms = end_date\n        .and_hms_opt(0, 0, 0)\n        .unwrap()\n        .and_utc()\n        .timestamp_millis();\n\n    let total_days = (end_ms - start_ms) / 86_400_000;\n    let days_elapsed = (now_ms - start_ms) / 86_400_000;\n    let days_remaining = total_days - days_elapsed;\n\n    BillingCycle {\n        start_ms,\n        end_ms,\n        billing_day,\n        total_days,\n        days_elapsed,\n        days_remaining,\n    }\n}\n\nfn prev_month_date(today: chrono::NaiveDate, day: u32) -\u003e chrono::NaiveDate {\n    use chrono::{Datelike, NaiveDate};\n    let (year, month) = if today.month() == 1 {\n        (today.year() - 1, 12)\n    } else {\n        (today.year(), today.month() - 1)\n    };\n    NaiveDate::from_ymd_opt(year, month, day).unwrap_or_else(|| last_day_of_month(year, month))\n}\n\nfn next_month_date(today: chrono::NaiveDate, day: u32) -\u003e chrono::NaiveDate {\n    use chrono::{Datelike, NaiveDate};\n    let (year, month) = if today.month() == 12 {\n        (today.year() + 1, 1)\n    } else {\n        (today.year(), today.month() + 1)\n    };\n    NaiveDate::from_ymd_opt(year, month, day).unwrap_or_else(|| last_day_of_month(year, month))\n}\n\nfn last_day_of_month(year: i32, month: u32) -\u003e chrono::NaiveDate {\n    use chrono::NaiveDate;\n    let (next_year, next_month) = if month == 12 {\n        (year + 1, 1)\n    } else {\n        (year, month + 1)\n    };\n    NaiveDate::from_ymd_opt(next_year, next_month, 1)\n        .unwrap()\n        .pred_opt()\n        .unwrap()\n}\n\n// --- Break-even analysis ---\n\n#[derive(Debug, Clone, Serialize)]\npub struct BreakEvenAnalysis {\n    pub price: f64,\n    pub break_even_output_tokens: i64,\n    pub break_even_input_tokens: i64,\n}\n\npub fn calculate_break_even(subscription_price: f64) -\u003e BreakEvenAnalysis {\n    // Uses Opus 4.5 pricing: $5/MTok input, $25/MTok output\n    let break_even_output_tokens = ((subscription_price / 25.0) * 1_000_000.0).round() as i64;\n    let break_even_input_tokens = ((subscription_price / 5.0) * 1_000_000.0).round() as i64;\n    BreakEvenAnalysis {\n        price: subscription_price,\n        break_even_output_tokens,\n        break_even_input_tokens,\n    }\n}\n\n#[allow(dead_code)]\npub fn get_max_tier_break_even() -\u003e (BreakEvenAnalysis, BreakEvenAnalysis) {\n    (calculate_break_even(100.0), calculate_break_even(200.0))\n}\n\npub fn project_cycle_cost(current_cost: f64, days_elapsed: i64, total_days: i64) -\u003e f64 {\n    if days_elapsed \u003c= 0 {\n        return 0.0;\n    }\n    (current_cost / days_elapsed as f64) * total_days as f64\n}\n\n// --- Competitor pricing ---\n\n#[derive(Debug, Clone, Serialize)]\npub struct CompetitorPricing {\n    pub name: \u0026'static str,\n    pub url: \u0026'static str,\n    pub plans: Vec\u003cCompetitorPlan\u003e,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct CompetitorPlan {\n    pub name: \u0026'static str,\n    pub price: f64,\n    pub plan_type: \u0026'static str,\n    pub limits: Option\u003c\u0026'static str\u003e,\n}\n\npub fn get_competitor_pricing() -\u003e Vec\u003cCompetitorPricing\u003e {\n    vec![\n        CompetitorPricing {\n            name: \"Claude (Anthropic)\",\n            url: \"https://claude.com/pricing\",\n            plans: vec![\n                CompetitorPlan {\n                    name: \"Free\",\n                    price: 0.0,\n                    plan_type: \"individual\",\n                    limits: Some(\"Basic usage\"),\n                },\n                CompetitorPlan {\n                    name: \"Pro\",\n                    price: 20.0,\n                    plan_type: \"individual\",\n                    limits: Some(\"More usage, Claude Code access\"),\n                },\n                CompetitorPlan {\n                    name: \"Max 5x\",\n                    price: 100.0,\n                    plan_type: \"individual\",\n                    limits: Some(\"5x Pro usage\"),\n                },\n                CompetitorPlan {\n                    name: \"Max 20x\",\n                    price: 200.0,\n                    plan_type: \"individual\",\n                    limits: Some(\"20x Pro usage\"),\n                },\n                CompetitorPlan {\n                    name: \"Team Standard\",\n                    price: 30.0,\n                    plan_type: \"team\",\n                    limits: Some(\"Per seat, min 5 members\"),\n                },\n                CompetitorPlan {\n                    name: \"Team Premium\",\n                    price: 150.0,\n                    plan_type: \"team\",\n                    limits: Some(\"Per seat, includes Claude Code\"),\n                },\n            ],\n        },\n        CompetitorPricing {\n            name: \"GitHub Copilot\",\n            url: \"https://github.com/features/copilot\",\n            plans: vec![\n                CompetitorPlan {\n                    name: \"Free\",\n                    price: 0.0,\n                    plan_type: \"individual\",\n                    limits: Some(\"2,000 completions/mo, 50 chat/mo\"),\n                },\n                CompetitorPlan {\n                    name: \"Pro\",\n                    price: 10.0,\n                    plan_type: \"individual\",\n                    limits: Some(\"Unlimited completions, 300 premium req/mo\"),\n                },\n                CompetitorPlan {\n                    name: \"Pro+\",\n                    price: 39.0,\n                    plan_type: \"individual\",\n                    limits: Some(\"1,500 premium req/mo\"),\n                },\n                CompetitorPlan {\n                    name: \"Business\",\n                    price: 19.0,\n                    plan_type: \"team\",\n                    limits: Some(\"300 premium req/mo per user\"),\n                },\n                CompetitorPlan {\n                    name: \"Enterprise\",\n                    price: 39.0,\n                    plan_type: \"enterprise\",\n                    limits: Some(\"1,000 premium req/mo per user\"),\n                },\n            ],\n        },\n        CompetitorPricing {\n            name: \"Cursor\",\n            url: \"https://cursor.com/pricing\",\n            plans: vec![\n                CompetitorPlan {\n                    name: \"Hobby\",\n                    price: 0.0,\n                    plan_type: \"individual\",\n                    limits: Some(\"Limited Agent \u0026 Tab completions\"),\n                },\n                CompetitorPlan {\n                    name: \"Pro\",\n                    price: 20.0,\n                    plan_type: \"individual\",\n                    limits: Some(\"Extended Agent, unlimited Tabs\"),\n                },\n                CompetitorPlan {\n                    name: \"Pro+\",\n                    price: 60.0,\n                    plan_type: \"individual\",\n                    limits: Some(\"3x usage on all models\"),\n                },\n                CompetitorPlan {\n                    name: \"Ultra\",\n                    price: 200.0,\n                    plan_type: \"individual\",\n                    limits: Some(\"20x usage, priority features\"),\n                },\n                CompetitorPlan {\n                    name: \"Teams\",\n                    price: 40.0,\n                    plan_type: \"team\",\n                    limits: Some(\"Shared chats, SSO, RBAC\"),\n                },\n            ],\n        },\n        CompetitorPricing {\n            name: \"Windsurf\",\n            url: \"https://windsurf.com/pricing\",\n            plans: vec![\n                CompetitorPlan {\n                    name: \"Free\",\n                    price: 0.0,\n                    plan_type: \"individual\",\n                    limits: Some(\"25 prompt credits/mo\"),\n                },\n                CompetitorPlan {\n                    name: \"Pro\",\n                    price: 15.0,\n                    plan_type: \"individual\",\n                    limits: Some(\"500 credits/mo\"),\n                },\n                CompetitorPlan {\n                    name: \"Teams\",\n                    price: 30.0,\n                    plan_type: \"team\",\n                    limits: Some(\"500 credits/user/mo\"),\n                },\n            ],\n        },\n        CompetitorPricing {\n            name: \"Tabnine\",\n            url: \"https://tabnine.com/pricing\",\n            plans: vec![CompetitorPlan {\n                name: \"Agentic Platform\",\n                price: 59.0,\n                plan_type: \"individual\",\n                limits: Some(\"Unlimited with own LLM\"),\n            }],\n        },\n        CompetitorPricing {\n            name: \"Amazon Q Developer\",\n            url: \"https://aws.amazon.com/q/developer/pricing/\",\n            plans: vec![\n                CompetitorPlan {\n                    name: \"Free\",\n                    price: 0.0,\n                    plan_type: \"individual\",\n                    limits: Some(\"50 agentic req/mo\"),\n                },\n                CompetitorPlan {\n                    name: \"Pro\",\n                    price: 19.0,\n                    plan_type: \"team\",\n                    limits: Some(\"4,000 lines/mo pooled\"),\n                },\n            ],\n        },\n    ]\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct ValueComparison {\n    pub service: String,\n    pub plan: String,\n    pub price: f64,\n    pub savings: f64,\n    pub savings_percent: f64,\n}\n\npub fn get_value_comparison(api_equivalent_cost: f64) -\u003e Vec\u003cValueComparison\u003e {\n    let mut comparisons = Vec::new();\n\n    for competitor in get_competitor_pricing() {\n        for plan in \u0026competitor.plans {\n            if plan.plan_type != \"individual\" || plan.price \u003c= 0.0 {\n                continue;\n            }\n            let savings = api_equivalent_cost - plan.price;\n            let savings_percent = if api_equivalent_cost \u003e 0.0 {\n                (savings / api_equivalent_cost) * 100.0\n            } else {\n                0.0\n            };\n            comparisons.push(ValueComparison {\n                service: competitor.name.to_string(),\n                plan: plan.name.to_string(),\n                price: plan.price,\n                savings,\n                savings_percent,\n            });\n        }\n    }\n\n    comparisons.sort_by(|a, b| a.price.partial_cmp(\u0026b.price).unwrap());\n    comparisons\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use chrono::Datelike;\n\n    #[test]\n    fn exact_match_opus_45() {\n        let p = get_model_pricing(Some(\"claude-opus-4-5-20251101\"));\n        assert_eq!(p.display_name, \"Opus 4.5\");\n        assert_eq!(p.input_per_mtok, 5.0);\n        assert_eq!(p.output_per_mtok, 25.0);\n    }\n\n    #[test]\n    fn exact_match_sonnet_45() {\n        let p = get_model_pricing(Some(\"claude-sonnet-4-5-20251101\"));\n        assert_eq!(p.display_name, \"Sonnet 4.5\");\n    }\n\n    #[test]\n    fn exact_match_haiku_45() {\n        let p = get_model_pricing(Some(\"claude-haiku-4-5-20251001\"));\n        assert_eq!(p.display_name, \"Haiku 4.5\");\n    }\n\n    #[test]\n    fn exact_match_opus_4() {\n        let p = get_model_pricing(Some(\"claude-opus-4-20250514\"));\n        assert_eq!(p.display_name, \"Opus 4\");\n        assert_eq!(p.input_per_mtok, 15.0);\n    }\n\n    #[test]\n    fn exact_match_sonnet_35() {\n        let p = get_model_pricing(Some(\"claude-3-5-sonnet-20241022\"));\n        assert_eq!(p.display_name, \"Sonnet 3.5\");\n    }\n\n    #[test]\n    fn exact_match_haiku_3() {\n        let p = get_model_pricing(Some(\"claude-3-haiku-20240307\"));\n        assert_eq!(p.display_name, \"Haiku 3\");\n        assert_eq!(p.input_per_mtok, 0.25);\n    }\n\n    #[test]\n    fn family_match_opus() {\n        let p = get_model_pricing(Some(\"some-opus-model\"));\n        assert_eq!(p.display_name, \"Opus 4\");\n    }\n\n    #[test]\n    fn family_match_sonnet() {\n        let p = get_model_pricing(Some(\"some-sonnet-model\"));\n        assert_eq!(p.display_name, \"Sonnet 4\");\n    }\n\n    #[test]\n    fn family_match_haiku() {\n        let p = get_model_pricing(Some(\"some-haiku-model\"));\n        assert_eq!(p.display_name, \"Haiku 3\");\n    }\n\n    #[test]\n    fn family_match_opus_45_variant() {\n        let p = get_model_pricing(Some(\"claude-opus-4-5-extended\"));\n        assert_eq!(p.display_name, \"Opus 4.5\");\n    }\n\n    #[test]\n    fn family_match_sonnet_45_variant() {\n        let p = get_model_pricing(Some(\"claude-sonnet-4.5-new\"));\n        assert_eq!(p.display_name, \"Sonnet 4.5\");\n    }\n\n    #[test]\n    fn none_returns_default() {\n        let p = get_model_pricing(None);\n        assert_eq!(p.display_name, \"Unknown Model\");\n        assert_eq!(p.input_per_mtok, 3.0);\n    }\n\n    #[test]\n    fn unknown_model_returns_default() {\n        let p = get_model_pricing(Some(\"totally-unknown-model\"));\n        assert_eq!(p.display_name, \"Unknown Model\");\n    }\n\n    #[test]\n    fn calculate_cost_sonnet() {\n        let cost = calculate_cost(Some(\"claude-sonnet-4-5-20251101\"), 1_000_000, 1_000_000);\n        // $3/MTok input + $15/MTok output = $18\n        assert!((cost - 18.0).abs() \u003c 0.001);\n    }\n\n    #[test]\n    fn calculate_cost_zero_tokens() {\n        let cost = calculate_cost(Some(\"claude-opus-4-5-20251101\"), 0, 0);\n        assert_eq!(cost, 0.0);\n    }\n\n    #[test]\n    fn calculate_cost_unknown_model() {\n        let cost = calculate_cost(None, 1_000_000, 1_000_000);\n        // Default: $3 + $15 = $18\n        assert!((cost - 18.0).abs() \u003c 0.001);\n    }\n\n    #[test]\n    fn format_cost_small() {\n        assert_eq!(format_cost(0.001), \"$0.0010\");\n        assert_eq!(format_cost(0.0001), \"$0.0001\");\n    }\n\n    #[test]\n    fn format_cost_medium() {\n        assert_eq!(format_cost(0.123), \"$0.123\");\n        assert_eq!(format_cost(0.5), \"$0.500\");\n    }\n\n    #[test]\n    fn format_cost_large() {\n        assert_eq!(format_cost(1.5), \"$1.50\");\n        assert_eq!(format_cost(100.0), \"$100.00\");\n    }\n\n    #[test]\n    fn format_cost_zero() {\n        assert_eq!(format_cost(0.0), \"$0.0000\");\n    }\n\n    #[test]\n    fn get_all_pricing_returns_all() {\n        let all = get_all_pricing();\n        assert_eq!(all.len(), 7);\n    }\n\n    #[test]\n    fn subscription_price_known() {\n        assert_eq!(get_subscription_price(\"free\"), 0.0);\n        assert_eq!(get_subscription_price(\"pro\"), 20.0);\n        assert_eq!(get_subscription_price(\"max5x\"), 100.0);\n        assert_eq!(get_subscription_price(\"max20x\"), 200.0);\n    }\n\n    #[test]\n    fn subscription_price_normalized() {\n        assert_eq!(get_subscription_price(\"Max-5x\"), 100.0);\n        assert_eq!(get_subscription_price(\"MAX 20X\"), 200.0);\n        assert_eq!(get_subscription_price(\"Pro\"), 20.0);\n    }\n\n    #[test]\n    fn subscription_price_unknown() {\n        assert_eq!(get_subscription_price(\"enterprise\"), 200.0);\n    }\n\n    #[test]\n    fn billing_cycle_mid_month() {\n        // Jan 15, billing day 6 -\u003e cycle started Jan 6\n        let jan15 = chrono::NaiveDate::from_ymd_opt(2024, 1, 15)\n            .unwrap()\n            .and_hms_opt(12, 0, 0)\n            .unwrap()\n            .and_utc()\n            .timestamp_millis();\n        let cycle = calculate_billing_cycle(6, jan15);\n        assert_eq!(cycle.billing_day, 6);\n        assert!(cycle.days_elapsed \u003e 0);\n        assert!(cycle.days_remaining \u003e= 0);\n        assert_eq!(cycle.total_days, cycle.days_elapsed + cycle.days_remaining);\n    }\n\n    #[test]\n    fn billing_cycle_before_billing_day() {\n        // Jan 3, billing day 6 -\u003e cycle started Dec 6\n        let jan3 = chrono::NaiveDate::from_ymd_opt(2024, 1, 3)\n            .unwrap()\n            .and_hms_opt(12, 0, 0)\n            .unwrap()\n            .and_utc()\n            .timestamp_millis();\n        let cycle = calculate_billing_cycle(6, jan3);\n        assert!(cycle.total_days \u003e= 28);\n        assert!(cycle.days_elapsed \u003e 0);\n    }\n\n    #[test]\n    fn billing_cycle_on_billing_day() {\n        // Jan 6, billing day 6 -\u003e cycle started Jan 6\n        let jan6 = chrono::NaiveDate::from_ymd_opt(2024, 1, 6)\n            .unwrap()\n            .and_hms_opt(12, 0, 0)\n            .unwrap()\n            .and_utc()\n            .timestamp_millis();\n        let cycle = calculate_billing_cycle(6, jan6);\n        assert_eq!(cycle.days_elapsed, 0);\n    }\n\n    #[test]\n    fn break_even_max5x() {\n        let be = calculate_break_even(100.0);\n        assert_eq!(be.price, 100.0);\n        assert_eq!(be.break_even_output_tokens, 4_000_000);\n        assert_eq!(be.break_even_input_tokens, 20_000_000);\n    }\n\n    #[test]\n    fn break_even_max20x() {\n        let be = calculate_break_even(200.0);\n        assert_eq!(be.break_even_output_tokens, 8_000_000);\n        assert_eq!(be.break_even_input_tokens, 40_000_000);\n    }\n\n    #[test]\n    fn break_even_zero() {\n        let be = calculate_break_even(0.0);\n        assert_eq!(be.break_even_output_tokens, 0);\n        assert_eq!(be.break_even_input_tokens, 0);\n    }\n\n    #[test]\n    fn max_tier_break_even() {\n        let (max5x, max20x) = get_max_tier_break_even();\n        assert_eq!(max5x.price, 100.0);\n        assert_eq!(max20x.price, 200.0);\n    }\n\n    #[test]\n    fn project_cycle_cost_normal() {\n        let projected = project_cycle_cost(10.0, 15, 30);\n        assert!((projected - 20.0).abs() \u003c 0.001);\n    }\n\n    #[test]\n    fn project_cycle_cost_zero_elapsed() {\n        assert_eq!(project_cycle_cost(10.0, 0, 30), 0.0);\n    }\n\n    #[test]\n    fn project_cycle_cost_negative_elapsed() {\n        assert_eq!(project_cycle_cost(10.0, -1, 30), 0.0);\n    }\n\n    #[test]\n    fn competitor_pricing_count() {\n        let competitors = get_competitor_pricing();\n        assert_eq!(competitors.len(), 6);\n    }\n\n    #[test]\n    fn competitor_pricing_claude_first() {\n        let competitors = get_competitor_pricing();\n        assert_eq!(competitors[0].name, \"Claude (Anthropic)\");\n    }\n\n    #[test]\n    fn value_comparison_positive() {\n        let comparisons = get_value_comparison(500.0);\n        assert!(!comparisons.is_empty());\n        // All individual plans with price \u003e 0\n        for c in \u0026comparisons {\n            assert!(c.price \u003e 0.0);\n        }\n        // Sorted by price ascending\n        for w in comparisons.windows(2) {\n            assert!(w[0].price \u003c= w[1].price);\n        }\n    }\n\n    #[test]\n    fn value_comparison_zero_cost() {\n        let comparisons = get_value_comparison(0.0);\n        for c in \u0026comparisons {\n            assert_eq!(c.savings_percent, 0.0);\n        }\n    }\n\n    #[test]\n    fn first_n_segments_works() {\n        assert_eq!(first_n_segments(\"a-b-c-d\", 3), \"a-b-c\");\n        assert_eq!(first_n_segments(\"a-b\", 3), \"a-b\");\n        assert_eq!(first_n_segments(\"abc\", 3), \"abc\");\n    }\n\n    #[test]\n    fn partial_match_different_date() {\n        // Same model prefix, different date suffix\n        let p = get_model_pricing(Some(\"claude-opus-4-5-20260101\"));\n        assert_eq!(p.display_name, \"Opus 4.5\");\n    }\n\n    #[test]\n    fn last_day_of_february() {\n        let d = last_day_of_month(2024, 2); // Leap year\n        assert_eq!(d.day(), 29);\n        let d2 = last_day_of_month(2023, 2); // Non-leap\n        assert_eq!(d2.day(), 28);\n    }\n\n    #[test]\n    fn last_day_of_december() {\n        let d = last_day_of_month(2024, 12);\n        assert_eq!(d.day(), 31);\n    }\n\n    #[test]\n    fn family_match_opus_45_dot_variant() {\n        let p = get_model_pricing(Some(\"some-opus-4.5-model\"));\n        assert_eq!(p.display_name, \"Opus 4.5\");\n    }\n\n    #[test]\n    fn family_match_haiku_45_dot_variant() {\n        let p = get_model_pricing(Some(\"some-haiku-4.5-model\"));\n        assert_eq!(p.display_name, \"Haiku 4.5\");\n    }\n\n    #[test]\n    fn billing_cycle_december_wrap() {\n        // Dec 15, billing day 10 -\u003e cycle started Dec 10, ends Jan 10\n        let dec15 = chrono::NaiveDate::from_ymd_opt(2024, 12, 15)\n            .unwrap()\n            .and_hms_opt(12, 0, 0)\n            .unwrap()\n            .and_utc()\n            .timestamp_millis();\n        let cycle = calculate_billing_cycle(10, dec15);\n        assert_eq!(cycle.billing_day, 10);\n        assert!(cycle.days_elapsed \u003e= 5);\n        assert!(cycle.total_days \u003e= 28);\n    }\n\n    #[test]\n    fn model_pricing_cache_fields() {\n        let p = get_model_pricing(Some(\"claude-opus-4-5-20251101\"));\n        assert_eq!(p.cache_write_per_mtok, Some(6.25));\n        assert_eq!(p.cache_read_per_mtok, Some(0.5));\n\n        let p2 = get_model_pricing(Some(\"claude-opus-4-20250514\"));\n        assert!(p2.cache_write_per_mtok.is_none());\n    }\n}\n","traces":[{"line":102,"address":[],"length":0,"stats":{"Line":22}},{"line":103,"address":[],"length":0,"stats":{"Line":42}},{"line":104,"address":[],"length":0,"stats":{"Line":40}},{"line":105,"address":[],"length":0,"stats":{"Line":2}},{"line":109,"address":[],"length":0,"stats":{"Line":297}},{"line":110,"address":[],"length":0,"stats":{"Line":96}},{"line":111,"address":[],"length":0,"stats":{"Line":22}},{"line":116,"address":[],"length":0,"stats":{"Line":27}},{"line":117,"address":[],"length":0,"stats":{"Line":27}},{"line":118,"address":[],"length":0,"stats":{"Line":160}},{"line":119,"address":[],"length":0,"stats":{"Line":153}},{"line":120,"address":[],"length":0,"stats":{"Line":51}},{"line":121,"address":[],"length":0,"stats":{"Line":4}},{"line":126,"address":[],"length":0,"stats":{"Line":14}},{"line":127,"address":[],"length":0,"stats":{"Line":2}},{"line":129,"address":[],"length":0,"stats":{"Line":12}},{"line":130,"address":[],"length":0,"stats":{"Line":2}},{"line":132,"address":[],"length":0,"stats":{"Line":10}},{"line":133,"address":[],"length":0,"stats":{"Line":2}},{"line":135,"address":[],"length":0,"stats":{"Line":4}},{"line":136,"address":[],"length":0,"stats":{"Line":2}},{"line":138,"address":[],"length":0,"stats":{"Line":3}},{"line":139,"address":[],"length":0,"stats":{"Line":2}},{"line":141,"address":[],"length":0,"stats":{"Line":2}},{"line":142,"address":[],"length":0,"stats":{"Line":2}},{"line":145,"address":[],"length":0,"stats":{"Line":1}},{"line":148,"address":[],"length":0,"stats":{"Line":63}},{"line":149,"address":[],"length":0,"stats":{"Line":315}},{"line":152,"address":[],"length":0,"stats":{"Line":4}},{"line":153,"address":[],"length":0,"stats":{"Line":12}},{"line":154,"address":[],"length":0,"stats":{"Line":8}},{"line":155,"address":[],"length":0,"stats":{"Line":8}},{"line":156,"address":[],"length":0,"stats":{"Line":4}},{"line":159,"address":[],"length":0,"stats":{"Line":39}},{"line":160,"address":[],"length":0,"stats":{"Line":39}},{"line":161,"address":[],"length":0,"stats":{"Line":8}},{"line":162,"address":[],"length":0,"stats":{"Line":35}},{"line":163,"address":[],"length":0,"stats":{"Line":8}},{"line":165,"address":[],"length":0,"stats":{"Line":62}},{"line":170,"address":[],"length":0,"stats":{"Line":1}},{"line":171,"address":[],"length":0,"stats":{"Line":18}},{"line":176,"address":[],"length":0,"stats":{"Line":8}},{"line":177,"address":[],"length":0,"stats":{"Line":8}},{"line":178,"address":[],"length":0,"stats":{"Line":8}},{"line":179,"address":[],"length":0,"stats":{"Line":8}},{"line":180,"address":[],"length":0,"stats":{"Line":8}},{"line":181,"address":[],"length":0,"stats":{"Line":8}},{"line":185,"address":[],"length":0,"stats":{"Line":8}},{"line":186,"address":[],"length":0,"stats":{"Line":32}},{"line":187,"address":[],"length":0,"stats":{"Line":54}},{"line":188,"address":[],"length":0,"stats":{"Line":23}},{"line":189,"address":[],"length":0,"stats":{"Line":7}},{"line":192,"address":[],"length":0,"stats":{"Line":1}},{"line":205,"address":[],"length":0,"stats":{"Line":9}},{"line":208,"address":[],"length":0,"stats":{"Line":45}},{"line":209,"address":[],"length":0,"stats":{"Line":27}},{"line":211,"address":[],"length":0,"stats":{"Line":36}},{"line":213,"address":[],"length":0,"stats":{"Line":4}},{"line":214,"address":[],"length":0,"stats":{"Line":7}},{"line":215,"address":[],"length":0,"stats":{"Line":1}},{"line":216,"address":[],"length":0,"stats":{"Line":1}},{"line":219,"address":[],"length":0,"stats":{"Line":56}},{"line":220,"address":[],"length":0,"stats":{"Line":8}},{"line":221,"address":[],"length":0,"stats":{"Line":32}},{"line":222,"address":[],"length":0,"stats":{"Line":8}},{"line":225,"address":[],"length":0,"stats":{"Line":27}},{"line":230,"address":[],"length":0,"stats":{"Line":27}},{"line":236,"address":[],"length":0,"stats":{"Line":18}},{"line":237,"address":[],"length":0,"stats":{"Line":18}},{"line":238,"address":[],"length":0,"stats":{"Line":18}},{"line":250,"address":[],"length":0,"stats":{"Line":1}},{"line":252,"address":[],"length":0,"stats":{"Line":3}},{"line":253,"address":[],"length":0,"stats":{"Line":1}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":5}},{"line":260,"address":[],"length":0,"stats":{"Line":8}},{"line":262,"address":[],"length":0,"stats":{"Line":24}},{"line":263,"address":[],"length":0,"stats":{"Line":1}},{"line":265,"address":[],"length":0,"stats":{"Line":21}},{"line":267,"address":[],"length":0,"stats":{"Line":40}},{"line":270,"address":[],"length":0,"stats":{"Line":3}},{"line":272,"address":[],"length":0,"stats":{"Line":9}},{"line":273,"address":[],"length":0,"stats":{"Line":1}},{"line":275,"address":[],"length":0,"stats":{"Line":2}},{"line":277,"address":[],"length":0,"stats":{"Line":9}},{"line":292,"address":[],"length":0,"stats":{"Line":10}},{"line":294,"address":[],"length":0,"stats":{"Line":20}},{"line":295,"address":[],"length":0,"stats":{"Line":20}},{"line":304,"address":[],"length":0,"stats":{"Line":1}},{"line":305,"address":[],"length":0,"stats":{"Line":1}},{"line":308,"address":[],"length":0,"stats":{"Line":3}},{"line":309,"address":[],"length":0,"stats":{"Line":3}},{"line":310,"address":[],"length":0,"stats":{"Line":2}},{"line":312,"address":[],"length":0,"stats":{"Line":1}},{"line":332,"address":[],"length":0,"stats":{"Line":9}},{"line":333,"address":[],"length":0,"stats":{"Line":9}},{"line":334,"address":[],"length":0,"stats":{"Line":9}},{"line":335,"address":[],"length":0,"stats":{"Line":9}},{"line":336,"address":[],"length":0,"stats":{"Line":9}},{"line":337,"address":[],"length":0,"stats":{"Line":18}},{"line":338,"address":[],"length":0,"stats":{"Line":18}},{"line":339,"address":[],"length":0,"stats":{"Line":18}},{"line":340,"address":[],"length":0,"stats":{"Line":18}},{"line":341,"address":[],"length":0,"stats":{"Line":18}},{"line":342,"address":[],"length":0,"stats":{"Line":18}},{"line":344,"address":[],"length":0,"stats":{"Line":18}},{"line":345,"address":[],"length":0,"stats":{"Line":18}},{"line":346,"address":[],"length":0,"stats":{"Line":18}},{"line":347,"address":[],"length":0,"stats":{"Line":18}},{"line":348,"address":[],"length":0,"stats":{"Line":18}},{"line":350,"address":[],"length":0,"stats":{"Line":18}},{"line":351,"address":[],"length":0,"stats":{"Line":18}},{"line":352,"address":[],"length":0,"stats":{"Line":18}},{"line":353,"address":[],"length":0,"stats":{"Line":18}},{"line":354,"address":[],"length":0,"stats":{"Line":18}},{"line":356,"address":[],"length":0,"stats":{"Line":18}},{"line":357,"address":[],"length":0,"stats":{"Line":18}},{"line":358,"address":[],"length":0,"stats":{"Line":18}},{"line":359,"address":[],"length":0,"stats":{"Line":18}},{"line":360,"address":[],"length":0,"stats":{"Line":18}},{"line":362,"address":[],"length":0,"stats":{"Line":9}},{"line":363,"address":[],"length":0,"stats":{"Line":9}},{"line":364,"address":[],"length":0,"stats":{"Line":9}},{"line":365,"address":[],"length":0,"stats":{"Line":9}},{"line":366,"address":[],"length":0,"stats":{"Line":9}},{"line":368,"address":[],"length":0,"stats":{"Line":9}},{"line":369,"address":[],"length":0,"stats":{"Line":9}},{"line":370,"address":[],"length":0,"stats":{"Line":9}},{"line":371,"address":[],"length":0,"stats":{"Line":9}},{"line":372,"address":[],"length":0,"stats":{"Line":9}},{"line":376,"address":[],"length":0,"stats":{"Line":9}},{"line":377,"address":[],"length":0,"stats":{"Line":9}},{"line":378,"address":[],"length":0,"stats":{"Line":9}},{"line":379,"address":[],"length":0,"stats":{"Line":18}},{"line":380,"address":[],"length":0,"stats":{"Line":18}},{"line":381,"address":[],"length":0,"stats":{"Line":18}},{"line":382,"address":[],"length":0,"stats":{"Line":18}},{"line":383,"address":[],"length":0,"stats":{"Line":18}},{"line":384,"address":[],"length":0,"stats":{"Line":18}},{"line":386,"address":[],"length":0,"stats":{"Line":18}},{"line":387,"address":[],"length":0,"stats":{"Line":18}},{"line":388,"address":[],"length":0,"stats":{"Line":18}},{"line":389,"address":[],"length":0,"stats":{"Line":18}},{"line":390,"address":[],"length":0,"stats":{"Line":18}},{"line":392,"address":[],"length":0,"stats":{"Line":18}},{"line":393,"address":[],"length":0,"stats":{"Line":18}},{"line":394,"address":[],"length":0,"stats":{"Line":18}},{"line":395,"address":[],"length":0,"stats":{"Line":18}},{"line":396,"address":[],"length":0,"stats":{"Line":18}},{"line":398,"address":[],"length":0,"stats":{"Line":9}},{"line":399,"address":[],"length":0,"stats":{"Line":9}},{"line":400,"address":[],"length":0,"stats":{"Line":9}},{"line":401,"address":[],"length":0,"stats":{"Line":9}},{"line":402,"address":[],"length":0,"stats":{"Line":9}},{"line":404,"address":[],"length":0,"stats":{"Line":9}},{"line":405,"address":[],"length":0,"stats":{"Line":9}},{"line":406,"address":[],"length":0,"stats":{"Line":9}},{"line":407,"address":[],"length":0,"stats":{"Line":9}},{"line":408,"address":[],"length":0,"stats":{"Line":9}},{"line":412,"address":[],"length":0,"stats":{"Line":9}},{"line":413,"address":[],"length":0,"stats":{"Line":9}},{"line":414,"address":[],"length":0,"stats":{"Line":9}},{"line":415,"address":[],"length":0,"stats":{"Line":18}},{"line":416,"address":[],"length":0,"stats":{"Line":18}},{"line":417,"address":[],"length":0,"stats":{"Line":18}},{"line":418,"address":[],"length":0,"stats":{"Line":18}},{"line":419,"address":[],"length":0,"stats":{"Line":18}},{"line":420,"address":[],"length":0,"stats":{"Line":18}},{"line":422,"address":[],"length":0,"stats":{"Line":18}},{"line":423,"address":[],"length":0,"stats":{"Line":18}},{"line":424,"address":[],"length":0,"stats":{"Line":18}},{"line":425,"address":[],"length":0,"stats":{"Line":18}},{"line":426,"address":[],"length":0,"stats":{"Line":18}},{"line":428,"address":[],"length":0,"stats":{"Line":18}},{"line":429,"address":[],"length":0,"stats":{"Line":18}},{"line":430,"address":[],"length":0,"stats":{"Line":18}},{"line":431,"address":[],"length":0,"stats":{"Line":18}},{"line":432,"address":[],"length":0,"stats":{"Line":18}},{"line":434,"address":[],"length":0,"stats":{"Line":9}},{"line":435,"address":[],"length":0,"stats":{"Line":9}},{"line":436,"address":[],"length":0,"stats":{"Line":9}},{"line":437,"address":[],"length":0,"stats":{"Line":9}},{"line":438,"address":[],"length":0,"stats":{"Line":9}},{"line":440,"address":[],"length":0,"stats":{"Line":9}},{"line":441,"address":[],"length":0,"stats":{"Line":9}},{"line":442,"address":[],"length":0,"stats":{"Line":9}},{"line":443,"address":[],"length":0,"stats":{"Line":9}},{"line":444,"address":[],"length":0,"stats":{"Line":9}},{"line":448,"address":[],"length":0,"stats":{"Line":9}},{"line":449,"address":[],"length":0,"stats":{"Line":9}},{"line":450,"address":[],"length":0,"stats":{"Line":9}},{"line":451,"address":[],"length":0,"stats":{"Line":18}},{"line":452,"address":[],"length":0,"stats":{"Line":18}},{"line":453,"address":[],"length":0,"stats":{"Line":18}},{"line":454,"address":[],"length":0,"stats":{"Line":18}},{"line":455,"address":[],"length":0,"stats":{"Line":18}},{"line":456,"address":[],"length":0,"stats":{"Line":18}},{"line":458,"address":[],"length":0,"stats":{"Line":9}},{"line":459,"address":[],"length":0,"stats":{"Line":9}},{"line":460,"address":[],"length":0,"stats":{"Line":9}},{"line":461,"address":[],"length":0,"stats":{"Line":9}},{"line":462,"address":[],"length":0,"stats":{"Line":9}},{"line":464,"address":[],"length":0,"stats":{"Line":9}},{"line":465,"address":[],"length":0,"stats":{"Line":9}},{"line":466,"address":[],"length":0,"stats":{"Line":9}},{"line":467,"address":[],"length":0,"stats":{"Line":9}},{"line":468,"address":[],"length":0,"stats":{"Line":9}},{"line":472,"address":[],"length":0,"stats":{"Line":9}},{"line":473,"address":[],"length":0,"stats":{"Line":9}},{"line":474,"address":[],"length":0,"stats":{"Line":9}},{"line":475,"address":[],"length":0,"stats":{"Line":9}},{"line":476,"address":[],"length":0,"stats":{"Line":9}},{"line":477,"address":[],"length":0,"stats":{"Line":9}},{"line":478,"address":[],"length":0,"stats":{"Line":9}},{"line":479,"address":[],"length":0,"stats":{"Line":9}},{"line":482,"address":[],"length":0,"stats":{"Line":9}},{"line":483,"address":[],"length":0,"stats":{"Line":9}},{"line":484,"address":[],"length":0,"stats":{"Line":9}},{"line":485,"address":[],"length":0,"stats":{"Line":18}},{"line":486,"address":[],"length":0,"stats":{"Line":9}},{"line":487,"address":[],"length":0,"stats":{"Line":9}},{"line":488,"address":[],"length":0,"stats":{"Line":9}},{"line":489,"address":[],"length":0,"stats":{"Line":9}},{"line":490,"address":[],"length":0,"stats":{"Line":9}},{"line":492,"address":[],"length":0,"stats":{"Line":9}},{"line":493,"address":[],"length":0,"stats":{"Line":9}},{"line":494,"address":[],"length":0,"stats":{"Line":9}},{"line":495,"address":[],"length":0,"stats":{"Line":9}},{"line":496,"address":[],"length":0,"stats":{"Line":9}},{"line":512,"address":[],"length":0,"stats":{"Line":7}},{"line":513,"address":[],"length":0,"stats":{"Line":14}},{"line":515,"address":[],"length":0,"stats":{"Line":49}},{"line":516,"address":[],"length":0,"stats":{"Line":350}},{"line":517,"address":[],"length":0,"stats":{"Line":259}},{"line":518,"address":[],"length":0,"stats":{"Line":84}},{"line":520,"address":[],"length":0,"stats":{"Line":140}},{"line":521,"address":[],"length":0,"stats":{"Line":140}},{"line":522,"address":[],"length":0,"stats":{"Line":60}},{"line":524,"address":[],"length":0,"stats":{"Line":10}},{"line":526,"address":[],"length":0,"stats":{"Line":210}},{"line":527,"address":[],"length":0,"stats":{"Line":210}},{"line":528,"address":[],"length":0,"stats":{"Line":210}},{"line":529,"address":[],"length":0,"stats":{"Line":140}},{"line":530,"address":[],"length":0,"stats":{"Line":70}},{"line":531,"address":[],"length":0,"stats":{"Line":70}},{"line":536,"address":[],"length":0,"stats":{"Line":826}},{"line":537,"address":[],"length":0,"stats":{"Line":7}}],"covered":246,"coverable":247},{"path":["/","Users","chi","Projects","hu","src","data","queries.rs"],"content":"use anyhow::Result;\nuse rusqlite::Connection;\nuse rusqlite::OptionalExtension;\n\nuse super::types::*;\n\npub fn get_sessions(conn: \u0026Connection, project: Option\u003c\u0026str\u003e, limit: i64) -\u003e Result\u003cVec\u003cSession\u003e\u003e {\n    let (sql, params) = match project {\n        Some(p) =\u003e {\n            let pattern = format!(\"%{p}%\");\n            (\n                \"SELECT id, project, display, started_at, message_count, total_cost_usd, git_branch FROM sessions WHERE project LIKE ?1 ORDER BY started_at DESC LIMIT ?2\".to_string(),\n                vec![rusqlite::types::Value::Text(pattern), rusqlite::types::Value::Integer(limit)],\n            )\n        }\n        None =\u003e (\n            \"SELECT id, project, display, started_at, message_count, total_cost_usd, git_branch FROM sessions ORDER BY started_at DESC LIMIT ?1\".to_string(),\n            vec![rusqlite::types::Value::Integer(limit)],\n        ),\n    };\n\n    let mut stmt = conn.prepare(\u0026sql)?;\n    let rows = stmt.query_map(rusqlite::params_from_iter(params), |row| {\n        Ok(Session {\n            id: row.get(0)?,\n            project: row.get(1)?,\n            display: row.get(2)?,\n            started_at: row.get(3)?,\n            message_count: row.get(4)?,\n            total_cost_usd: row.get(5)?,\n            git_branch: row.get(6)?,\n        })\n    })?;\n\n    Ok(rows.filter_map(|r| r.ok()).collect())\n}\n\npub fn get_session_by_prefix(conn: \u0026Connection, prefix: \u0026str) -\u003e Result\u003cOption\u003cSession\u003e\u003e {\n    let pattern = format!(\"{prefix}%\");\n    Ok(conn.query_row(\n        \"SELECT id, project, display, started_at, message_count, total_cost_usd, git_branch FROM sessions WHERE id LIKE ?1 ORDER BY started_at DESC LIMIT 1\",\n        rusqlite::params![pattern],\n        |row| {\n            Ok(Session {\n                id: row.get(0)?,\n                project: row.get(1)?,\n                display: row.get(2)?,\n                started_at: row.get(3)?,\n                message_count: row.get(4)?,\n                total_cost_usd: row.get(5)?,\n                git_branch: row.get(6)?,\n            })\n        },\n    ).optional()?)\n}\n\npub fn get_session_by_id(conn: \u0026Connection, id: \u0026str) -\u003e Result\u003cOption\u003cSession\u003e\u003e {\n    Ok(conn.query_row(\n        \"SELECT id, project, display, started_at, message_count, total_cost_usd, git_branch FROM sessions WHERE id = ?1\",\n        rusqlite::params![id],\n        |row| {\n            Ok(Session {\n                id: row.get(0)?,\n                project: row.get(1)?,\n                display: row.get(2)?,\n                started_at: row.get(3)?,\n                message_count: row.get(4)?,\n                total_cost_usd: row.get(5)?,\n                git_branch: row.get(6)?,\n            })\n        },\n    ).optional()?)\n}\n\npub fn get_messages_by_session(conn: \u0026Connection, session_id: \u0026str) -\u003e Result\u003cVec\u003cMessage\u003e\u003e {\n    let mut stmt = conn.prepare(\n        \"SELECT id, session_id, parent_id, role, content, model, input_tokens, output_tokens, cost_usd, duration_ms, created_at FROM messages WHERE session_id = ?1 ORDER BY created_at ASC\",\n    )?;\n    let rows = stmt.query_map(rusqlite::params![session_id], |row| {\n        Ok(Message {\n            id: row.get(0)?,\n            session_id: row.get(1)?,\n            parent_id: row.get(2)?,\n            role: row.get(3)?,\n            content: row.get(4)?,\n            model: row.get(5)?,\n            input_tokens: row.get(6)?,\n            output_tokens: row.get(7)?,\n            cost_usd: row.get(8)?,\n            duration_ms: row.get(9)?,\n            created_at: row.get(10)?,\n        })\n    })?;\n    Ok(rows.filter_map(|r| r.ok()).collect())\n}\n\npub fn search_messages(conn: \u0026Connection, query: \u0026str, limit: i64) -\u003e Result\u003cVec\u003cSearchResult\u003e\u003e {\n    let pattern = format!(\"%{query}%\");\n    let mut stmt = conn.prepare(\n        \"SELECT m.id, m.session_id, m.role, m.content, m.model, m.created_at, s.project FROM messages m JOIN sessions s ON m.session_id = s.id WHERE m.content LIKE ?1 ORDER BY m.created_at DESC LIMIT ?2\",\n    )?;\n    let rows = stmt.query_map(rusqlite::params![pattern, limit], |row| {\n        Ok(SearchResult {\n            id: row.get(0)?,\n            session_id: row.get(1)?,\n            role: row.get(2)?,\n            content: row.get(3)?,\n            model: row.get(4)?,\n            created_at: row.get(5)?,\n            project: row.get(6)?,\n        })\n    })?;\n    Ok(rows.filter_map(|r| r.ok()).collect())\n}\n\npub fn get_todos(conn: \u0026Connection, status: Option\u003c\u0026str\u003e) -\u003e Result\u003cVec\u003cTodo\u003e\u003e {\n    let (sql, params) = match status {\n        Some(s) =\u003e (\n            \"SELECT id, session_id, content, status, active_form FROM todos WHERE status = ?1 ORDER BY id DESC\".to_string(),\n            vec![rusqlite::types::Value::Text(s.to_string())],\n        ),\n        None =\u003e (\n            \"SELECT id, session_id, content, status, active_form FROM todos ORDER BY id DESC\"\n                .to_string(),\n            vec![],\n        ),\n    };\n\n    let mut stmt = conn.prepare(\u0026sql)?;\n    let rows = stmt.query_map(rusqlite::params_from_iter(params), |row| {\n        Ok(Todo {\n            id: row.get(0)?,\n            session_id: row.get(1)?,\n            content: row.get(2)?,\n            status: row.get(3)?,\n            active_form: row.get(4)?,\n        })\n    })?;\n    Ok(rows.filter_map(|r| r.ok()).collect())\n}\n\npub fn get_pending_todos(conn: \u0026Connection, project: Option\u003c\u0026str\u003e) -\u003e Result\u003cVec\u003cTodoWithProject\u003e\u003e {\n    let (sql, params) = match project {\n        Some(p) =\u003e {\n            let pattern = format!(\"%{p}%\");\n            (\n                \"SELECT t.id, t.session_id, t.content, t.status, t.active_form, s.project FROM todos t JOIN sessions s ON t.session_id = s.id WHERE t.status != 'completed' AND s.project LIKE ?1 ORDER BY t.id DESC\".to_string(),\n                vec![rusqlite::types::Value::Text(pattern)],\n            )\n        }\n        None =\u003e (\n            \"SELECT t.id, t.session_id, t.content, t.status, t.active_form, s.project FROM todos t JOIN sessions s ON t.session_id = s.id WHERE t.status != 'completed' ORDER BY t.id DESC\".to_string(),\n            vec![],\n        ),\n    };\n\n    let mut stmt = conn.prepare(\u0026sql)?;\n    let rows = stmt.query_map(rusqlite::params_from_iter(params), |row| {\n        Ok(TodoWithProject {\n            id: row.get(0)?,\n            session_id: row.get(1)?,\n            content: row.get(2)?,\n            status: row.get(3)?,\n            active_form: row.get(4)?,\n            project: row.get(5)?,\n        })\n    })?;\n    Ok(rows.filter_map(|r| r.ok()).collect())\n}\n\npub fn get_usage_stats(conn: \u0026Connection, since: Option\u003ci64\u003e) -\u003e Result\u003cUsageStats\u003e {\n    let total_sessions: i64 = conn.query_row(\"SELECT COUNT(*) FROM sessions\", [], |r| r.get(0))?;\n\n    let (total_messages, total_cost, total_input_tokens, total_output_tokens) = match since {\n        Some(ts) =\u003e {\n            let msgs: i64 = conn.query_row(\n                \"SELECT COUNT(*) FROM messages WHERE created_at \u003e= ?1\",\n                rusqlite::params![ts],\n                |r| r.get(0),\n            )?;\n            let cost: f64 = conn.query_row(\n                \"SELECT COALESCE(SUM(cost_usd), 0) FROM messages WHERE created_at \u003e= ?1\",\n                rusqlite::params![ts],\n                |r| r.get(0),\n            )?;\n            let input: i64 = conn.query_row(\n                \"SELECT COALESCE(SUM(input_tokens), 0) FROM messages WHERE created_at \u003e= ?1\",\n                rusqlite::params![ts],\n                |r| r.get(0),\n            )?;\n            let output: i64 = conn.query_row(\n                \"SELECT COALESCE(SUM(output_tokens), 0) FROM messages WHERE created_at \u003e= ?1\",\n                rusqlite::params![ts],\n                |r| r.get(0),\n            )?;\n            (msgs, cost, input, output)\n        }\n        None =\u003e {\n            let msgs: i64 = conn.query_row(\"SELECT COUNT(*) FROM messages\", [], |r| r.get(0))?;\n            let cost: f64 =\n                conn.query_row(\"SELECT COALESCE(SUM(cost_usd), 0) FROM messages\", [], |r| {\n                    r.get(0)\n                })?;\n            let input: i64 = conn.query_row(\n                \"SELECT COALESCE(SUM(input_tokens), 0) FROM messages\",\n                [],\n                |r| r.get(0),\n            )?;\n            let output: i64 = conn.query_row(\n                \"SELECT COALESCE(SUM(output_tokens), 0) FROM messages\",\n                [],\n                |r| r.get(0),\n            )?;\n            (msgs, cost, input, output)\n        }\n    };\n\n    Ok(UsageStats {\n        total_sessions,\n        total_messages,\n        total_cost,\n        total_input_tokens,\n        total_output_tokens,\n    })\n}\n\npub fn get_model_usage(conn: \u0026Connection, since: Option\u003ci64\u003e) -\u003e Result\u003cVec\u003cModelUsage\u003e\u003e {\n    let (sql, params): (String, Vec\u003crusqlite::types::Value\u003e) = match since {\n        Some(ts) =\u003e (\n            \"SELECT model, COUNT(*) as count, COALESCE(SUM(cost_usd), 0) as cost, COALESCE(SUM(input_tokens), 0) as input_tokens, COALESCE(SUM(output_tokens), 0) as output_tokens FROM messages WHERE model IS NOT NULL AND created_at \u003e= ?1 GROUP BY model ORDER BY count DESC\".to_string(),\n            vec![rusqlite::types::Value::Integer(ts)],\n        ),\n        None =\u003e (\n            \"SELECT model, COUNT(*) as count, COALESCE(SUM(cost_usd), 0) as cost, COALESCE(SUM(input_tokens), 0) as input_tokens, COALESCE(SUM(output_tokens), 0) as output_tokens FROM messages WHERE model IS NOT NULL GROUP BY model ORDER BY count DESC\".to_string(),\n            vec![],\n        ),\n    };\n\n    let mut stmt = conn.prepare(\u0026sql)?;\n    let rows = stmt.query_map(rusqlite::params_from_iter(params), |row| {\n        Ok(ModelUsage {\n            model: row.get(0)?,\n            count: row.get(1)?,\n            cost: row.get(2)?,\n            input_tokens: row.get(3)?,\n            output_tokens: row.get(4)?,\n        })\n    })?;\n    Ok(rows.filter_map(|r| r.ok()).collect())\n}\n\npub fn get_tool_stats(conn: \u0026Connection) -\u003e Result\u003cVec\u003cToolUsageStats\u003e\u003e {\n    let mut stmt = conn.prepare(\n        \"SELECT tool_name, COUNT(*) as count, MAX(created_at) as last_used FROM tool_usage GROUP BY tool_name ORDER BY count DESC\",\n    )?;\n    let rows = stmt.query_map([], |row| {\n        Ok(ToolUsageStats {\n            tool_name: row.get(0)?,\n            count: row.get(1)?,\n            last_used: row.get(2)?,\n        })\n    })?;\n    Ok(rows.filter_map(|r| r.ok()).collect())\n}\n\npub fn get_tool_detail(conn: \u0026Connection, tool_name: \u0026str) -\u003e Result\u003cVec\u003cToolUsageDetail\u003e\u003e {\n    let mut stmt = conn.prepare(\n        \"SELECT tu.tool_name, tu.session_id, s.project, tu.created_at FROM tool_usage tu JOIN sessions s ON tu.session_id = s.id WHERE tu.tool_name = ?1 ORDER BY tu.created_at DESC LIMIT 20\",\n    )?;\n    let rows = stmt.query_map(rusqlite::params![tool_name], |row| {\n        Ok(ToolUsageDetail {\n            tool_name: row.get(0)?,\n            session_id: row.get(1)?,\n            project: row.get(2)?,\n            created_at: row.get(3)?,\n        })\n    })?;\n    Ok(rows.filter_map(|r| r.ok()).collect())\n}\n\npub fn get_branch_stats(\n    conn: \u0026Connection,\n    branch_filter: Option\u003c\u0026str\u003e,\n    limit: i64,\n) -\u003e Result\u003cVec\u003cBranchStats\u003e\u003e {\n    let (sql, params): (String, Vec\u003crusqlite::types::Value\u003e) = match branch_filter {\n        Some(b) =\u003e {\n            let pattern = format!(\"%{b}%\");\n            (\n                \"SELECT git_branch, COUNT(*) as session_count, GROUP_CONCAT(id) as session_ids, MAX(started_at) as last_activity, SUM(message_count) as total_messages, SUM(total_cost_usd) as total_cost, project FROM sessions WHERE git_branch IS NOT NULL AND git_branch LIKE ?1 GROUP BY git_branch, project ORDER BY last_activity DESC LIMIT ?2\".to_string(),\n                vec![rusqlite::types::Value::Text(pattern), rusqlite::types::Value::Integer(limit)],\n            )\n        }\n        None =\u003e (\n            \"SELECT git_branch, COUNT(*) as session_count, GROUP_CONCAT(id) as session_ids, MAX(started_at) as last_activity, SUM(message_count) as total_messages, SUM(total_cost_usd) as total_cost, project FROM sessions WHERE git_branch IS NOT NULL GROUP BY git_branch, project ORDER BY last_activity DESC LIMIT ?1\".to_string(),\n            vec![rusqlite::types::Value::Integer(limit)],\n        ),\n    };\n\n    let mut stmt = conn.prepare(\u0026sql)?;\n    let rows = stmt.query_map(rusqlite::params_from_iter(params), |row| {\n        Ok(BranchStats {\n            git_branch: row.get(0)?,\n            session_count: row.get(1)?,\n            session_ids: row.get::\u003c_, Option\u003cString\u003e\u003e(2)?.unwrap_or_default(),\n            last_activity: row.get(3)?,\n            total_messages: row.get(4)?,\n            total_cost: row.get(5)?,\n            project: row.get(6)?,\n        })\n    })?;\n    Ok(rows.filter_map(|r| r.ok()).collect())\n}\n\npub fn get_period_usage(conn: \u0026Connection, since: i64) -\u003e Result\u003cPeriodUsage\u003e {\n    let row = conn.query_row(\n        \"SELECT COUNT(*) as messages, COALESCE(SUM(input_tokens), 0) as input_tokens, COALESCE(SUM(output_tokens), 0) as output_tokens FROM messages WHERE created_at \u003e= ?1\",\n        rusqlite::params![since],\n        |row| {\n            Ok(PeriodUsage {\n                messages: row.get(0)?,\n                input_tokens: row.get(1)?,\n                output_tokens: row.get(2)?,\n            })\n        },\n    )?;\n    Ok(row)\n}\n\npub fn get_period_model_usage(conn: \u0026Connection, since: i64) -\u003e Result\u003cVec\u003cModelTokenUsage\u003e\u003e {\n    let mut stmt = conn.prepare(\n        \"SELECT model, COALESCE(SUM(input_tokens), 0) as input_tokens, COALESCE(SUM(output_tokens), 0) as output_tokens FROM messages WHERE model IS NOT NULL AND created_at \u003e= ?1 GROUP BY model\",\n    )?;\n    let rows = stmt.query_map(rusqlite::params![since], |row| {\n        Ok(ModelTokenUsage {\n            model: row.get(0)?,\n            input_tokens: row.get(1)?,\n            output_tokens: row.get(2)?,\n        })\n    })?;\n    Ok(rows.filter_map(|r| r.ok()).collect())\n}\n\n// Extra types used only by queries\n\n#[derive(Debug, Clone, Default, serde::Serialize)]\npub struct PeriodUsage {\n    pub messages: i64,\n    pub input_tokens: i64,\n    pub output_tokens: i64,\n}\n\n#[derive(Debug, Clone, Default, serde::Serialize)]\npub struct ModelTokenUsage {\n    pub model: String,\n    pub input_tokens: i64,\n    pub output_tokens: i64,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::data::db::open_test_db;\n\n    fn seed_data(conn: \u0026Connection) {\n        conn.execute_batch(\n            \"\n            INSERT INTO sessions (id, project, display, started_at, message_count, total_cost_usd, git_branch) VALUES\n                ('s1', '/home/user/proj', 'First session', 1700000000000, 3, 0.05, 'main'),\n                ('s2', '/home/user/proj2', 'Second session', 1700001000000, 1, 0.01, 'feature/x');\n\n            INSERT INTO messages (id, session_id, role, content, model, input_tokens, output_tokens, cost_usd, created_at) VALUES\n                ('m1', 's1', 'user', 'hello world', NULL, 10, 0, NULL, 1700000000000),\n                ('m2', 's1', 'assistant', 'hi there', 'claude-sonnet-4-5-20251101', 10, 50, 0.003, 1700000001000),\n                ('m3', 's1', 'user', 'search test query', NULL, 15, 0, NULL, 1700000002000),\n                ('m4', 's2', 'user', 'other message', NULL, 5, 0, NULL, 1700001000000);\n\n            INSERT INTO todos (session_id, content, status, active_form) VALUES\n                ('s1', 'Fix bug', 'pending', 'Fixing bug'),\n                ('s1', 'Add tests', 'completed', NULL),\n                ('s2', 'Review PR', 'in_progress', 'Reviewing PR');\n\n            INSERT INTO tool_usage (session_id, message_id, tool_name, created_at) VALUES\n                ('s1', 'm2', 'Read', 1700000001000),\n                ('s1', 'm2', 'Read', 1700000001500),\n                ('s1', 'm2', 'Edit', 1700000002000);\n            \",\n        )\n        .unwrap();\n    }\n\n    #[test]\n    fn get_sessions_all() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let sessions = get_sessions(\u0026store.conn, None, 20).unwrap();\n        assert_eq!(sessions.len(), 2);\n        assert_eq!(sessions[0].id, \"s2\"); // Most recent first\n    }\n\n    #[test]\n    fn get_sessions_filtered() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let sessions = get_sessions(\u0026store.conn, Some(\"proj2\"), 20).unwrap();\n        assert_eq!(sessions.len(), 1);\n        assert_eq!(sessions[0].id, \"s2\");\n    }\n\n    #[test]\n    fn get_sessions_limited() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let sessions = get_sessions(\u0026store.conn, None, 1).unwrap();\n        assert_eq!(sessions.len(), 1);\n    }\n\n    #[test]\n    fn get_sessions_empty() {\n        let store = open_test_db();\n        let sessions = get_sessions(\u0026store.conn, None, 20).unwrap();\n        assert!(sessions.is_empty());\n    }\n\n    #[test]\n    fn get_session_by_prefix_found() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let session = get_session_by_prefix(\u0026store.conn, \"s1\").unwrap();\n        assert!(session.is_some());\n        assert_eq!(session.unwrap().id, \"s1\");\n    }\n\n    #[test]\n    fn get_session_by_prefix_not_found() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let session = get_session_by_prefix(\u0026store.conn, \"zzz\").unwrap();\n        assert!(session.is_none());\n    }\n\n    #[test]\n    fn get_session_by_id_found() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let session = get_session_by_id(\u0026store.conn, \"s1\").unwrap();\n        assert!(session.is_some());\n    }\n\n    #[test]\n    fn get_session_by_id_not_found() {\n        let store = open_test_db();\n        let session = get_session_by_id(\u0026store.conn, \"nonexistent\").unwrap();\n        assert!(session.is_none());\n    }\n\n    #[test]\n    fn get_messages_by_session_found() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let msgs = get_messages_by_session(\u0026store.conn, \"s1\").unwrap();\n        assert_eq!(msgs.len(), 3);\n        assert_eq!(msgs[0].role, \"user\");\n        assert_eq!(msgs[1].role, \"assistant\");\n    }\n\n    #[test]\n    fn get_messages_by_session_empty() {\n        let store = open_test_db();\n        let msgs = get_messages_by_session(\u0026store.conn, \"nonexistent\").unwrap();\n        assert!(msgs.is_empty());\n    }\n\n    #[test]\n    fn search_messages_found() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let results = search_messages(\u0026store.conn, \"search test\", 50).unwrap();\n        assert_eq!(results.len(), 1);\n        assert_eq!(results[0].id, \"m3\");\n    }\n\n    #[test]\n    fn search_messages_not_found() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let results = search_messages(\u0026store.conn, \"nonexistent_xyz\", 50).unwrap();\n        assert!(results.is_empty());\n    }\n\n    #[test]\n    fn search_messages_empty_db() {\n        let store = open_test_db();\n        let results = search_messages(\u0026store.conn, \"test\", 50).unwrap();\n        assert!(results.is_empty());\n    }\n\n    #[test]\n    fn get_todos_all() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let todos = get_todos(\u0026store.conn, None).unwrap();\n        assert_eq!(todos.len(), 3);\n    }\n\n    #[test]\n    fn get_todos_filtered() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let todos = get_todos(\u0026store.conn, Some(\"pending\")).unwrap();\n        assert_eq!(todos.len(), 1);\n        assert_eq!(todos[0].content, \"Fix bug\");\n    }\n\n    #[test]\n    fn get_todos_empty() {\n        let store = open_test_db();\n        let todos = get_todos(\u0026store.conn, None).unwrap();\n        assert!(todos.is_empty());\n    }\n\n    #[test]\n    fn get_pending_todos_all() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let todos = get_pending_todos(\u0026store.conn, None).unwrap();\n        assert_eq!(todos.len(), 2); // pending + in_progress\n    }\n\n    #[test]\n    fn get_pending_todos_filtered() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let todos = get_pending_todos(\u0026store.conn, Some(\"proj2\")).unwrap();\n        assert_eq!(todos.len(), 1);\n        assert_eq!(todos[0].content, \"Review PR\");\n    }\n\n    #[test]\n    fn get_pending_todos_empty() {\n        let store = open_test_db();\n        let todos = get_pending_todos(\u0026store.conn, None).unwrap();\n        assert!(todos.is_empty());\n    }\n\n    #[test]\n    fn get_usage_stats_all() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let stats = get_usage_stats(\u0026store.conn, None).unwrap();\n        assert_eq!(stats.total_sessions, 2);\n        assert_eq!(stats.total_messages, 4);\n        assert!(stats.total_cost \u003e 0.0);\n        assert!(stats.total_input_tokens \u003e 0);\n    }\n\n    #[test]\n    fn get_usage_stats_since() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let stats = get_usage_stats(\u0026store.conn, Some(1700000500000)).unwrap();\n        assert_eq!(stats.total_sessions, 2); // sessions always counted fully\n        assert_eq!(stats.total_messages, 1); // only m4\n    }\n\n    #[test]\n    fn get_usage_stats_empty() {\n        let store = open_test_db();\n        let stats = get_usage_stats(\u0026store.conn, None).unwrap();\n        assert_eq!(stats.total_sessions, 0);\n        assert_eq!(stats.total_messages, 0);\n        assert_eq!(stats.total_cost, 0.0);\n    }\n\n    #[test]\n    fn get_model_usage_all() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let usage = get_model_usage(\u0026store.conn, None).unwrap();\n        assert_eq!(usage.len(), 1); // Only assistant msgs have model\n        assert_eq!(usage[0].model, \"claude-sonnet-4-5-20251101\");\n    }\n\n    #[test]\n    fn get_model_usage_empty() {\n        let store = open_test_db();\n        let usage = get_model_usage(\u0026store.conn, None).unwrap();\n        assert!(usage.is_empty());\n    }\n\n    #[test]\n    fn get_model_usage_since() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        // After all messages\n        let usage = get_model_usage(\u0026store.conn, Some(9999999999999)).unwrap();\n        assert!(usage.is_empty());\n    }\n\n    #[test]\n    fn get_tool_stats_found() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let stats = get_tool_stats(\u0026store.conn).unwrap();\n        assert_eq!(stats.len(), 2); // Read and Edit\n        assert_eq!(stats[0].tool_name, \"Read\"); // Most used\n        assert_eq!(stats[0].count, 2);\n    }\n\n    #[test]\n    fn get_tool_stats_empty() {\n        let store = open_test_db();\n        let stats = get_tool_stats(\u0026store.conn).unwrap();\n        assert!(stats.is_empty());\n    }\n\n    #[test]\n    fn get_tool_detail_found() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let detail = get_tool_detail(\u0026store.conn, \"Read\").unwrap();\n        assert_eq!(detail.len(), 2);\n        assert_eq!(detail[0].project, \"/home/user/proj\");\n    }\n\n    #[test]\n    fn get_tool_detail_not_found() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let detail = get_tool_detail(\u0026store.conn, \"NonexistentTool\").unwrap();\n        assert!(detail.is_empty());\n    }\n\n    #[test]\n    fn get_branch_stats_all() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let stats = get_branch_stats(\u0026store.conn, None, 20).unwrap();\n        assert_eq!(stats.len(), 2);\n    }\n\n    #[test]\n    fn get_branch_stats_filtered() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let stats = get_branch_stats(\u0026store.conn, Some(\"feature\"), 20).unwrap();\n        assert_eq!(stats.len(), 1);\n        assert_eq!(stats[0].git_branch, \"feature/x\");\n    }\n\n    #[test]\n    fn get_branch_stats_limited() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let stats = get_branch_stats(\u0026store.conn, None, 1).unwrap();\n        assert_eq!(stats.len(), 1);\n    }\n\n    #[test]\n    fn get_branch_stats_empty() {\n        let store = open_test_db();\n        let stats = get_branch_stats(\u0026store.conn, None, 20).unwrap();\n        assert!(stats.is_empty());\n    }\n\n    #[test]\n    fn get_period_usage_found() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let usage = get_period_usage(\u0026store.conn, 0).unwrap();\n        assert_eq!(usage.messages, 4);\n        assert!(usage.input_tokens \u003e 0);\n    }\n\n    #[test]\n    fn get_period_usage_empty() {\n        let store = open_test_db();\n        let usage = get_period_usage(\u0026store.conn, 0).unwrap();\n        assert_eq!(usage.messages, 0);\n    }\n\n    #[test]\n    fn get_period_model_usage_found() {\n        let store = open_test_db();\n        seed_data(\u0026store.conn);\n        let usage = get_period_model_usage(\u0026store.conn, 0).unwrap();\n        assert_eq!(usage.len(), 1);\n    }\n\n    #[test]\n    fn get_period_model_usage_empty() {\n        let store = open_test_db();\n        let usage = get_period_model_usage(\u0026store.conn, 0).unwrap();\n        assert!(usage.is_empty());\n    }\n\n    #[test]\n    fn period_usage_default() {\n        let p = PeriodUsage::default();\n        assert_eq!(p.messages, 0);\n    }\n\n    #[test]\n    fn model_token_usage_default() {\n        let m = ModelTokenUsage::default();\n        assert_eq!(m.model, \"\");\n    }\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":4}},{"line":8,"address":[],"length":0,"stats":{"Line":12}},{"line":9,"address":[],"length":0,"stats":{"Line":1}},{"line":10,"address":[],"length":0,"stats":{"Line":3}},{"line":12,"address":[],"length":0,"stats":{"Line":3}},{"line":13,"address":[],"length":0,"stats":{"Line":2}},{"line":16,"address":[],"length":0,"stats":{"Line":3}},{"line":17,"address":[],"length":0,"stats":{"Line":9}},{"line":18,"address":[],"length":0,"stats":{"Line":3}},{"line":22,"address":[],"length":0,"stats":{"Line":16}},{"line":23,"address":[],"length":0,"stats":{"Line":24}},{"line":25,"address":[],"length":0,"stats":{"Line":8}},{"line":26,"address":[],"length":0,"stats":{"Line":8}},{"line":27,"address":[],"length":0,"stats":{"Line":8}},{"line":28,"address":[],"length":0,"stats":{"Line":8}},{"line":29,"address":[],"length":0,"stats":{"Line":8}},{"line":30,"address":[],"length":0,"stats":{"Line":8}},{"line":31,"address":[],"length":0,"stats":{"Line":8}},{"line":35,"address":[],"length":0,"stats":{"Line":20}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":39,"address":[],"length":0,"stats":{"Line":6}},{"line":40,"address":[],"length":0,"stats":{"Line":4}},{"line":41,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":1}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":47,"address":[],"length":0,"stats":{"Line":2}},{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":2}},{"line":50,"address":[],"length":0,"stats":{"Line":2}},{"line":51,"address":[],"length":0,"stats":{"Line":2}},{"line":54,"address":[],"length":0,"stats":{"Line":2}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":4}},{"line":59,"address":[],"length":0,"stats":{"Line":2}},{"line":60,"address":[],"length":0,"stats":{"Line":2}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":63,"address":[],"length":0,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":2}},{"line":65,"address":[],"length":0,"stats":{"Line":2}},{"line":66,"address":[],"length":0,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":2}},{"line":68,"address":[],"length":0,"stats":{"Line":2}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":75,"address":[],"length":0,"stats":{"Line":2}},{"line":76,"address":[],"length":0,"stats":{"Line":6}},{"line":79,"address":[],"length":0,"stats":{"Line":11}},{"line":81,"address":[],"length":0,"stats":{"Line":6}},{"line":82,"address":[],"length":0,"stats":{"Line":6}},{"line":83,"address":[],"length":0,"stats":{"Line":6}},{"line":84,"address":[],"length":0,"stats":{"Line":6}},{"line":85,"address":[],"length":0,"stats":{"Line":6}},{"line":86,"address":[],"length":0,"stats":{"Line":6}},{"line":87,"address":[],"length":0,"stats":{"Line":6}},{"line":88,"address":[],"length":0,"stats":{"Line":6}},{"line":89,"address":[],"length":0,"stats":{"Line":6}},{"line":90,"address":[],"length":0,"stats":{"Line":6}},{"line":91,"address":[],"length":0,"stats":{"Line":6}},{"line":94,"address":[],"length":0,"stats":{"Line":12}},{"line":97,"address":[],"length":0,"stats":{"Line":3}},{"line":98,"address":[],"length":0,"stats":{"Line":9}},{"line":99,"address":[],"length":0,"stats":{"Line":9}},{"line":102,"address":[],"length":0,"stats":{"Line":13}},{"line":104,"address":[],"length":0,"stats":{"Line":2}},{"line":105,"address":[],"length":0,"stats":{"Line":2}},{"line":106,"address":[],"length":0,"stats":{"Line":2}},{"line":107,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":2}},{"line":109,"address":[],"length":0,"stats":{"Line":2}},{"line":110,"address":[],"length":0,"stats":{"Line":2}},{"line":113,"address":[],"length":0,"stats":{"Line":11}},{"line":116,"address":[],"length":0,"stats":{"Line":3}},{"line":117,"address":[],"length":0,"stats":{"Line":9}},{"line":118,"address":[],"length":0,"stats":{"Line":2}},{"line":119,"address":[],"length":0,"stats":{"Line":3}},{"line":120,"address":[],"length":0,"stats":{"Line":2}},{"line":122,"address":[],"length":0,"stats":{"Line":2}},{"line":123,"address":[],"length":0,"stats":{"Line":4}},{"line":124,"address":[],"length":0,"stats":{"Line":2}},{"line":125,"address":[],"length":0,"stats":{"Line":2}},{"line":129,"address":[],"length":0,"stats":{"Line":12}},{"line":130,"address":[],"length":0,"stats":{"Line":19}},{"line":132,"address":[],"length":0,"stats":{"Line":8}},{"line":133,"address":[],"length":0,"stats":{"Line":8}},{"line":134,"address":[],"length":0,"stats":{"Line":8}},{"line":135,"address":[],"length":0,"stats":{"Line":8}},{"line":136,"address":[],"length":0,"stats":{"Line":8}},{"line":139,"address":[],"length":0,"stats":{"Line":17}},{"line":142,"address":[],"length":0,"stats":{"Line":3}},{"line":143,"address":[],"length":0,"stats":{"Line":9}},{"line":144,"address":[],"length":0,"stats":{"Line":1}},{"line":145,"address":[],"length":0,"stats":{"Line":3}},{"line":147,"address":[],"length":0,"stats":{"Line":3}},{"line":148,"address":[],"length":0,"stats":{"Line":1}},{"line":151,"address":[],"length":0,"stats":{"Line":2}},{"line":152,"address":[],"length":0,"stats":{"Line":4}},{"line":153,"address":[],"length":0,"stats":{"Line":2}},{"line":157,"address":[],"length":0,"stats":{"Line":12}},{"line":158,"address":[],"length":0,"stats":{"Line":18}},{"line":160,"address":[],"length":0,"stats":{"Line":6}},{"line":161,"address":[],"length":0,"stats":{"Line":6}},{"line":162,"address":[],"length":0,"stats":{"Line":6}},{"line":163,"address":[],"length":0,"stats":{"Line":6}},{"line":164,"address":[],"length":0,"stats":{"Line":6}},{"line":165,"address":[],"length":0,"stats":{"Line":6}},{"line":168,"address":[],"length":0,"stats":{"Line":15}},{"line":171,"address":[],"length":0,"stats":{"Line":3}},{"line":172,"address":[],"length":0,"stats":{"Line":24}},{"line":174,"address":[],"length":0,"stats":{"Line":15}},{"line":175,"address":[],"length":0,"stats":{"Line":1}},{"line":176,"address":[],"length":0,"stats":{"Line":4}},{"line":178,"address":[],"length":0,"stats":{"Line":1}},{"line":179,"address":[],"length":0,"stats":{"Line":2}},{"line":181,"address":[],"length":0,"stats":{"Line":4}},{"line":183,"address":[],"length":0,"stats":{"Line":1}},{"line":184,"address":[],"length":0,"stats":{"Line":2}},{"line":186,"address":[],"length":0,"stats":{"Line":4}},{"line":188,"address":[],"length":0,"stats":{"Line":1}},{"line":189,"address":[],"length":0,"stats":{"Line":2}},{"line":191,"address":[],"length":0,"stats":{"Line":4}},{"line":193,"address":[],"length":0,"stats":{"Line":1}},{"line":194,"address":[],"length":0,"stats":{"Line":2}},{"line":196,"address":[],"length":0,"stats":{"Line":3}},{"line":199,"address":[],"length":0,"stats":{"Line":16}},{"line":200,"address":[],"length":0,"stats":{"Line":4}},{"line":201,"address":[],"length":0,"stats":{"Line":10}},{"line":202,"address":[],"length":0,"stats":{"Line":4}},{"line":204,"address":[],"length":0,"stats":{"Line":8}},{"line":207,"address":[],"length":0,"stats":{"Line":4}},{"line":209,"address":[],"length":0,"stats":{"Line":8}},{"line":212,"address":[],"length":0,"stats":{"Line":4}},{"line":214,"address":[],"length":0,"stats":{"Line":6}},{"line":218,"address":[],"length":0,"stats":{"Line":3}},{"line":219,"address":[],"length":0,"stats":{"Line":6}},{"line":220,"address":[],"length":0,"stats":{"Line":6}},{"line":221,"address":[],"length":0,"stats":{"Line":6}},{"line":222,"address":[],"length":0,"stats":{"Line":3}},{"line":223,"address":[],"length":0,"stats":{"Line":3}},{"line":227,"address":[],"length":0,"stats":{"Line":3}},{"line":228,"address":[],"length":0,"stats":{"Line":12}},{"line":229,"address":[],"length":0,"stats":{"Line":2}},{"line":230,"address":[],"length":0,"stats":{"Line":3}},{"line":231,"address":[],"length":0,"stats":{"Line":1}},{"line":233,"address":[],"length":0,"stats":{"Line":2}},{"line":234,"address":[],"length":0,"stats":{"Line":4}},{"line":235,"address":[],"length":0,"stats":{"Line":2}},{"line":239,"address":[],"length":0,"stats":{"Line":12}},{"line":240,"address":[],"length":0,"stats":{"Line":16}},{"line":242,"address":[],"length":0,"stats":{"Line":2}},{"line":243,"address":[],"length":0,"stats":{"Line":2}},{"line":244,"address":[],"length":0,"stats":{"Line":2}},{"line":245,"address":[],"length":0,"stats":{"Line":2}},{"line":246,"address":[],"length":0,"stats":{"Line":2}},{"line":249,"address":[],"length":0,"stats":{"Line":11}},{"line":252,"address":[],"length":0,"stats":{"Line":2}},{"line":253,"address":[],"length":0,"stats":{"Line":6}},{"line":256,"address":[],"length":0,"stats":{"Line":10}},{"line":258,"address":[],"length":0,"stats":{"Line":4}},{"line":259,"address":[],"length":0,"stats":{"Line":4}},{"line":260,"address":[],"length":0,"stats":{"Line":4}},{"line":263,"address":[],"length":0,"stats":{"Line":10}},{"line":266,"address":[],"length":0,"stats":{"Line":2}},{"line":267,"address":[],"length":0,"stats":{"Line":6}},{"line":270,"address":[],"length":0,"stats":{"Line":10}},{"line":272,"address":[],"length":0,"stats":{"Line":4}},{"line":273,"address":[],"length":0,"stats":{"Line":4}},{"line":274,"address":[],"length":0,"stats":{"Line":4}},{"line":275,"address":[],"length":0,"stats":{"Line":4}},{"line":278,"address":[],"length":0,"stats":{"Line":10}},{"line":281,"address":[],"length":0,"stats":{"Line":4}},{"line":286,"address":[],"length":0,"stats":{"Line":16}},{"line":287,"address":[],"length":0,"stats":{"Line":1}},{"line":288,"address":[],"length":0,"stats":{"Line":3}},{"line":290,"address":[],"length":0,"stats":{"Line":3}},{"line":291,"address":[],"length":0,"stats":{"Line":2}},{"line":294,"address":[],"length":0,"stats":{"Line":3}},{"line":295,"address":[],"length":0,"stats":{"Line":9}},{"line":296,"address":[],"length":0,"stats":{"Line":3}},{"line":300,"address":[],"length":0,"stats":{"Line":16}},{"line":301,"address":[],"length":0,"stats":{"Line":24}},{"line":303,"address":[],"length":0,"stats":{"Line":8}},{"line":304,"address":[],"length":0,"stats":{"Line":8}},{"line":305,"address":[],"length":0,"stats":{"Line":12}},{"line":306,"address":[],"length":0,"stats":{"Line":8}},{"line":307,"address":[],"length":0,"stats":{"Line":8}},{"line":308,"address":[],"length":0,"stats":{"Line":8}},{"line":309,"address":[],"length":0,"stats":{"Line":8}},{"line":312,"address":[],"length":0,"stats":{"Line":20}},{"line":315,"address":[],"length":0,"stats":{"Line":2}},{"line":316,"address":[],"length":0,"stats":{"Line":6}},{"line":318,"address":[],"length":0,"stats":{"Line":2}},{"line":319,"address":[],"length":0,"stats":{"Line":2}},{"line":321,"address":[],"length":0,"stats":{"Line":4}},{"line":322,"address":[],"length":0,"stats":{"Line":4}},{"line":323,"address":[],"length":0,"stats":{"Line":4}},{"line":327,"address":[],"length":0,"stats":{"Line":2}},{"line":330,"address":[],"length":0,"stats":{"Line":2}},{"line":331,"address":[],"length":0,"stats":{"Line":6}},{"line":334,"address":[],"length":0,"stats":{"Line":9}},{"line":336,"address":[],"length":0,"stats":{"Line":2}},{"line":337,"address":[],"length":0,"stats":{"Line":2}},{"line":338,"address":[],"length":0,"stats":{"Line":2}},{"line":341,"address":[],"length":0,"stats":{"Line":8}}],"covered":205,"coverable":205},{"path":["/","Users","chi","Projects","hu","src","data","schema.rs"],"content":"use anyhow::Result;\nuse rusqlite::Connection;\n\nconst MIGRATION_V1: \u0026str = r#\"\nCREATE TABLE IF NOT EXISTS schema_version (\n    version INTEGER PRIMARY KEY,\n    applied_at INTEGER NOT NULL\n);\n\nCREATE TABLE IF NOT EXISTS sessions (\n    id TEXT PRIMARY KEY,\n    project TEXT NOT NULL,\n    display TEXT,\n    started_at INTEGER NOT NULL,\n    message_count INTEGER DEFAULT 0,\n    total_cost_usd REAL DEFAULT 0\n);\nCREATE INDEX IF NOT EXISTS idx_sessions_project ON sessions(project);\nCREATE INDEX IF NOT EXISTS idx_sessions_started_at ON sessions(started_at);\n\nCREATE TABLE IF NOT EXISTS messages (\n    id TEXT PRIMARY KEY,\n    session_id TEXT NOT NULL,\n    parent_id TEXT,\n    role TEXT NOT NULL,\n    content TEXT,\n    model TEXT,\n    input_tokens INTEGER,\n    output_tokens INTEGER,\n    cost_usd REAL,\n    duration_ms INTEGER,\n    created_at INTEGER NOT NULL,\n    FOREIGN KEY (session_id) REFERENCES sessions(id)\n);\nCREATE INDEX IF NOT EXISTS idx_messages_session ON messages(session_id);\nCREATE INDEX IF NOT EXISTS idx_messages_created ON messages(created_at);\n\nCREATE VIRTUAL TABLE IF NOT EXISTS messages_fts USING fts5(\n    content,\n    content=messages,\n    content_rowid=rowid\n);\n\nCREATE TRIGGER IF NOT EXISTS messages_ai AFTER INSERT ON messages BEGIN\n    INSERT INTO messages_fts(rowid, content) VALUES (NEW.rowid, NEW.content);\nEND;\n\nCREATE TRIGGER IF NOT EXISTS messages_ad AFTER DELETE ON messages BEGIN\n    INSERT INTO messages_fts(messages_fts, rowid, content)\n        VALUES('delete', OLD.rowid, OLD.content);\nEND;\n\nCREATE TRIGGER IF NOT EXISTS messages_au AFTER UPDATE ON messages BEGIN\n    INSERT INTO messages_fts(messages_fts, rowid, content)\n        VALUES('delete', OLD.rowid, OLD.content);\n    INSERT INTO messages_fts(rowid, content) VALUES (NEW.rowid, NEW.content);\nEND;\n\nCREATE TABLE IF NOT EXISTS todos (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    session_id TEXT NOT NULL,\n    content TEXT NOT NULL,\n    status TEXT NOT NULL DEFAULT 'pending',\n    active_form TEXT,\n    FOREIGN KEY (session_id) REFERENCES sessions(id)\n);\nCREATE INDEX IF NOT EXISTS idx_todos_session ON todos(session_id);\nCREATE INDEX IF NOT EXISTS idx_todos_status ON todos(status);\n\nCREATE TABLE IF NOT EXISTS tool_usage (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    session_id TEXT NOT NULL,\n    message_id TEXT,\n    tool_name TEXT NOT NULL,\n    input_json TEXT,\n    output_json TEXT,\n    duration_ms INTEGER,\n    created_at INTEGER NOT NULL,\n    FOREIGN KEY (session_id) REFERENCES sessions(id)\n);\nCREATE INDEX IF NOT EXISTS idx_tool_usage_session ON tool_usage(session_id);\nCREATE INDEX IF NOT EXISTS idx_tool_usage_tool ON tool_usage(tool_name);\n\nCREATE TABLE IF NOT EXISTS sync_state (\n    source TEXT PRIMARY KEY,\n    last_sync_at INTEGER NOT NULL,\n    last_modified_at INTEGER,\n    checksum TEXT\n);\n\"#;\n\nconst MIGRATION_V2: \u0026str = r#\"\nALTER TABLE sessions ADD COLUMN git_branch TEXT;\nCREATE INDEX IF NOT EXISTS idx_sessions_git_branch ON sessions(git_branch);\n\"#;\n\nstruct Migration {\n    version: i64,\n    sql: \u0026'static str,\n}\n\nconst MIGRATIONS: \u0026[Migration] = \u0026[\n    Migration {\n        version: 1,\n        sql: MIGRATION_V1,\n    },\n    Migration {\n        version: 2,\n        sql: MIGRATION_V2,\n    },\n];\n\npub fn get_schema_version(conn: \u0026Connection) -\u003e Result\u003ci64\u003e {\n    // Check if schema_version table exists\n    let exists: bool = conn.query_row(\n        \"SELECT COUNT(*) \u003e 0 FROM sqlite_master WHERE type='table' AND name='schema_version'\",\n        [],\n        |row| row.get(0),\n    )?;\n\n    if !exists {\n        return Ok(0);\n    }\n\n    let version: i64 = conn.query_row(\n        \"SELECT COALESCE(MAX(version), 0) FROM schema_version\",\n        [],\n        |row| row.get(0),\n    )?;\n    Ok(version)\n}\n\npub fn run_migrations(conn: \u0026Connection) -\u003e Result\u003c()\u003e {\n    let current = get_schema_version(conn)?;\n\n    for migration in MIGRATIONS {\n        if migration.version \u003e current {\n            conn.execute_batch(migration.sql)?;\n\n            let now = chrono::Utc::now().timestamp_millis();\n            conn.execute(\n                \"INSERT INTO schema_version (version, applied_at) VALUES (?1, ?2)\",\n                rusqlite::params![migration.version, now],\n            )?;\n        }\n    }\n\n    Ok(())\n}\n\npub fn initialize_schema(conn: \u0026Connection) -\u003e Result\u003c()\u003e {\n    run_migrations(conn)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn open_memory() -\u003e Connection {\n        let conn = Connection::open_in_memory().unwrap();\n        conn.execute_batch(\"PRAGMA journal_mode=WAL; PRAGMA foreign_keys=ON;\")\n            .unwrap();\n        conn\n    }\n\n    #[test]\n    fn schema_version_no_table() {\n        let conn = open_memory();\n        assert_eq!(get_schema_version(\u0026conn).unwrap(), 0);\n    }\n\n    #[test]\n    fn initialize_creates_tables() {\n        let conn = open_memory();\n        initialize_schema(\u0026conn).unwrap();\n\n        let version = get_schema_version(\u0026conn).unwrap();\n        assert_eq!(version, 2);\n\n        // Verify tables exist\n        let tables: Vec\u003cString\u003e = conn\n            .prepare(\"SELECT name FROM sqlite_master WHERE type='table' ORDER BY name\")\n            .unwrap()\n            .query_map([], |row| row.get(0))\n            .unwrap()\n            .filter_map(|r| r.ok())\n            .collect();\n\n        assert!(tables.contains(\u0026\"sessions\".to_string()));\n        assert!(tables.contains(\u0026\"messages\".to_string()));\n        assert!(tables.contains(\u0026\"todos\".to_string()));\n        assert!(tables.contains(\u0026\"tool_usage\".to_string()));\n        assert!(tables.contains(\u0026\"sync_state\".to_string()));\n        assert!(tables.contains(\u0026\"schema_version\".to_string()));\n    }\n\n    #[test]\n    fn initialize_is_idempotent() {\n        let conn = open_memory();\n        initialize_schema(\u0026conn).unwrap();\n        initialize_schema(\u0026conn).unwrap();\n        assert_eq!(get_schema_version(\u0026conn).unwrap(), 2);\n    }\n\n    #[test]\n    fn migration_v2_adds_git_branch() {\n        let conn = open_memory();\n        initialize_schema(\u0026conn).unwrap();\n\n        // Verify git_branch column exists by inserting with it\n        conn.execute(\n            \"INSERT INTO sessions (id, project, started_at, git_branch) VALUES ('s1', '/p', 100, 'main')\",\n            [],\n        )\n        .unwrap();\n\n        let branch: Option\u003cString\u003e = conn\n            .query_row(\n                \"SELECT git_branch FROM sessions WHERE id = 's1'\",\n                [],\n                |row| row.get(0),\n            )\n            .unwrap();\n        assert_eq!(branch, Some(\"main\".to_string()));\n    }\n\n    #[test]\n    fn fts_trigger_inserts() {\n        let conn = open_memory();\n        initialize_schema(\u0026conn).unwrap();\n\n        conn.execute(\n            \"INSERT INTO sessions (id, project, started_at) VALUES ('s1', '/p', 100)\",\n            [],\n        )\n        .unwrap();\n        conn.execute(\n            \"INSERT INTO messages (id, session_id, role, content, created_at) VALUES ('m1', 's1', 'user', 'hello world', 100)\",\n            [],\n        )\n        .unwrap();\n\n        let fts_count: i64 = conn\n            .query_row(\n                \"SELECT COUNT(*) FROM messages_fts WHERE messages_fts MATCH 'hello'\",\n                [],\n                |row| row.get(0),\n            )\n            .unwrap();\n        assert_eq!(fts_count, 1);\n    }\n\n    #[test]\n    fn fts_trigger_deletes() {\n        let conn = open_memory();\n        initialize_schema(\u0026conn).unwrap();\n\n        conn.execute(\n            \"INSERT INTO sessions (id, project, started_at) VALUES ('s1', '/p', 100)\",\n            [],\n        )\n        .unwrap();\n        conn.execute(\n            \"INSERT INTO messages (id, session_id, role, content, created_at) VALUES ('m1', 's1', 'user', 'unique_test_word', 100)\",\n            [],\n        )\n        .unwrap();\n\n        // Delete should propagate to FTS\n        conn.execute_batch(\"PRAGMA foreign_keys=OFF;\").unwrap();\n        conn.execute(\"DELETE FROM messages WHERE id = 'm1'\", [])\n            .unwrap();\n\n        let fts_count: i64 = conn\n            .query_row(\n                \"SELECT COUNT(*) FROM messages_fts WHERE messages_fts MATCH 'unique_test_word'\",\n                [],\n                |row| row.get(0),\n            )\n            .unwrap();\n        assert_eq!(fts_count, 0);\n    }\n\n    #[test]\n    fn schema_version_tracks_migrations() {\n        let conn = open_memory();\n        initialize_schema(\u0026conn).unwrap();\n\n        let count: i64 = conn\n            .query_row(\"SELECT COUNT(*) FROM schema_version\", [], |row| row.get(0))\n            .unwrap();\n        assert_eq!(count, 2); // v1 + v2\n    }\n}\n","traces":[{"line":113,"address":[],"length":0,"stats":{"Line":72}},{"line":115,"address":[],"length":0,"stats":{"Line":288}},{"line":118,"address":[],"length":0,"stats":{"Line":144}},{"line":121,"address":[],"length":0,"stats":{"Line":72}},{"line":122,"address":[],"length":0,"stats":{"Line":69}},{"line":125,"address":[],"length":0,"stats":{"Line":12}},{"line":128,"address":[],"length":0,"stats":{"Line":6}},{"line":130,"address":[],"length":0,"stats":{"Line":3}},{"line":133,"address":[],"length":0,"stats":{"Line":69}},{"line":134,"address":[],"length":0,"stats":{"Line":207}},{"line":136,"address":[],"length":0,"stats":{"Line":345}},{"line":137,"address":[],"length":0,"stats":{"Line":138}},{"line":138,"address":[],"length":0,"stats":{"Line":408}},{"line":140,"address":[],"length":0,"stats":{"Line":408}},{"line":141,"address":[],"length":0,"stats":{"Line":272}},{"line":143,"address":[],"length":0,"stats":{"Line":136}},{"line":148,"address":[],"length":0,"stats":{"Line":69}},{"line":151,"address":[],"length":0,"stats":{"Line":69}},{"line":152,"address":[],"length":0,"stats":{"Line":138}}],"covered":19,"coverable":19},{"path":["/","Users","chi","Projects","hu","src","data","sync.rs"],"content":"use anyhow::Result;\nuse rusqlite::Connection;\nuse rusqlite::OptionalExtension;\nuse std::path::Path;\n\nuse super::paths;\nuse super::types::{HistoryEntry, MessageEntry, SyncResult, TodoEntry};\n\npub fn get_last_sync_time(conn: \u0026Connection, source: \u0026str) -\u003e Result\u003ci64\u003e {\n    let result: Option\u003ci64\u003e = conn\n        .query_row(\n            \"SELECT last_sync_at FROM sync_state WHERE source = ?1\",\n            rusqlite::params![source],\n            |row| row.get(0),\n        )\n        .optional()?;\n    Ok(result.unwrap_or(0))\n}\n\npub fn update_sync_state(conn: \u0026Connection, source: \u0026str) -\u003e Result\u003c()\u003e {\n    let now = chrono::Utc::now().timestamp_millis();\n    conn.execute(\n        \"INSERT OR REPLACE INTO sync_state (source, last_sync_at, last_modified_at) VALUES (?1, ?2, ?3)\",\n        rusqlite::params![source, now, now],\n    )?;\n    Ok(())\n}\n\npub fn needs_sync(conn: \u0026Connection, source: \u0026str, interval_secs: u64) -\u003e Result\u003cbool\u003e {\n    if interval_secs == 0 {\n        return Ok(false);\n    }\n    let last = get_last_sync_time(conn, source)?;\n    let now = chrono::Utc::now().timestamp_millis();\n    let interval_ms = interval_secs as i64 * 1000;\n    Ok(now - last \u003e interval_ms)\n}\n\npub fn sync_history(conn: \u0026Connection, claude_dir: \u0026Path) -\u003e Result\u003cusize\u003e {\n    let path = paths::history_path(claude_dir);\n    if !path.exists() {\n        update_sync_state(conn, \"history\")?;\n        return Ok(0);\n    }\n\n    let content = std::fs::read_to_string(\u0026path)?;\n    let entries: Vec\u003cHistoryEntry\u003e = paths::parse_jsonl(\u0026content);\n    let mut count = 0;\n\n    for entry in \u0026entries {\n        let (session_id, project, display, timestamp) = match (\n            entry.session_id.as_deref(),\n            entry.project.as_deref(),\n            entry.timestamp,\n        ) {\n            (Some(id), Some(proj), Some(ts)) =\u003e (id, proj, entry.display.as_deref(), ts as i64),\n            _ =\u003e continue,\n        };\n\n        let changed = conn.execute(\n            \"INSERT OR IGNORE INTO sessions (id, project, display, started_at) VALUES (?1, ?2, ?3, ?4)\",\n            rusqlite::params![session_id, project, display, timestamp],\n        )?;\n        if changed \u003e 0 {\n            count += 1;\n        }\n    }\n\n    update_sync_state(conn, \"history\")?;\n    Ok(count)\n}\n\npub fn sync_sessions(conn: \u0026Connection, claude_dir: \u0026Path) -\u003e Result\u003cusize\u003e {\n    let projects = paths::list_project_dirs(claude_dir)?;\n    let mut total = 0;\n\n    for project in \u0026projects {\n        let sessions = paths::list_session_files(\u0026project.dir)?;\n        for session_file in \u0026sessions {\n            total += sync_session_file(conn, \u0026project.path, session_file)?;\n        }\n    }\n\n    update_sync_state(conn, \"sessions\")?;\n    Ok(total)\n}\n\nfn sync_session_file(\n    conn: \u0026Connection,\n    project_path: \u0026str,\n    session_file: \u0026paths::SessionFile,\n) -\u003e Result\u003cusize\u003e {\n    let content = std::fs::read_to_string(\u0026session_file.path)?;\n    let entries: Vec\u003cMessageEntry\u003e = paths::parse_jsonl(\u0026content);\n    let session_id = \u0026session_file.session_id;\n\n    let tx = conn.unchecked_transaction()?;\n\n    // Ensure session exists\n    let now = chrono::Utc::now().timestamp_millis();\n    tx.execute(\n        \"INSERT OR IGNORE INTO sessions (id, project, started_at) VALUES (?1, ?2, ?3)\",\n        rusqlite::params![session_id, project_path, now],\n    )?;\n\n    // Extract git_branch from first entry that has one\n    let git_branch = entries.iter().find_map(|e| e.git_branch.as_ref());\n    if let Some(branch) = git_branch {\n        tx.execute(\n            \"UPDATE sessions SET git_branch = ?1 WHERE id = ?2 AND git_branch IS NULL\",\n            rusqlite::params![branch, session_id],\n        )?;\n    }\n\n    let mut msg_count = 0;\n\n    for entry in \u0026entries {\n        let uuid = match entry.uuid.as_deref() {\n            Some(id) =\u003e id,\n            None =\u003e continue,\n        };\n\n        let msg = match entry.message.as_ref() {\n            Some(m) =\u003e m,\n            None =\u003e continue,\n        };\n\n        let timestamp_str = match entry.timestamp.as_deref() {\n            Some(ts) =\u003e ts,\n            None =\u003e continue,\n        };\n\n        let created_at = parse_timestamp(timestamp_str);\n        let role = msg.role.as_deref().unwrap_or(\"unknown\");\n\n        let content_str = msg.content.as_ref().map(|c| c.as_string());\n        let model = msg.model.as_deref();\n        let input_tokens = msg.usage.as_ref().and_then(|u| u.input_tokens);\n        let output_tokens = msg.usage.as_ref().and_then(|u| u.output_tokens);\n        let cost_usd = entry.cost_usd;\n        let duration_ms = entry.duration_ms;\n        let parent_id = entry.parent_uuid.as_deref();\n\n        let changed = tx.execute(\n            \"INSERT OR IGNORE INTO messages (id, session_id, parent_id, role, content, model, input_tokens, output_tokens, cost_usd, duration_ms, created_at) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11)\",\n            rusqlite::params![uuid, session_id, parent_id, role, content_str, model, input_tokens, output_tokens, cost_usd, duration_ms, created_at],\n        )?;\n        if changed \u003e 0 {\n            msg_count += 1;\n        }\n\n        // Extract tool usage from assistant messages\n        if role == \"assistant\" {\n            if let Some(content) = msg.content.as_ref() {\n                for block in content.tool_use_blocks() {\n                    let tool_name = match block.name.as_deref() {\n                        Some(n) =\u003e n,\n                        None =\u003e continue,\n                    };\n                    let input_json = block.input.as_ref().map(|v| v.to_string());\n                    tx.execute(\n                        \"INSERT OR IGNORE INTO tool_usage (session_id, message_id, tool_name, input_json, created_at) VALUES (?1, ?2, ?3, ?4, ?5)\",\n                        rusqlite::params![session_id, uuid, tool_name, input_json, created_at],\n                    )?;\n                }\n            }\n        }\n    }\n\n    // Update session stats\n    tx.execute(\n        \"UPDATE sessions SET message_count = (SELECT COUNT(*) FROM messages WHERE session_id = ?1), total_cost_usd = (SELECT COALESCE(SUM(cost_usd), 0) FROM messages WHERE session_id = ?1) WHERE id = ?1\",\n        rusqlite::params![session_id],\n    )?;\n\n    tx.commit()?;\n    Ok(msg_count)\n}\n\nfn parse_timestamp(ts: \u0026str) -\u003e i64 {\n    chrono::DateTime::parse_from_rfc3339(ts)\n        .map(|dt| dt.timestamp_millis())\n        .unwrap_or(0)\n}\n\npub fn sync_todos(conn: \u0026Connection, claude_dir: \u0026Path) -\u003e Result\u003cusize\u003e {\n    let dir = paths::todos_dir(claude_dir);\n    if !dir.exists() {\n        update_sync_state(conn, \"todos\")?;\n        return Ok(0);\n    }\n\n    let mut count = 0;\n    for entry in std::fs::read_dir(\u0026dir)? {\n        let entry = entry?;\n        let name = entry.file_name().to_string_lossy().to_string();\n        if !name.ends_with(\".json\") {\n            continue;\n        }\n\n        let session_id = name.trim_end_matches(\".json\");\n        let content = std::fs::read_to_string(entry.path())?;\n        let todos: Vec\u003cTodoEntry\u003e = match serde_json::from_str(\u0026content) {\n            Ok(t) =\u003e t,\n            Err(_) =\u003e continue,\n        };\n\n        // Ensure session exists (may not be in history.jsonl yet)\n        let now = chrono::Utc::now().timestamp_millis();\n        conn.execute(\n            \"INSERT OR IGNORE INTO sessions (id, project, started_at) VALUES (?1, ?2, ?3)\",\n            rusqlite::params![session_id, \"unknown\", now],\n        )?;\n\n        // Delete existing todos for this session, then re-insert\n        conn.execute(\n            \"DELETE FROM todos WHERE session_id = ?1\",\n            rusqlite::params![session_id],\n        )?;\n\n        for todo in \u0026todos {\n            let todo_content = match todo.content.as_deref() {\n                Some(c) =\u003e c,\n                None =\u003e continue,\n            };\n            let status = todo.status.as_deref().unwrap_or(\"pending\");\n            let active_form = todo.active_form.as_deref();\n\n            conn.execute(\n                \"INSERT INTO todos (session_id, content, status, active_form) VALUES (?1, ?2, ?3, ?4)\",\n                rusqlite::params![session_id, todo_content, status, active_form],\n            )?;\n            count += 1;\n        }\n    }\n\n    update_sync_state(conn, \"todos\")?;\n    Ok(count)\n}\n\npub fn sync_all(conn: \u0026Connection, claude_dir: \u0026Path) -\u003e Result\u003cSyncResult\u003e {\n    let history = sync_history(conn, claude_dir)?;\n    let messages = sync_sessions(conn, claude_dir)?;\n    let todos = sync_todos(conn, claude_dir)?;\n    Ok(SyncResult {\n        history,\n        messages,\n        todos,\n    })\n}\n\npub fn sync_if_needed(conn: \u0026Connection, claude_dir: \u0026Path, interval_secs: u64) -\u003e Result\u003cbool\u003e {\n    let any_needed = needs_sync(conn, \"history\", interval_secs)?\n        || needs_sync(conn, \"sessions\", interval_secs)?\n        || needs_sync(conn, \"todos\", interval_secs)?;\n\n    if any_needed {\n        sync_all(conn, claude_dir)?;\n        Ok(true)\n    } else {\n        Ok(false)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::data::db::open_test_db;\n\n    #[test]\n    fn get_last_sync_no_record() {\n        let store = open_test_db();\n        assert_eq!(get_last_sync_time(\u0026store.conn, \"history\").unwrap(), 0);\n    }\n\n    #[test]\n    fn update_and_get_sync_time() {\n        let store = open_test_db();\n        update_sync_state(\u0026store.conn, \"history\").unwrap();\n        let time = get_last_sync_time(\u0026store.conn, \"history\").unwrap();\n        assert!(time \u003e 0);\n    }\n\n    #[test]\n    fn needs_sync_zero_interval() {\n        let store = open_test_db();\n        assert!(!needs_sync(\u0026store.conn, \"test\", 0).unwrap());\n    }\n\n    #[test]\n    fn needs_sync_no_prior() {\n        let store = open_test_db();\n        assert!(needs_sync(\u0026store.conn, \"test\", 300).unwrap());\n    }\n\n    #[test]\n    fn needs_sync_recent() {\n        let store = open_test_db();\n        update_sync_state(\u0026store.conn, \"test\").unwrap();\n        assert!(!needs_sync(\u0026store.conn, \"test\", 300).unwrap());\n    }\n\n    #[test]\n    fn sync_history_missing_file() {\n        let store = open_test_db();\n        let result = sync_history(\u0026store.conn, Path::new(\"/nonexistent\")).unwrap();\n        assert_eq!(result, 0);\n    }\n\n    #[test]\n    fn sync_history_from_fixture() {\n        let store = open_test_db();\n        let tmp = std::env::temp_dir().join(\"hu-test-sync-history\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n        std::fs::create_dir_all(\u0026tmp).unwrap();\n\n        let jsonl = r#\"{\"display\":\"test session\",\"timestamp\":1700000000000,\"project\":\"/home/user/proj\",\"sessionId\":\"sess-001\"}\n{\"display\":\"another\",\"timestamp\":1700001000000,\"project\":\"/home/user/proj2\",\"sessionId\":\"sess-002\"}\n\"#;\n        std::fs::write(tmp.join(\"history.jsonl\"), jsonl).unwrap();\n\n        let count = sync_history(\u0026store.conn, \u0026tmp).unwrap();\n        assert_eq!(count, 2);\n\n        // Verify data\n        let session_count: i64 = store\n            .conn\n            .query_row(\"SELECT COUNT(*) FROM sessions\", [], |r| r.get(0))\n            .unwrap();\n        assert_eq!(session_count, 2);\n\n        // Idempotent\n        let count2 = sync_history(\u0026store.conn, \u0026tmp).unwrap();\n        assert_eq!(count2, 0);\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn sync_history_skips_incomplete() {\n        let store = open_test_db();\n        let tmp = std::env::temp_dir().join(\"hu-test-sync-hist-skip\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n        std::fs::create_dir_all(\u0026tmp).unwrap();\n\n        let jsonl = r#\"{\"display\":\"no session id\",\"timestamp\":1700000000000,\"project\":\"/proj\"}\n{\"display\":\"no timestamp\",\"project\":\"/proj\",\"sessionId\":\"s1\"}\n{\"display\":\"ok\",\"timestamp\":1700000000000,\"project\":\"/proj\",\"sessionId\":\"s2\"}\n\"#;\n        std::fs::write(tmp.join(\"history.jsonl\"), jsonl).unwrap();\n\n        let count = sync_history(\u0026store.conn, \u0026tmp).unwrap();\n        assert_eq!(count, 1);\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn sync_sessions_from_fixture() {\n        let store = open_test_db();\n        let tmp = std::env::temp_dir().join(\"hu-test-sync-sessions\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n\n        let proj_dir = tmp.join(\"projects\").join(\"-home-user-proj\");\n        std::fs::create_dir_all(\u0026proj_dir).unwrap();\n\n        let jsonl = r#\"{\"uuid\":\"m1\",\"type\":\"user\",\"timestamp\":\"2024-01-01T00:00:00Z\",\"gitBranch\":\"main\",\"message\":{\"role\":\"user\",\"content\":\"hello\",\"usage\":{\"input_tokens\":10,\"output_tokens\":0}}}\n{\"uuid\":\"m2\",\"parentUuid\":\"m1\",\"type\":\"assistant\",\"timestamp\":\"2024-01-01T00:00:01Z\",\"message\":{\"role\":\"assistant\",\"content\":[{\"type\":\"text\",\"text\":\"hi\"},{\"type\":\"tool_use\",\"name\":\"Read\",\"input\":{\"path\":\"/tmp\"}}],\"model\":\"claude-sonnet-4-5-20251101\",\"usage\":{\"input_tokens\":10,\"output_tokens\":50}},\"costUSD\":0.001,\"durationMs\":500}\n\"#;\n        std::fs::write(proj_dir.join(\"sess-001.jsonl\"), jsonl).unwrap();\n\n        let count = sync_sessions(\u0026store.conn, \u0026tmp).unwrap();\n        assert_eq!(count, 2);\n\n        // Check session was created with git_branch\n        let branch: Option\u003cString\u003e = store\n            .conn\n            .query_row(\n                \"SELECT git_branch FROM sessions WHERE id = 'sess-001'\",\n                [],\n                |r| r.get(0),\n            )\n            .unwrap();\n        assert_eq!(branch, Some(\"main\".to_string()));\n\n        // Check tool usage\n        let tool_count: i64 = store\n            .conn\n            .query_row(\"SELECT COUNT(*) FROM tool_usage\", [], |r| r.get(0))\n            .unwrap();\n        assert_eq!(tool_count, 1);\n\n        // Check message stats updated\n        let msg_count: i64 = store\n            .conn\n            .query_row(\n                \"SELECT message_count FROM sessions WHERE id = 'sess-001'\",\n                [],\n                |r| r.get(0),\n            )\n            .unwrap();\n        assert_eq!(msg_count, 2);\n\n        // Idempotent\n        let count2 = sync_sessions(\u0026store.conn, \u0026tmp).unwrap();\n        assert_eq!(count2, 0);\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn sync_sessions_skips_non_message_entries() {\n        let store = open_test_db();\n        let tmp = std::env::temp_dir().join(\"hu-test-sync-skip-types\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n\n        let proj_dir = tmp.join(\"projects\").join(\"-home-user-proj\");\n        std::fs::create_dir_all(\u0026proj_dir).unwrap();\n\n        let jsonl = r#\"{\"uuid\":\"m1\",\"type\":\"summary\",\"timestamp\":\"2024-01-01T00:00:00Z\"}\n{\"uuid\":\"m2\",\"type\":\"user\",\"timestamp\":\"2024-01-01T00:00:01Z\",\"message\":{\"role\":\"user\",\"content\":\"hello\"}}\n\"#;\n        std::fs::write(proj_dir.join(\"sess-002.jsonl\"), jsonl).unwrap();\n\n        let count = sync_sessions(\u0026store.conn, \u0026tmp).unwrap();\n        assert_eq!(count, 1); // Only the message with message body\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn sync_todos_missing_dir() {\n        let store = open_test_db();\n        let result = sync_todos(\u0026store.conn, Path::new(\"/nonexistent\")).unwrap();\n        assert_eq!(result, 0);\n    }\n\n    #[test]\n    fn sync_todos_from_fixture() {\n        let store = open_test_db();\n        let tmp = std::env::temp_dir().join(\"hu-test-sync-todos\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n\n        // Need a session first\n        store\n            .conn\n            .execute(\n                \"INSERT INTO sessions (id, project, started_at) VALUES ('sess-t1', '/proj', 100)\",\n                [],\n            )\n            .unwrap();\n\n        let todos_dir = tmp.join(\"todos\");\n        std::fs::create_dir_all(\u0026todos_dir).unwrap();\n\n        let json = r#\"[\n            {\"content\":\"Fix bug\",\"status\":\"pending\",\"activeForm\":\"Fixing bug\"},\n            {\"content\":\"Add tests\",\"status\":\"completed\"}\n        ]\"#;\n        std::fs::write(todos_dir.join(\"sess-t1.json\"), json).unwrap();\n\n        let count = sync_todos(\u0026store.conn, \u0026tmp).unwrap();\n        assert_eq!(count, 2);\n\n        let todo_count: i64 = store\n            .conn\n            .query_row(\"SELECT COUNT(*) FROM todos\", [], |r| r.get(0))\n            .unwrap();\n        assert_eq!(todo_count, 2);\n\n        // Re-sync replaces (delete + insert)\n        let count2 = sync_todos(\u0026store.conn, \u0026tmp).unwrap();\n        assert_eq!(count2, 2);\n        let todo_count2: i64 = store\n            .conn\n            .query_row(\"SELECT COUNT(*) FROM todos\", [], |r| r.get(0))\n            .unwrap();\n        assert_eq!(todo_count2, 2);\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn sync_todos_skips_invalid_json() {\n        let store = open_test_db();\n        let tmp = std::env::temp_dir().join(\"hu-test-sync-todos-bad\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n\n        let todos_dir = tmp.join(\"todos\");\n        std::fs::create_dir_all(\u0026todos_dir).unwrap();\n        std::fs::write(todos_dir.join(\"bad-session.json\"), \"not json\").unwrap();\n\n        let count = sync_todos(\u0026store.conn, \u0026tmp).unwrap();\n        assert_eq!(count, 0);\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn sync_all_from_fixture() {\n        let store = open_test_db();\n        let tmp = std::env::temp_dir().join(\"hu-test-sync-all\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n        std::fs::create_dir_all(\u0026tmp).unwrap();\n\n        // Empty claude dir\n        let result = sync_all(\u0026store.conn, \u0026tmp).unwrap();\n        assert_eq!(result.history, 0);\n        assert_eq!(result.messages, 0);\n        assert_eq!(result.todos, 0);\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn sync_if_needed_fresh_db() {\n        let store = open_test_db();\n        let tmp = std::env::temp_dir().join(\"hu-test-sync-needed\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n        std::fs::create_dir_all(\u0026tmp).unwrap();\n\n        let synced = sync_if_needed(\u0026store.conn, \u0026tmp, 300).unwrap();\n        assert!(synced);\n\n        // After sync, should not need again\n        let synced2 = sync_if_needed(\u0026store.conn, \u0026tmp, 300).unwrap();\n        assert!(!synced2);\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn parse_timestamp_valid() {\n        let ts = parse_timestamp(\"2024-01-01T00:00:00Z\");\n        assert!(ts \u003e 0);\n    }\n\n    #[test]\n    fn parse_timestamp_invalid() {\n        let ts = parse_timestamp(\"not a date\");\n        assert_eq!(ts, 0);\n    }\n\n    #[test]\n    fn sync_todos_skips_non_json() {\n        let store = open_test_db();\n        let tmp = std::env::temp_dir().join(\"hu-test-sync-todos-nonjson\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n\n        let todos_dir = tmp.join(\"todos\");\n        std::fs::create_dir_all(\u0026todos_dir).unwrap();\n        std::fs::write(todos_dir.join(\"notes.txt\"), \"not a todo file\").unwrap();\n\n        let count = sync_todos(\u0026store.conn, \u0026tmp).unwrap();\n        assert_eq!(count, 0);\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn sync_sessions_skips_missing_uuid() {\n        let store = open_test_db();\n        let tmp = std::env::temp_dir().join(\"hu-test-sync-no-uuid\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n\n        let proj_dir = tmp.join(\"projects\").join(\"-home-user-proj\");\n        std::fs::create_dir_all(\u0026proj_dir).unwrap();\n\n        // Entry without uuid should be skipped\n        let jsonl = r#\"{\"type\":\"user\",\"timestamp\":\"2024-01-01T00:00:00Z\",\"message\":{\"role\":\"user\",\"content\":\"hello\"}}\n{\"uuid\":\"m1\",\"type\":\"user\",\"timestamp\":\"2024-01-01T00:00:01Z\",\"message\":{\"role\":\"user\",\"content\":\"world\"}}\n\"#;\n        std::fs::write(proj_dir.join(\"sess-nouuid.jsonl\"), jsonl).unwrap();\n\n        let count = sync_sessions(\u0026store.conn, \u0026tmp).unwrap();\n        assert_eq!(count, 1); // Only the entry with uuid\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn sync_sessions_skips_missing_timestamp() {\n        let store = open_test_db();\n        let tmp = std::env::temp_dir().join(\"hu-test-sync-no-ts\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n\n        let proj_dir = tmp.join(\"projects\").join(\"-home-user-proj\");\n        std::fs::create_dir_all(\u0026proj_dir).unwrap();\n\n        // Entry with uuid and message but no timestamp should be skipped\n        let jsonl = r#\"{\"uuid\":\"m1\",\"type\":\"user\",\"message\":{\"role\":\"user\",\"content\":\"hello\"}}\n{\"uuid\":\"m2\",\"type\":\"user\",\"timestamp\":\"2024-01-01T00:00:01Z\",\"message\":{\"role\":\"user\",\"content\":\"world\"}}\n\"#;\n        std::fs::write(proj_dir.join(\"sess-nots.jsonl\"), jsonl).unwrap();\n\n        let count = sync_sessions(\u0026store.conn, \u0026tmp).unwrap();\n        assert_eq!(count, 1); // Only the entry with timestamp\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn sync_sessions_skips_nameless_tool_use() {\n        let store = open_test_db();\n        let tmp = std::env::temp_dir().join(\"hu-test-sync-no-toolname\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n\n        let proj_dir = tmp.join(\"projects\").join(\"-home-user-proj\");\n        std::fs::create_dir_all(\u0026proj_dir).unwrap();\n\n        // Assistant message with tool_use block that has no name should skip that block\n        let jsonl = r#\"{\"uuid\":\"m1\",\"type\":\"assistant\",\"timestamp\":\"2024-01-01T00:00:01Z\",\"message\":{\"role\":\"assistant\",\"content\":[{\"type\":\"tool_use\",\"input\":{\"path\":\"/tmp\"}},{\"type\":\"tool_use\",\"name\":\"Read\",\"input\":{\"path\":\"/tmp\"}}],\"model\":\"claude-sonnet-4-5-20251101\",\"usage\":{\"input_tokens\":10,\"output_tokens\":50}}}\n\"#;\n        std::fs::write(proj_dir.join(\"sess-notool.jsonl\"), jsonl).unwrap();\n\n        let count = sync_sessions(\u0026store.conn, \u0026tmp).unwrap();\n        assert_eq!(count, 1);\n\n        // Only one tool_usage row (the one with name \"Read\"), nameless block skipped\n        let tool_count: i64 = store\n            .conn\n            .query_row(\"SELECT COUNT(*) FROM tool_usage\", [], |r| r.get(0))\n            .unwrap();\n        assert_eq!(tool_count, 1);\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn sync_todos_skips_missing_content() {\n        let store = open_test_db();\n        let tmp = std::env::temp_dir().join(\"hu-test-sync-todos-nocontent\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n\n        store\n            .conn\n            .execute(\n                \"INSERT INTO sessions (id, project, started_at) VALUES ('sess-nc', '/proj', 100)\",\n                [],\n            )\n            .unwrap();\n\n        let todos_dir = tmp.join(\"todos\");\n        std::fs::create_dir_all(\u0026todos_dir).unwrap();\n\n        // Todo with no content should be skipped\n        let json = r#\"[\n            {\"status\":\"pending\"},\n            {\"content\":\"Valid todo\",\"status\":\"pending\"}\n        ]\"#;\n        std::fs::write(todos_dir.join(\"sess-nc.json\"), json).unwrap();\n\n        let count = sync_todos(\u0026store.conn, \u0026tmp).unwrap();\n        assert_eq!(count, 1); // Only the valid todo\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n\n    #[test]\n    fn sync_sessions_empty_projects() {\n        let store = open_test_db();\n        let tmp = std::env::temp_dir().join(\"hu-test-sync-empty-proj\");\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n        std::fs::create_dir_all(tmp.join(\"projects\")).unwrap();\n\n        let count = sync_sessions(\u0026store.conn, \u0026tmp).unwrap();\n        assert_eq!(count, 0);\n\n        let _ = std::fs::remove_dir_all(\u0026tmp);\n    }\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":8}},{"line":10,"address":[],"length":0,"stats":{"Line":24}},{"line":13,"address":[],"length":0,"stats":{"Line":8}},{"line":14,"address":[],"length":0,"stats":{"Line":10}},{"line":17,"address":[],"length":0,"stats":{"Line":8}},{"line":20,"address":[],"length":0,"stats":{"Line":25}},{"line":21,"address":[],"length":0,"stats":{"Line":75}},{"line":22,"address":[],"length":0,"stats":{"Line":50}},{"line":24,"address":[],"length":0,"stats":{"Line":25}},{"line":26,"address":[],"length":0,"stats":{"Line":25}},{"line":29,"address":[],"length":0,"stats":{"Line":7}},{"line":30,"address":[],"length":0,"stats":{"Line":7}},{"line":31,"address":[],"length":0,"stats":{"Line":1}},{"line":33,"address":[],"length":0,"stats":{"Line":24}},{"line":34,"address":[],"length":0,"stats":{"Line":18}},{"line":35,"address":[],"length":0,"stats":{"Line":12}},{"line":36,"address":[],"length":0,"stats":{"Line":6}},{"line":39,"address":[],"length":0,"stats":{"Line":6}},{"line":40,"address":[],"length":0,"stats":{"Line":18}},{"line":41,"address":[],"length":0,"stats":{"Line":6}},{"line":42,"address":[],"length":0,"stats":{"Line":9}},{"line":43,"address":[],"length":0,"stats":{"Line":3}},{"line":46,"address":[],"length":0,"stats":{"Line":9}},{"line":47,"address":[],"length":0,"stats":{"Line":12}},{"line":48,"address":[],"length":0,"stats":{"Line":6}},{"line":50,"address":[],"length":0,"stats":{"Line":17}},{"line":51,"address":[],"length":0,"stats":{"Line":20}},{"line":52,"address":[],"length":0,"stats":{"Line":14}},{"line":53,"address":[],"length":0,"stats":{"Line":14}},{"line":54,"address":[],"length":0,"stats":{"Line":7}},{"line":56,"address":[],"length":0,"stats":{"Line":35}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":60,"address":[],"length":0,"stats":{"Line":15}},{"line":62,"address":[],"length":0,"stats":{"Line":5}},{"line":64,"address":[],"length":0,"stats":{"Line":8}},{"line":65,"address":[],"length":0,"stats":{"Line":3}},{"line":69,"address":[],"length":0,"stats":{"Line":9}},{"line":70,"address":[],"length":0,"stats":{"Line":3}},{"line":73,"address":[],"length":0,"stats":{"Line":9}},{"line":74,"address":[],"length":0,"stats":{"Line":27}},{"line":75,"address":[],"length":0,"stats":{"Line":18}},{"line":77,"address":[],"length":0,"stats":{"Line":21}},{"line":78,"address":[],"length":0,"stats":{"Line":18}},{"line":79,"address":[],"length":0,"stats":{"Line":18}},{"line":80,"address":[],"length":0,"stats":{"Line":24}},{"line":84,"address":[],"length":0,"stats":{"Line":27}},{"line":85,"address":[],"length":0,"stats":{"Line":9}},{"line":88,"address":[],"length":0,"stats":{"Line":6}},{"line":93,"address":[],"length":0,"stats":{"Line":18}},{"line":94,"address":[],"length":0,"stats":{"Line":24}},{"line":95,"address":[],"length":0,"stats":{"Line":12}},{"line":97,"address":[],"length":0,"stats":{"Line":18}},{"line":100,"address":[],"length":0,"stats":{"Line":18}},{"line":101,"address":[],"length":0,"stats":{"Line":18}},{"line":103,"address":[],"length":0,"stats":{"Line":6}},{"line":107,"address":[],"length":0,"stats":{"Line":36}},{"line":108,"address":[],"length":0,"stats":{"Line":8}},{"line":109,"address":[],"length":0,"stats":{"Line":6}},{"line":111,"address":[],"length":0,"stats":{"Line":2}},{"line":115,"address":[],"length":0,"stats":{"Line":12}},{"line":117,"address":[],"length":0,"stats":{"Line":28}},{"line":118,"address":[],"length":0,"stats":{"Line":21}},{"line":119,"address":[],"length":0,"stats":{"Line":20}},{"line":120,"address":[],"length":0,"stats":{"Line":1}},{"line":123,"address":[],"length":0,"stats":{"Line":19}},{"line":124,"address":[],"length":0,"stats":{"Line":18}},{"line":125,"address":[],"length":0,"stats":{"Line":1}},{"line":128,"address":[],"length":0,"stats":{"Line":17}},{"line":129,"address":[],"length":0,"stats":{"Line":16}},{"line":130,"address":[],"length":0,"stats":{"Line":1}},{"line":133,"address":[],"length":0,"stats":{"Line":24}},{"line":134,"address":[],"length":0,"stats":{"Line":40}},{"line":136,"address":[],"length":0,"stats":{"Line":48}},{"line":137,"address":[],"length":0,"stats":{"Line":24}},{"line":138,"address":[],"length":0,"stats":{"Line":32}},{"line":139,"address":[],"length":0,"stats":{"Line":32}},{"line":140,"address":[],"length":0,"stats":{"Line":16}},{"line":141,"address":[],"length":0,"stats":{"Line":16}},{"line":142,"address":[],"length":0,"stats":{"Line":24}},{"line":144,"address":[],"length":0,"stats":{"Line":32}},{"line":146,"address":[],"length":0,"stats":{"Line":8}},{"line":148,"address":[],"length":0,"stats":{"Line":14}},{"line":149,"address":[],"length":0,"stats":{"Line":6}},{"line":153,"address":[],"length":0,"stats":{"Line":8}},{"line":154,"address":[],"length":0,"stats":{"Line":6}},{"line":155,"address":[],"length":0,"stats":{"Line":10}},{"line":156,"address":[],"length":0,"stats":{"Line":7}},{"line":157,"address":[],"length":0,"stats":{"Line":6}},{"line":158,"address":[],"length":0,"stats":{"Line":1}},{"line":160,"address":[],"length":0,"stats":{"Line":18}},{"line":161,"address":[],"length":0,"stats":{"Line":9}},{"line":163,"address":[],"length":0,"stats":{"Line":3}},{"line":171,"address":[],"length":0,"stats":{"Line":18}},{"line":173,"address":[],"length":0,"stats":{"Line":6}},{"line":176,"address":[],"length":0,"stats":{"Line":12}},{"line":177,"address":[],"length":0,"stats":{"Line":6}},{"line":180,"address":[],"length":0,"stats":{"Line":10}},{"line":181,"address":[],"length":0,"stats":{"Line":20}},{"line":182,"address":[],"length":0,"stats":{"Line":28}},{"line":186,"address":[],"length":0,"stats":{"Line":8}},{"line":187,"address":[],"length":0,"stats":{"Line":24}},{"line":188,"address":[],"length":0,"stats":{"Line":8}},{"line":189,"address":[],"length":0,"stats":{"Line":9}},{"line":190,"address":[],"length":0,"stats":{"Line":3}},{"line":193,"address":[],"length":0,"stats":{"Line":10}},{"line":194,"address":[],"length":0,"stats":{"Line":15}},{"line":195,"address":[],"length":0,"stats":{"Line":10}},{"line":196,"address":[],"length":0,"stats":{"Line":15}},{"line":197,"address":[],"length":0,"stats":{"Line":5}},{"line":198,"address":[],"length":0,"stats":{"Line":1}},{"line":201,"address":[],"length":0,"stats":{"Line":8}},{"line":202,"address":[],"length":0,"stats":{"Line":16}},{"line":203,"address":[],"length":0,"stats":{"Line":10}},{"line":204,"address":[],"length":0,"stats":{"Line":6}},{"line":205,"address":[],"length":0,"stats":{"Line":1}},{"line":209,"address":[],"length":0,"stats":{"Line":9}},{"line":210,"address":[],"length":0,"stats":{"Line":6}},{"line":212,"address":[],"length":0,"stats":{"Line":3}},{"line":216,"address":[],"length":0,"stats":{"Line":6}},{"line":218,"address":[],"length":0,"stats":{"Line":3}},{"line":221,"address":[],"length":0,"stats":{"Line":15}},{"line":222,"address":[],"length":0,"stats":{"Line":11}},{"line":223,"address":[],"length":0,"stats":{"Line":10}},{"line":224,"address":[],"length":0,"stats":{"Line":1}},{"line":226,"address":[],"length":0,"stats":{"Line":25}},{"line":227,"address":[],"length":0,"stats":{"Line":15}},{"line":229,"address":[],"length":0,"stats":{"Line":10}},{"line":231,"address":[],"length":0,"stats":{"Line":5}},{"line":233,"address":[],"length":0,"stats":{"Line":5}},{"line":237,"address":[],"length":0,"stats":{"Line":15}},{"line":238,"address":[],"length":0,"stats":{"Line":5}},{"line":241,"address":[],"length":0,"stats":{"Line":2}},{"line":242,"address":[],"length":0,"stats":{"Line":8}},{"line":243,"address":[],"length":0,"stats":{"Line":8}},{"line":244,"address":[],"length":0,"stats":{"Line":8}},{"line":245,"address":[],"length":0,"stats":{"Line":2}},{"line":246,"address":[],"length":0,"stats":{"Line":4}},{"line":247,"address":[],"length":0,"stats":{"Line":2}},{"line":248,"address":[],"length":0,"stats":{"Line":2}},{"line":252,"address":[],"length":0,"stats":{"Line":2}},{"line":253,"address":[],"length":0,"stats":{"Line":10}},{"line":254,"address":[],"length":0,"stats":{"Line":4}},{"line":255,"address":[],"length":0,"stats":{"Line":4}},{"line":257,"address":[],"length":0,"stats":{"Line":2}},{"line":258,"address":[],"length":0,"stats":{"Line":3}},{"line":259,"address":[],"length":0,"stats":{"Line":1}},{"line":261,"address":[],"length":0,"stats":{"Line":1}}],"covered":147,"coverable":147},{"path":["/","Users","chi","Projects","hu","src","data","types.rs"],"content":"use serde::{Deserialize, Serialize};\n\n// --- JSONL source types (read from Claude Code files) ---\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct HistoryEntry {\n    pub display: Option\u003cString\u003e,\n    pub timestamp: Option\u003cf64\u003e,\n    pub project: Option\u003cString\u003e,\n    #[serde(rename = \"sessionId\")]\n    pub session_id: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MessageEntry {\n    pub uuid: Option\u003cString\u003e,\n    #[serde(rename = \"parentUuid\")]\n    pub parent_uuid: Option\u003cString\u003e,\n    #[serde(rename = \"sessionId\")]\n    pub session_id: Option\u003cString\u003e,\n    #[serde(rename = \"type\")]\n    pub entry_type: Option\u003cString\u003e,\n    pub timestamp: Option\u003cString\u003e,\n    #[serde(rename = \"gitBranch\")]\n    pub git_branch: Option\u003cString\u003e,\n    pub cwd: Option\u003cString\u003e,\n    pub message: Option\u003cMessageBody\u003e,\n    #[serde(rename = \"costUSD\")]\n    pub cost_usd: Option\u003cf64\u003e,\n    #[serde(rename = \"durationMs\")]\n    pub duration_ms: Option\u003ci64\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MessageBody {\n    pub role: Option\u003cString\u003e,\n    pub content: Option\u003cMessageContent\u003e,\n    pub model: Option\u003cString\u003e,\n    pub usage: Option\u003cTokenUsage\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum MessageContent {\n    Text(String),\n    Blocks(Vec\u003cContentBlock\u003e),\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ContentBlock {\n    #[serde(rename = \"type\")]\n    pub block_type: Option\u003cString\u003e,\n    pub text: Option\u003cString\u003e,\n    pub name: Option\u003cString\u003e,\n    pub input: Option\u003cserde_json::Value\u003e,\n    pub id: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TokenUsage {\n    pub input_tokens: Option\u003ci64\u003e,\n    pub output_tokens: Option\u003ci64\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TodoEntry {\n    pub content: Option\u003cString\u003e,\n    pub status: Option\u003cString\u003e,\n    #[serde(rename = \"activeForm\")]\n    pub active_form: Option\u003cString\u003e,\n}\n\n// --- DB row types ---\n\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct Session {\n    pub id: String,\n    pub project: String,\n    pub display: Option\u003cString\u003e,\n    pub started_at: i64,\n    pub message_count: i64,\n    pub total_cost_usd: f64,\n    pub git_branch: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct Message {\n    pub id: String,\n    pub session_id: String,\n    pub parent_id: Option\u003cString\u003e,\n    pub role: String,\n    pub content: Option\u003cString\u003e,\n    pub model: Option\u003cString\u003e,\n    pub input_tokens: Option\u003ci64\u003e,\n    pub output_tokens: Option\u003ci64\u003e,\n    pub cost_usd: Option\u003cf64\u003e,\n    pub duration_ms: Option\u003ci64\u003e,\n    pub created_at: i64,\n}\n\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct Todo {\n    pub id: i64,\n    pub session_id: String,\n    pub content: String,\n    pub status: String,\n    pub active_form: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct TodoWithProject {\n    pub id: i64,\n    pub session_id: String,\n    pub content: String,\n    pub status: String,\n    pub active_form: Option\u003cString\u003e,\n    pub project: String,\n}\n\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct UsageStats {\n    pub total_sessions: i64,\n    pub total_messages: i64,\n    pub total_cost: f64,\n    pub total_input_tokens: i64,\n    pub total_output_tokens: i64,\n}\n\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct ModelUsage {\n    pub model: String,\n    pub count: i64,\n    pub cost: f64,\n    pub input_tokens: i64,\n    pub output_tokens: i64,\n}\n\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct ToolUsageStats {\n    pub tool_name: String,\n    pub count: i64,\n    pub last_used: i64,\n}\n\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct ToolUsageDetail {\n    pub tool_name: String,\n    pub session_id: String,\n    pub project: String,\n    pub created_at: i64,\n}\n\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct BranchStats {\n    pub git_branch: String,\n    pub session_count: i64,\n    pub session_ids: String,\n    pub last_activity: i64,\n    pub total_messages: i64,\n    pub total_cost: f64,\n    pub project: String,\n}\n\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct SearchResult {\n    pub id: String,\n    pub session_id: String,\n    pub role: String,\n    pub content: Option\u003cString\u003e,\n    pub model: Option\u003cString\u003e,\n    pub created_at: i64,\n    pub project: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DebugError {\n    pub file: String,\n    pub line: usize,\n    pub content: String,\n    pub timestamp: i64,\n}\n\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct SyncResult {\n    pub history: usize,\n    pub messages: usize,\n    pub todos: usize,\n}\n\n#[derive(Debug, Clone, Default)]\npub enum OutputFormat {\n    #[default]\n    Table,\n    Json,\n}\n\n// --- Helpers ---\n\nimpl MessageContent {\n    pub fn as_string(\u0026self) -\u003e String {\n        match self {\n            MessageContent::Text(s) =\u003e s.clone(),\n            MessageContent::Blocks(blocks) =\u003e serde_json::to_string(blocks).unwrap_or_default(),\n        }\n    }\n\n    pub fn tool_use_blocks(\u0026self) -\u003e Vec\u003c\u0026ContentBlock\u003e {\n        match self {\n            MessageContent::Text(_) =\u003e vec![],\n            MessageContent::Blocks(blocks) =\u003e blocks\n                .iter()\n                .filter(|b| b.block_type.as_deref() == Some(\"tool_use\"))\n                .collect(),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn history_entry_serde_roundtrip() {\n        let json = r#\"{\"display\":\"test\",\"timestamp\":1700000000000,\"project\":\"/home/user\",\"sessionId\":\"abc-123\"}\"#;\n        let entry: HistoryEntry = serde_json::from_str(json).unwrap();\n        assert_eq!(entry.session_id.as_deref(), Some(\"abc-123\"));\n        assert_eq!(entry.display.as_deref(), Some(\"test\"));\n        let serialized = serde_json::to_string(\u0026entry).unwrap();\n        let re: HistoryEntry = serde_json::from_str(\u0026serialized).unwrap();\n        assert_eq!(re.session_id, entry.session_id);\n    }\n\n    #[test]\n    fn history_entry_partial_fields() {\n        let json = r#\"{\"display\":\"test\"}\"#;\n        let entry: HistoryEntry = serde_json::from_str(json).unwrap();\n        assert!(entry.session_id.is_none());\n        assert!(entry.timestamp.is_none());\n        assert!(entry.project.is_none());\n    }\n\n    #[test]\n    fn message_entry_serde_roundtrip() {\n        let json = r#\"{\n            \"uuid\": \"msg-1\",\n            \"parentUuid\": \"msg-0\",\n            \"type\": \"user\",\n            \"timestamp\": \"2024-01-01T00:00:00Z\",\n            \"message\": {\n                \"role\": \"user\",\n                \"content\": \"hello\",\n                \"model\": null,\n                \"usage\": null\n            }\n        }\"#;\n        let entry: MessageEntry = serde_json::from_str(json).unwrap();\n        assert_eq!(entry.uuid.as_deref(), Some(\"msg-1\"));\n        assert_eq!(entry.parent_uuid.as_deref(), Some(\"msg-0\"));\n        let body = entry.message.as_ref().unwrap();\n        assert_eq!(body.role.as_deref(), Some(\"user\"));\n    }\n\n    #[test]\n    fn message_content_text() {\n        let content = MessageContent::Text(\"hello world\".to_string());\n        assert_eq!(content.as_string(), \"hello world\");\n        assert!(content.tool_use_blocks().is_empty());\n    }\n\n    #[test]\n    fn message_content_blocks() {\n        let blocks = vec![\n            ContentBlock {\n                block_type: Some(\"text\".to_string()),\n                text: Some(\"hi\".to_string()),\n                name: None,\n                input: None,\n                id: None,\n            },\n            ContentBlock {\n                block_type: Some(\"tool_use\".to_string()),\n                text: None,\n                name: Some(\"Read\".to_string()),\n                input: Some(serde_json::json!({\"path\": \"/tmp/test\"})),\n                id: Some(\"tu-1\".to_string()),\n            },\n        ];\n        let content = MessageContent::Blocks(blocks);\n        let s = content.as_string();\n        assert!(s.contains(\"text\"));\n        assert!(s.contains(\"tool_use\"));\n        let tool_blocks = content.tool_use_blocks();\n        assert_eq!(tool_blocks.len(), 1);\n        assert_eq!(tool_blocks[0].name.as_deref(), Some(\"Read\"));\n    }\n\n    #[test]\n    fn message_content_blocks_serde() {\n        let json = r#\"[{\"type\":\"text\",\"text\":\"hello\"},{\"type\":\"tool_use\",\"name\":\"Bash\",\"input\":{\"cmd\":\"ls\"}}]\"#;\n        let content: MessageContent = serde_json::from_str(json).unwrap();\n        assert_eq!(content.tool_use_blocks().len(), 1);\n    }\n\n    #[test]\n    fn message_content_text_serde() {\n        let json = r#\"\"just a string\"\"#;\n        let content: MessageContent = serde_json::from_str(json).unwrap();\n        assert_eq!(content.as_string(), \"just a string\");\n    }\n\n    #[test]\n    fn todo_entry_serde() {\n        let json = r#\"{\"content\":\"Fix bug\",\"status\":\"pending\",\"activeForm\":\"Fixing bug\"}\"#;\n        let entry: TodoEntry = serde_json::from_str(json).unwrap();\n        assert_eq!(entry.content.as_deref(), Some(\"Fix bug\"));\n        assert_eq!(entry.status.as_deref(), Some(\"pending\"));\n        assert_eq!(entry.active_form.as_deref(), Some(\"Fixing bug\"));\n    }\n\n    #[test]\n    fn todo_entry_minimal() {\n        let json = r#\"{}\"#;\n        let entry: TodoEntry = serde_json::from_str(json).unwrap();\n        assert!(entry.content.is_none());\n    }\n\n    #[test]\n    fn token_usage_serde() {\n        let json = r#\"{\"input_tokens\":100,\"output_tokens\":200}\"#;\n        let usage: TokenUsage = serde_json::from_str(json).unwrap();\n        assert_eq!(usage.input_tokens, Some(100));\n        assert_eq!(usage.output_tokens, Some(200));\n    }\n\n    #[test]\n    fn session_default() {\n        let s = Session::default();\n        assert_eq!(s.id, \"\");\n        assert_eq!(s.message_count, 0);\n        assert_eq!(s.total_cost_usd, 0.0);\n        assert!(s.git_branch.is_none());\n    }\n\n    #[test]\n    fn usage_stats_default() {\n        let s = UsageStats::default();\n        assert_eq!(s.total_sessions, 0);\n        assert_eq!(s.total_messages, 0);\n        assert_eq!(s.total_cost, 0.0);\n    }\n\n    #[test]\n    fn sync_result_default() {\n        let r = SyncResult::default();\n        assert_eq!(r.history, 0);\n        assert_eq!(r.messages, 0);\n        assert_eq!(r.todos, 0);\n    }\n\n    #[test]\n    fn output_format_default() {\n        let f = OutputFormat::default();\n        assert!(matches!(f, OutputFormat::Table));\n    }\n\n    #[test]\n    fn debug_error_fields() {\n        let e = DebugError {\n            file: \"test.log\".to_string(),\n            line: 42,\n            content: \"error: something failed\".to_string(),\n            timestamp: 1700000000,\n        };\n        let json = serde_json::to_string(\u0026e).unwrap();\n        let re: DebugError = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(re.file, \"test.log\");\n        assert_eq!(re.line, 42);\n    }\n\n    #[test]\n    fn branch_stats_default() {\n        let b = BranchStats::default();\n        assert_eq!(b.git_branch, \"\");\n        assert_eq!(b.session_count, 0);\n    }\n\n    #[test]\n    fn tool_usage_stats_default() {\n        let t = ToolUsageStats::default();\n        assert_eq!(t.tool_name, \"\");\n        assert_eq!(t.count, 0);\n    }\n\n    #[test]\n    fn search_result_serialize() {\n        let sr = SearchResult {\n            id: \"msg-1\".to_string(),\n            session_id: \"sess-1\".to_string(),\n            role: \"user\".to_string(),\n            content: Some(\"hello\".to_string()),\n            model: None,\n            created_at: 1700000000,\n            project: \"/home/user/proj\".to_string(),\n        };\n        let json = serde_json::to_string(\u0026sr).unwrap();\n        assert!(json.contains(\"msg-1\"));\n    }\n\n    #[test]\n    fn message_entry_with_git_branch() {\n        let json = r#\"{\n            \"uuid\": \"msg-1\",\n            \"type\": \"user\",\n            \"gitBranch\": \"feature/test\",\n            \"timestamp\": \"2024-01-01T00:00:00Z\"\n        }\"#;\n        let entry: MessageEntry = serde_json::from_str(json).unwrap();\n        assert_eq!(entry.git_branch.as_deref(), Some(\"feature/test\"));\n    }\n\n    #[test]\n    fn message_entry_with_cost() {\n        let json = r#\"{\n            \"uuid\": \"msg-1\",\n            \"type\": \"assistant\",\n            \"costUSD\": 0.0123,\n            \"durationMs\": 500\n        }\"#;\n        let entry: MessageEntry = serde_json::from_str(json).unwrap();\n        assert!((entry.cost_usd.unwrap() - 0.0123).abs() \u003c f64::EPSILON);\n        assert_eq!(entry.duration_ms, Some(500));\n    }\n\n    #[test]\n    fn content_block_serde() {\n        let json = r#\"{\"type\":\"tool_use\",\"name\":\"Read\",\"input\":{\"path\":\"/tmp\"},\"id\":\"tu-1\"}\"#;\n        let block: ContentBlock = serde_json::from_str(json).unwrap();\n        assert_eq!(block.block_type.as_deref(), Some(\"tool_use\"));\n        assert_eq!(block.name.as_deref(), Some(\"Read\"));\n        assert_eq!(block.id.as_deref(), Some(\"tu-1\"));\n    }\n}\n","traces":[{"line":200,"address":[],"length":0,"stats":{"Line":11}},{"line":201,"address":[],"length":0,"stats":{"Line":11}},{"line":202,"address":[],"length":0,"stats":{"Line":21}},{"line":203,"address":[],"length":0,"stats":{"Line":16}},{"line":207,"address":[],"length":0,"stats":{"Line":6}},{"line":208,"address":[],"length":0,"stats":{"Line":6}},{"line":209,"address":[],"length":0,"stats":{"Line":1}},{"line":210,"address":[],"length":0,"stats":{"Line":10}},{"line":212,"address":[],"length":0,"stats":{"Line":25}}],"covered":9,"coverable":9},{"path":["/","Users","chi","Projects","hu","src","docs","cli.rs"],"content":"use clap::{Args, Subcommand};\nuse std::path::PathBuf;\n\n#[derive(Debug, Subcommand)]\npub enum DocsCommand {\n    /// Create a scaffold file for a topic (to be filled by Claude)\n    Add(AddArgs),\n    /// Fetch documentation from a URL\n    Get(GetArgs),\n    /// List documentation files\n    List(ListArgs),\n    /// Remove a documentation file\n    Remove(RemoveArgs),\n    /// Commit and push documentation changes\n    Sync(SyncArgs),\n}\n\n#[derive(Debug, Args)]\npub struct AddArgs {\n    /// Topic to document\n    pub topic: String,\n    /// Output directory (default: ~/Projects/docs)\n    #[arg(short, long)]\n    pub output: Option\u003cPathBuf\u003e,\n    /// Skip git commit\n    #[arg(long)]\n    pub no_commit: bool,\n}\n\n#[derive(Debug, Args)]\npub struct GetArgs {\n    /// URL to fetch\n    pub url: String,\n    /// Output filename (derived from URL if omitted)\n    pub name: Option\u003cString\u003e,\n    /// Output directory (default: ~/Projects/docs)\n    #[arg(short, long)]\n    pub output: Option\u003cPathBuf\u003e,\n    /// Skip git commit\n    #[arg(long)]\n    pub no_commit: bool,\n}\n\n#[derive(Debug, Args)]\npub struct ListArgs {\n    /// Directory to list (default: ~/Projects/docs)\n    pub path: Option\u003cPathBuf\u003e,\n    /// Output as JSON\n    #[arg(short, long)]\n    pub json: bool,\n}\n\n#[derive(Debug, Args)]\npub struct RemoveArgs {\n    /// File to remove (path or slug)\n    pub file: String,\n    /// Base directory for relative paths (default: ~/Projects/docs)\n    #[arg(short, long)]\n    pub dir: Option\u003cPathBuf\u003e,\n    /// Skip git commit\n    #[arg(long)]\n    pub no_commit: bool,\n}\n\n#[derive(Debug, Args)]\npub struct SyncArgs {\n    /// Directory to sync (default: ~/Projects/docs)\n    pub path: Option\u003cPathBuf\u003e,\n    /// Skip git push\n    #[arg(long)]\n    pub no_push: bool,\n    /// Custom commit message\n    #[arg(long, short)]\n    pub message: Option\u003cString\u003e,\n    /// Output as JSON\n    #[arg(long, short)]\n    pub json: bool,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use clap::Parser;\n\n    #[derive(Parser)]\n    struct TestCli {\n        #[command(subcommand)]\n        cmd: DocsCommand,\n    }\n\n    #[test]\n    fn parse_add() {\n        let cli = TestCli::try_parse_from([\"test\", \"add\", \"rust error handling\"]).unwrap();\n        match cli.cmd {\n            DocsCommand::Add(args) =\u003e {\n                assert_eq!(args.topic, \"rust error handling\");\n                assert!(args.output.is_none());\n                assert!(!args.no_commit);\n            }\n            _ =\u003e panic!(\"expected Add\"),\n        }\n    }\n\n    #[test]\n    fn parse_add_with_options() {\n        let cli =\n            TestCli::try_parse_from([\"test\", \"add\", \"topic\", \"--output\", \"/tmp\", \"--no-commit\"])\n                .unwrap();\n        match cli.cmd {\n            DocsCommand::Add(args) =\u003e {\n                assert_eq!(args.output, Some(PathBuf::from(\"/tmp\")));\n                assert!(args.no_commit);\n            }\n            _ =\u003e panic!(\"expected Add\"),\n        }\n    }\n\n    #[test]\n    fn parse_get() {\n        let cli = TestCli::try_parse_from([\"test\", \"get\", \"https://example.com\"]).unwrap();\n        match cli.cmd {\n            DocsCommand::Get(args) =\u003e {\n                assert_eq!(args.url, \"https://example.com\");\n                assert!(args.name.is_none());\n            }\n            _ =\u003e panic!(\"expected Get\"),\n        }\n    }\n\n    #[test]\n    fn parse_get_with_name() {\n        let cli =\n            TestCli::try_parse_from([\"test\", \"get\", \"https://example.com\", \"example\"]).unwrap();\n        match cli.cmd {\n            DocsCommand::Get(args) =\u003e {\n                assert_eq!(args.name, Some(\"example\".to_string()));\n            }\n            _ =\u003e panic!(\"expected Get\"),\n        }\n    }\n\n    #[test]\n    fn parse_list() {\n        let cli = TestCli::try_parse_from([\"test\", \"list\"]).unwrap();\n        match cli.cmd {\n            DocsCommand::List(args) =\u003e {\n                assert!(args.path.is_none());\n                assert!(!args.json);\n            }\n            _ =\u003e panic!(\"expected List\"),\n        }\n    }\n\n    #[test]\n    fn parse_list_with_path() {\n        let cli = TestCli::try_parse_from([\"test\", \"list\", \"/tmp/docs\"]).unwrap();\n        match cli.cmd {\n            DocsCommand::List(args) =\u003e {\n                assert_eq!(args.path, Some(PathBuf::from(\"/tmp/docs\")));\n            }\n            _ =\u003e panic!(\"expected List\"),\n        }\n    }\n\n    #[test]\n    fn parse_list_json() {\n        let cli = TestCli::try_parse_from([\"test\", \"list\", \"--json\"]).unwrap();\n        match cli.cmd {\n            DocsCommand::List(args) =\u003e {\n                assert!(args.json);\n            }\n            _ =\u003e panic!(\"expected List\"),\n        }\n    }\n\n    #[test]\n    fn parse_remove() {\n        let cli = TestCli::try_parse_from([\"test\", \"remove\", \"file.md\"]).unwrap();\n        match cli.cmd {\n            DocsCommand::Remove(args) =\u003e {\n                assert_eq!(args.file, \"file.md\");\n                assert!(!args.no_commit);\n            }\n            _ =\u003e panic!(\"expected Remove\"),\n        }\n    }\n\n    #[test]\n    fn parse_remove_no_commit() {\n        let cli = TestCli::try_parse_from([\"test\", \"remove\", \"file.md\", \"--no-commit\"]).unwrap();\n        match cli.cmd {\n            DocsCommand::Remove(args) =\u003e {\n                assert!(args.no_commit);\n            }\n            _ =\u003e panic!(\"expected Remove\"),\n        }\n    }\n\n    #[test]\n    fn parse_sync() {\n        let cli = TestCli::try_parse_from([\"test\", \"sync\"]).unwrap();\n        match cli.cmd {\n            DocsCommand::Sync(args) =\u003e {\n                assert!(args.path.is_none());\n                assert!(!args.no_push);\n            }\n            _ =\u003e panic!(\"expected Sync\"),\n        }\n    }\n\n    #[test]\n    fn parse_sync_with_options() {\n        let cli = TestCli::try_parse_from([\n            \"test\",\n            \"sync\",\n            \"/tmp/docs\",\n            \"--no-push\",\n            \"-m\",\n            \"custom message\",\n        ])\n        .unwrap();\n        match cli.cmd {\n            DocsCommand::Sync(args) =\u003e {\n                assert_eq!(args.path, Some(PathBuf::from(\"/tmp/docs\")));\n                assert!(args.no_push);\n                assert_eq!(args.message, Some(\"custom message\".to_string()));\n            }\n            _ =\u003e panic!(\"expected Sync\"),\n        }\n    }\n\n    #[test]\n    fn parse_remove_with_dir() {\n        let cli =\n            TestCli::try_parse_from([\"test\", \"remove\", \"file.md\", \"-d\", \"/custom/docs\"]).unwrap();\n        match cli.cmd {\n            DocsCommand::Remove(args) =\u003e {\n                assert_eq!(args.dir, Some(PathBuf::from(\"/custom/docs\")));\n            }\n            _ =\u003e panic!(\"expected Remove\"),\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","docs","display","mod.rs"],"content":"use comfy_table::presets::UTF8_FULL_CONDENSED;\nuse comfy_table::{Cell, Table};\n\nuse super::types::DocEntry;\n\n#[cfg(test)]\nmod tests;\n\n/// Format documents for display\npub fn format_docs(docs: \u0026[DocEntry], json: bool) -\u003e String {\n    if json {\n        format_json(docs)\n    } else {\n        format_table(docs)\n    }\n}\n\n/// Format documents as JSON\nfn format_json(docs: \u0026[DocEntry]) -\u003e String {\n    serde_json::to_string_pretty(docs).unwrap_or_else(|_| \"[]\".to_string())\n}\n\n/// Format documents as a table\nfn format_table(docs: \u0026[DocEntry]) -\u003e String {\n    if docs.is_empty() {\n        return \"No documentation files found.\".to_string();\n    }\n\n    let mut table = Table::new();\n    table.load_preset(UTF8_FULL_CONDENSED);\n    table.set_header(vec![\"File\", \"Title\", \"Source\", \"Date\"]);\n\n    for doc in docs {\n        let file = doc\n            .path\n            .file_name()\n            .map(|s| s.to_string_lossy().to_string())\n            .unwrap_or_default();\n\n        let source = doc\n            .source\n            .as_ref()\n            .map(|s| truncate_url(s, 40))\n            .unwrap_or_else(|| \"-\".to_string());\n\n        let date = doc.fetched.as_deref().unwrap_or(\"-\");\n\n        table.add_row(vec![\n            Cell::new(file),\n            Cell::new(truncate(\u0026doc.title, 30)),\n            Cell::new(source),\n            Cell::new(date),\n        ]);\n    }\n\n    table.to_string()\n}\n\n/// Truncate string with ellipsis\nfn truncate(s: \u0026str, max: usize) -\u003e String {\n    if s.len() \u003c= max {\n        s.to_string()\n    } else {\n        format!(\"{}...\", \u0026s[..max - 3])\n    }\n}\n\n/// Truncate URL, keeping domain visible\nfn truncate_url(url: \u0026str, max: usize) -\u003e String {\n    if url.len() \u003c= max {\n        return url.to_string();\n    }\n\n    // Try to keep domain visible\n    let url = url\n        .trim_start_matches(\"https://\")\n        .trim_start_matches(\"http://\");\n\n    if url.len() \u003c= max {\n        return url.to_string();\n    }\n\n    format!(\"{}...\", \u0026url[..max - 3])\n}\n\n/// Format sync result for display\npub fn format_sync_result(result: \u0026crate::git::SyncResult, json: bool) -\u003e String {\n    if json {\n        return serde_json::to_string_pretty(result).unwrap_or_else(|_| \"{}\".to_string());\n    }\n\n    if result.files_committed == 0 {\n        return \"Nothing to commit, working tree clean\".to_string();\n    }\n\n    let mut output = Vec::new();\n\n    if let Some(hash) = \u0026result.commit_hash {\n        let branch = result.branch.as_deref().unwrap_or(\"unknown\");\n        output.push(format!(\n            \"\\x1b[32m\\u{2713}\\x1b[0m Committed {} {} [{}] {}\",\n            result.files_committed,\n            if result.files_committed == 1 {\n                \"file\"\n            } else {\n                \"files\"\n            },\n            branch,\n            hash\n        ));\n    }\n\n    if result.pushed {\n        output.push(\"\\x1b[32m\\u{2713}\\x1b[0m Pushed to origin\".to_string());\n    } else if result.commit_hash.is_some() {\n        output.push(\"\\x1b[33m\\u{25D0}\\x1b[0m No remote or --no-push\".to_string());\n    }\n\n    output.join(\"\\n\")\n}\n\n/// Format file creation result\npub fn format_created(path: \u0026std::path::Path, topic: \u0026str) -\u003e String {\n    format!(\n        \"\\x1b[32m\\u{2713}\\x1b[0m Created {} ({})\",\n        path.display(),\n        topic\n    )\n}\n\n/// Format file removal result\npub fn format_removed(path: \u0026std::path::Path) -\u003e String {\n    format!(\"\\x1b[32m\\u{2713}\\x1b[0m Removed {}\", path.display())\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":7}},{"line":11,"address":[],"length":0,"stats":{"Line":7}},{"line":12,"address":[],"length":0,"stats":{"Line":4}},{"line":14,"address":[],"length":0,"stats":{"Line":10}},{"line":19,"address":[],"length":0,"stats":{"Line":2}},{"line":20,"address":[],"length":0,"stats":{"Line":6}},{"line":24,"address":[],"length":0,"stats":{"Line":5}},{"line":25,"address":[],"length":0,"stats":{"Line":10}},{"line":26,"address":[],"length":0,"stats":{"Line":2}},{"line":29,"address":[],"length":0,"stats":{"Line":8}},{"line":30,"address":[],"length":0,"stats":{"Line":12}},{"line":31,"address":[],"length":0,"stats":{"Line":24}},{"line":33,"address":[],"length":0,"stats":{"Line":14}},{"line":34,"address":[],"length":0,"stats":{"Line":10}},{"line":35,"address":[],"length":0,"stats":{"Line":5}},{"line":37,"address":[],"length":0,"stats":{"Line":15}},{"line":40,"address":[],"length":0,"stats":{"Line":10}},{"line":41,"address":[],"length":0,"stats":{"Line":5}},{"line":43,"address":[],"length":0,"stats":{"Line":9}},{"line":44,"address":[],"length":0,"stats":{"Line":11}},{"line":46,"address":[],"length":0,"stats":{"Line":25}},{"line":48,"address":[],"length":0,"stats":{"Line":15}},{"line":49,"address":[],"length":0,"stats":{"Line":10}},{"line":50,"address":[],"length":0,"stats":{"Line":15}},{"line":51,"address":[],"length":0,"stats":{"Line":10}},{"line":52,"address":[],"length":0,"stats":{"Line":10}},{"line":56,"address":[],"length":0,"stats":{"Line":8}},{"line":60,"address":[],"length":0,"stats":{"Line":8}},{"line":61,"address":[],"length":0,"stats":{"Line":16}},{"line":62,"address":[],"length":0,"stats":{"Line":12}},{"line":64,"address":[],"length":0,"stats":{"Line":6}},{"line":69,"address":[],"length":0,"stats":{"Line":6}},{"line":70,"address":[],"length":0,"stats":{"Line":12}},{"line":71,"address":[],"length":0,"stats":{"Line":6}},{"line":75,"address":[],"length":0,"stats":{"Line":6}},{"line":79,"address":[],"length":0,"stats":{"Line":6}},{"line":80,"address":[],"length":0,"stats":{"Line":4}},{"line":83,"address":[],"length":0,"stats":{"Line":3}},{"line":87,"address":[],"length":0,"stats":{"Line":6}},{"line":88,"address":[],"length":0,"stats":{"Line":6}},{"line":89,"address":[],"length":0,"stats":{"Line":6}},{"line":92,"address":[],"length":0,"stats":{"Line":4}},{"line":93,"address":[],"length":0,"stats":{"Line":2}},{"line":96,"address":[],"length":0,"stats":{"Line":6}},{"line":98,"address":[],"length":0,"stats":{"Line":6}},{"line":99,"address":[],"length":0,"stats":{"Line":15}},{"line":100,"address":[],"length":0,"stats":{"Line":9}},{"line":101,"address":[],"length":0,"stats":{"Line":3}},{"line":103,"address":[],"length":0,"stats":{"Line":3}},{"line":104,"address":[],"length":0,"stats":{"Line":2}},{"line":106,"address":[],"length":0,"stats":{"Line":1}},{"line":113,"address":[],"length":0,"stats":{"Line":4}},{"line":114,"address":[],"length":0,"stats":{"Line":3}},{"line":115,"address":[],"length":0,"stats":{"Line":7}},{"line":116,"address":[],"length":0,"stats":{"Line":6}},{"line":119,"address":[],"length":0,"stats":{"Line":6}},{"line":123,"address":[],"length":0,"stats":{"Line":1}},{"line":124,"address":[],"length":0,"stats":{"Line":1}},{"line":126,"address":[],"length":0,"stats":{"Line":2}},{"line":132,"address":[],"length":0,"stats":{"Line":1}},{"line":133,"address":[],"length":0,"stats":{"Line":4}}],"covered":61,"coverable":61},{"path":["/","Users","chi","Projects","hu","src","docs","display","tests.rs"],"content":"use super::*;\nuse std::path::PathBuf;\n\n#[test]\nfn format_docs_empty() {\n    let output = format_docs(\u0026[], false);\n    assert!(output.contains(\"No documentation files found\"));\n}\n\n#[test]\nfn format_docs_empty_json() {\n    let output = format_docs(\u0026[], true);\n    assert_eq!(output, \"[]\");\n}\n\n#[test]\nfn format_docs_table() {\n    let docs = vec![DocEntry {\n        path: PathBuf::from(\"/docs/test.md\"),\n        title: \"Test Doc\".to_string(),\n        source: Some(\"https://example.com\".to_string()),\n        fetched: Some(\"2024-01-01\".to_string()),\n        size: 1234,\n    }];\n\n    let output = format_docs(\u0026docs, false);\n    assert!(output.contains(\"test.md\"));\n    assert!(output.contains(\"Test Doc\"));\n    assert!(output.contains(\"example.com\"));\n    assert!(output.contains(\"2024-01-01\"));\n}\n\n#[test]\nfn format_docs_table_no_source() {\n    let docs = vec![DocEntry {\n        path: PathBuf::from(\"/docs/local.md\"),\n        title: \"Local Doc\".to_string(),\n        source: None,\n        fetched: None,\n        size: 100,\n    }];\n\n    let output = format_docs(\u0026docs, false);\n    assert!(output.contains(\"local.md\"));\n    assert!(output.contains(\"-\")); // placeholder for missing source/date\n}\n\n#[test]\nfn format_docs_json() {\n    let docs = vec![DocEntry {\n        path: PathBuf::from(\"/docs/test.md\"),\n        title: \"Test\".to_string(),\n        source: Some(\"https://test.com\".to_string()),\n        fetched: Some(\"2024-01-01\".to_string()),\n        size: 500,\n    }];\n\n    let output = format_docs(\u0026docs, true);\n    assert!(output.contains(\"\\\"title\\\"\"));\n    assert!(output.contains(\"\\\"Test\\\"\"));\n    assert!(output.contains(\"\\\"source\\\"\"));\n}\n\n#[test]\nfn truncate_short() {\n    assert_eq!(truncate(\"short\", 10), \"short\");\n}\n\n#[test]\nfn truncate_exact() {\n    assert_eq!(truncate(\"exactly10!\", 10), \"exactly10!\");\n}\n\n#[test]\nfn truncate_long() {\n    assert_eq!(truncate(\"this is too long\", 10), \"this is...\");\n}\n\n#[test]\nfn truncate_url_short() {\n    assert_eq!(\n        truncate_url(\"https://example.com\", 30),\n        \"https://example.com\"\n    );\n}\n\n#[test]\nfn truncate_url_strips_protocol() {\n    assert_eq!(\n        truncate_url(\"https://example.com/very/long/path/here\", 20),\n        \"example.com/very/...\"\n    );\n}\n\n#[test]\nfn truncate_url_http() {\n    assert_eq!(\n        truncate_url(\"http://example.com/path\", 20),\n        \"example.com/path\"\n    );\n}\n\n#[test]\nfn format_sync_result_clean() {\n    let result = crate::git::SyncResult {\n        files_committed: 0,\n        commit_hash: None,\n        pushed: false,\n        branch: None,\n    };\n    let output = format_sync_result(\u0026result, false);\n    assert!(output.contains(\"Nothing to commit\"));\n}\n\n#[test]\nfn format_sync_result_committed() {\n    let result = crate::git::SyncResult {\n        files_committed: 3,\n        commit_hash: Some(\"abc1234\".to_string()),\n        pushed: false,\n        branch: Some(\"main\".to_string()),\n    };\n    let output = format_sync_result(\u0026result, false);\n    assert!(output.contains(\"Committed 3 files\"));\n    assert!(output.contains(\"[main]\"));\n    assert!(output.contains(\"abc1234\"));\n}\n\n#[test]\nfn format_sync_result_single_file() {\n    let result = crate::git::SyncResult {\n        files_committed: 1,\n        commit_hash: Some(\"def5678\".to_string()),\n        pushed: true,\n        branch: Some(\"feature\".to_string()),\n    };\n    let output = format_sync_result(\u0026result, false);\n    assert!(output.contains(\"1 file\"));\n    assert!(!output.contains(\"1 files\"));\n    assert!(output.contains(\"Pushed to origin\"));\n}\n\n#[test]\nfn format_sync_result_json() {\n    let result = crate::git::SyncResult {\n        files_committed: 2,\n        commit_hash: Some(\"xyz\".to_string()),\n        pushed: true,\n        branch: Some(\"main\".to_string()),\n    };\n    let output = format_sync_result(\u0026result, true);\n    assert!(output.contains(\"\\\"files_committed\\\"\"));\n    assert!(output.contains(\"\\\"pushed\\\": true\"));\n}\n\n#[test]\nfn format_created_output() {\n    let path = PathBuf::from(\"/docs/test.md\");\n    let output = format_created(\u0026path, \"Test Topic\");\n    assert!(output.contains(\"/docs/test.md\"));\n    assert!(output.contains(\"Test Topic\"));\n    assert!(output.contains(\"\\u{2713}\")); // checkmark\n}\n\n#[test]\nfn format_removed_output() {\n    let path = PathBuf::from(\"/docs/removed.md\");\n    let output = format_removed(\u0026path);\n    assert!(output.contains(\"/docs/removed.md\"));\n    assert!(output.contains(\"Removed\"));\n}\n\n#[test]\nfn format_docs_multiple() {\n    let docs = vec![\n        DocEntry {\n            path: PathBuf::from(\"/docs/first.md\"),\n            title: \"First\".to_string(),\n            source: None,\n            fetched: None,\n            size: 100,\n        },\n        DocEntry {\n            path: PathBuf::from(\"/docs/second.md\"),\n            title: \"Second\".to_string(),\n            source: Some(\"https://second.com\".to_string()),\n            fetched: Some(\"2024-02-01\".to_string()),\n            size: 200,\n        },\n    ];\n\n    let output = format_docs(\u0026docs, false);\n    assert!(output.contains(\"first.md\"));\n    assert!(output.contains(\"second.md\"));\n    assert!(output.contains(\"First\"));\n    assert!(output.contains(\"Second\"));\n}\n\n#[test]\nfn format_docs_long_title_truncated() {\n    let docs = vec![DocEntry {\n        path: PathBuf::from(\"/docs/test.md\"),\n        title: \"This is a very long title that should be truncated\".to_string(),\n        source: None,\n        fetched: None,\n        size: 100,\n    }];\n\n    let output = format_docs(\u0026docs, false);\n    assert!(output.contains(\"...\"));\n}\n\n#[test]\nfn format_sync_result_no_push() {\n    let result = crate::git::SyncResult {\n        files_committed: 1,\n        commit_hash: Some(\"abc\".to_string()),\n        pushed: false,\n        branch: Some(\"main\".to_string()),\n    };\n    let output = format_sync_result(\u0026result, false);\n    assert!(output.contains(\"--no-push\"));\n}\n\n#[test]\nfn truncate_url_already_short_after_strip() {\n    // After stripping protocol, URL is short enough\n    assert_eq!(truncate_url(\"https://ex.com\", 10), \"ex.com\");\n}\n\n#[test]\nfn format_sync_json_zero_files() {\n    let result = crate::git::SyncResult {\n        files_committed: 0,\n        commit_hash: None,\n        pushed: false,\n        branch: None,\n    };\n    let output = format_sync_result(\u0026result, true);\n    assert!(output.contains(\"\\\"files_committed\\\": 0\"));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","docs","mod.rs"],"content":"mod cli;\nmod display;\nmod service;\nmod types;\n\npub use cli::DocsCommand;\n\nuse anyhow::Result;\n\n/// Run a docs subcommand\npub async fn run_command(cmd: DocsCommand) -\u003e Result\u003c()\u003e {\n    match cmd {\n        DocsCommand::Add(args) =\u003e run_add(args),\n        DocsCommand::Get(args) =\u003e run_get(args).await,\n        DocsCommand::List(args) =\u003e run_list(args),\n        DocsCommand::Remove(args) =\u003e run_remove(args),\n        DocsCommand::Sync(args) =\u003e run_sync(args),\n    }\n}\n\nfn run_add(args: cli::AddArgs) -\u003e Result\u003c()\u003e {\n    let path = service::add(\u0026args.topic, args.output.as_deref(), args.no_commit)?;\n    println!(\"{}\", display::format_created(\u0026path, \u0026args.topic));\n    Ok(())\n}\n\nasync fn run_get(args: cli::GetArgs) -\u003e Result\u003c()\u003e {\n    let path = service::get(\n        \u0026args.url,\n        args.name.as_deref(),\n        args.output.as_deref(),\n        args.no_commit,\n    )\n    .await?;\n    println!(\"\\x1b[32m\\u{2713}\\x1b[0m Fetched to {}\", path.display());\n    Ok(())\n}\n\nfn run_list(args: cli::ListArgs) -\u003e Result\u003c()\u003e {\n    let docs = service::list(args.path.as_deref())?;\n    println!(\"{}\", display::format_docs(\u0026docs, args.json));\n    Ok(())\n}\n\nfn run_remove(args: cli::RemoveArgs) -\u003e Result\u003c()\u003e {\n    let path = service::remove(\u0026args.file, args.dir.as_deref(), args.no_commit)?;\n    println!(\"{}\", display::format_removed(\u0026path));\n    Ok(())\n}\n\nfn run_sync(args: cli::SyncArgs) -\u003e Result\u003c()\u003e {\n    let result = service::sync(args.path.as_deref(), args.no_push, args.message.as_deref())?;\n    println!(\"{}\", display::format_sync_result(\u0026result, args.json));\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn docs_command_exported() {\n        let _ = std::any::type_name::\u003cDocsCommand\u003e();\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":31},{"path":["/","Users","chi","Projects","hu","src","docs","service.rs"],"content":"use anyhow::{Context, Result};\nuse chrono::Local;\nuse std::fs;\nuse std::path::{Path, PathBuf};\n\nuse super::types::{extract_title, to_slug, DocEntry, Frontmatter};\nuse crate::git::{self, SyncOptions};\n\n/// Default docs directory\npub fn default_docs_dir() -\u003e PathBuf {\n    dirs::home_dir()\n        .map(|h| h.join(\"Projects/docs\"))\n        .unwrap_or_else(|| PathBuf::from(\".\"))\n}\n\n/// Create a scaffold file for a topic\npub fn add(topic: \u0026str, output_dir: Option\u003c\u0026Path\u003e, no_commit: bool) -\u003e Result\u003cPathBuf\u003e {\n    let dir = output_dir\n        .map(PathBuf::from)\n        .unwrap_or_else(default_docs_dir);\n    fs::create_dir_all(\u0026dir)?;\n\n    let slug = to_slug(topic);\n    let filename = format!(\"{}.md\", slug);\n    let path = dir.join(\u0026filename);\n\n    if path.exists() {\n        anyhow::bail!(\"File already exists: {}\", path.display());\n    }\n\n    let date = Local::now().format(\"%Y-%m-%d\").to_string();\n    let frontmatter = Frontmatter {\n        topic: Some(topic.to_string()),\n        created: Some(date),\n        ..Default::default()\n    };\n\n    let content = format!(\n        \"{}\n# {}\n\n\u003c!-- Research and document this topic --\u003e\n\",\n        frontmatter.to_block(),\n        topic\n    );\n\n    fs::write(\u0026path, content).with_context(|| format!(\"Failed to write {}\", path.display()))?;\n\n    if !no_commit {\n        commit_file(\u0026dir, \u0026filename, \u0026format!(\"Add {}\", topic))?;\n    }\n\n    Ok(path)\n}\n\n/// Fetch documentation from a URL\npub async fn get(\n    url: \u0026str,\n    name: Option\u003c\u0026str\u003e,\n    output_dir: Option\u003c\u0026Path\u003e,\n    no_commit: bool,\n) -\u003e Result\u003cPathBuf\u003e {\n    let dir = output_dir\n        .map(PathBuf::from)\n        .unwrap_or_else(default_docs_dir);\n    fs::create_dir_all(\u0026dir)?;\n\n    // Derive filename from URL or use provided name\n    let slug = name.map(to_slug).unwrap_or_else(|| slug_from_url(url));\n    let filename = format!(\"{}.md\", slug);\n    let path = dir.join(\u0026filename);\n\n    // Fetch content\n    let html = fetch_url(url).await?;\n    let markdown = html_to_markdown(\u0026html);\n\n    let date = Local::now().format(\"%Y-%m-%d\").to_string();\n    let frontmatter = Frontmatter {\n        source: Some(url.to_string()),\n        fetched: Some(date),\n        ..Default::default()\n    };\n\n    let content = format!(\"{}\\n{}\", frontmatter.to_block(), markdown);\n\n    fs::write(\u0026path, content).with_context(|| format!(\"Failed to write {}\", path.display()))?;\n\n    if !no_commit {\n        let title = extract_title(\u0026markdown).unwrap_or_else(|| slug.clone());\n        commit_file(\u0026dir, \u0026filename, \u0026format!(\"Add docs: {}\", title))?;\n    }\n\n    Ok(path)\n}\n\n/// List documentation files in a directory\npub fn list(path: Option\u003c\u0026Path\u003e) -\u003e Result\u003cVec\u003cDocEntry\u003e\u003e {\n    let dir = path.map(PathBuf::from).unwrap_or_else(default_docs_dir);\n\n    if !dir.exists() {\n        return Ok(vec![]);\n    }\n\n    let mut entries = Vec::new();\n    collect_docs(\u0026dir, \u0026mut entries)?;\n    entries.sort_by(|a, b| a.path.cmp(\u0026b.path));\n\n    Ok(entries)\n}\n\n/// Recursively collect documentation files\nfn collect_docs(dir: \u0026Path, entries: \u0026mut Vec\u003cDocEntry\u003e) -\u003e Result\u003c()\u003e {\n    for entry in fs::read_dir(dir)? {\n        let entry = entry?;\n        let path = entry.path();\n\n        if path.is_dir() {\n            collect_docs(\u0026path, entries)?;\n        } else if path.extension().is_some_and(|e| e == \"md\") {\n            if let Ok(entry) = parse_doc_entry(\u0026path) {\n                entries.push(entry);\n            }\n        }\n    }\n    Ok(())\n}\n\n/// Parse a documentation file into a DocEntry\nfn parse_doc_entry(path: \u0026Path) -\u003e Result\u003cDocEntry\u003e {\n    let content = fs::read_to_string(path)?;\n    let metadata = fs::metadata(path)?;\n\n    let frontmatter = Frontmatter::parse(\u0026content);\n    let title = extract_title(\u0026content)\n        .or_else(|| frontmatter.as_ref().and_then(|f| f.topic.clone()))\n        .unwrap_or_else(|| {\n            path.file_stem()\n                .map(|s| s.to_string_lossy().to_string())\n                .unwrap_or_default()\n        });\n\n    Ok(DocEntry {\n        path: path.to_path_buf(),\n        title,\n        source: frontmatter.as_ref().and_then(|f| f.source.clone()),\n        fetched: frontmatter\n            .as_ref()\n            .and_then(|f| f.fetched.clone().or_else(|| f.created.clone())),\n        size: metadata.len(),\n    })\n}\n\n/// Remove a documentation file\npub fn remove(file: \u0026str, base_dir: Option\u003c\u0026Path\u003e, no_commit: bool) -\u003e Result\u003cPathBuf\u003e {\n    let dir = base_dir.map(PathBuf::from).unwrap_or_else(default_docs_dir);\n\n    // Try to resolve the file path\n    let path = resolve_file_path(file, \u0026dir)?;\n\n    if !path.exists() {\n        anyhow::bail!(\"File not found: {}\", path.display());\n    }\n\n    let filename = path\n        .file_name()\n        .map(|s| s.to_string_lossy().to_string())\n        .unwrap_or_default();\n\n    fs::remove_file(\u0026path).with_context(|| format!(\"Failed to remove {}\", path.display()))?;\n\n    if !no_commit {\n        commit_removal(\u0026dir, \u0026filename)?;\n    }\n\n    Ok(path)\n}\n\n/// Resolve file path from slug or relative/absolute path\nfn resolve_file_path(file: \u0026str, base_dir: \u0026Path) -\u003e Result\u003cPathBuf\u003e {\n    let path = PathBuf::from(file);\n\n    // If absolute path, use it directly\n    if path.is_absolute() {\n        return Ok(path);\n    }\n\n    // Try relative to base_dir\n    let in_base = base_dir.join(\u0026path);\n    if in_base.exists() {\n        return Ok(in_base);\n    }\n\n    // Try with .md extension\n    let with_ext = base_dir.join(format!(\"{}.md\", file));\n    if with_ext.exists() {\n        return Ok(with_ext);\n    }\n\n    // Try as slug\n    let slug = to_slug(file);\n    let as_slug = base_dir.join(format!(\"{}.md\", slug));\n    if as_slug.exists() {\n        return Ok(as_slug);\n    }\n\n    // Return the path in base_dir (will fail with \"not found\" later)\n    Ok(in_base)\n}\n\n/// Sync (commit and push) documentation changes\npub fn sync(path: Option\u003c\u0026Path\u003e, no_push: bool, message: Option\u003c\u0026str\u003e) -\u003e Result\u003cgit::SyncResult\u003e {\n    let dir = path.map(PathBuf::from).unwrap_or_else(default_docs_dir);\n\n    let options = SyncOptions {\n        no_commit: false,\n        no_push,\n        message: message.map(String::from),\n        path: Some(dir),\n    };\n\n    git::sync(\u0026options)\n}\n\n/// Commit a single file\nfn commit_file(dir: \u0026Path, filename: \u0026str, message: \u0026str) -\u003e Result\u003c()\u003e {\n    use std::process::Command;\n\n    Command::new(\"git\")\n        .args([\"add\", filename])\n        .current_dir(dir)\n        .output()\n        .context(\"Failed to stage file\")?;\n\n    Command::new(\"git\")\n        .args([\"commit\", \"-m\", message])\n        .current_dir(dir)\n        .output()\n        .context(\"Failed to commit\")?;\n\n    Ok(())\n}\n\n/// Commit a file removal\nfn commit_removal(dir: \u0026Path, filename: \u0026str) -\u003e Result\u003c()\u003e {\n    use std::process::Command;\n\n    Command::new(\"git\")\n        .args([\"add\", filename])\n        .current_dir(dir)\n        .output()\n        .context(\"Failed to stage removal\")?;\n\n    Command::new(\"git\")\n        .args([\"commit\", \"-m\", \u0026format!(\"Remove {}\", filename)])\n        .current_dir(dir)\n        .output()\n        .context(\"Failed to commit removal\")?;\n\n    Ok(())\n}\n\n/// Extract slug from URL\nfn slug_from_url(url: \u0026str) -\u003e String {\n    // Remove protocol\n    let url = url\n        .trim_start_matches(\"https://\")\n        .trim_start_matches(\"http://\");\n\n    // Get path parts\n    let parts: Vec\u003c\u0026str\u003e = url.split('/').filter(|s| !s.is_empty()).collect();\n\n    // Try to get meaningful slug from path\n    if parts.len() \u003e 1 {\n        // Use last path segment\n        let last = parts.last().unwrap_or(\u0026\"doc\");\n        let slug = last.trim_end_matches(\".html\").trim_end_matches(\".htm\");\n        return to_slug(slug);\n    }\n\n    // Use domain name\n    if let Some(domain) = parts.first() {\n        let domain = domain.split('.').next().unwrap_or(\"doc\");\n        return to_slug(domain);\n    }\n\n    \"doc\".to_string()\n}\n\n/// Fetch URL content (async)\nasync fn fetch_url(url: \u0026str) -\u003e Result\u003cString\u003e {\n    let client = reqwest::Client::builder()\n        .user_agent(\"hu-cli/0.1\")\n        .build()?;\n\n    let response = client\n        .get(url)\n        .send()\n        .await\n        .with_context(|| format!(\"Failed to fetch {}\", url))?;\n\n    response\n        .text()\n        .await\n        .with_context(|| format!(\"Failed to read response from {}\", url))\n}\n\n/// Convert HTML to markdown (simplified version)\nfn html_to_markdown(html: \u0026str) -\u003e String {\n    use regex::Regex;\n\n    let mut result = html.to_string();\n\n    // Remove script, style, nav, footer\n    for tag in \u0026[\"script\", \"style\", \"noscript\", \"nav\", \"footer\", \"header\"] {\n        let re = Regex::new(\u0026format!(r\"(?is)\u003c{}\\b[^\u003e]*\u003e.*?\u003c/{}\u003e\", tag, tag)).unwrap();\n        result = re.replace_all(\u0026result, \"\").to_string();\n    }\n\n    // Convert headings\n    for level in 1..=6 {\n        let prefix = \"#\".repeat(level);\n        let open_re = Regex::new(\u0026format!(r\"(?i)\u003ch{}\\b[^\u003e]*\u003e\", level)).unwrap();\n        let close_re = Regex::new(\u0026format!(r\"(?i)\u003c/h{}\u003e\", level)).unwrap();\n        result = open_re\n            .replace_all(\u0026result, format!(\"\\n{} \", prefix))\n            .to_string();\n        result = close_re.replace_all(\u0026result, \"\\n\").to_string();\n    }\n\n    // Convert links\n    let link_re = Regex::new(r#\"(?i)\u003ca\\s+[^\u003e]*href=[\"']([^\"']+)[\"'][^\u003e]*\u003e([^\u003c]*)\u003c/a\u003e\"#).unwrap();\n    result = link_re.replace_all(\u0026result, \"[$2]($1)\").to_string();\n\n    // Convert emphasis\n    for tag in [\"strong\", \"b\"] {\n        let re = Regex::new(\u0026format!(r\"(?i)\u003c{}\\b[^\u003e]*\u003e([^\u003c]*)\u003c/{}\u003e\", tag, tag)).unwrap();\n        result = re.replace_all(\u0026result, \"**$1**\").to_string();\n    }\n    for tag in [\"em\", \"i\"] {\n        let re = Regex::new(\u0026format!(r\"(?i)\u003c{}\\b[^\u003e]*\u003e([^\u003c]*)\u003c/{}\u003e\", tag, tag)).unwrap();\n        result = re.replace_all(\u0026result, \"*$1*\").to_string();\n    }\n\n    // Convert code\n    result = Regex::new(r\"(?i)\u003ccode\\b[^\u003e]*\u003e([^\u003c]*)\u003c/code\u003e\")\n        .unwrap()\n        .replace_all(\u0026result, \"`$1`\")\n        .to_string();\n\n    // Convert paragraphs\n    result = Regex::new(r\"(?i)\u003cp\\b[^\u003e]*\u003e\")\n        .unwrap()\n        .replace_all(\u0026result, \"\\n\\n\")\n        .to_string();\n    result = Regex::new(r\"(?i)\u003c/p\u003e\")\n        .unwrap()\n        .replace_all(\u0026result, \"\\n\")\n        .to_string();\n\n    // Convert lists\n    result = Regex::new(r\"(?i)\u003cli\\b[^\u003e]*\u003e\")\n        .unwrap()\n        .replace_all(\u0026result, \"\\n- \")\n        .to_string();\n    result = Regex::new(r\"(?i)\u003c/li\u003e\")\n        .unwrap()\n        .replace_all(\u0026result, \"\")\n        .to_string();\n\n    // Remove remaining tags\n    result = Regex::new(r\"\u003c[^\u003e]+\u003e\")\n        .unwrap()\n        .replace_all(\u0026result, \"\")\n        .to_string();\n\n    // Decode entities\n    result = result\n        .replace(\"\u0026amp;\", \"\u0026\")\n        .replace(\"\u0026lt;\", \"\u003c\")\n        .replace(\"\u0026gt;\", \"\u003e\")\n        .replace(\"\u0026quot;\", \"\\\"\")\n        .replace(\"\u0026#39;\", \"'\")\n        .replace(\"\u0026nbsp;\", \" \");\n\n    // Clean up whitespace\n    result = Regex::new(r\"\\n{3,}\")\n        .unwrap()\n        .replace_all(\u0026result, \"\\n\\n\")\n        .to_string();\n    result = Regex::new(r\"[ \\t]+\")\n        .unwrap()\n        .replace_all(\u0026result, \" \")\n        .to_string();\n\n    result.trim().to_string()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use tempfile::tempdir;\n\n    #[test]\n    fn default_docs_dir_exists() {\n        let dir = default_docs_dir();\n        // Should return a path (may or may not exist)\n        assert!(!dir.as_os_str().is_empty());\n    }\n\n    #[test]\n    fn slug_from_url_path() {\n        assert_eq!(slug_from_url(\"https://docs.rs/clap/latest/clap\"), \"clap\");\n    }\n\n    #[test]\n    fn slug_from_url_html() {\n        assert_eq!(\n            slug_from_url(\"https://example.com/guide/intro.html\"),\n            \"intro\"\n        );\n    }\n\n    #[test]\n    fn slug_from_url_domain_only() {\n        assert_eq!(slug_from_url(\"https://example.com/\"), \"example\");\n    }\n\n    #[test]\n    fn slug_from_url_empty() {\n        assert_eq!(slug_from_url(\"\"), \"doc\");\n    }\n\n    #[test]\n    fn add_creates_file() {\n        let tmp = tempdir().unwrap();\n        let path = add(\"Test Topic\", Some(tmp.path()), true).unwrap();\n\n        assert!(path.exists());\n        let content = fs::read_to_string(\u0026path).unwrap();\n        assert!(content.contains(\"topic: \\\"Test Topic\\\"\"));\n        assert!(content.contains(\"# Test Topic\"));\n    }\n\n    #[test]\n    fn add_fails_if_exists() {\n        let tmp = tempdir().unwrap();\n        let _ = add(\"Duplicate\", Some(tmp.path()), true).unwrap();\n        let result = add(\"Duplicate\", Some(tmp.path()), true);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn list_empty_dir() {\n        let tmp = tempdir().unwrap();\n        let entries = list(Some(tmp.path())).unwrap();\n        assert!(entries.is_empty());\n    }\n\n    #[test]\n    fn list_with_docs() {\n        let tmp = tempdir().unwrap();\n        let _ = add(\"First\", Some(tmp.path()), true).unwrap();\n        let _ = add(\"Second\", Some(tmp.path()), true).unwrap();\n\n        let entries = list(Some(tmp.path())).unwrap();\n        assert_eq!(entries.len(), 2);\n    }\n\n    #[test]\n    fn list_nonexistent_dir() {\n        let entries = list(Some(Path::new(\"/nonexistent/path/docs\"))).unwrap();\n        assert!(entries.is_empty());\n    }\n\n    #[test]\n    fn remove_deletes_file() {\n        let tmp = tempdir().unwrap();\n        let path = add(\"ToRemove\", Some(tmp.path()), true).unwrap();\n        assert!(path.exists());\n\n        remove(\"toremove.md\", Some(tmp.path()), true).unwrap();\n        assert!(!path.exists());\n    }\n\n    #[test]\n    fn remove_by_slug() {\n        let tmp = tempdir().unwrap();\n        let path = add(\"By Slug\", Some(tmp.path()), true).unwrap();\n        assert!(path.exists());\n\n        remove(\"by-slug\", Some(tmp.path()), true).unwrap();\n        assert!(!path.exists());\n    }\n\n    #[test]\n    fn remove_not_found() {\n        let tmp = tempdir().unwrap();\n        let result = remove(\"nonexistent.md\", Some(tmp.path()), true);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn resolve_file_path_absolute() {\n        let path = resolve_file_path(\"/absolute/path.md\", Path::new(\"/base\")).unwrap();\n        assert_eq!(path, PathBuf::from(\"/absolute/path.md\"));\n    }\n\n    #[test]\n    fn resolve_file_path_with_ext() {\n        let tmp = tempdir().unwrap();\n        fs::write(tmp.path().join(\"test.md\"), \"# Test\").unwrap();\n\n        let path = resolve_file_path(\"test.md\", tmp.path()).unwrap();\n        assert!(path.exists());\n    }\n\n    #[test]\n    fn resolve_file_path_without_ext() {\n        let tmp = tempdir().unwrap();\n        fs::write(tmp.path().join(\"test.md\"), \"# Test\").unwrap();\n\n        let path = resolve_file_path(\"test\", tmp.path()).unwrap();\n        assert!(path.exists());\n    }\n\n    #[test]\n    fn parse_doc_entry_basic() {\n        let tmp = tempdir().unwrap();\n        let file = tmp.path().join(\"test.md\");\n        fs::write(\u0026file, \"# My Title\\n\\nContent\").unwrap();\n\n        let entry = parse_doc_entry(\u0026file).unwrap();\n        assert_eq!(entry.title, \"My Title\");\n        assert!(entry.source.is_none());\n    }\n\n    #[test]\n    fn parse_doc_entry_with_frontmatter() {\n        let tmp = tempdir().unwrap();\n        let file = tmp.path().join(\"test.md\");\n        fs::write(\n            \u0026file,\n            \"---\\nsource: https://example.com\\nfetched: 2024-01-01\\n---\\n# Title\",\n        )\n        .unwrap();\n\n        let entry = parse_doc_entry(\u0026file).unwrap();\n        assert_eq!(entry.source, Some(\"https://example.com\".to_string()));\n        assert_eq!(entry.fetched, Some(\"2024-01-01\".to_string()));\n    }\n\n    #[test]\n    fn parse_doc_entry_title_from_topic() {\n        let tmp = tempdir().unwrap();\n        let file = tmp.path().join(\"test.md\");\n        fs::write(\u0026file, \"---\\ntopic: My Topic\\n---\\n\\nNo heading\").unwrap();\n\n        let entry = parse_doc_entry(\u0026file).unwrap();\n        assert_eq!(entry.title, \"My Topic\");\n    }\n\n    #[test]\n    fn parse_doc_entry_title_from_filename() {\n        let tmp = tempdir().unwrap();\n        let file = tmp.path().join(\"my-file.md\");\n        fs::write(\u0026file, \"No frontmatter, no heading\").unwrap();\n\n        let entry = parse_doc_entry(\u0026file).unwrap();\n        assert_eq!(entry.title, \"my-file\");\n    }\n\n    #[test]\n    fn html_to_markdown_headings() {\n        let html = \"\u003ch1\u003eTitle\u003c/h1\u003e\u003ch2\u003eSubtitle\u003c/h2\u003e\";\n        let md = html_to_markdown(html);\n        assert!(md.contains(\"# Title\"));\n        assert!(md.contains(\"## Subtitle\"));\n    }\n\n    #[test]\n    fn html_to_markdown_links() {\n        let html = r#\"\u003ca href=\"https://example.com\"\u003eLink\u003c/a\u003e\"#;\n        let md = html_to_markdown(html);\n        assert!(md.contains(\"[Link](https://example.com)\"));\n    }\n\n    #[test]\n    fn html_to_markdown_emphasis() {\n        let html = \"\u003cstrong\u003ebold\u003c/strong\u003e and \u003cem\u003eitalic\u003c/em\u003e\";\n        let md = html_to_markdown(html);\n        assert!(md.contains(\"**bold**\"));\n        assert!(md.contains(\"*italic*\"));\n    }\n\n    #[test]\n    fn html_to_markdown_code() {\n        let html = \"\u003ccode\u003einline code\u003c/code\u003e\";\n        let md = html_to_markdown(html);\n        assert!(md.contains(\"`inline code`\"));\n    }\n\n    #[test]\n    fn html_to_markdown_strips_scripts() {\n        let html = \"\u003cscript\u003ealert('x')\u003c/script\u003e\u003cp\u003eContent\u003c/p\u003e\";\n        let md = html_to_markdown(html);\n        assert!(!md.contains(\"script\"));\n        assert!(md.contains(\"Content\"));\n    }\n\n    #[test]\n    fn html_to_markdown_entities() {\n        let html = \"\u0026amp; \u0026lt; \u0026gt; \u0026quot;\";\n        let md = html_to_markdown(html);\n        assert!(md.contains(\"\u0026 \u003c \u003e \\\"\"));\n    }\n\n    #[test]\n    fn sync_not_git_repo() {\n        let tmp = tempdir().unwrap();\n        let result = sync(Some(tmp.path()), false, None);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn collect_docs_recursive() {\n        let tmp = tempdir().unwrap();\n        let subdir = tmp.path().join(\"sub\");\n        fs::create_dir(\u0026subdir).unwrap();\n\n        fs::write(tmp.path().join(\"root.md\"), \"# Root\").unwrap();\n        fs::write(subdir.join(\"nested.md\"), \"# Nested\").unwrap();\n\n        let mut entries = Vec::new();\n        collect_docs(tmp.path(), \u0026mut entries).unwrap();\n\n        assert_eq!(entries.len(), 2);\n    }\n\n    #[test]\n    fn collect_docs_ignores_non_md() {\n        let tmp = tempdir().unwrap();\n        fs::write(tmp.path().join(\"doc.md\"), \"# Doc\").unwrap();\n        fs::write(tmp.path().join(\"other.txt\"), \"text\").unwrap();\n\n        let mut entries = Vec::new();\n        collect_docs(tmp.path(), \u0026mut entries).unwrap();\n\n        assert_eq!(entries.len(), 1);\n    }\n\n    #[test]\n    fn list_sorted_by_path() {\n        let tmp = tempdir().unwrap();\n        fs::write(tmp.path().join(\"z-last.md\"), \"# Z\").unwrap();\n        fs::write(tmp.path().join(\"a-first.md\"), \"# A\").unwrap();\n\n        let entries = list(Some(tmp.path())).unwrap();\n        assert_eq!(entries.len(), 2);\n        assert!(entries[0].path.to_string_lossy().contains(\"a-first\"));\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":1}},{"line":11,"address":[],"length":0,"stats":{"Line":1}},{"line":12,"address":[],"length":0,"stats":{"Line":3}},{"line":13,"address":[],"length":0,"stats":{"Line":1}},{"line":17,"address":[],"length":0,"stats":{"Line":7}},{"line":18,"address":[],"length":0,"stats":{"Line":14}},{"line":19,"address":[],"length":0,"stats":{"Line":7}},{"line":20,"address":[],"length":0,"stats":{"Line":7}},{"line":21,"address":[],"length":0,"stats":{"Line":14}},{"line":23,"address":[],"length":0,"stats":{"Line":21}},{"line":24,"address":[],"length":0,"stats":{"Line":21}},{"line":25,"address":[],"length":0,"stats":{"Line":21}},{"line":27,"address":[],"length":0,"stats":{"Line":7}},{"line":28,"address":[],"length":0,"stats":{"Line":3}},{"line":31,"address":[],"length":0,"stats":{"Line":24}},{"line":33,"address":[],"length":0,"stats":{"Line":12}},{"line":34,"address":[],"length":0,"stats":{"Line":6}},{"line":38,"address":[],"length":0,"stats":{"Line":12}},{"line":44,"address":[],"length":0,"stats":{"Line":12}},{"line":48,"address":[],"length":0,"stats":{"Line":24}},{"line":50,"address":[],"length":0,"stats":{"Line":6}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":6}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":4}},{"line":99,"address":[],"length":0,"stats":{"Line":16}},{"line":101,"address":[],"length":0,"stats":{"Line":4}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":105,"address":[],"length":0,"stats":{"Line":6}},{"line":106,"address":[],"length":0,"stats":{"Line":9}},{"line":107,"address":[],"length":0,"stats":{"Line":12}},{"line":109,"address":[],"length":0,"stats":{"Line":3}},{"line":113,"address":[],"length":0,"stats":{"Line":6}},{"line":114,"address":[],"length":0,"stats":{"Line":21}},{"line":115,"address":[],"length":0,"stats":{"Line":18}},{"line":116,"address":[],"length":0,"stats":{"Line":27}},{"line":118,"address":[],"length":0,"stats":{"Line":9}},{"line":119,"address":[],"length":0,"stats":{"Line":3}},{"line":120,"address":[],"length":0,"stats":{"Line":32}},{"line":121,"address":[],"length":0,"stats":{"Line":21}},{"line":122,"address":[],"length":0,"stats":{"Line":14}},{"line":126,"address":[],"length":0,"stats":{"Line":6}},{"line":130,"address":[],"length":0,"stats":{"Line":11}},{"line":131,"address":[],"length":0,"stats":{"Line":33}},{"line":132,"address":[],"length":0,"stats":{"Line":33}},{"line":134,"address":[],"length":0,"stats":{"Line":33}},{"line":135,"address":[],"length":0,"stats":{"Line":33}},{"line":136,"address":[],"length":0,"stats":{"Line":19}},{"line":137,"address":[],"length":0,"stats":{"Line":12}},{"line":138,"address":[],"length":0,"stats":{"Line":2}},{"line":139,"address":[],"length":0,"stats":{"Line":3}},{"line":140,"address":[],"length":0,"stats":{"Line":1}},{"line":144,"address":[],"length":0,"stats":{"Line":22}},{"line":145,"address":[],"length":0,"stats":{"Line":11}},{"line":146,"address":[],"length":0,"stats":{"Line":41}},{"line":147,"address":[],"length":0,"stats":{"Line":11}},{"line":148,"address":[],"length":0,"stats":{"Line":11}},{"line":149,"address":[],"length":0,"stats":{"Line":29}},{"line":150,"address":[],"length":0,"stats":{"Line":22}},{"line":155,"address":[],"length":0,"stats":{"Line":3}},{"line":156,"address":[],"length":0,"stats":{"Line":12}},{"line":159,"address":[],"length":0,"stats":{"Line":12}},{"line":161,"address":[],"length":0,"stats":{"Line":3}},{"line":162,"address":[],"length":0,"stats":{"Line":3}},{"line":165,"address":[],"length":0,"stats":{"Line":4}},{"line":167,"address":[],"length":0,"stats":{"Line":6}},{"line":170,"address":[],"length":0,"stats":{"Line":6}},{"line":172,"address":[],"length":0,"stats":{"Line":2}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":2}},{"line":180,"address":[],"length":0,"stats":{"Line":6}},{"line":181,"address":[],"length":0,"stats":{"Line":18}},{"line":184,"address":[],"length":0,"stats":{"Line":6}},{"line":185,"address":[],"length":0,"stats":{"Line":1}},{"line":189,"address":[],"length":0,"stats":{"Line":20}},{"line":190,"address":[],"length":0,"stats":{"Line":5}},{"line":191,"address":[],"length":0,"stats":{"Line":2}},{"line":195,"address":[],"length":0,"stats":{"Line":15}},{"line":196,"address":[],"length":0,"stats":{"Line":3}},{"line":197,"address":[],"length":0,"stats":{"Line":2}},{"line":201,"address":[],"length":0,"stats":{"Line":3}},{"line":202,"address":[],"length":0,"stats":{"Line":5}},{"line":203,"address":[],"length":0,"stats":{"Line":1}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":1}},{"line":212,"address":[],"length":0,"stats":{"Line":1}},{"line":213,"address":[],"length":0,"stats":{"Line":4}},{"line":218,"address":[],"length":0,"stats":{"Line":2}},{"line":219,"address":[],"length":0,"stats":{"Line":1}},{"line":222,"address":[],"length":0,"stats":{"Line":2}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":4}},{"line":266,"address":[],"length":0,"stats":{"Line":8}},{"line":271,"address":[],"length":0,"stats":{"Line":44}},{"line":274,"address":[],"length":0,"stats":{"Line":4}},{"line":276,"address":[],"length":0,"stats":{"Line":8}},{"line":277,"address":[],"length":0,"stats":{"Line":6}},{"line":278,"address":[],"length":0,"stats":{"Line":4}},{"line":282,"address":[],"length":0,"stats":{"Line":3}},{"line":283,"address":[],"length":0,"stats":{"Line":5}},{"line":284,"address":[],"length":0,"stats":{"Line":2}},{"line":287,"address":[],"length":0,"stats":{"Line":2}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":6}},{"line":312,"address":[],"length":0,"stats":{"Line":18}},{"line":315,"address":[],"length":0,"stats":{"Line":114}},{"line":316,"address":[],"length":0,"stats":{"Line":180}},{"line":317,"address":[],"length":0,"stats":{"Line":108}},{"line":321,"address":[],"length":0,"stats":{"Line":114}},{"line":322,"address":[],"length":0,"stats":{"Line":180}},{"line":323,"address":[],"length":0,"stats":{"Line":180}},{"line":324,"address":[],"length":0,"stats":{"Line":180}},{"line":325,"address":[],"length":0,"stats":{"Line":144}},{"line":326,"address":[],"length":0,"stats":{"Line":144}},{"line":327,"address":[],"length":0,"stats":{"Line":72}},{"line":328,"address":[],"length":0,"stats":{"Line":108}},{"line":332,"address":[],"length":0,"stats":{"Line":24}},{"line":333,"address":[],"length":0,"stats":{"Line":24}},{"line":336,"address":[],"length":0,"stats":{"Line":30}},{"line":337,"address":[],"length":0,"stats":{"Line":60}},{"line":338,"address":[],"length":0,"stats":{"Line":36}},{"line":340,"address":[],"length":0,"stats":{"Line":30}},{"line":341,"address":[],"length":0,"stats":{"Line":60}},{"line":342,"address":[],"length":0,"stats":{"Line":36}},{"line":346,"address":[],"length":0,"stats":{"Line":24}},{"line":347,"address":[],"length":0,"stats":{"Line":12}},{"line":348,"address":[],"length":0,"stats":{"Line":6}},{"line":349,"address":[],"length":0,"stats":{"Line":6}},{"line":352,"address":[],"length":0,"stats":{"Line":24}},{"line":353,"address":[],"length":0,"stats":{"Line":12}},{"line":354,"address":[],"length":0,"stats":{"Line":6}},{"line":355,"address":[],"length":0,"stats":{"Line":6}},{"line":356,"address":[],"length":0,"stats":{"Line":24}},{"line":357,"address":[],"length":0,"stats":{"Line":12}},{"line":358,"address":[],"length":0,"stats":{"Line":6}},{"line":359,"address":[],"length":0,"stats":{"Line":6}},{"line":362,"address":[],"length":0,"stats":{"Line":24}},{"line":363,"address":[],"length":0,"stats":{"Line":12}},{"line":364,"address":[],"length":0,"stats":{"Line":6}},{"line":365,"address":[],"length":0,"stats":{"Line":6}},{"line":366,"address":[],"length":0,"stats":{"Line":24}},{"line":367,"address":[],"length":0,"stats":{"Line":12}},{"line":368,"address":[],"length":0,"stats":{"Line":6}},{"line":369,"address":[],"length":0,"stats":{"Line":6}},{"line":372,"address":[],"length":0,"stats":{"Line":24}},{"line":373,"address":[],"length":0,"stats":{"Line":12}},{"line":374,"address":[],"length":0,"stats":{"Line":6}},{"line":375,"address":[],"length":0,"stats":{"Line":6}},{"line":378,"address":[],"length":0,"stats":{"Line":48}},{"line":379,"address":[],"length":0,"stats":{"Line":36}},{"line":380,"address":[],"length":0,"stats":{"Line":30}},{"line":381,"address":[],"length":0,"stats":{"Line":24}},{"line":382,"address":[],"length":0,"stats":{"Line":18}},{"line":383,"address":[],"length":0,"stats":{"Line":12}},{"line":384,"address":[],"length":0,"stats":{"Line":6}},{"line":387,"address":[],"length":0,"stats":{"Line":24}},{"line":388,"address":[],"length":0,"stats":{"Line":12}},{"line":389,"address":[],"length":0,"stats":{"Line":6}},{"line":390,"address":[],"length":0,"stats":{"Line":6}},{"line":391,"address":[],"length":0,"stats":{"Line":24}},{"line":392,"address":[],"length":0,"stats":{"Line":12}},{"line":393,"address":[],"length":0,"stats":{"Line":6}},{"line":394,"address":[],"length":0,"stats":{"Line":6}},{"line":396,"address":[],"length":0,"stats":{"Line":12}}],"covered":158,"coverable":205},{"path":["/","Users","chi","Projects","hu","src","docs","types.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::path::PathBuf;\n\n/// Representation of a documentation file\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DocEntry {\n    /// Path to the file\n    pub path: PathBuf,\n    /// Document title (from first heading or filename)\n    pub title: String,\n    /// Source URL if fetched from web\n    pub source: Option\u003cString\u003e,\n    /// Date when document was fetched/created\n    pub fetched: Option\u003cString\u003e,\n    /// File size in bytes\n    pub size: u64,\n}\n\n/// YAML frontmatter structure for documentation files\n#[derive(Debug, Clone, Default)]\npub struct Frontmatter {\n    /// Primary source URL\n    pub source: Option\u003cString\u003e,\n    /// Date when document was fetched\n    pub fetched: Option\u003cString\u003e,\n    /// Topic for scaffold files\n    pub topic: Option\u003cString\u003e,\n    /// Date when scaffold was created\n    pub created: Option\u003cString\u003e,\n}\n\nimpl Frontmatter {\n    /// Parse frontmatter from markdown content (simple key: value parsing)\n    pub fn parse(content: \u0026str) -\u003e Option\u003cSelf\u003e {\n        if !content.starts_with(\"---\") {\n            return None;\n        }\n\n        let parts: Vec\u003c\u0026str\u003e = content.splitn(3, \"---\").collect();\n        if parts.len() \u003c 3 {\n            return None;\n        }\n\n        let yaml = parts[1].trim();\n        let mut fm = Frontmatter::default();\n\n        for line in yaml.lines() {\n            let line = line.trim();\n            if let Some((key, value)) = line.split_once(':') {\n                let key = key.trim();\n                let value = value.trim().trim_matches('\"').trim_matches('\\'');\n                match key {\n                    \"source\" =\u003e fm.source = Some(value.to_string()),\n                    \"fetched\" =\u003e fm.fetched = Some(value.to_string()),\n                    \"topic\" =\u003e fm.topic = Some(value.to_string()),\n                    \"created\" =\u003e fm.created = Some(value.to_string()),\n                    _ =\u003e {}\n                }\n            }\n        }\n\n        Some(fm)\n    }\n\n    /// Serialize frontmatter to YAML-like string\n    pub fn to_yaml(\u0026self) -\u003e String {\n        let mut lines = Vec::new();\n        if let Some(ref source) = self.source {\n            lines.push(format!(\"source: {}\", source));\n        }\n        if let Some(ref fetched) = self.fetched {\n            lines.push(format!(\"fetched: {}\", fetched));\n        }\n        if let Some(ref topic) = self.topic {\n            lines.push(format!(\"topic: \\\"{}\\\"\", topic));\n        }\n        if let Some(ref created) = self.created {\n            lines.push(format!(\"created: {}\", created));\n        }\n        if !lines.is_empty() {\n            lines.push(String::new()); // trailing newline\n        }\n        lines.join(\"\\n\")\n    }\n\n    /// Create frontmatter block for markdown\n    pub fn to_block(\u0026self) -\u003e String {\n        format!(\"---\\n{}---\\n\", self.to_yaml())\n    }\n}\n\n/// Convert a string to kebab-case slug\npub fn to_slug(s: \u0026str) -\u003e String {\n    s.to_lowercase()\n        .chars()\n        .map(|c| if c.is_alphanumeric() { c } else { '-' })\n        .collect::\u003cString\u003e()\n        .split('-')\n        .filter(|s| !s.is_empty())\n        .collect::\u003cVec\u003c_\u003e\u003e()\n        .join(\"-\")\n}\n\n/// Extract title from markdown content (first heading)\npub fn extract_title(content: \u0026str) -\u003e Option\u003cString\u003e {\n    for line in content.lines() {\n        let trimmed = line.trim();\n        if let Some(rest) = trimmed.strip_prefix('#') {\n            let title = rest.trim_start_matches('#').trim();\n            if !title.is_empty() {\n                return Some(title.to_string());\n            }\n        }\n    }\n    None\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn to_slug_basic() {\n        assert_eq!(to_slug(\"Hello World\"), \"hello-world\");\n    }\n\n    #[test]\n    fn to_slug_special_chars() {\n        assert_eq!(to_slug(\"Rust's Best Practices!\"), \"rust-s-best-practices\");\n    }\n\n    #[test]\n    fn to_slug_multiple_spaces() {\n        assert_eq!(to_slug(\"one   two  three\"), \"one-two-three\");\n    }\n\n    #[test]\n    fn to_slug_already_slug() {\n        assert_eq!(to_slug(\"already-a-slug\"), \"already-a-slug\");\n    }\n\n    #[test]\n    fn to_slug_empty() {\n        assert_eq!(to_slug(\"\"), \"\");\n    }\n\n    #[test]\n    fn to_slug_numbers() {\n        assert_eq!(to_slug(\"Chapter 1: Introduction\"), \"chapter-1-introduction\");\n    }\n\n    #[test]\n    fn frontmatter_parse_valid() {\n        let content = r#\"---\nsource: https://example.com\nfetched: 2024-01-01\n---\n# Content\"#;\n        let fm = Frontmatter::parse(content).unwrap();\n        assert_eq!(fm.source, Some(\"https://example.com\".to_string()));\n        assert_eq!(fm.fetched, Some(\"2024-01-01\".to_string()));\n    }\n\n    #[test]\n    fn frontmatter_parse_no_frontmatter() {\n        let content = \"# Just Content\";\n        assert!(Frontmatter::parse(content).is_none());\n    }\n\n    #[test]\n    fn frontmatter_parse_incomplete() {\n        let content = \"---\\nsource: test\";\n        assert!(Frontmatter::parse(content).is_none());\n    }\n\n    #[test]\n    fn frontmatter_to_yaml() {\n        let fm = Frontmatter {\n            source: Some(\"https://example.com\".to_string()),\n            fetched: Some(\"2024-01-01\".to_string()),\n            ..Default::default()\n        };\n        let yaml = fm.to_yaml();\n        assert!(yaml.contains(\"source:\"));\n        assert!(yaml.contains(\"https://example.com\"));\n    }\n\n    #[test]\n    fn frontmatter_to_block() {\n        let fm = Frontmatter {\n            source: Some(\"https://test.com\".to_string()),\n            ..Default::default()\n        };\n        let block = fm.to_block();\n        assert!(block.starts_with(\"---\\n\"));\n        assert!(block.ends_with(\"---\\n\"));\n    }\n\n    #[test]\n    fn frontmatter_skips_none_values() {\n        let fm = Frontmatter {\n            source: Some(\"url\".to_string()),\n            fetched: None,\n            topic: None,\n            created: None,\n        };\n        let yaml = fm.to_yaml();\n        assert!(!yaml.contains(\"fetched:\"));\n        assert!(!yaml.contains(\"topic:\"));\n    }\n\n    #[test]\n    fn frontmatter_parse_ignores_unknown_keys() {\n        let content = r#\"---\nsource: https://example.com\nunknown_key: some_value\nanother_unknown: test\nfetched: 2024-01-01\n---\n# Content\"#;\n        let fm = Frontmatter::parse(content).unwrap();\n        assert_eq!(fm.source, Some(\"https://example.com\".to_string()));\n        assert_eq!(fm.fetched, Some(\"2024-01-01\".to_string()));\n    }\n\n    #[test]\n    fn extract_title_h1() {\n        let content = \"# My Title\\n\\nContent here\";\n        assert_eq!(extract_title(content), Some(\"My Title\".to_string()));\n    }\n\n    #[test]\n    fn extract_title_h2() {\n        let content = \"## Second Level\\n\\nContent\";\n        assert_eq!(extract_title(content), Some(\"Second Level\".to_string()));\n    }\n\n    #[test]\n    fn extract_title_with_frontmatter() {\n        let content = \"---\\nsource: url\\n---\\n\\n# Actual Title\";\n        assert_eq!(extract_title(content), Some(\"Actual Title\".to_string()));\n    }\n\n    #[test]\n    fn extract_title_no_heading() {\n        let content = \"Just plain text\\nNo headings here\";\n        assert!(extract_title(content).is_none());\n    }\n\n    #[test]\n    fn extract_title_empty_heading() {\n        let content = \"#\\n\\nNo text after hash\";\n        assert!(extract_title(content).is_none());\n    }\n\n    #[test]\n    fn doc_entry_serialize() {\n        let entry = DocEntry {\n            path: PathBuf::from(\"/docs/test.md\"),\n            title: \"Test\".to_string(),\n            source: Some(\"https://example.com\".to_string()),\n            fetched: Some(\"2024-01-01\".to_string()),\n            size: 1234,\n        };\n        let json = serde_json::to_string(\u0026entry).unwrap();\n        assert!(json.contains(\"Test\"));\n        assert!(json.contains(\"1234\"));\n    }\n\n    #[test]\n    fn doc_entry_debug() {\n        let entry = DocEntry {\n            path: PathBuf::from(\"test.md\"),\n            title: \"Test\".to_string(),\n            source: None,\n            fetched: None,\n            size: 0,\n        };\n        let debug = format!(\"{:?}\", entry);\n        assert!(debug.contains(\"DocEntry\"));\n    }\n\n    #[test]\n    fn frontmatter_parse_with_source() {\n        let content = r#\"---\nsource: https://main.com\nfetched: 2024-02-01\n---\n# Content\"#;\n        let fm = Frontmatter::parse(content).unwrap();\n        assert_eq!(fm.source, Some(\"https://main.com\".to_string()));\n        assert_eq!(fm.fetched, Some(\"2024-02-01\".to_string()));\n    }\n\n    #[test]\n    fn frontmatter_parse_topic() {\n        let content = r#\"---\ntopic: Rust Error Handling\ncreated: 2024-01-01\n---\n# Content\"#;\n        let fm = Frontmatter::parse(content).unwrap();\n        assert_eq!(fm.topic, Some(\"Rust Error Handling\".to_string()));\n        assert_eq!(fm.created, Some(\"2024-01-01\".to_string()));\n    }\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":16}},{"line":35,"address":[],"length":0,"stats":{"Line":16}},{"line":36,"address":[],"length":0,"stats":{"Line":8}},{"line":39,"address":[],"length":0,"stats":{"Line":40}},{"line":40,"address":[],"length":0,"stats":{"Line":8}},{"line":41,"address":[],"length":0,"stats":{"Line":1}},{"line":44,"address":[],"length":0,"stats":{"Line":21}},{"line":45,"address":[],"length":0,"stats":{"Line":14}},{"line":47,"address":[],"length":0,"stats":{"Line":27}},{"line":48,"address":[],"length":0,"stats":{"Line":39}},{"line":49,"address":[],"length":0,"stats":{"Line":39}},{"line":50,"address":[],"length":0,"stats":{"Line":39}},{"line":51,"address":[],"length":0,"stats":{"Line":39}},{"line":52,"address":[],"length":0,"stats":{"Line":13}},{"line":53,"address":[],"length":0,"stats":{"Line":19}},{"line":54,"address":[],"length":0,"stats":{"Line":16}},{"line":55,"address":[],"length":0,"stats":{"Line":15}},{"line":56,"address":[],"length":0,"stats":{"Line":9}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":7}},{"line":66,"address":[],"length":0,"stats":{"Line":9}},{"line":67,"address":[],"length":0,"stats":{"Line":18}},{"line":68,"address":[],"length":0,"stats":{"Line":15}},{"line":69,"address":[],"length":0,"stats":{"Line":9}},{"line":71,"address":[],"length":0,"stats":{"Line":11}},{"line":72,"address":[],"length":0,"stats":{"Line":3}},{"line":74,"address":[],"length":0,"stats":{"Line":21}},{"line":75,"address":[],"length":0,"stats":{"Line":18}},{"line":77,"address":[],"length":0,"stats":{"Line":21}},{"line":78,"address":[],"length":0,"stats":{"Line":18}},{"line":80,"address":[],"length":0,"stats":{"Line":18}},{"line":81,"address":[],"length":0,"stats":{"Line":18}},{"line":83,"address":[],"length":0,"stats":{"Line":18}},{"line":87,"address":[],"length":0,"stats":{"Line":7}},{"line":88,"address":[],"length":0,"stats":{"Line":28}},{"line":93,"address":[],"length":0,"stats":{"Line":17}},{"line":94,"address":[],"length":0,"stats":{"Line":17}},{"line":96,"address":[],"length":0,"stats":{"Line":697}},{"line":99,"address":[],"length":0,"stats":{"Line":87}},{"line":105,"address":[],"length":0,"stats":{"Line":16}},{"line":106,"address":[],"length":0,"stats":{"Line":73}},{"line":107,"address":[],"length":0,"stats":{"Line":123}},{"line":108,"address":[],"length":0,"stats":{"Line":54}},{"line":109,"address":[],"length":0,"stats":{"Line":39}},{"line":110,"address":[],"length":0,"stats":{"Line":13}},{"line":111,"address":[],"length":0,"stats":{"Line":12}},{"line":115,"address":[],"length":0,"stats":{"Line":4}}],"covered":46,"coverable":47},{"path":["/","Users","chi","Projects","hu","src","eks","cli.rs"],"content":"//! EKS CLI commands\n\nuse clap::Subcommand;\n\n#[derive(Debug, Subcommand)]\npub enum EksCommand {\n    /// List pods in the cluster\n    List {\n        /// Namespace to list pods from\n        #[arg(short, long)]\n        namespace: Option\u003cString\u003e,\n\n        /// List pods from all namespaces\n        #[arg(short = 'A', long)]\n        all_namespaces: bool,\n\n        /// Kubeconfig context to use\n        #[arg(short, long)]\n        context: Option\u003cString\u003e,\n\n        /// Output as JSON\n        #[arg(long)]\n        json: bool,\n    },\n\n    /// Execute a command in a pod (interactive shell by default)\n    Exec {\n        /// Pod name\n        pod: String,\n\n        /// Namespace\n        #[arg(short, long)]\n        namespace: Option\u003cString\u003e,\n\n        /// Container name (if pod has multiple containers)\n        #[arg(short, long)]\n        container: Option\u003cString\u003e,\n\n        /// Kubeconfig context to use\n        #[arg(long)]\n        context: Option\u003cString\u003e,\n\n        /// Command to run (default: /bin/sh)\n        #[arg(last = true)]\n        command: Vec\u003cString\u003e,\n    },\n\n    /// Tail logs from a pod\n    Logs {\n        /// Pod name\n        pod: String,\n\n        /// Namespace\n        #[arg(short, long)]\n        namespace: Option\u003cString\u003e,\n\n        /// Container name (if pod has multiple containers)\n        #[arg(short, long)]\n        container: Option\u003cString\u003e,\n\n        /// Follow log output\n        #[arg(short, long)]\n        follow: bool,\n\n        /// Show logs from previous container instance\n        #[arg(long)]\n        previous: bool,\n\n        /// Number of lines to show from the end\n        #[arg(long)]\n        tail: Option\u003cusize\u003e,\n\n        /// Kubeconfig context to use\n        #[arg(long)]\n        context: Option\u003cString\u003e,\n    },\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use clap::{CommandFactory, Parser};\n\n    #[derive(Parser)]\n    struct TestCli {\n        #[command(subcommand)]\n        cmd: EksCommand,\n    }\n\n    #[test]\n    fn parses_list_basic() {\n        let cli = TestCli::try_parse_from([\"test\", \"list\"]).unwrap();\n        match cli.cmd {\n            EksCommand::List {\n                namespace,\n                all_namespaces,\n                context,\n                json,\n            } =\u003e {\n                assert!(namespace.is_none());\n                assert!(!all_namespaces);\n                assert!(context.is_none());\n                assert!(!json);\n            }\n            _ =\u003e panic!(\"Expected List command\"),\n        }\n    }\n\n    #[test]\n    fn parses_list_with_namespace() {\n        let cli = TestCli::try_parse_from([\"test\", \"list\", \"-n\", \"kube-system\"]).unwrap();\n        match cli.cmd {\n            EksCommand::List { namespace, .. } =\u003e {\n                assert_eq!(namespace, Some(\"kube-system\".to_string()));\n            }\n            _ =\u003e panic!(\"Expected List command\"),\n        }\n    }\n\n    #[test]\n    fn parses_list_all_namespaces() {\n        let cli = TestCli::try_parse_from([\"test\", \"list\", \"-A\"]).unwrap();\n        match cli.cmd {\n            EksCommand::List { all_namespaces, .. } =\u003e {\n                assert!(all_namespaces);\n            }\n            _ =\u003e panic!(\"Expected List command\"),\n        }\n    }\n\n    #[test]\n    fn parses_list_with_context() {\n        let cli = TestCli::try_parse_from([\"test\", \"list\", \"-c\", \"prod\"]).unwrap();\n        match cli.cmd {\n            EksCommand::List { context, .. } =\u003e {\n                assert_eq!(context, Some(\"prod\".to_string()));\n            }\n            _ =\u003e panic!(\"Expected List command\"),\n        }\n    }\n\n    #[test]\n    fn parses_list_json() {\n        let cli = TestCli::try_parse_from([\"test\", \"list\", \"--json\"]).unwrap();\n        match cli.cmd {\n            EksCommand::List { json, .. } =\u003e {\n                assert!(json);\n            }\n            _ =\u003e panic!(\"Expected List command\"),\n        }\n    }\n\n    #[test]\n    fn parses_exec_basic() {\n        let cli = TestCli::try_parse_from([\"test\", \"exec\", \"my-pod\"]).unwrap();\n        match cli.cmd {\n            EksCommand::Exec {\n                pod,\n                namespace,\n                container,\n                command,\n                ..\n            } =\u003e {\n                assert_eq!(pod, \"my-pod\");\n                assert!(namespace.is_none());\n                assert!(container.is_none());\n                assert!(command.is_empty());\n            }\n            _ =\u003e panic!(\"Expected Exec command\"),\n        }\n    }\n\n    #[test]\n    fn parses_exec_with_namespace() {\n        let cli = TestCli::try_parse_from([\"test\", \"exec\", \"my-pod\", \"-n\", \"prod\"]).unwrap();\n        match cli.cmd {\n            EksCommand::Exec { namespace, .. } =\u003e {\n                assert_eq!(namespace, Some(\"prod\".to_string()));\n            }\n            _ =\u003e panic!(\"Expected Exec command\"),\n        }\n    }\n\n    #[test]\n    fn parses_exec_with_container() {\n        let cli = TestCli::try_parse_from([\"test\", \"exec\", \"my-pod\", \"-c\", \"app\"]).unwrap();\n        match cli.cmd {\n            EksCommand::Exec { container, .. } =\u003e {\n                assert_eq!(container, Some(\"app\".to_string()));\n            }\n            _ =\u003e panic!(\"Expected Exec command\"),\n        }\n    }\n\n    #[test]\n    fn parses_exec_with_command() {\n        let cli =\n            TestCli::try_parse_from([\"test\", \"exec\", \"my-pod\", \"--\", \"bash\", \"-c\", \"ls\"]).unwrap();\n        match cli.cmd {\n            EksCommand::Exec { command, .. } =\u003e {\n                assert_eq!(command, vec![\"bash\", \"-c\", \"ls\"]);\n            }\n            _ =\u003e panic!(\"Expected Exec command\"),\n        }\n    }\n\n    #[test]\n    fn parses_logs_basic() {\n        let cli = TestCli::try_parse_from([\"test\", \"logs\", \"my-pod\"]).unwrap();\n        match cli.cmd {\n            EksCommand::Logs {\n                pod,\n                follow,\n                previous,\n                tail,\n                ..\n            } =\u003e {\n                assert_eq!(pod, \"my-pod\");\n                assert!(!follow);\n                assert!(!previous);\n                assert!(tail.is_none());\n            }\n            _ =\u003e panic!(\"Expected Logs command\"),\n        }\n    }\n\n    #[test]\n    fn parses_logs_follow() {\n        let cli = TestCli::try_parse_from([\"test\", \"logs\", \"my-pod\", \"-f\"]).unwrap();\n        match cli.cmd {\n            EksCommand::Logs { follow, .. } =\u003e {\n                assert!(follow);\n            }\n            _ =\u003e panic!(\"Expected Logs command\"),\n        }\n    }\n\n    #[test]\n    fn parses_logs_previous() {\n        let cli = TestCli::try_parse_from([\"test\", \"logs\", \"my-pod\", \"--previous\"]).unwrap();\n        match cli.cmd {\n            EksCommand::Logs { previous, .. } =\u003e {\n                assert!(previous);\n            }\n            _ =\u003e panic!(\"Expected Logs command\"),\n        }\n    }\n\n    #[test]\n    fn parses_logs_tail() {\n        let cli = TestCli::try_parse_from([\"test\", \"logs\", \"my-pod\", \"--tail\", \"100\"]).unwrap();\n        match cli.cmd {\n            EksCommand::Logs { tail, .. } =\u003e {\n                assert_eq!(tail, Some(100));\n            }\n            _ =\u003e panic!(\"Expected Logs command\"),\n        }\n    }\n\n    #[test]\n    fn parses_logs_with_container() {\n        let cli = TestCli::try_parse_from([\"test\", \"logs\", \"my-pod\", \"-c\", \"sidecar\"]).unwrap();\n        match cli.cmd {\n            EksCommand::Logs { container, .. } =\u003e {\n                assert_eq!(container, Some(\"sidecar\".to_string()));\n            }\n            _ =\u003e panic!(\"Expected Logs command\"),\n        }\n    }\n\n    #[test]\n    fn command_debug() {\n        let cmd = EksCommand::List {\n            namespace: None,\n            all_namespaces: false,\n            context: None,\n            json: false,\n        };\n        let debug = format!(\"{:?}\", cmd);\n        assert!(debug.contains(\"List\"));\n    }\n\n    #[test]\n    fn command_has_help() {\n        let mut cmd = TestCli::command();\n        let help = cmd.render_help();\n        assert!(!help.to_string().is_empty());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","eks","display.rs"],"content":"//! EKS output formatting\n\nuse anyhow::{Context, Result};\nuse comfy_table::{presets::UTF8_FULL_CONDENSED, Cell, Color, ContentArrangement, Table};\n\nuse super::types::{OutputFormat, Pod};\n\n/// Get color for pod status\nfn status_color(status: \u0026str) -\u003e Color {\n    match status {\n        \"Running\" =\u003e Color::Green,\n        \"Pending\" =\u003e Color::Yellow,\n        \"Succeeded\" =\u003e Color::Cyan,\n        \"Failed\" =\u003e Color::Red,\n        \"Unknown\" =\u003e Color::DarkGrey,\n        _ =\u003e Color::White,\n    }\n}\n\n/// Output pods list\npub fn output_pods(pods: \u0026[Pod], format: OutputFormat, show_namespace: bool) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            if pods.is_empty() {\n                println!(\"No pods found.\");\n                return Ok(());\n            }\n\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_content_arrangement(ContentArrangement::Dynamic);\n\n            if show_namespace {\n                table.set_header(vec![\n                    \"NAMESPACE\",\n                    \"NAME\",\n                    \"READY\",\n                    \"STATUS\",\n                    \"RESTARTS\",\n                    \"AGE\",\n                ]);\n            } else {\n                table.set_header(vec![\"NAME\", \"READY\", \"STATUS\", \"RESTARTS\", \"AGE\"]);\n            }\n\n            for pod in pods {\n                if show_namespace {\n                    table.add_row(vec![\n                        Cell::new(\u0026pod.namespace),\n                        Cell::new(\u0026pod.name).fg(Color::Cyan),\n                        Cell::new(\u0026pod.ready),\n                        Cell::new(\u0026pod.status).fg(status_color(\u0026pod.status)),\n                        Cell::new(pod.restarts.to_string()),\n                        Cell::new(\u0026pod.age),\n                    ]);\n                } else {\n                    table.add_row(vec![\n                        Cell::new(\u0026pod.name).fg(Color::Cyan),\n                        Cell::new(\u0026pod.ready),\n                        Cell::new(\u0026pod.status).fg(status_color(\u0026pod.status)),\n                        Cell::new(pod.restarts.to_string()),\n                        Cell::new(\u0026pod.age),\n                    ]);\n                }\n            }\n\n            println!(\"{table}\");\n            println!(\"\\n{} pods\", pods.len());\n        }\n        OutputFormat::Json =\u003e {\n            let json = serde_json::to_string_pretty(pods).context(\"Failed to serialize pods\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn status_color_running() {\n        assert_eq!(status_color(\"Running\"), Color::Green);\n    }\n\n    #[test]\n    fn status_color_pending() {\n        assert_eq!(status_color(\"Pending\"), Color::Yellow);\n    }\n\n    #[test]\n    fn status_color_succeeded() {\n        assert_eq!(status_color(\"Succeeded\"), Color::Cyan);\n    }\n\n    #[test]\n    fn status_color_failed() {\n        assert_eq!(status_color(\"Failed\"), Color::Red);\n    }\n\n    #[test]\n    fn status_color_unknown() {\n        assert_eq!(status_color(\"Unknown\"), Color::DarkGrey);\n    }\n\n    #[test]\n    fn status_color_other() {\n        assert_eq!(status_color(\"CrashLoopBackOff\"), Color::White);\n    }\n\n    #[test]\n    fn output_pods_empty() {\n        let result = output_pods(\u0026[], OutputFormat::Table, false);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn output_pods_table() {\n        let pods = vec![Pod {\n            name: \"test-pod\".to_string(),\n            namespace: \"default\".to_string(),\n            status: \"Running\".to_string(),\n            ready: \"1/1\".to_string(),\n            restarts: 0,\n            age: \"1d\".to_string(),\n            node: None,\n        }];\n        let result = output_pods(\u0026pods, OutputFormat::Table, false);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn output_pods_table_with_namespace() {\n        let pods = vec![Pod {\n            name: \"test-pod\".to_string(),\n            namespace: \"kube-system\".to_string(),\n            status: \"Running\".to_string(),\n            ready: \"1/1\".to_string(),\n            restarts: 0,\n            age: \"1d\".to_string(),\n            node: None,\n        }];\n        let result = output_pods(\u0026pods, OutputFormat::Table, true);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn output_pods_json() {\n        let pods = vec![Pod {\n            name: \"test-pod\".to_string(),\n            namespace: \"default\".to_string(),\n            status: \"Running\".to_string(),\n            ready: \"1/1\".to_string(),\n            restarts: 0,\n            age: \"1d\".to_string(),\n            node: None,\n        }];\n        let result = output_pods(\u0026pods, OutputFormat::Json, false);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn output_pods_json_empty() {\n        let result = output_pods(\u0026[], OutputFormat::Json, false);\n        assert!(result.is_ok());\n    }\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":8}},{"line":10,"address":[],"length":0,"stats":{"Line":8}},{"line":11,"address":[],"length":0,"stats":{"Line":11}},{"line":12,"address":[],"length":0,"stats":{"Line":6}},{"line":13,"address":[],"length":0,"stats":{"Line":5}},{"line":14,"address":[],"length":0,"stats":{"Line":4}},{"line":15,"address":[],"length":0,"stats":{"Line":3}},{"line":16,"address":[],"length":0,"stats":{"Line":1}},{"line":21,"address":[],"length":0,"stats":{"Line":5}},{"line":22,"address":[],"length":0,"stats":{"Line":5}},{"line":24,"address":[],"length":0,"stats":{"Line":6}},{"line":25,"address":[],"length":0,"stats":{"Line":2}},{"line":26,"address":[],"length":0,"stats":{"Line":1}},{"line":29,"address":[],"length":0,"stats":{"Line":4}},{"line":30,"address":[],"length":0,"stats":{"Line":6}},{"line":31,"address":[],"length":0,"stats":{"Line":6}},{"line":33,"address":[],"length":0,"stats":{"Line":3}},{"line":34,"address":[],"length":0,"stats":{"Line":4}},{"line":35,"address":[],"length":0,"stats":{"Line":1}},{"line":36,"address":[],"length":0,"stats":{"Line":2}},{"line":37,"address":[],"length":0,"stats":{"Line":2}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":39,"address":[],"length":0,"stats":{"Line":1}},{"line":40,"address":[],"length":0,"stats":{"Line":1}},{"line":43,"address":[],"length":0,"stats":{"Line":6}},{"line":46,"address":[],"length":0,"stats":{"Line":6}},{"line":47,"address":[],"length":0,"stats":{"Line":3}},{"line":48,"address":[],"length":0,"stats":{"Line":4}},{"line":49,"address":[],"length":0,"stats":{"Line":3}},{"line":50,"address":[],"length":0,"stats":{"Line":5}},{"line":51,"address":[],"length":0,"stats":{"Line":3}},{"line":52,"address":[],"length":0,"stats":{"Line":6}},{"line":53,"address":[],"length":0,"stats":{"Line":4}},{"line":54,"address":[],"length":0,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":4}},{"line":58,"address":[],"length":0,"stats":{"Line":5}},{"line":59,"address":[],"length":0,"stats":{"Line":3}},{"line":60,"address":[],"length":0,"stats":{"Line":6}},{"line":61,"address":[],"length":0,"stats":{"Line":4}},{"line":62,"address":[],"length":0,"stats":{"Line":1}},{"line":67,"address":[],"length":0,"stats":{"Line":4}},{"line":68,"address":[],"length":0,"stats":{"Line":8}},{"line":71,"address":[],"length":0,"stats":{"Line":8}},{"line":72,"address":[],"length":0,"stats":{"Line":4}},{"line":75,"address":[],"length":0,"stats":{"Line":4}}],"covered":45,"coverable":45},{"path":["/","Users","chi","Projects","hu","src","eks","kubectl","mod.rs"],"content":"//! kubectl wrapper functions\n\nuse anyhow::{Context, Result};\nuse std::process::{Command, Stdio};\n\nuse super::types::{KubectlConfig, Pod, PodList};\n\n#[cfg(test)]\nmod tests;\n\n/// Build kubectl base command with context/namespace\nfn build_kubectl_cmd(config: \u0026KubectlConfig) -\u003e Command {\n    let mut cmd = Command::new(\"kubectl\");\n\n    if let Some(ctx) = \u0026config.context {\n        cmd.arg(\"--context\").arg(ctx);\n    }\n\n    if let Some(ns) = \u0026config.namespace {\n        cmd.arg(\"-n\").arg(ns);\n    }\n\n    cmd\n}\n\n/// List pods using kubectl\npub fn list_pods(config: \u0026KubectlConfig, all_namespaces: bool) -\u003e Result\u003cVec\u003cPod\u003e\u003e {\n    let mut cmd = build_kubectl_cmd(config);\n    cmd.arg(\"get\").arg(\"pods\").arg(\"-o\").arg(\"json\");\n\n    if all_namespaces {\n        cmd.arg(\"--all-namespaces\");\n    }\n\n    let output = cmd\n        .output()\n        .context(\"Failed to execute kubectl. Is kubectl installed and configured?\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"kubectl failed: {}\", stderr.trim());\n    }\n\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    parse_pod_list(\u0026stdout)\n}\n\n/// Parse kubectl JSON output into Pod list\npub fn parse_pod_list(json: \u0026str) -\u003e Result\u003cVec\u003cPod\u003e\u003e {\n    let pod_list: PodList = serde_json::from_str(json).context(\"Failed to parse kubectl output\")?;\n\n    Ok(pod_list.items.iter().map(|item| item.to_pod()).collect())\n}\n\n/// Execute into a pod (interactive)\npub fn exec_pod(\n    config: \u0026KubectlConfig,\n    pod: \u0026str,\n    container: Option\u003c\u0026str\u003e,\n    command: \u0026[String],\n) -\u003e Result\u003c()\u003e {\n    let mut cmd = build_kubectl_cmd(config);\n    cmd.arg(\"exec\").arg(\"-it\").arg(pod);\n\n    if let Some(c) = container {\n        cmd.arg(\"-c\").arg(c);\n    }\n\n    cmd.arg(\"--\");\n\n    if command.is_empty() {\n        cmd.arg(\"/bin/sh\");\n    } else {\n        for arg in command {\n            cmd.arg(arg);\n        }\n    }\n\n    // Run interactively\n    cmd.stdin(Stdio::inherit())\n        .stdout(Stdio::inherit())\n        .stderr(Stdio::inherit());\n\n    let status = cmd.status().context(\"Failed to execute kubectl exec\")?;\n\n    if !status.success() {\n        anyhow::bail!(\"kubectl exec exited with status: {}\", status);\n    }\n\n    Ok(())\n}\n\n/// Tail logs from a pod\n#[allow(clippy::too_many_arguments)]\npub fn tail_logs(\n    config: \u0026KubectlConfig,\n    pod: \u0026str,\n    container: Option\u003c\u0026str\u003e,\n    follow: bool,\n    previous: bool,\n    tail_lines: Option\u003cusize\u003e,\n) -\u003e Result\u003c()\u003e {\n    let mut cmd = build_kubectl_cmd(config);\n    cmd.arg(\"logs\").arg(pod);\n\n    if let Some(c) = container {\n        cmd.arg(\"-c\").arg(c);\n    }\n\n    if follow {\n        cmd.arg(\"-f\");\n    }\n\n    if previous {\n        cmd.arg(\"--previous\");\n    }\n\n    if let Some(n) = tail_lines {\n        cmd.arg(\"--tail\").arg(n.to_string());\n    }\n\n    // Stream output\n    cmd.stdin(Stdio::inherit())\n        .stdout(Stdio::inherit())\n        .stderr(Stdio::inherit());\n\n    let status = cmd.status().context(\"Failed to execute kubectl logs\")?;\n\n    if !status.success() {\n        anyhow::bail!(\"kubectl logs exited with status: {}\", status);\n    }\n\n    Ok(())\n}\n\n/// Get list of containers in a pod\n#[allow(dead_code)]\npub fn get_containers(config: \u0026KubectlConfig, pod: \u0026str) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n    let mut cmd = build_kubectl_cmd(config);\n    cmd.arg(\"get\")\n        .arg(\"pod\")\n        .arg(pod)\n        .arg(\"-o\")\n        .arg(\"jsonpath={.spec.containers[*].name}\");\n\n    let output = cmd.output().context(\"Failed to execute kubectl\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"kubectl failed: {}\", stderr.trim());\n    }\n\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    Ok(stdout.split_whitespace().map(|s| s.to_string()).collect())\n}\n\n/// Build kubectl command args (for testing)\n#[cfg(test)]\npub fn build_list_args(config: \u0026KubectlConfig, all_namespaces: bool) -\u003e Vec\u003cString\u003e {\n    let mut args = Vec::new();\n\n    if let Some(ctx) = \u0026config.context {\n        args.push(\"--context\".to_string());\n        args.push(ctx.clone());\n    }\n\n    if let Some(ns) = \u0026config.namespace {\n        args.push(\"-n\".to_string());\n        args.push(ns.clone());\n    }\n\n    args.push(\"get\".to_string());\n    args.push(\"pods\".to_string());\n    args.push(\"-o\".to_string());\n    args.push(\"json\".to_string());\n\n    if all_namespaces {\n        args.push(\"--all-namespaces\".to_string());\n    }\n\n    args\n}\n\n/// Build kubectl exec args (for testing)\n#[cfg(test)]\npub fn build_exec_args(\n    config: \u0026KubectlConfig,\n    pod: \u0026str,\n    container: Option\u003c\u0026str\u003e,\n    command: \u0026[String],\n) -\u003e Vec\u003cString\u003e {\n    let mut args = Vec::new();\n\n    if let Some(ctx) = \u0026config.context {\n        args.push(\"--context\".to_string());\n        args.push(ctx.clone());\n    }\n\n    if let Some(ns) = \u0026config.namespace {\n        args.push(\"-n\".to_string());\n        args.push(ns.clone());\n    }\n\n    args.push(\"exec\".to_string());\n    args.push(\"-it\".to_string());\n    args.push(pod.to_string());\n\n    if let Some(c) = container {\n        args.push(\"-c\".to_string());\n        args.push(c.to_string());\n    }\n\n    args.push(\"--\".to_string());\n\n    if command.is_empty() {\n        args.push(\"/bin/sh\".to_string());\n    } else {\n        args.extend(command.iter().cloned());\n    }\n\n    args\n}\n\n/// Build kubectl logs args (for testing)\n#[cfg(test)]\n#[allow(clippy::too_many_arguments)]\npub fn build_logs_args(\n    config: \u0026KubectlConfig,\n    pod: \u0026str,\n    container: Option\u003c\u0026str\u003e,\n    follow: bool,\n    previous: bool,\n    tail_lines: Option\u003cusize\u003e,\n) -\u003e Vec\u003cString\u003e {\n    let mut args = Vec::new();\n\n    if let Some(ctx) = \u0026config.context {\n        args.push(\"--context\".to_string());\n        args.push(ctx.clone());\n    }\n\n    if let Some(ns) = \u0026config.namespace {\n        args.push(\"-n\".to_string());\n        args.push(ns.clone());\n    }\n\n    args.push(\"logs\".to_string());\n    args.push(pod.to_string());\n\n    if let Some(c) = container {\n        args.push(\"-c\".to_string());\n        args.push(c.to_string());\n    }\n\n    if follow {\n        args.push(\"-f\".to_string());\n    }\n\n    if previous {\n        args.push(\"--previous\".to_string());\n    }\n\n    if let Some(n) = tail_lines {\n        args.push(\"--tail\".to_string());\n        args.push(n.to_string());\n    }\n\n    args\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":1}},{"line":13,"address":[],"length":0,"stats":{"Line":2}},{"line":15,"address":[],"length":0,"stats":{"Line":1}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":1}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":1}},{"line":27,"address":[],"length":0,"stats":{"Line":1}},{"line":28,"address":[],"length":0,"stats":{"Line":3}},{"line":29,"address":[],"length":0,"stats":{"Line":2}},{"line":31,"address":[],"length":0,"stats":{"Line":1}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":2}},{"line":39,"address":[],"length":0,"stats":{"Line":1}},{"line":40,"address":[],"length":0,"stats":{"Line":3}},{"line":41,"address":[],"length":0,"stats":{"Line":3}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":9}},{"line":50,"address":[],"length":0,"stats":{"Line":44}},{"line":52,"address":[],"length":0,"stats":{"Line":40}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":5}},{"line":160,"address":[],"length":0,"stats":{"Line":10}},{"line":162,"address":[],"length":0,"stats":{"Line":9}},{"line":163,"address":[],"length":0,"stats":{"Line":10}},{"line":164,"address":[],"length":0,"stats":{"Line":6}},{"line":167,"address":[],"length":0,"stats":{"Line":9}},{"line":168,"address":[],"length":0,"stats":{"Line":10}},{"line":169,"address":[],"length":0,"stats":{"Line":6}},{"line":172,"address":[],"length":0,"stats":{"Line":20}},{"line":173,"address":[],"length":0,"stats":{"Line":20}},{"line":174,"address":[],"length":0,"stats":{"Line":20}},{"line":175,"address":[],"length":0,"stats":{"Line":20}},{"line":177,"address":[],"length":0,"stats":{"Line":7}},{"line":178,"address":[],"length":0,"stats":{"Line":6}},{"line":181,"address":[],"length":0,"stats":{"Line":5}},{"line":186,"address":[],"length":0,"stats":{"Line":8}},{"line":192,"address":[],"length":0,"stats":{"Line":16}},{"line":194,"address":[],"length":0,"stats":{"Line":14}},{"line":195,"address":[],"length":0,"stats":{"Line":15}},{"line":196,"address":[],"length":0,"stats":{"Line":9}},{"line":199,"address":[],"length":0,"stats":{"Line":14}},{"line":200,"address":[],"length":0,"stats":{"Line":15}},{"line":201,"address":[],"length":0,"stats":{"Line":9}},{"line":204,"address":[],"length":0,"stats":{"Line":32}},{"line":205,"address":[],"length":0,"stats":{"Line":32}},{"line":206,"address":[],"length":0,"stats":{"Line":32}},{"line":208,"address":[],"length":0,"stats":{"Line":14}},{"line":209,"address":[],"length":0,"stats":{"Line":15}},{"line":210,"address":[],"length":0,"stats":{"Line":9}},{"line":213,"address":[],"length":0,"stats":{"Line":32}},{"line":215,"address":[],"length":0,"stats":{"Line":21}},{"line":216,"address":[],"length":0,"stats":{"Line":15}},{"line":218,"address":[],"length":0,"stats":{"Line":12}},{"line":221,"address":[],"length":0,"stats":{"Line":8}},{"line":227,"address":[],"length":0,"stats":{"Line":10}},{"line":235,"address":[],"length":0,"stats":{"Line":20}},{"line":237,"address":[],"length":0,"stats":{"Line":14}},{"line":238,"address":[],"length":0,"stats":{"Line":10}},{"line":239,"address":[],"length":0,"stats":{"Line":6}},{"line":242,"address":[],"length":0,"stats":{"Line":14}},{"line":243,"address":[],"length":0,"stats":{"Line":10}},{"line":244,"address":[],"length":0,"stats":{"Line":6}},{"line":247,"address":[],"length":0,"stats":{"Line":40}},{"line":248,"address":[],"length":0,"stats":{"Line":40}},{"line":250,"address":[],"length":0,"stats":{"Line":14}},{"line":251,"address":[],"length":0,"stats":{"Line":10}},{"line":252,"address":[],"length":0,"stats":{"Line":6}},{"line":255,"address":[],"length":0,"stats":{"Line":13}},{"line":256,"address":[],"length":0,"stats":{"Line":9}},{"line":259,"address":[],"length":0,"stats":{"Line":13}},{"line":260,"address":[],"length":0,"stats":{"Line":9}},{"line":263,"address":[],"length":0,"stats":{"Line":18}},{"line":264,"address":[],"length":0,"stats":{"Line":20}},{"line":265,"address":[],"length":0,"stats":{"Line":12}},{"line":268,"address":[],"length":0,"stats":{"Line":10}}],"covered":71,"coverable":121},{"path":["/","Users","chi","Projects","hu","src","eks","kubectl","tests.rs"],"content":"use super::*;\n\n#[test]\nfn build_list_args_basic() {\n    let config = KubectlConfig::default();\n    let args = build_list_args(\u0026config, false);\n    assert_eq!(args, vec![\"get\", \"pods\", \"-o\", \"json\"]);\n}\n\n#[test]\nfn build_list_args_with_context() {\n    let config = KubectlConfig {\n        context: Some(\"prod\".to_string()),\n        namespace: None,\n    };\n    let args = build_list_args(\u0026config, false);\n    assert_eq!(args, vec![\"--context\", \"prod\", \"get\", \"pods\", \"-o\", \"json\"]);\n}\n\n#[test]\nfn build_list_args_with_namespace() {\n    let config = KubectlConfig {\n        context: None,\n        namespace: Some(\"kube-system\".to_string()),\n    };\n    let args = build_list_args(\u0026config, false);\n    assert_eq!(args, vec![\"-n\", \"kube-system\", \"get\", \"pods\", \"-o\", \"json\"]);\n}\n\n#[test]\nfn build_list_args_all_namespaces() {\n    let config = KubectlConfig::default();\n    let args = build_list_args(\u0026config, true);\n    assert_eq!(args, vec![\"get\", \"pods\", \"-o\", \"json\", \"--all-namespaces\"]);\n}\n\n#[test]\nfn build_list_args_full() {\n    let config = KubectlConfig {\n        context: Some(\"prod\".to_string()),\n        namespace: Some(\"default\".to_string()),\n    };\n    let args = build_list_args(\u0026config, true);\n    assert_eq!(\n        args,\n        vec![\n            \"--context\",\n            \"prod\",\n            \"-n\",\n            \"default\",\n            \"get\",\n            \"pods\",\n            \"-o\",\n            \"json\",\n            \"--all-namespaces\"\n        ]\n    );\n}\n\n#[test]\nfn build_exec_args_basic() {\n    let config = KubectlConfig::default();\n    let args = build_exec_args(\u0026config, \"my-pod\", None, \u0026[]);\n    assert_eq!(args, vec![\"exec\", \"-it\", \"my-pod\", \"--\", \"/bin/sh\"]);\n}\n\n#[test]\nfn build_exec_args_with_container() {\n    let config = KubectlConfig::default();\n    let args = build_exec_args(\u0026config, \"my-pod\", Some(\"app\"), \u0026[]);\n    assert_eq!(\n        args,\n        vec![\"exec\", \"-it\", \"my-pod\", \"-c\", \"app\", \"--\", \"/bin/sh\"]\n    );\n}\n\n#[test]\nfn build_exec_args_with_command() {\n    let config = KubectlConfig::default();\n    let cmd = vec![\"bash\".to_string(), \"-c\".to_string(), \"ls -la\".to_string()];\n    let args = build_exec_args(\u0026config, \"my-pod\", None, \u0026cmd);\n    assert_eq!(\n        args,\n        vec![\"exec\", \"-it\", \"my-pod\", \"--\", \"bash\", \"-c\", \"ls -la\"]\n    );\n}\n\n#[test]\nfn build_exec_args_full() {\n    let config = KubectlConfig {\n        context: Some(\"prod\".to_string()),\n        namespace: Some(\"app\".to_string()),\n    };\n    let args = build_exec_args(\u0026config, \"my-pod\", Some(\"main\"), \u0026[]);\n    assert_eq!(\n        args,\n        vec![\n            \"--context\",\n            \"prod\",\n            \"-n\",\n            \"app\",\n            \"exec\",\n            \"-it\",\n            \"my-pod\",\n            \"-c\",\n            \"main\",\n            \"--\",\n            \"/bin/sh\"\n        ]\n    );\n}\n\n#[test]\nfn build_logs_args_basic() {\n    let config = KubectlConfig::default();\n    let args = build_logs_args(\u0026config, \"my-pod\", None, false, false, None);\n    assert_eq!(args, vec![\"logs\", \"my-pod\"]);\n}\n\n#[test]\nfn build_logs_args_follow() {\n    let config = KubectlConfig::default();\n    let args = build_logs_args(\u0026config, \"my-pod\", None, true, false, None);\n    assert_eq!(args, vec![\"logs\", \"my-pod\", \"-f\"]);\n}\n\n#[test]\nfn build_logs_args_previous() {\n    let config = KubectlConfig::default();\n    let args = build_logs_args(\u0026config, \"my-pod\", None, false, true, None);\n    assert_eq!(args, vec![\"logs\", \"my-pod\", \"--previous\"]);\n}\n\n#[test]\nfn build_logs_args_tail() {\n    let config = KubectlConfig::default();\n    let args = build_logs_args(\u0026config, \"my-pod\", None, false, false, Some(100));\n    assert_eq!(args, vec![\"logs\", \"my-pod\", \"--tail\", \"100\"]);\n}\n\n#[test]\nfn build_logs_args_full() {\n    let config = KubectlConfig {\n        context: Some(\"prod\".to_string()),\n        namespace: Some(\"app\".to_string()),\n    };\n    let args = build_logs_args(\u0026config, \"my-pod\", Some(\"main\"), true, true, Some(50));\n    assert_eq!(\n        args,\n        vec![\n            \"--context\",\n            \"prod\",\n            \"-n\",\n            \"app\",\n            \"logs\",\n            \"my-pod\",\n            \"-c\",\n            \"main\",\n            \"-f\",\n            \"--previous\",\n            \"--tail\",\n            \"50\"\n        ]\n    );\n}\n\n#[test]\nfn parse_pod_list_empty() {\n    let json = r#\"{\"items\": []}\"#;\n    let pods = parse_pod_list(json).unwrap();\n    assert!(pods.is_empty());\n}\n\n#[test]\nfn parse_pod_list_single() {\n    let json = r#\"{\n            \"items\": [{\n                \"metadata\": {\"name\": \"test\", \"namespace\": \"default\"},\n                \"status\": {\"phase\": \"Running\", \"containerStatuses\": []}\n            }]\n        }\"#;\n    let pods = parse_pod_list(json).unwrap();\n    assert_eq!(pods.len(), 1);\n    assert_eq!(pods[0].name, \"test\");\n}\n\n#[test]\nfn parse_pod_list_invalid_json() {\n    let result = parse_pod_list(\"not json\");\n    assert!(result.is_err());\n}\n\n#[test]\nfn parse_pod_list_multiple_pods() {\n    let json = r#\"{\n            \"items\": [\n                {\n                    \"metadata\": {\"name\": \"pod1\", \"namespace\": \"default\"},\n                    \"status\": {\"phase\": \"Running\", \"containerStatuses\": []}\n                },\n                {\n                    \"metadata\": {\"name\": \"pod2\", \"namespace\": \"kube-system\"},\n                    \"status\": {\"phase\": \"Pending\", \"containerStatuses\": []}\n                }\n            ]\n        }\"#;\n    let pods = parse_pod_list(json).unwrap();\n    assert_eq!(pods.len(), 2);\n    assert_eq!(pods[0].name, \"pod1\");\n    assert_eq!(pods[1].name, \"pod2\");\n    assert_eq!(pods[1].namespace, \"kube-system\");\n}\n\n#[test]\nfn parse_pod_list_with_full_metadata() {\n    let json = r#\"{\n            \"items\": [{\n                \"metadata\": {\n                    \"name\": \"full-pod\",\n                    \"namespace\": \"production\",\n                    \"creationTimestamp\": \"2026-01-15T10:30:00Z\"\n                },\n                \"spec\": {\n                    \"nodeName\": \"worker-node-1\",\n                    \"containers\": [{\"name\": \"main\"}]\n                },\n                \"status\": {\n                    \"phase\": \"Running\",\n                    \"containerStatuses\": [\n                        {\"name\": \"main\", \"ready\": true, \"restartCount\": 5}\n                    ]\n                }\n            }]\n        }\"#;\n    let pods = parse_pod_list(json).unwrap();\n    assert_eq!(pods.len(), 1);\n    assert_eq!(pods[0].name, \"full-pod\");\n    assert_eq!(pods[0].namespace, \"production\");\n    assert_eq!(pods[0].node, Some(\"worker-node-1\".to_string()));\n    assert_eq!(pods[0].restarts, 5);\n    assert_eq!(pods[0].ready, \"1/1\");\n}\n\n#[test]\nfn build_logs_args_with_container_only() {\n    let config = KubectlConfig::default();\n    let args = build_logs_args(\u0026config, \"my-pod\", Some(\"sidecar\"), false, false, None);\n    assert_eq!(args, vec![\"logs\", \"my-pod\", \"-c\", \"sidecar\"]);\n}\n\n#[test]\nfn build_exec_args_with_context_only() {\n    let config = KubectlConfig {\n        context: Some(\"staging\".to_string()),\n        namespace: None,\n    };\n    let args = build_exec_args(\u0026config, \"test-pod\", None, \u0026[]);\n    assert_eq!(\n        args,\n        vec![\n            \"--context\",\n            \"staging\",\n            \"exec\",\n            \"-it\",\n            \"test-pod\",\n            \"--\",\n            \"/bin/sh\"\n        ]\n    );\n}\n\n#[test]\nfn build_exec_args_with_namespace_only() {\n    let config = KubectlConfig {\n        context: None,\n        namespace: Some(\"monitoring\".to_string()),\n    };\n    let args = build_exec_args(\u0026config, \"test-pod\", None, \u0026[]);\n    assert_eq!(\n        args,\n        vec![\n            \"-n\",\n            \"monitoring\",\n            \"exec\",\n            \"-it\",\n            \"test-pod\",\n            \"--\",\n            \"/bin/sh\"\n        ]\n    );\n}\n\n#[test]\nfn build_logs_args_with_context_only() {\n    let config = KubectlConfig {\n        context: Some(\"dev\".to_string()),\n        namespace: None,\n    };\n    let args = build_logs_args(\u0026config, \"app-pod\", None, false, false, None);\n    assert_eq!(args, vec![\"--context\", \"dev\", \"logs\", \"app-pod\"]);\n}\n\n#[test]\nfn build_logs_args_with_namespace_only() {\n    let config = KubectlConfig {\n        context: None,\n        namespace: Some(\"logging\".to_string()),\n    };\n    let args = build_logs_args(\u0026config, \"app-pod\", None, false, false, None);\n    assert_eq!(args, vec![\"-n\", \"logging\", \"logs\", \"app-pod\"]);\n}\n\n#[test]\nfn build_logs_args_follow_and_tail() {\n    let config = KubectlConfig::default();\n    let args = build_logs_args(\u0026config, \"my-pod\", None, true, false, Some(200));\n    assert_eq!(args, vec![\"logs\", \"my-pod\", \"-f\", \"--tail\", \"200\"]);\n}\n\n#[test]\nfn build_logs_args_previous_and_tail() {\n    let config = KubectlConfig::default();\n    let args = build_logs_args(\u0026config, \"my-pod\", None, false, true, Some(50));\n    assert_eq!(args, vec![\"logs\", \"my-pod\", \"--previous\", \"--tail\", \"50\"]);\n}\n\n#[test]\nfn build_exec_args_with_multi_word_command() {\n    let config = KubectlConfig::default();\n    let cmd = vec![\n        \"python\".to_string(),\n        \"-c\".to_string(),\n        \"print('hello')\".to_string(),\n    ];\n    let args = build_exec_args(\u0026config, \"py-pod\", None, \u0026cmd);\n    assert_eq!(\n        args,\n        vec![\n            \"exec\",\n            \"-it\",\n            \"py-pod\",\n            \"--\",\n            \"python\",\n            \"-c\",\n            \"print('hello')\"\n        ]\n    );\n}\n\n#[test]\nfn build_exec_args_full_with_command() {\n    let config = KubectlConfig {\n        context: Some(\"prod\".to_string()),\n        namespace: Some(\"api\".to_string()),\n    };\n    let cmd = vec![\"cat\".to_string(), \"/etc/hosts\".to_string()];\n    let args = build_exec_args(\u0026config, \"api-pod\", Some(\"nginx\"), \u0026cmd);\n    assert_eq!(\n        args,\n        vec![\n            \"--context\",\n            \"prod\",\n            \"-n\",\n            \"api\",\n            \"exec\",\n            \"-it\",\n            \"api-pod\",\n            \"-c\",\n            \"nginx\",\n            \"--\",\n            \"cat\",\n            \"/etc/hosts\"\n        ]\n    );\n}\n\n#[test]\nfn parse_pod_list_mixed_container_states() {\n    let json = r#\"{\n            \"items\": [{\n                \"metadata\": {\"name\": \"mixed\", \"namespace\": \"default\"},\n                \"status\": {\n                    \"phase\": \"Running\",\n                    \"containerStatuses\": [\n                        {\"name\": \"a\", \"ready\": true, \"restartCount\": 0},\n                        {\"name\": \"b\", \"ready\": false, \"restartCount\": 2},\n                        {\"name\": \"c\", \"ready\": true, \"restartCount\": 1}\n                    ]\n                }\n            }]\n        }\"#;\n    let pods = parse_pod_list(json).unwrap();\n    assert_eq!(pods[0].ready, \"2/3\");\n    assert_eq!(pods[0].restarts, 3);\n}\n\n#[test]\nfn parse_pod_list_failed_status() {\n    let json = r#\"{\n            \"items\": [{\n                \"metadata\": {\"name\": \"failed\", \"namespace\": \"default\"},\n                \"status\": {\"phase\": \"Failed\", \"containerStatuses\": []}\n            }]\n        }\"#;\n    let pods = parse_pod_list(json).unwrap();\n    assert_eq!(pods[0].status, \"Failed\");\n}\n\n#[test]\nfn parse_pod_list_succeeded_status() {\n    let json = r#\"{\n            \"items\": [{\n                \"metadata\": {\"name\": \"job-pod\", \"namespace\": \"batch\"},\n                \"status\": {\"phase\": \"Succeeded\", \"containerStatuses\": []}\n            }]\n        }\"#;\n    let pods = parse_pod_list(json).unwrap();\n    assert_eq!(pods[0].status, \"Succeeded\");\n}\n\n#[test]\nfn parse_pod_list_unknown_status() {\n    let json = r#\"{\n            \"items\": [{\n                \"metadata\": {\"name\": \"mystery\", \"namespace\": \"default\"},\n                \"status\": {\"phase\": \"Unknown\", \"containerStatuses\": []}\n            }]\n        }\"#;\n    let pods = parse_pod_list(json).unwrap();\n    assert_eq!(pods[0].status, \"Unknown\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","eks","mod.rs"],"content":"//! EKS pod management\n//!\n//! List pods, exec into pods, and tail logs.\n\nmod cli;\nmod display;\nmod kubectl;\nmod types;\n\nuse anyhow::Result;\n\npub use cli::EksCommand;\nuse types::{KubectlConfig, OutputFormat};\n\n/// Run an EKS command\npub async fn run(cmd: EksCommand) -\u003e Result\u003c()\u003e {\n    match cmd {\n        EksCommand::List {\n            namespace,\n            all_namespaces,\n            context,\n            json,\n        } =\u003e cmd_list(namespace, all_namespaces, context, json),\n        EksCommand::Exec {\n            pod,\n            namespace,\n            container,\n            context,\n            command,\n        } =\u003e cmd_exec(\u0026pod, namespace, container, context, command),\n        EksCommand::Logs {\n            pod,\n            namespace,\n            container,\n            follow,\n            previous,\n            tail,\n            context,\n        } =\u003e cmd_logs(\u0026pod, namespace, container, follow, previous, tail, context),\n    }\n}\n\n/// List pods\nfn cmd_list(\n    namespace: Option\u003cString\u003e,\n    all_namespaces: bool,\n    context: Option\u003cString\u003e,\n    json: bool,\n) -\u003e Result\u003c()\u003e {\n    let config = KubectlConfig {\n        context,\n        namespace: namespace.clone(),\n    };\n\n    let pods = kubectl::list_pods(\u0026config, all_namespaces)?;\n\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n\n    // Show namespace column if listing all namespaces or no specific namespace\n    let show_namespace = all_namespaces || namespace.is_none();\n    display::output_pods(\u0026pods, format, show_namespace)?;\n\n    Ok(())\n}\n\n/// Exec into a pod\nfn cmd_exec(\n    pod: \u0026str,\n    namespace: Option\u003cString\u003e,\n    container: Option\u003cString\u003e,\n    context: Option\u003cString\u003e,\n    command: Vec\u003cString\u003e,\n) -\u003e Result\u003c()\u003e {\n    let config = KubectlConfig { context, namespace };\n\n    kubectl::exec_pod(\u0026config, pod, container.as_deref(), \u0026command)\n}\n\n/// Tail logs from a pod\n#[allow(clippy::too_many_arguments)]\nfn cmd_logs(\n    pod: \u0026str,\n    namespace: Option\u003cString\u003e,\n    container: Option\u003cString\u003e,\n    follow: bool,\n    previous: bool,\n    tail: Option\u003cusize\u003e,\n    context: Option\u003cString\u003e,\n) -\u003e Result\u003c()\u003e {\n    let config = KubectlConfig { context, namespace };\n\n    kubectl::tail_logs(\u0026config, pod, container.as_deref(), follow, previous, tail)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn kubectl_config_from_options() {\n        let config = KubectlConfig {\n            context: Some(\"prod\".to_string()),\n            namespace: Some(\"default\".to_string()),\n        };\n        assert_eq!(config.context, Some(\"prod\".to_string()));\n        assert_eq!(config.namespace, Some(\"default\".to_string()));\n    }\n\n    #[test]\n    fn kubectl_config_none_options() {\n        let config = KubectlConfig {\n            context: None,\n            namespace: None,\n        };\n        assert!(config.context.is_none());\n        assert!(config.namespace.is_none());\n    }\n\n    #[test]\n    fn output_format_table() {\n        let format = OutputFormat::Table;\n        assert_eq!(format, OutputFormat::Table);\n    }\n\n    #[test]\n    fn output_format_json() {\n        let format = OutputFormat::Json;\n        assert_eq!(format, OutputFormat::Json);\n    }\n\n    #[test]\n    fn output_format_from_bool_false() {\n        let json = false;\n        let format = if json {\n            OutputFormat::Json\n        } else {\n            OutputFormat::Table\n        };\n        assert_eq!(format, OutputFormat::Table);\n    }\n\n    #[test]\n    fn output_format_from_bool_true() {\n        let json = true;\n        let format = if json {\n            OutputFormat::Json\n        } else {\n            OutputFormat::Table\n        };\n        assert_eq!(format, OutputFormat::Json);\n    }\n\n    // Test show_namespace logic - matches cmd_list behavior\n    #[test]\n    fn show_namespace_all_namespaces() {\n        let all_namespaces = true;\n        let namespace: Option\u003cString\u003e = None;\n        let show_namespace = all_namespaces || namespace.is_none();\n        assert!(show_namespace);\n    }\n\n    #[test]\n    fn show_namespace_specific_namespace() {\n        let all_namespaces = false;\n        let namespace = Some(\"kube-system\".to_string());\n        let show_namespace = all_namespaces || namespace.is_none();\n        assert!(!show_namespace);\n    }\n\n    #[test]\n    fn show_namespace_no_namespace() {\n        let all_namespaces = false;\n        let namespace: Option\u003cString\u003e = None;\n        let show_namespace = all_namespaces || namespace.is_none();\n        assert!(show_namespace);\n    }\n\n    #[test]\n    fn show_namespace_both_set() {\n        // When both all_namespaces and specific namespace set,\n        // show_namespace should be true (all_namespaces takes precedence)\n        let all_namespaces = true;\n        let namespace = Some(\"default\".to_string());\n        let show_namespace = all_namespaces || namespace.is_none();\n        assert!(show_namespace);\n    }\n\n    // Test EksCommand variants exist and can be constructed\n    #[test]\n    fn eks_command_list_variant() {\n        let cmd = EksCommand::List {\n            namespace: None,\n            all_namespaces: false,\n            context: None,\n            json: false,\n        };\n        // Just verify it constructs\n        match cmd {\n            EksCommand::List { .. } =\u003e {}\n            _ =\u003e panic!(\"Expected List variant\"),\n        }\n    }\n\n    #[test]\n    fn eks_command_exec_variant() {\n        let cmd = EksCommand::Exec {\n            pod: \"my-pod\".to_string(),\n            namespace: None,\n            container: None,\n            context: None,\n            command: vec![],\n        };\n        match cmd {\n            EksCommand::Exec { pod, .. } =\u003e {\n                assert_eq!(pod, \"my-pod\");\n            }\n            _ =\u003e panic!(\"Expected Exec variant\"),\n        }\n    }\n\n    #[test]\n    fn eks_command_logs_variant() {\n        let cmd = EksCommand::Logs {\n            pod: \"log-pod\".to_string(),\n            namespace: Some(\"prod\".to_string()),\n            container: None,\n            follow: true,\n            previous: false,\n            tail: Some(100),\n            context: None,\n        };\n        match cmd {\n            EksCommand::Logs {\n                pod,\n                namespace,\n                follow,\n                tail,\n                ..\n            } =\u003e {\n                assert_eq!(pod, \"log-pod\");\n                assert_eq!(namespace, Some(\"prod\".to_string()));\n                assert!(follow);\n                assert_eq!(tail, Some(100));\n            }\n            _ =\u003e panic!(\"Expected Logs variant\"),\n        }\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":2}},{"line":17,"address":[],"length":0,"stats":{"Line":1}},{"line":19,"address":[],"length":0,"stats":{"Line":1}},{"line":20,"address":[],"length":0,"stats":{"Line":1}},{"line":21,"address":[],"length":0,"stats":{"Line":1}},{"line":22,"address":[],"length":0,"stats":{"Line":1}},{"line":23,"address":[],"length":0,"stats":{"Line":5}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":1}},{"line":55,"address":[],"length":0,"stats":{"Line":4}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}}],"covered":10,"coverable":36},{"path":["/","Users","chi","Projects","hu","src","eks","types","mod.rs"],"content":"//! EKS data types\n\nuse serde::{Deserialize, Serialize};\n\n#[cfg(test)]\nmod tests;\n\n/// Kubernetes pod\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Pod {\n    /// Pod name\n    pub name: String,\n    /// Namespace\n    pub namespace: String,\n    /// Pod status (Running, Pending, etc.)\n    pub status: String,\n    /// Ready containers (e.g., \"1/1\")\n    pub ready: String,\n    /// Restart count\n    pub restarts: u32,\n    /// Age (e.g., \"2d\", \"5h\")\n    pub age: String,\n    /// Node name\n    #[serde(default)]\n    pub node: Option\u003cString\u003e,\n}\n\n/// Kubectl configuration\n#[derive(Debug, Clone, Default)]\npub struct KubectlConfig {\n    /// Kubeconfig context to use\n    pub context: Option\u003cString\u003e,\n    /// Namespace to use\n    pub namespace: Option\u003cString\u003e,\n}\n\n/// Output format\n#[derive(Debug, Clone, Copy, Default, PartialEq, Eq)]\npub enum OutputFormat {\n    /// Table format\n    #[default]\n    Table,\n    /// JSON format\n    Json,\n}\n\n/// Kubectl JSON output for pods\n#[derive(Debug, Deserialize)]\npub struct PodList {\n    /// List of items\n    pub items: Vec\u003cPodItem\u003e,\n}\n\n/// Single pod item from kubectl JSON\n#[derive(Debug, Deserialize)]\npub struct PodItem {\n    /// Metadata\n    pub metadata: PodMetadata,\n    /// Spec\n    #[serde(default)]\n    pub spec: Option\u003cPodSpec\u003e,\n    /// Status\n    pub status: PodStatus,\n}\n\n/// Pod metadata\n#[derive(Debug, Deserialize)]\npub struct PodMetadata {\n    /// Pod name\n    pub name: String,\n    /// Namespace\n    pub namespace: String,\n    /// Creation timestamp\n    #[serde(rename = \"creationTimestamp\")]\n    pub creation_timestamp: Option\u003cString\u003e,\n}\n\n/// Pod spec\n#[derive(Debug, Deserialize, Default)]\npub struct PodSpec {\n    /// Node name\n    #[serde(rename = \"nodeName\")]\n    pub node_name: Option\u003cString\u003e,\n    /// Containers\n    #[serde(default)]\n    #[allow(dead_code)]\n    pub containers: Vec\u003cContainer\u003e,\n}\n\n/// Container spec\n#[derive(Debug, Deserialize)]\n#[allow(dead_code)]\npub struct Container {\n    /// Container name\n    pub name: String,\n}\n\n/// Pod status\n#[derive(Debug, Deserialize)]\npub struct PodStatus {\n    /// Phase (Running, Pending, Succeeded, Failed, Unknown)\n    pub phase: String,\n    /// Container statuses\n    #[serde(rename = \"containerStatuses\", default)]\n    pub container_statuses: Vec\u003cContainerStatus\u003e,\n}\n\n/// Container status\n#[derive(Debug, Deserialize)]\npub struct ContainerStatus {\n    /// Container name\n    #[allow(dead_code)]\n    pub name: String,\n    /// Ready state\n    pub ready: bool,\n    /// Restart count\n    #[serde(rename = \"restartCount\")]\n    pub restart_count: u32,\n}\n\nimpl PodItem {\n    /// Convert to simplified Pod struct\n    pub fn to_pod(\u0026self) -\u003e Pod {\n        let ready = self.ready_string();\n        let restarts = self.total_restarts();\n        let age = self.age_string();\n        let node = self.spec.as_ref().and_then(|s| s.node_name.clone());\n\n        Pod {\n            name: self.metadata.name.clone(),\n            namespace: self.metadata.namespace.clone(),\n            status: self.status.phase.clone(),\n            ready,\n            restarts,\n            age,\n            node,\n        }\n    }\n\n    /// Get ready string (e.g., \"1/2\")\n    fn ready_string(\u0026self) -\u003e String {\n        let total = self.status.container_statuses.len();\n        let ready = self\n            .status\n            .container_statuses\n            .iter()\n            .filter(|c| c.ready)\n            .count();\n        format!(\"{}/{}\", ready, total)\n    }\n\n    /// Get total restart count\n    fn total_restarts(\u0026self) -\u003e u32 {\n        self.status\n            .container_statuses\n            .iter()\n            .map(|c| c.restart_count)\n            .sum()\n    }\n\n    /// Get age string from creation timestamp\n    fn age_string(\u0026self) -\u003e String {\n        let Some(ts) = \u0026self.metadata.creation_timestamp else {\n            return \"-\".to_string();\n        };\n\n        let Ok(created) = chrono::DateTime::parse_from_rfc3339(ts) else {\n            return \"-\".to_string();\n        };\n\n        let now = chrono::Utc::now();\n        let duration = now.signed_duration_since(created);\n\n        if duration.num_days() \u003e 0 {\n            format!(\"{}d\", duration.num_days())\n        } else if duration.num_hours() \u003e 0 {\n            format!(\"{}h\", duration.num_hours())\n        } else if duration.num_minutes() \u003e 0 {\n            format!(\"{}m\", duration.num_minutes())\n        } else {\n            format!(\"{}s\", duration.num_seconds())\n        }\n    }\n}\n","traces":[{"line":123,"address":[],"length":0,"stats":{"Line":23}},{"line":124,"address":[],"length":0,"stats":{"Line":69}},{"line":125,"address":[],"length":0,"stats":{"Line":69}},{"line":126,"address":[],"length":0,"stats":{"Line":69}},{"line":127,"address":[],"length":0,"stats":{"Line":100}},{"line":130,"address":[],"length":0,"stats":{"Line":69}},{"line":131,"address":[],"length":0,"stats":{"Line":69}},{"line":132,"address":[],"length":0,"stats":{"Line":69}},{"line":141,"address":[],"length":0,"stats":{"Line":23}},{"line":142,"address":[],"length":0,"stats":{"Line":69}},{"line":143,"address":[],"length":0,"stats":{"Line":46}},{"line":144,"address":[],"length":0,"stats":{"Line":23}},{"line":145,"address":[],"length":0,"stats":{"Line":23}},{"line":147,"address":[],"length":0,"stats":{"Line":23}},{"line":149,"address":[],"length":0,"stats":{"Line":46}},{"line":153,"address":[],"length":0,"stats":{"Line":23}},{"line":154,"address":[],"length":0,"stats":{"Line":23}},{"line":155,"address":[],"length":0,"stats":{"Line":23}},{"line":157,"address":[],"length":0,"stats":{"Line":23}},{"line":162,"address":[],"length":0,"stats":{"Line":23}},{"line":163,"address":[],"length":0,"stats":{"Line":30}},{"line":164,"address":[],"length":0,"stats":{"Line":32}},{"line":167,"address":[],"length":0,"stats":{"Line":13}},{"line":168,"address":[],"length":0,"stats":{"Line":2}},{"line":171,"address":[],"length":0,"stats":{"Line":12}},{"line":172,"address":[],"length":0,"stats":{"Line":24}},{"line":174,"address":[],"length":0,"stats":{"Line":6}},{"line":175,"address":[],"length":0,"stats":{"Line":12}},{"line":176,"address":[],"length":0,"stats":{"Line":3}},{"line":177,"address":[],"length":0,"stats":{"Line":4}},{"line":178,"address":[],"length":0,"stats":{"Line":2}},{"line":179,"address":[],"length":0,"stats":{"Line":4}},{"line":181,"address":[],"length":0,"stats":{"Line":4}}],"covered":33,"coverable":33},{"path":["/","Users","chi","Projects","hu","src","eks","types","tests.rs"],"content":"use super::*;\n\n#[test]\nfn pod_debug() {\n    let pod = Pod {\n        name: \"test-pod\".to_string(),\n        namespace: \"default\".to_string(),\n        status: \"Running\".to_string(),\n        ready: \"1/1\".to_string(),\n        restarts: 0,\n        age: \"1d\".to_string(),\n        node: Some(\"node-1\".to_string()),\n    };\n    let debug = format!(\"{:?}\", pod);\n    assert!(debug.contains(\"test-pod\"));\n}\n\n#[test]\nfn pod_clone() {\n    let pod = Pod {\n        name: \"test-pod\".to_string(),\n        namespace: \"default\".to_string(),\n        status: \"Running\".to_string(),\n        ready: \"1/1\".to_string(),\n        restarts: 0,\n        age: \"1d\".to_string(),\n        node: None,\n    };\n    let cloned = pod.clone();\n    assert_eq!(cloned.name, pod.name);\n}\n\n#[test]\nfn kubectl_config_default() {\n    let config = KubectlConfig::default();\n    assert!(config.context.is_none());\n    assert!(config.namespace.is_none());\n}\n\n#[test]\nfn output_format_default() {\n    let format = OutputFormat::default();\n    assert_eq!(format, OutputFormat::Table);\n}\n\n#[test]\nfn parse_pod_list() {\n    let json = r#\"{\n            \"items\": [\n                {\n                    \"metadata\": {\n                        \"name\": \"my-pod\",\n                        \"namespace\": \"default\",\n                        \"creationTimestamp\": \"2026-01-01T00:00:00Z\"\n                    },\n                    \"status\": {\n                        \"phase\": \"Running\",\n                        \"containerStatuses\": [\n                            {\"name\": \"main\", \"ready\": true, \"restartCount\": 2}\n                        ]\n                    }\n                }\n            ]\n        }\"#;\n\n    let pod_list: PodList = serde_json::from_str(json).unwrap();\n    assert_eq!(pod_list.items.len(), 1);\n\n    let pod = pod_list.items[0].to_pod();\n    assert_eq!(pod.name, \"my-pod\");\n    assert_eq!(pod.namespace, \"default\");\n    assert_eq!(pod.status, \"Running\");\n    assert_eq!(pod.ready, \"1/1\");\n    assert_eq!(pod.restarts, 2);\n}\n\n#[test]\nfn parse_pod_list_multiple_containers() {\n    let json = r#\"{\n            \"items\": [\n                {\n                    \"metadata\": {\n                        \"name\": \"multi-container\",\n                        \"namespace\": \"prod\"\n                    },\n                    \"status\": {\n                        \"phase\": \"Running\",\n                        \"containerStatuses\": [\n                            {\"name\": \"app\", \"ready\": true, \"restartCount\": 1},\n                            {\"name\": \"sidecar\", \"ready\": false, \"restartCount\": 3}\n                        ]\n                    }\n                }\n            ]\n        }\"#;\n\n    let pod_list: PodList = serde_json::from_str(json).unwrap();\n    let pod = pod_list.items[0].to_pod();\n    assert_eq!(pod.ready, \"1/2\");\n    assert_eq!(pod.restarts, 4);\n}\n\n#[test]\nfn parse_pod_list_with_node() {\n    let json = r#\"{\n            \"items\": [\n                {\n                    \"metadata\": {\n                        \"name\": \"my-pod\",\n                        \"namespace\": \"default\"\n                    },\n                    \"spec\": {\n                        \"nodeName\": \"node-abc123\"\n                    },\n                    \"status\": {\n                        \"phase\": \"Running\",\n                        \"containerStatuses\": []\n                    }\n                }\n            ]\n        }\"#;\n\n    let pod_list: PodList = serde_json::from_str(json).unwrap();\n    let pod = pod_list.items[0].to_pod();\n    assert_eq!(pod.node, Some(\"node-abc123\".to_string()));\n}\n\n#[test]\nfn parse_pod_list_no_node() {\n    let json = r#\"{\n            \"items\": [\n                {\n                    \"metadata\": {\n                        \"name\": \"pending-pod\",\n                        \"namespace\": \"default\"\n                    },\n                    \"status\": {\n                        \"phase\": \"Pending\",\n                        \"containerStatuses\": []\n                    }\n                }\n            ]\n        }\"#;\n\n    let pod_list: PodList = serde_json::from_str(json).unwrap();\n    let pod = pod_list.items[0].to_pod();\n    assert!(pod.node.is_none());\n}\n\n#[test]\nfn age_string_no_timestamp() {\n    let item = PodItem {\n        metadata: PodMetadata {\n            name: \"test\".to_string(),\n            namespace: \"default\".to_string(),\n            creation_timestamp: None,\n        },\n        spec: None,\n        status: PodStatus {\n            phase: \"Running\".to_string(),\n            container_statuses: vec![],\n        },\n    };\n    let pod = item.to_pod();\n    assert_eq!(pod.age, \"-\");\n}\n\n#[test]\nfn age_string_invalid_timestamp() {\n    let item = PodItem {\n        metadata: PodMetadata {\n            name: \"test\".to_string(),\n            namespace: \"default\".to_string(),\n            creation_timestamp: Some(\"not-a-date\".to_string()),\n        },\n        spec: None,\n        status: PodStatus {\n            phase: \"Running\".to_string(),\n            container_statuses: vec![],\n        },\n    };\n    let pod = item.to_pod();\n    assert_eq!(pod.age, \"-\");\n}\n\n#[test]\nfn pod_serialize() {\n    let pod = Pod {\n        name: \"test\".to_string(),\n        namespace: \"default\".to_string(),\n        status: \"Running\".to_string(),\n        ready: \"1/1\".to_string(),\n        restarts: 0,\n        age: \"1h\".to_string(),\n        node: None,\n    };\n    let json = serde_json::to_string(\u0026pod).unwrap();\n    assert!(json.contains(\"test\"));\n}\n\n#[test]\nfn pod_deserialize() {\n    let json = r#\"{\n            \"name\": \"test-pod\",\n            \"namespace\": \"default\",\n            \"status\": \"Running\",\n            \"ready\": \"1/1\",\n            \"restarts\": 5,\n            \"age\": \"2d\",\n            \"node\": \"worker-1\"\n        }\"#;\n    let pod: Pod = serde_json::from_str(json).unwrap();\n    assert_eq!(pod.name, \"test-pod\");\n    assert_eq!(pod.restarts, 5);\n    assert_eq!(pod.node, Some(\"worker-1\".to_string()));\n}\n\n#[test]\nfn pod_deserialize_no_node() {\n    let json = r#\"{\n            \"name\": \"test-pod\",\n            \"namespace\": \"default\",\n            \"status\": \"Running\",\n            \"ready\": \"1/1\",\n            \"restarts\": 0,\n            \"age\": \"1h\"\n        }\"#;\n    let pod: Pod = serde_json::from_str(json).unwrap();\n    assert!(pod.node.is_none());\n}\n\n#[test]\nfn output_format_debug() {\n    let format = OutputFormat::Json;\n    let debug = format!(\"{:?}\", format);\n    assert!(debug.contains(\"Json\"));\n}\n\n#[test]\nfn output_format_clone() {\n    let format = OutputFormat::Table;\n    let cloned = format;\n    assert_eq!(cloned, OutputFormat::Table);\n}\n\n#[test]\nfn output_format_eq() {\n    assert_eq!(OutputFormat::Table, OutputFormat::Table);\n    assert_eq!(OutputFormat::Json, OutputFormat::Json);\n    assert_ne!(OutputFormat::Table, OutputFormat::Json);\n}\n\n#[test]\nfn kubectl_config_debug() {\n    let config = KubectlConfig {\n        context: Some(\"test\".to_string()),\n        namespace: Some(\"default\".to_string()),\n    };\n    let debug = format!(\"{:?}\", config);\n    assert!(debug.contains(\"test\"));\n}\n\n#[test]\nfn kubectl_config_clone() {\n    let config = KubectlConfig {\n        context: Some(\"prod\".to_string()),\n        namespace: None,\n    };\n    let cloned = config.clone();\n    assert_eq!(cloned.context, Some(\"prod\".to_string()));\n}\n\n#[test]\nfn pod_list_debug() {\n    let pod_list = PodList { items: vec![] };\n    let debug = format!(\"{:?}\", pod_list);\n    assert!(debug.contains(\"PodList\"));\n}\n\n#[test]\nfn pod_item_debug() {\n    let item = PodItem {\n        metadata: PodMetadata {\n            name: \"debug-test\".to_string(),\n            namespace: \"default\".to_string(),\n            creation_timestamp: None,\n        },\n        spec: None,\n        status: PodStatus {\n            phase: \"Running\".to_string(),\n            container_statuses: vec![],\n        },\n    };\n    let debug = format!(\"{:?}\", item);\n    assert!(debug.contains(\"debug-test\"));\n}\n\n#[test]\nfn pod_metadata_debug() {\n    let meta = PodMetadata {\n        name: \"test\".to_string(),\n        namespace: \"ns\".to_string(),\n        creation_timestamp: Some(\"2026-01-01T00:00:00Z\".to_string()),\n    };\n    let debug = format!(\"{:?}\", meta);\n    assert!(debug.contains(\"test\"));\n}\n\n#[test]\nfn pod_spec_debug() {\n    let spec = PodSpec {\n        node_name: Some(\"node-1\".to_string()),\n        containers: vec![Container {\n            name: \"main\".to_string(),\n        }],\n    };\n    let debug = format!(\"{:?}\", spec);\n    assert!(debug.contains(\"node-1\"));\n}\n\n#[test]\nfn pod_spec_default() {\n    let spec = PodSpec::default();\n    assert!(spec.node_name.is_none());\n    assert!(spec.containers.is_empty());\n}\n\n#[test]\nfn container_debug() {\n    let container = Container {\n        name: \"sidecar\".to_string(),\n    };\n    let debug = format!(\"{:?}\", container);\n    assert!(debug.contains(\"sidecar\"));\n}\n\n#[test]\nfn pod_status_debug() {\n    let status = PodStatus {\n        phase: \"Pending\".to_string(),\n        container_statuses: vec![],\n    };\n    let debug = format!(\"{:?}\", status);\n    assert!(debug.contains(\"Pending\"));\n}\n\n#[test]\nfn container_status_debug() {\n    let status = ContainerStatus {\n        name: \"app\".to_string(),\n        ready: true,\n        restart_count: 3,\n    };\n    let debug = format!(\"{:?}\", status);\n    assert!(debug.contains(\"app\"));\n    assert!(debug.contains(\"true\"));\n}\n\n#[test]\nfn ready_string_all_ready() {\n    let item = PodItem {\n        metadata: PodMetadata {\n            name: \"test\".to_string(),\n            namespace: \"default\".to_string(),\n            creation_timestamp: None,\n        },\n        spec: None,\n        status: PodStatus {\n            phase: \"Running\".to_string(),\n            container_statuses: vec![\n                ContainerStatus {\n                    name: \"a\".to_string(),\n                    ready: true,\n                    restart_count: 0,\n                },\n                ContainerStatus {\n                    name: \"b\".to_string(),\n                    ready: true,\n                    restart_count: 0,\n                },\n            ],\n        },\n    };\n    let pod = item.to_pod();\n    assert_eq!(pod.ready, \"2/2\");\n}\n\n#[test]\nfn ready_string_none_ready() {\n    let item = PodItem {\n        metadata: PodMetadata {\n            name: \"test\".to_string(),\n            namespace: \"default\".to_string(),\n            creation_timestamp: None,\n        },\n        spec: None,\n        status: PodStatus {\n            phase: \"Pending\".to_string(),\n            container_statuses: vec![\n                ContainerStatus {\n                    name: \"a\".to_string(),\n                    ready: false,\n                    restart_count: 0,\n                },\n                ContainerStatus {\n                    name: \"b\".to_string(),\n                    ready: false,\n                    restart_count: 0,\n                },\n            ],\n        },\n    };\n    let pod = item.to_pod();\n    assert_eq!(pod.ready, \"0/2\");\n}\n\n#[test]\nfn total_restarts_sum() {\n    let item = PodItem {\n        metadata: PodMetadata {\n            name: \"test\".to_string(),\n            namespace: \"default\".to_string(),\n            creation_timestamp: None,\n        },\n        spec: None,\n        status: PodStatus {\n            phase: \"Running\".to_string(),\n            container_statuses: vec![\n                ContainerStatus {\n                    name: \"a\".to_string(),\n                    ready: true,\n                    restart_count: 5,\n                },\n                ContainerStatus {\n                    name: \"b\".to_string(),\n                    ready: true,\n                    restart_count: 3,\n                },\n                ContainerStatus {\n                    name: \"c\".to_string(),\n                    ready: true,\n                    restart_count: 2,\n                },\n            ],\n        },\n    };\n    let pod = item.to_pod();\n    assert_eq!(pod.restarts, 10);\n}\n\n#[test]\nfn age_string_hours() {\n    // Use a timestamp from a few hours ago\n    let now = chrono::Utc::now();\n    let hours_ago = now - chrono::Duration::hours(5);\n    let ts = hours_ago.to_rfc3339();\n\n    let item = PodItem {\n        metadata: PodMetadata {\n            name: \"test\".to_string(),\n            namespace: \"default\".to_string(),\n            creation_timestamp: Some(ts),\n        },\n        spec: None,\n        status: PodStatus {\n            phase: \"Running\".to_string(),\n            container_statuses: vec![],\n        },\n    };\n    let pod = item.to_pod();\n    assert!(pod.age.ends_with('h'), \"Expected hours, got: {}\", pod.age);\n}\n\n#[test]\nfn age_string_minutes() {\n    let now = chrono::Utc::now();\n    let mins_ago = now - chrono::Duration::minutes(30);\n    let ts = mins_ago.to_rfc3339();\n\n    let item = PodItem {\n        metadata: PodMetadata {\n            name: \"test\".to_string(),\n            namespace: \"default\".to_string(),\n            creation_timestamp: Some(ts),\n        },\n        spec: None,\n        status: PodStatus {\n            phase: \"Running\".to_string(),\n            container_statuses: vec![],\n        },\n    };\n    let pod = item.to_pod();\n    assert!(pod.age.ends_with('m'), \"Expected minutes, got: {}\", pod.age);\n}\n\n#[test]\nfn age_string_seconds() {\n    let now = chrono::Utc::now();\n    let secs_ago = now - chrono::Duration::seconds(45);\n    let ts = secs_ago.to_rfc3339();\n\n    let item = PodItem {\n        metadata: PodMetadata {\n            name: \"test\".to_string(),\n            namespace: \"default\".to_string(),\n            creation_timestamp: Some(ts),\n        },\n        spec: None,\n        status: PodStatus {\n            phase: \"Running\".to_string(),\n            container_statuses: vec![],\n        },\n    };\n    let pod = item.to_pod();\n    assert!(pod.age.ends_with('s'), \"Expected seconds, got: {}\", pod.age);\n}\n\n#[test]\nfn age_string_days() {\n    let now = chrono::Utc::now();\n    let days_ago = now - chrono::Duration::days(7);\n    let ts = days_ago.to_rfc3339();\n\n    let item = PodItem {\n        metadata: PodMetadata {\n            name: \"test\".to_string(),\n            namespace: \"default\".to_string(),\n            creation_timestamp: Some(ts),\n        },\n        spec: None,\n        status: PodStatus {\n            phase: \"Running\".to_string(),\n            container_statuses: vec![],\n        },\n    };\n    let pod = item.to_pod();\n    assert!(pod.age.ends_with('d'), \"Expected days, got: {}\", pod.age);\n}\n\n#[test]\nfn pod_with_spec_node() {\n    let item = PodItem {\n        metadata: PodMetadata {\n            name: \"test\".to_string(),\n            namespace: \"default\".to_string(),\n            creation_timestamp: None,\n        },\n        spec: Some(PodSpec {\n            node_name: Some(\"worker-abc\".to_string()),\n            containers: vec![],\n        }),\n        status: PodStatus {\n            phase: \"Running\".to_string(),\n            container_statuses: vec![],\n        },\n    };\n    let pod = item.to_pod();\n    assert_eq!(pod.node, Some(\"worker-abc\".to_string()));\n}\n\n#[test]\nfn pod_with_spec_no_node() {\n    let item = PodItem {\n        metadata: PodMetadata {\n            name: \"test\".to_string(),\n            namespace: \"default\".to_string(),\n            creation_timestamp: None,\n        },\n        spec: Some(PodSpec {\n            node_name: None,\n            containers: vec![],\n        }),\n        status: PodStatus {\n            phase: \"Pending\".to_string(),\n            container_statuses: vec![],\n        },\n    };\n    let pod = item.to_pod();\n    assert!(pod.node.is_none());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","gh","auth.rs"],"content":"use anyhow::{Context, Result};\n\nuse crate::util::{load_credentials, save_credentials, GithubCredentials};\n\n#[cfg(test)]\nuse crate::util::{load_credentials_from, save_credentials_to};\n\n#[cfg(test)]\nuse std::path::PathBuf;\n\n/// Save token and fetch username\npub async fn login(token: \u0026str) -\u003e Result\u003cString\u003e {\n    let username = fetch_username_from_github(token).await?;\n    save_login(\u0026username, token)?;\n    Ok(username)\n}\n\n/// Save login credentials (extracted for testability)\npub fn save_login(username: \u0026str, token: \u0026str) -\u003e Result\u003c()\u003e {\n    let mut creds = load_credentials().unwrap_or_default();\n    creds.github = Some(GithubCredentials {\n        token: token.to_string(),\n        username: username.to_string(),\n    });\n    save_credentials(\u0026creds)\n}\n\n/// Save login to a specific path (for testing)\n#[cfg(test)]\nfn save_login_to(username: \u0026str, token: \u0026str, path: \u0026PathBuf) -\u003e Result\u003c()\u003e {\n    let mut creds = load_credentials_from(path).unwrap_or_default();\n    creds.github = Some(GithubCredentials {\n        token: token.to_string(),\n        username: username.to_string(),\n    });\n    save_credentials_to(\u0026creds, path)\n}\n\n/// Load login from a specific path (for testing)\n#[cfg(test)]\nfn load_login_from(path: \u0026PathBuf) -\u003e Option\u003c(String, String)\u003e {\n    load_credentials_from(path)\n        .ok()\n        .and_then(|c| c.github.map(|g| (g.username, g.token)))\n}\n\n/// Fetch username from GitHub API (the actual network call)\nasync fn fetch_username_from_github(token: \u0026str) -\u003e Result\u003cString\u003e {\n    let octocrab = octocrab::OctocrabBuilder::new()\n        .personal_token(token.to_string())\n        .build()\n        .context(\"Failed to create GitHub client\")?;\n\n    let user = octocrab\n        .current()\n        .user()\n        .await\n        .context(\"Failed to get current user - check your token\")?;\n\n    Ok(user.login)\n}\n\n/// Get stored token if available\npub fn get_token() -\u003e Option\u003cString\u003e {\n    load_credentials()\n        .ok()\n        .and_then(|c| c.github.map(|g| g.token))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn get_token_returns_option() {\n        let result = get_token();\n        // Result is either Some(token) or None\n        assert!(result.is_some() || result.is_none());\n    }\n\n    #[test]\n    fn get_token_consistent_results() {\n        // Calling get_token multiple times should return the same result\n        let result1 = get_token();\n        let result2 = get_token();\n        assert_eq!(result1.is_some(), result2.is_some());\n    }\n\n    #[test]\n    fn credentials_struct_usage() {\n        // Verify we can create and use the credential structs\n        let creds = GithubCredentials {\n            token: \"test_token\".to_string(),\n            username: \"testuser\".to_string(),\n        };\n        assert_eq!(creds.token, \"test_token\");\n        assert_eq!(creds.username, \"testuser\");\n    }\n\n    #[test]\n    fn credentials_optional_in_parent() {\n        use crate::util::Credentials;\n        let creds = Credentials::default();\n        assert!(creds.github.is_none());\n    }\n\n    // Tests for path-based login functions\n    #[test]\n    fn save_and_load_login_roundtrip() {\n        let temp_dir = std::env::temp_dir().join(\"hu_test_auth\");\n        let _ = std::fs::remove_dir_all(\u0026temp_dir);\n        let path = temp_dir.join(\"credentials.toml\");\n\n        // Save login\n        save_login_to(\"testuser\", \"test_token\", \u0026path).unwrap();\n\n        // Load login\n        let result = load_login_from(\u0026path);\n        assert!(result.is_some());\n        let (username, token) = result.unwrap();\n        assert_eq!(username, \"testuser\");\n        assert_eq!(token, \"test_token\");\n\n        let _ = std::fs::remove_dir_all(\u0026temp_dir);\n    }\n\n    #[test]\n    fn load_login_from_missing_file() {\n        let path = PathBuf::from(\"/nonexistent/credentials.toml\");\n        let result = load_login_from(\u0026path);\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn load_login_from_empty_credentials() {\n        let temp_dir = std::env::temp_dir().join(\"hu_test_auth_empty\");\n        let _ = std::fs::create_dir_all(\u0026temp_dir);\n        let path = temp_dir.join(\"credentials.toml\");\n\n        // Write empty credentials\n        std::fs::write(\u0026path, \"\").unwrap();\n\n        let result = load_login_from(\u0026path);\n        assert!(result.is_none());\n\n        let _ = std::fs::remove_dir_all(\u0026temp_dir);\n    }\n\n    #[test]\n    fn save_login_overwrites_existing() {\n        let temp_dir = std::env::temp_dir().join(\"hu_test_auth_overwrite\");\n        let _ = std::fs::remove_dir_all(\u0026temp_dir);\n        let path = temp_dir.join(\"credentials.toml\");\n\n        // Save first login\n        save_login_to(\"user1\", \"token1\", \u0026path).unwrap();\n\n        // Save second login\n        save_login_to(\"user2\", \"token2\", \u0026path).unwrap();\n\n        // Load and verify\n        let (username, token) = load_login_from(\u0026path).unwrap();\n        assert_eq!(username, \"user2\");\n        assert_eq!(token, \"token2\");\n\n        let _ = std::fs::remove_dir_all(\u0026temp_dir);\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":3}},{"line":31,"address":[],"length":0,"stats":{"Line":12}},{"line":32,"address":[],"length":0,"stats":{"Line":6}},{"line":33,"address":[],"length":0,"stats":{"Line":9}},{"line":34,"address":[],"length":0,"stats":{"Line":3}},{"line":36,"address":[],"length":0,"stats":{"Line":9}},{"line":41,"address":[],"length":0,"stats":{"Line":4}},{"line":42,"address":[],"length":0,"stats":{"Line":8}},{"line":44,"address":[],"length":0,"stats":{"Line":16}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":5}},{"line":65,"address":[],"length":0,"stats":{"Line":5}},{"line":67,"address":[],"length":0,"stats":{"Line":15}}],"covered":12,"coverable":28},{"path":["/","Users","chi","Projects","hu","src","gh","cli.rs"],"content":"use clap::{Args, Subcommand};\nuse std::path::PathBuf;\n\n#[derive(Debug, Subcommand)]\npub enum GhCommand {\n    /// Authenticate with GitHub using a Personal Access Token\n    Login(LoginArgs),\n    /// List open pull requests authored by you\n    Prs,\n    /// Extract test failures from CI\n    Failures(FailuresArgs),\n    /// Analyze CI failures and output investigation context\n    Fix(FixArgs),\n    /// List workflow runs\n    Runs(RunsArgs),\n    /// Commit and push all changes (quick sync)\n    Sync(SyncArgs),\n}\n\n#[derive(Debug, Args)]\npub struct SyncArgs {\n    /// Path to git repository (default: current directory)\n    pub path: Option\u003cPathBuf\u003e,\n    /// Skip git commit\n    #[arg(long)]\n    pub no_commit: bool,\n    /// Skip git push\n    #[arg(long)]\n    pub no_push: bool,\n    /// Custom commit message\n    #[arg(long, short)]\n    pub message: Option\u003cString\u003e,\n    /// Output as JSON\n    #[arg(long, short)]\n    pub json: bool,\n}\n\n#[derive(Debug, Args)]\npub struct LoginArgs {\n    /// Personal Access Token (create at https://github.com/settings/tokens)\n    #[arg(long, short)]\n    pub token: String,\n}\n\n#[derive(Debug, Args)]\npub struct FailuresArgs {\n    /// PR number (defaults to current branch's PR)\n    #[arg(long)]\n    pub pr: Option\u003cu64\u003e,\n    /// Repository in owner/repo format (defaults to current directory's repo)\n    #[arg(long, short)]\n    pub repo: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Args)]\npub struct FixArgs {\n    /// PR number\n    #[arg(long)]\n    pub pr: Option\u003cu64\u003e,\n    /// Workflow run ID\n    #[arg(long)]\n    pub run: Option\u003cu64\u003e,\n    /// Branch name\n    #[arg(long, short)]\n    pub branch: Option\u003cString\u003e,\n    /// Repository in owner/repo format\n    #[arg(long, short)]\n    pub repo: Option\u003cString\u003e,\n    /// Output as JSON\n    #[arg(long, short)]\n    pub json: bool,\n}\n\n#[derive(Debug, Args)]\npub struct RunsArgs {\n    /// Ticket key to find runs for (e.g. BFR-1234)\n    pub ticket: Option\u003cString\u003e,\n    /// Filter by status: queued, in_progress, completed, success, failure\n    #[arg(long, short)]\n    pub status: Option\u003cString\u003e,\n    /// Filter by branch name\n    #[arg(long, short)]\n    pub branch: Option\u003cString\u003e,\n    /// Repository in owner/repo format\n    #[arg(long, short)]\n    pub repo: Option\u003cString\u003e,\n    /// Max results (default: 20)\n    #[arg(long, short = 'n', default_value = \"20\")]\n    pub limit: usize,\n    /// Output as JSON\n    #[arg(long, short)]\n    pub json: bool,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","gh","client","mod.rs"],"content":"use anyhow::{Context, Result};\nuse octocrab::Octocrab;\n\nuse super::auth::get_token;\nuse super::types::{CiStatus, PullRequest, RunsQuery, WorkflowRun};\n\nmod parsing;\n\n#[cfg(test)]\nuse parsing::clean_ci_line;\npub use parsing::parse_test_failures;\n\n#[cfg(test)]\nmod tests;\n\n/// Trait for GitHub API operations (enables mocking in tests)\npub trait GithubApi: Send + Sync {\n    /// List open PRs authored by the current user\n    fn list_user_prs(\u0026self) -\u003e impl std::future::Future\u003cOutput = Result\u003cVec\u003cPullRequest\u003e\u003e\u003e + Send;\n\n    /// Get CI status for a PR\n    fn get_ci_status(\n        \u0026self,\n        owner: \u0026str,\n        repo: \u0026str,\n        pr_number: u64,\n    ) -\u003e impl std::future::Future\u003cOutput = Result\u003cCiStatus\u003e\u003e + Send;\n\n    /// Get the branch name for a PR\n    fn get_pr_branch(\n        \u0026self,\n        owner: \u0026str,\n        repo: \u0026str,\n        pr_number: u64,\n    ) -\u003e impl std::future::Future\u003cOutput = Result\u003cString\u003e\u003e + Send;\n\n    /// Get the latest failed workflow run for a branch\n    fn get_latest_failed_run_for_branch(\n        \u0026self,\n        owner: \u0026str,\n        repo: \u0026str,\n        branch: \u0026str,\n    ) -\u003e impl std::future::Future\u003cOutput = Result\u003cOption\u003cu64\u003e\u003e\u003e + Send;\n\n    /// Get failed jobs for a workflow run\n    fn get_failed_jobs(\n        \u0026self,\n        owner: \u0026str,\n        repo: \u0026str,\n        run_id: u64,\n    ) -\u003e impl std::future::Future\u003cOutput = Result\u003cVec\u003c(u64, String)\u003e\u003e\u003e + Send;\n\n    /// Download logs for a job\n    fn get_job_logs(\n        \u0026self,\n        owner: \u0026str,\n        repo: \u0026str,\n        job_id: u64,\n    ) -\u003e impl std::future::Future\u003cOutput = Result\u003cString\u003e\u003e + Send;\n\n    /// Find PR number for a branch\n    fn find_pr_for_branch(\n        \u0026self,\n        owner: \u0026str,\n        repo: \u0026str,\n        branch: \u0026str,\n    ) -\u003e impl std::future::Future\u003cOutput = Result\u003cOption\u003cu64\u003e\u003e\u003e + Send;\n\n    /// List workflow runs for a repository\n    fn list_workflow_runs(\n        \u0026self,\n        query: \u0026RunsQuery\u003c'_\u003e,\n    ) -\u003e impl std::future::Future\u003cOutput = Result\u003cVec\u003cWorkflowRun\u003e\u003e\u003e + Send;\n\n    /// Search PRs by title/branch containing a query string\n    fn search_prs_by_title(\n        \u0026self,\n        owner: \u0026str,\n        repo: \u0026str,\n        query: \u0026str,\n    ) -\u003e impl std::future::Future\u003cOutput = Result\u003cVec\u003cPullRequest\u003e\u003e\u003e + Send;\n}\n\n/// Parse CI status from GitHub API responses (pure function, testable)\npub fn parse_ci_status(state: \u0026str, check_runs: Option\u003c\u0026Vec\u003cserde_json::Value\u003e\u003e) -\u003e CiStatus {\n    if let Some(runs) = check_runs {\n        if runs.is_empty() \u0026\u0026 state == \"pending\" {\n            return CiStatus::Pending;\n        }\n\n        let any_failed = runs\n            .iter()\n            .any(|r| r[\"conclusion\"].as_str() == Some(\"failure\"));\n        let any_pending = runs.iter().any(|r| {\n            r[\"status\"].as_str() != Some(\"completed\") || r[\"conclusion\"].as_str().is_none()\n        });\n        let all_success = runs\n            .iter()\n            .all(|r| r[\"conclusion\"].as_str() == Some(\"success\"));\n\n        if any_failed {\n            CiStatus::Failed\n        } else if any_pending {\n            CiStatus::Pending\n        } else if all_success \u0026\u0026 !runs.is_empty() {\n            CiStatus::Success\n        } else {\n            parse_state_string(state)\n        }\n    } else {\n        parse_state_string(state)\n    }\n}\n\n/// Parse state string to CiStatus\nfn parse_state_string(state: \u0026str) -\u003e CiStatus {\n    match state {\n        \"success\" =\u003e CiStatus::Success,\n        \"pending\" =\u003e CiStatus::Pending,\n        \"failure\" | \"error\" =\u003e CiStatus::Failed,\n        _ =\u003e CiStatus::Unknown,\n    }\n}\n\n/// Extract failed jobs from GitHub jobs API response (pure function, testable)\npub fn extract_failed_jobs(jobs: \u0026serde_json::Value) -\u003e Vec\u003c(u64, String)\u003e {\n    jobs[\"jobs\"]\n        .as_array()\n        .unwrap_or(\u0026vec![])\n        .iter()\n        .filter(|j| j[\"conclusion\"].as_str() == Some(\"failure\"))\n        .filter_map(|j| {\n            let id = j[\"id\"].as_u64()?;\n            let name = j[\"name\"].as_str()?.to_string();\n            Some((id, name))\n        })\n        .collect()\n}\n\n/// Extract PR number from pull request list response (pure function, testable)\npub fn extract_pr_number_from_list(prs: \u0026serde_json::Value) -\u003e Option\u003cu64\u003e {\n    prs.as_array()\n        .and_then(|arr| arr.first())\n        .and_then(|pr| pr[\"number\"].as_u64())\n}\n\n/// Extract run ID from workflow runs response (pure function, testable)\npub fn extract_run_id(runs: \u0026serde_json::Value) -\u003e Option\u003cu64\u003e {\n    runs[\"workflow_runs\"]\n        .as_array()\n        .and_then(|arr| arr.first())\n        .and_then(|r| r[\"id\"].as_u64())\n}\n\n/// Extract workflow runs from GitHub API response (pure function, testable)\npub fn extract_workflow_runs(response: \u0026serde_json::Value) -\u003e Vec\u003cWorkflowRun\u003e {\n    response[\"workflow_runs\"]\n        .as_array()\n        .unwrap_or(\u0026vec![])\n        .iter()\n        .filter_map(|r| {\n            Some(WorkflowRun {\n                id: r[\"id\"].as_u64()?,\n                name: r[\"name\"].as_str()?.to_string(),\n                status: r[\"status\"].as_str().unwrap_or(\"unknown\").to_string(),\n                conclusion: r[\"conclusion\"].as_str().map(|s| s.to_string()),\n                branch: r[\"head_branch\"].as_str().unwrap_or(\"\").to_string(),\n                html_url: r[\"html_url\"].as_str().unwrap_or(\"\").to_string(),\n                created_at: r[\"created_at\"].as_str().unwrap_or(\"\").to_string(),\n                updated_at: r[\"updated_at\"].as_str().unwrap_or(\"\").to_string(),\n                run_number: r[\"run_number\"].as_u64().unwrap_or(0),\n            })\n        })\n        .collect()\n}\n\n/// Extract PRs matching a query from GitHub PR list response (pure function, testable)\npub fn extract_matching_prs(response: \u0026serde_json::Value, query: \u0026str) -\u003e Vec\u003cPullRequest\u003e {\n    let query_lower = query.to_lowercase();\n    response\n        .as_array()\n        .unwrap_or(\u0026vec![])\n        .iter()\n        .filter(|pr| {\n            let title = pr[\"title\"].as_str().unwrap_or(\"\").to_lowercase();\n            let branch = pr[\"head\"][\"ref\"].as_str().unwrap_or(\"\").to_lowercase();\n            title.contains(\u0026query_lower) || branch.contains(\u0026query_lower)\n        })\n        .filter_map(|pr| {\n            let repo_full_name = pr[\"base\"][\"repo\"][\"full_name\"]\n                .as_str()\n                .unwrap_or(\"\")\n                .to_string();\n            Some(PullRequest {\n                number: pr[\"number\"].as_u64()?,\n                title: pr[\"title\"].as_str()?.to_string(),\n                html_url: pr[\"html_url\"].as_str().unwrap_or(\"\").to_string(),\n                state: pr[\"state\"].as_str().unwrap_or(\"\").to_string(),\n                repo_full_name,\n                created_at: pr[\"created_at\"].as_str().unwrap_or(\"\").to_string(),\n                updated_at: pr[\"updated_at\"].as_str().unwrap_or(\"\").to_string(),\n                ci_status: None,\n            })\n        })\n        .collect()\n}\n\npub struct GithubClient {\n    client: Octocrab,\n}\n\nimpl GithubClient {\n    /// Create a new authenticated GitHub client\n    pub fn new() -\u003e Result\u003cSelf\u003e {\n        let token = get_token().context(\"Not authenticated. Run `hu gh login` first.\")?;\n\n        let client = Octocrab::builder()\n            .personal_token(token)\n            .build()\n            .context(\"Failed to create GitHub client\")?;\n\n        Ok(Self { client })\n    }\n\n    /// Create client from provided token (for testing)\n    #[allow(dead_code)]\n    pub fn with_token(token: \u0026str) -\u003e Result\u003cSelf\u003e {\n        let client = Octocrab::builder()\n            .personal_token(token.to_string())\n            .build()\n            .context(\"Failed to create GitHub client\")?;\n\n        Ok(Self { client })\n    }\n}\n\nimpl GithubApi for GithubClient {\n    async fn list_user_prs(\u0026self) -\u003e Result\u003cVec\u003cPullRequest\u003e\u003e {\n        // Use the search API to find PRs where author is current user\n        let result = self\n            .client\n            .search()\n            .issues_and_pull_requests(\"is:pr is:open author:@me\")\n            .send()\n            .await\n            .context(\"Failed to search for PRs\")?;\n\n        let prs: Vec\u003cPullRequest\u003e = result\n            .items\n            .into_iter()\n            .filter_map(|issue| {\n                // Extract repo from URL: https://api.github.com/repos/owner/repo/issues/123\n                let repo_full_name = issue\n                    .repository_url\n                    .path_segments()?\n                    .skip(1) // skip \"repos\"\n                    .take(2) // take \"owner\" and \"repo\"\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n                    .join(\"/\");\n\n                let state = match issue.state {\n                    octocrab::models::IssueState::Open =\u003e \"open\",\n                    octocrab::models::IssueState::Closed =\u003e \"closed\",\n                    _ =\u003e \"unknown\",\n                };\n\n                Some(PullRequest {\n                    number: issue.number,\n                    title: issue.title,\n                    html_url: issue.html_url.to_string(),\n                    state: state.to_string(),\n                    repo_full_name,\n                    created_at: issue.created_at.to_rfc3339(),\n                    updated_at: issue.updated_at.to_rfc3339(),\n                    ci_status: None,\n                })\n            })\n            .collect();\n\n        Ok(prs)\n    }\n\n    async fn get_ci_status(\u0026self, owner: \u0026str, repo: \u0026str, pr_number: u64) -\u003e Result\u003cCiStatus\u003e {\n        // Get the PR to find the head SHA\n        let pr = self\n            .client\n            .pulls(owner, repo)\n            .get(pr_number)\n            .await\n            .context(\"Failed to get PR\")?;\n\n        let sha = \u0026pr.head.sha;\n\n        // Get combined status\n        let status: serde_json::Value = self\n            .client\n            .get(\n                format!(\"/repos/{}/{}/commits/{}/status\", owner, repo, sha),\n                None::\u003c\u0026()\u003e,\n            )\n            .await\n            .context(\"Failed to get commit status\")?;\n\n        let state = status[\"state\"].as_str().unwrap_or(\"unknown\");\n\n        // Also check for check runs (GitHub Actions uses this)\n        let checks: serde_json::Value = self\n            .client\n            .get(\n                format!(\"/repos/{}/{}/commits/{}/check-runs\", owner, repo, sha),\n                None::\u003c\u0026()\u003e,\n            )\n            .await\n            .unwrap_or_default();\n\n        let check_runs = checks[\"check_runs\"].as_array();\n\n        Ok(parse_ci_status(state, check_runs))\n    }\n\n    async fn get_pr_branch(\u0026self, owner: \u0026str, repo: \u0026str, pr_number: u64) -\u003e Result\u003cString\u003e {\n        let pr = self\n            .client\n            .pulls(owner, repo)\n            .get(pr_number)\n            .await\n            .context(\"Failed to get PR\")?;\n\n        Ok(pr.head.ref_field)\n    }\n\n    async fn get_latest_failed_run_for_branch(\n        \u0026self,\n        owner: \u0026str,\n        repo: \u0026str,\n        branch: \u0026str,\n    ) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n        let runs: serde_json::Value = self\n            .client\n            .get(\n                format!(\n                    \"/repos/{}/{}/actions/runs?branch={}\u0026status=failure\u0026per_page=1\",\n                    owner, repo, branch\n                ),\n                None::\u003c\u0026()\u003e,\n            )\n            .await\n            .context(\"Failed to get workflow runs\")?;\n\n        Ok(extract_run_id(\u0026runs))\n    }\n\n    async fn get_failed_jobs(\n        \u0026self,\n        owner: \u0026str,\n        repo: \u0026str,\n        run_id: u64,\n    ) -\u003e Result\u003cVec\u003c(u64, String)\u003e\u003e {\n        let jobs: serde_json::Value = self\n            .client\n            .get(\n                format!(\"/repos/{}/{}/actions/runs/{}/jobs\", owner, repo, run_id),\n                None::\u003c\u0026()\u003e,\n            )\n            .await\n            .context(\"Failed to get jobs\")?;\n\n        Ok(extract_failed_jobs(\u0026jobs))\n    }\n\n    async fn get_job_logs(\u0026self, owner: \u0026str, repo: \u0026str, job_id: u64) -\u003e Result\u003cString\u003e {\n        // The logs endpoint returns a redirect to a download URL\n        // We need to use reqwest directly for this\n        let token = get_token().context(\"Not authenticated\")?;\n\n        let client = reqwest::Client::new();\n        let url = format!(\n            \"https://api.github.com/repos/{}/{}/actions/jobs/{}/logs\",\n            owner, repo, job_id\n        );\n\n        let response = client\n            .get(\u0026url)\n            .header(\"Authorization\", format!(\"Bearer {}\", token))\n            .header(\"User-Agent\", \"hu-cli\")\n            .header(\"Accept\", \"application/vnd.github+json\")\n            .send()\n            .await\n            .context(\"Failed to request job logs\")?;\n\n        let logs = response.text().await.context(\"Failed to read job logs\")?;\n\n        Ok(logs)\n    }\n\n    async fn find_pr_for_branch(\n        \u0026self,\n        owner: \u0026str,\n        repo: \u0026str,\n        branch: \u0026str,\n    ) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n        let prs: serde_json::Value = self\n            .client\n            .get(\n                format!(\n                    \"/repos/{}/{}/pulls?head={}:{}\u0026state=open\u0026per_page=1\",\n                    owner, repo, owner, branch\n                ),\n                None::\u003c\u0026()\u003e,\n            )\n            .await\n            .context(\"Failed to search for PR by branch\")?;\n\n        Ok(extract_pr_number_from_list(\u0026prs))\n    }\n\n    async fn list_workflow_runs(\u0026self, query: \u0026RunsQuery\u003c'_\u003e) -\u003e Result\u003cVec\u003cWorkflowRun\u003e\u003e {\n        let mut url = format!(\n            \"/repos/{}/{}/actions/runs?per_page={}\",\n            query.owner, query.repo, query.limit\n        );\n        if let Some(b) = query.branch {\n            url.push_str(\u0026format!(\"\u0026branch={}\", b));\n        }\n        if let Some(s) = query.status {\n            url.push_str(\u0026format!(\"\u0026status={}\", s));\n        }\n\n        let response: serde_json::Value = self\n            .client\n            .get(url, None::\u003c\u0026()\u003e)\n            .await\n            .context(\"Failed to list workflow runs\")?;\n\n        Ok(extract_workflow_runs(\u0026response))\n    }\n\n    async fn search_prs_by_title(\n        \u0026self,\n        owner: \u0026str,\n        repo: \u0026str,\n        query: \u0026str,\n    ) -\u003e Result\u003cVec\u003cPullRequest\u003e\u003e {\n        let response: serde_json::Value = self\n            .client\n            .get(\n                format!(\"/repos/{}/{}/pulls?state=all\u0026per_page=100\", owner, repo),\n                None::\u003c\u0026()\u003e,\n            )\n            .await\n            .context(\"Failed to list PRs for search\")?;\n\n        Ok(extract_matching_prs(\u0026response, query))\n    }\n}\n","traces":[{"line":85,"address":[],"length":0,"stats":{"Line":9}},{"line":86,"address":[],"length":0,"stats":{"Line":13}},{"line":87,"address":[],"length":0,"stats":{"Line":9}},{"line":88,"address":[],"length":0,"stats":{"Line":1}},{"line":91,"address":[],"length":0,"stats":{"Line":6}},{"line":93,"address":[],"length":0,"stats":{"Line":13}},{"line":94,"address":[],"length":0,"stats":{"Line":14}},{"line":95,"address":[],"length":0,"stats":{"Line":13}},{"line":97,"address":[],"length":0,"stats":{"Line":6}},{"line":99,"address":[],"length":0,"stats":{"Line":13}},{"line":101,"address":[],"length":0,"stats":{"Line":3}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":103,"address":[],"length":0,"stats":{"Line":2}},{"line":104,"address":[],"length":0,"stats":{"Line":1}},{"line":105,"address":[],"length":0,"stats":{"Line":2}},{"line":106,"address":[],"length":0,"stats":{"Line":1}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":10}},{"line":116,"address":[],"length":0,"stats":{"Line":10}},{"line":117,"address":[],"length":0,"stats":{"Line":10}},{"line":118,"address":[],"length":0,"stats":{"Line":12}},{"line":119,"address":[],"length":0,"stats":{"Line":10}},{"line":120,"address":[],"length":0,"stats":{"Line":14}},{"line":121,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":4}},{"line":127,"address":[],"length":0,"stats":{"Line":8}},{"line":129,"address":[],"length":0,"stats":{"Line":4}},{"line":131,"address":[],"length":0,"stats":{"Line":12}},{"line":132,"address":[],"length":0,"stats":{"Line":6}},{"line":133,"address":[],"length":0,"stats":{"Line":6}},{"line":134,"address":[],"length":0,"stats":{"Line":8}},{"line":135,"address":[],"length":0,"stats":{"Line":2}},{"line":141,"address":[],"length":0,"stats":{"Line":6}},{"line":142,"address":[],"length":0,"stats":{"Line":12}},{"line":143,"address":[],"length":0,"stats":{"Line":14}},{"line":144,"address":[],"length":0,"stats":{"Line":12}},{"line":148,"address":[],"length":0,"stats":{"Line":3}},{"line":149,"address":[],"length":0,"stats":{"Line":3}},{"line":151,"address":[],"length":0,"stats":{"Line":7}},{"line":152,"address":[],"length":0,"stats":{"Line":5}},{"line":156,"address":[],"length":0,"stats":{"Line":5}},{"line":157,"address":[],"length":0,"stats":{"Line":10}},{"line":159,"address":[],"length":0,"stats":{"Line":5}},{"line":161,"address":[],"length":0,"stats":{"Line":9}},{"line":163,"address":[],"length":0,"stats":{"Line":9}},{"line":164,"address":[],"length":0,"stats":{"Line":9}},{"line":165,"address":[],"length":0,"stats":{"Line":12}},{"line":166,"address":[],"length":0,"stats":{"Line":13}},{"line":167,"address":[],"length":0,"stats":{"Line":12}},{"line":168,"address":[],"length":0,"stats":{"Line":12}},{"line":169,"address":[],"length":0,"stats":{"Line":12}},{"line":170,"address":[],"length":0,"stats":{"Line":12}},{"line":171,"address":[],"length":0,"stats":{"Line":9}},{"line":178,"address":[],"length":0,"stats":{"Line":6}},{"line":179,"address":[],"length":0,"stats":{"Line":18}},{"line":180,"address":[],"length":0,"stats":{"Line":12}},{"line":182,"address":[],"length":0,"stats":{"Line":6}},{"line":184,"address":[],"length":0,"stats":{"Line":11}},{"line":185,"address":[],"length":0,"stats":{"Line":25}},{"line":186,"address":[],"length":0,"stats":{"Line":25}},{"line":187,"address":[],"length":0,"stats":{"Line":16}},{"line":189,"address":[],"length":0,"stats":{"Line":9}},{"line":190,"address":[],"length":0,"stats":{"Line":9}},{"line":191,"address":[],"length":0,"stats":{"Line":6}},{"line":192,"address":[],"length":0,"stats":{"Line":3}},{"line":193,"address":[],"length":0,"stats":{"Line":3}},{"line":195,"address":[],"length":0,"stats":{"Line":6}},{"line":196,"address":[],"length":0,"stats":{"Line":9}},{"line":197,"address":[],"length":0,"stats":{"Line":12}},{"line":198,"address":[],"length":0,"stats":{"Line":12}},{"line":199,"address":[],"length":0,"stats":{"Line":3}},{"line":200,"address":[],"length":0,"stats":{"Line":12}},{"line":201,"address":[],"length":0,"stats":{"Line":12}},{"line":202,"address":[],"length":0,"stats":{"Line":3}},{"line":214,"address":[],"length":0,"stats":{"Line":1}},{"line":215,"address":[],"length":0,"stats":{"Line":3}},{"line":217,"address":[],"length":0,"stats":{"Line":2}},{"line":218,"address":[],"length":0,"stats":{"Line":2}},{"line":222,"address":[],"length":0,"stats":{"Line":1}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":2}},{"line":240,"address":[],"length":0,"stats":{"Line":3}},{"line":241,"address":[],"length":0,"stats":{"Line":2}},{"line":245,"address":[],"length":0,"stats":{"Line":1}},{"line":248,"address":[],"length":0,"stats":{"Line":3}},{"line":249,"address":[],"length":0,"stats":{"Line":1}},{"line":251,"address":[],"length":0,"stats":{"Line":1}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":1}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}}],"covered":86,"coverable":191},{"path":["/","Users","chi","Projects","hu","src","gh","client","parsing.rs"],"content":"use super::super::types::TestFailure;\n\n/// Extract test failures from logs (RSpec format)\npub fn parse_test_failures(logs: \u0026str) -\u003e Vec\u003cTestFailure\u003e {\n    let mut failures = Vec::new();\n\n    // Collect failure error messages in order\n    let mut error_messages: Vec\u003cString\u003e = Vec::new();\n\n    // Find the Failures section and parse each failure block\n    if let Some(failures_start) = logs.find(\"Failures:\") {\n        let failures_end = logs.find(\"Failed examples:\").unwrap_or(logs.len());\n        let failures_section = \u0026logs[failures_start..failures_end];\n\n        // Split by numbered failure pattern \"N) description\"\n        let block_starts: Vec\u003cusize\u003e = regex::Regex::new(r\"\\d+\\)\\s+\\S\")\n            .ok()\n            .map(|re| re.find_iter(failures_section).map(|m| m.start()).collect())\n            .unwrap_or_default();\n\n        let mut positions = block_starts.clone();\n        positions.push(failures_section.len());\n\n        for i in 0..block_starts.len() {\n            let block = \u0026failures_section[positions[i]..positions[i + 1]];\n\n            // Extract error: code line after Failure/Error: and the error message on next line\n            if let Some(fe_idx) = block.find(\"Failure/Error:\") {\n                let after_fe = \u0026block[fe_idx..];\n                let lines: Vec\u003cString\u003e = after_fe\n                    .lines()\n                    .map(clean_ci_line)\n                    .filter(|l| !l.is_empty())\n                    .take(4)\n                    .collect();\n\n                // lines[0] = \"Failure/Error: \u003ccode\u003e\"\n                // lines[1] = \"\u003cerror message\u003e\" or \"# \u003cstack trace\u003e\"\n                let code_line = lines\n                    .first()\n                    .map(|l| l.strip_prefix(\"Failure/Error:\").unwrap_or(l).trim())\n                    .unwrap_or(\"\");\n                let error_msg = lines.get(1).map(|s| s.as_str()).unwrap_or(\"\");\n\n                let error_text = if error_msg.is_empty() || error_msg.starts_with(\"# \") {\n                    code_line.to_string()\n                } else {\n                    format!(\"{}\\n{}\", code_line, error_msg)\n                };\n\n                error_messages.push(error_text);\n            }\n        }\n    }\n\n    // Extract failed examples from the \"Failed examples:\" section\n    // Format: rspec ./spec/helpers/prices_api_helper_spec.rb:289 # description\n    let failed_examples_re = regex::Regex::new(r\"rspec\\s+(\\./spec/[^\\s]+:\\d+)\").ok();\n\n    if let Some(re) = \u0026failed_examples_re {\n        for (i, cap) in re.captures_iter(logs).enumerate() {\n            let spec_file = cap.get(1).map(|m| m.as_str()).unwrap_or(\"\");\n\n            // Get error message by index (failures appear in same order)\n            let failure_text = error_messages\n                .get(i)\n                .cloned()\n                .unwrap_or_else(|| \"Test failed\".to_string());\n\n            // Avoid duplicates\n            if !failures\n                .iter()\n                .any(|f: \u0026TestFailure| f.spec_file == spec_file)\n            {\n                failures.push(TestFailure {\n                    spec_file: spec_file.to_string(),\n                    failure_text,\n                });\n            }\n        }\n    }\n\n    failures\n}\n\n/// Clean up CI log line by removing timestamp prefix\npub(super) fn clean_ci_line(line: \u0026str) -\u003e String {\n    // Remove timestamp prefix like \"2026-01-27T18:51:46.1029380Z\"\n    let re = regex::Regex::new(r\"^\\d{4}-\\d{2}-\\d{2}T[\\d:.]+Z\\s*\").ok();\n    if let Some(re) = re {\n        re.replace(line, \"\").trim().to_string()\n    } else {\n        line.trim().to_string()\n    }\n}\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":17}},{"line":5,"address":[],"length":0,"stats":{"Line":34}},{"line":8,"address":[],"length":0,"stats":{"Line":51}},{"line":11,"address":[],"length":0,"stats":{"Line":30}},{"line":12,"address":[],"length":0,"stats":{"Line":78}},{"line":13,"address":[],"length":0,"stats":{"Line":39}},{"line":16,"address":[],"length":0,"stats":{"Line":52}},{"line":18,"address":[],"length":0,"stats":{"Line":114}},{"line":21,"address":[],"length":0,"stats":{"Line":39}},{"line":22,"address":[],"length":0,"stats":{"Line":52}},{"line":24,"address":[],"length":0,"stats":{"Line":44}},{"line":25,"address":[],"length":0,"stats":{"Line":72}},{"line":28,"address":[],"length":0,"stats":{"Line":32}},{"line":29,"address":[],"length":0,"stats":{"Line":28}},{"line":30,"address":[],"length":0,"stats":{"Line":42}},{"line":32,"address":[],"length":0,"stats":{"Line":14}},{"line":33,"address":[],"length":0,"stats":{"Line":94}},{"line":39,"address":[],"length":0,"stats":{"Line":28}},{"line":41,"address":[],"length":0,"stats":{"Line":56}},{"line":43,"address":[],"length":0,"stats":{"Line":90}},{"line":45,"address":[],"length":0,"stats":{"Line":62}},{"line":46,"address":[],"length":0,"stats":{"Line":12}},{"line":48,"address":[],"length":0,"stats":{"Line":16}},{"line":51,"address":[],"length":0,"stats":{"Line":42}},{"line":58,"address":[],"length":0,"stats":{"Line":68}},{"line":60,"address":[],"length":0,"stats":{"Line":34}},{"line":61,"address":[],"length":0,"stats":{"Line":96}},{"line":62,"address":[],"length":0,"stats":{"Line":112}},{"line":65,"address":[],"length":0,"stats":{"Line":42}},{"line":66,"address":[],"length":0,"stats":{"Line":14}},{"line":68,"address":[],"length":0,"stats":{"Line":16}},{"line":71,"address":[],"length":0,"stats":{"Line":14}},{"line":72,"address":[],"length":0,"stats":{"Line":14}},{"line":73,"address":[],"length":0,"stats":{"Line":18}},{"line":75,"address":[],"length":0,"stats":{"Line":39}},{"line":76,"address":[],"length":0,"stats":{"Line":26}},{"line":77,"address":[],"length":0,"stats":{"Line":13}},{"line":83,"address":[],"length":0,"stats":{"Line":17}},{"line":87,"address":[],"length":0,"stats":{"Line":47}},{"line":89,"address":[],"length":0,"stats":{"Line":188}},{"line":90,"address":[],"length":0,"stats":{"Line":94}},{"line":91,"address":[],"length":0,"stats":{"Line":141}},{"line":93,"address":[],"length":0,"stats":{"Line":0}}],"covered":42,"coverable":43},{"path":["/","Users","chi","Projects","hu","src","gh","client","tests.rs"],"content":"use super::*;\nuse serde_json::json;\n\n#[test]\nfn get_token_returns_option() {\n    // Just verify get_token doesn't panic\n    let token = get_token();\n    assert!(token.is_some() || token.is_none());\n}\n\n// parse_ci_status tests\n#[test]\nfn parse_ci_status_success_from_runs() {\n    let runs = vec![json!({\"status\": \"completed\", \"conclusion\": \"success\"})];\n    assert_eq!(parse_ci_status(\"pending\", Some(\u0026runs)), CiStatus::Success);\n}\n\n#[test]\nfn parse_ci_status_failed_from_runs() {\n    let runs = vec![\n        json!({\"status\": \"completed\", \"conclusion\": \"success\"}),\n        json!({\"status\": \"completed\", \"conclusion\": \"failure\"}),\n    ];\n    assert_eq!(parse_ci_status(\"pending\", Some(\u0026runs)), CiStatus::Failed);\n}\n\n#[test]\nfn parse_ci_status_pending_from_runs() {\n    let runs = vec![\n        json!({\"status\": \"completed\", \"conclusion\": \"success\"}),\n        json!({\"status\": \"in_progress\", \"conclusion\": null}),\n    ];\n    assert_eq!(parse_ci_status(\"pending\", Some(\u0026runs)), CiStatus::Pending);\n}\n\n#[test]\nfn parse_ci_status_empty_runs_pending() {\n    let runs: Vec\u003cserde_json::Value\u003e = vec![];\n    assert_eq!(parse_ci_status(\"pending\", Some(\u0026runs)), CiStatus::Pending);\n}\n\n#[test]\nfn parse_ci_status_no_runs_uses_state() {\n    assert_eq!(parse_ci_status(\"success\", None), CiStatus::Success);\n    assert_eq!(parse_ci_status(\"failure\", None), CiStatus::Failed);\n    assert_eq!(parse_ci_status(\"error\", None), CiStatus::Failed);\n    assert_eq!(parse_ci_status(\"pending\", None), CiStatus::Pending);\n    assert_eq!(parse_ci_status(\"unknown\", None), CiStatus::Unknown);\n}\n\n#[test]\nfn parse_state_string_all_cases() {\n    assert_eq!(parse_state_string(\"success\"), CiStatus::Success);\n    assert_eq!(parse_state_string(\"pending\"), CiStatus::Pending);\n    assert_eq!(parse_state_string(\"failure\"), CiStatus::Failed);\n    assert_eq!(parse_state_string(\"error\"), CiStatus::Failed);\n    assert_eq!(parse_state_string(\"other\"), CiStatus::Unknown);\n}\n\n// extract_failed_jobs tests\n#[test]\nfn extract_failed_jobs_filters_failures() {\n    let jobs = json!({\n        \"jobs\": [\n            {\"id\": 1, \"name\": \"build\", \"conclusion\": \"success\"},\n            {\"id\": 2, \"name\": \"test\", \"conclusion\": \"failure\"},\n            {\"id\": 3, \"name\": \"lint\", \"conclusion\": \"failure\"},\n        ]\n    });\n    let failed = extract_failed_jobs(\u0026jobs);\n    assert_eq!(failed.len(), 2);\n    assert_eq!(failed[0], (2, \"test\".to_string()));\n    assert_eq!(failed[1], (3, \"lint\".to_string()));\n}\n\n#[test]\nfn extract_failed_jobs_empty_when_all_success() {\n    let jobs = json!({\n        \"jobs\": [\n            {\"id\": 1, \"name\": \"build\", \"conclusion\": \"success\"},\n        ]\n    });\n    assert!(extract_failed_jobs(\u0026jobs).is_empty());\n}\n\n#[test]\nfn extract_failed_jobs_handles_missing_jobs() {\n    let jobs = json!({});\n    assert!(extract_failed_jobs(\u0026jobs).is_empty());\n}\n\n#[test]\nfn extract_failed_jobs_handles_null_jobs() {\n    let jobs = json!({\"jobs\": null});\n    assert!(extract_failed_jobs(\u0026jobs).is_empty());\n}\n\n// extract_run_id tests\n#[test]\nfn extract_run_id_finds_first() {\n    let runs = json!({\n        \"workflow_runs\": [\n            {\"id\": 123},\n            {\"id\": 456},\n        ]\n    });\n    assert_eq!(extract_run_id(\u0026runs), Some(123));\n}\n\n#[test]\nfn extract_run_id_empty_array() {\n    let runs = json!({\"workflow_runs\": []});\n    assert_eq!(extract_run_id(\u0026runs), None);\n}\n\n#[test]\nfn extract_run_id_missing_key() {\n    let runs = json!({});\n    assert_eq!(extract_run_id(\u0026runs), None);\n}\n\n// extract_pr_number_from_list tests\n#[test]\nfn extract_pr_number_from_list_finds_first() {\n    let prs = json!([{\"number\": 42}, {\"number\": 99}]);\n    assert_eq!(extract_pr_number_from_list(\u0026prs), Some(42));\n}\n\n#[test]\nfn extract_pr_number_from_list_single() {\n    let prs = json!([{\"number\": 7}]);\n    assert_eq!(extract_pr_number_from_list(\u0026prs), Some(7));\n}\n\n#[test]\nfn extract_pr_number_from_list_empty() {\n    let prs = json!([]);\n    assert_eq!(extract_pr_number_from_list(\u0026prs), None);\n}\n\n#[test]\nfn extract_pr_number_from_list_missing_number() {\n    let prs = json!([{\"title\": \"no number\"}]);\n    assert_eq!(extract_pr_number_from_list(\u0026prs), None);\n}\n\n#[test]\nfn extract_pr_number_from_list_not_array() {\n    let prs = json!({\"number\": 42});\n    assert_eq!(extract_pr_number_from_list(\u0026prs), None);\n}\n\n#[test]\nfn extract_pr_number_from_list_null() {\n    let prs = json!(null);\n    assert_eq!(extract_pr_number_from_list(\u0026prs), None);\n}\n\n#[test]\nfn clean_ci_line_removes_timestamp() {\n    let line = \"2026-01-27T18:51:46.1029380Z      Failure/Error: some code\";\n    assert_eq!(clean_ci_line(line), \"Failure/Error: some code\");\n}\n\n#[test]\nfn clean_ci_line_preserves_line_without_timestamp() {\n    let line = \"  some regular line  \";\n    assert_eq!(clean_ci_line(line), \"some regular line\");\n}\n\n#[test]\nfn clean_ci_line_handles_empty() {\n    assert_eq!(clean_ci_line(\"\"), \"\");\n    assert_eq!(clean_ci_line(\"   \"), \"\");\n}\n\n#[test]\nfn parse_test_failures_extracts_rspec_failures() {\n    let logs = r#\"\n2026-01-27T18:51:46.1025638Z Failures:\n2026-01-27T18:51:46.1026049Z\n2026-01-27T18:51:46.1027821Z   1) MyClass does something\n2026-01-27T18:51:46.1029380Z      Failure/Error: expect(result).to eq(expected)\n2026-01-27T18:51:46.1167230Z        expected: 42\n2026-01-27T18:51:46.1168761Z      # ./spec/my_class_spec.rb:10:in `block'\n2026-01-27T18:51:46.1174151Z\n2026-01-27T18:51:46.1253383Z Failed examples:\n2026-01-27T18:51:46.1255271Z rspec ./spec/my_class_spec.rb:8 # MyClass does something\n\"#;\n    let failures = parse_test_failures(logs);\n    assert_eq!(failures.len(), 1);\n    assert_eq!(failures[0].spec_file, \"./spec/my_class_spec.rb:8\");\n    assert!(failures[0]\n        .failure_text\n        .contains(\"expect(result).to eq(expected)\"));\n    assert!(failures[0].failure_text.contains(\"expected: 42\"));\n}\n\n#[test]\nfn parse_test_failures_handles_multiple_failures() {\n    let logs = r#\"\nFailures:\n\n  1) First test fails\n     Failure/Error: assert false\n       error one\n     # ./spec/first_spec.rb:5\n\n  2) Second test fails\n     Failure/Error: raise \"boom\"\n       error two\n     # ./spec/second_spec.rb:10\n\nFailed examples:\n\nrspec ./spec/first_spec.rb:3 # First test fails\nrspec ./spec/second_spec.rb:8 # Second test fails\n\"#;\n    let failures = parse_test_failures(logs);\n    assert_eq!(failures.len(), 2);\n    assert_eq!(failures[0].spec_file, \"./spec/first_spec.rb:3\");\n    assert_eq!(failures[1].spec_file, \"./spec/second_spec.rb:8\");\n    assert!(failures[0].failure_text.contains(\"assert false\"));\n    assert!(failures[1].failure_text.contains(\"raise \\\"boom\\\"\"));\n}\n\n#[test]\nfn parse_test_failures_handles_no_failures() {\n    let logs = \"All tests passed!\\n0 failures\";\n    let failures = parse_test_failures(logs);\n    assert!(failures.is_empty());\n}\n\n#[test]\nfn parse_test_failures_handles_empty_logs() {\n    let failures = parse_test_failures(\"\");\n    assert!(failures.is_empty());\n}\n\n#[test]\nfn parse_test_failures_deduplicates() {\n    let logs = r#\"\nFailures:\n\n  1) Test fails\n     Failure/Error: fail\n     # ./spec/test_spec.rb:5\n\nFailed examples:\n\nrspec ./spec/test_spec.rb:3 # Test fails\nrspec ./spec/test_spec.rb:3 # Test fails duplicate\n\"#;\n    let failures = parse_test_failures(logs);\n    assert_eq!(failures.len(), 1);\n}\n\n#[test]\nfn parse_test_failures_mock_error_format() {\n    // Test the actual format from the CI logs\n    let logs = r#\"\n2026-01-27T18:51:46.1025638Z Failures:\n2026-01-27T18:51:46.1027821Z   1) PricesApiHelper pax value includes pax\n2026-01-27T18:51:46.1029380Z      Failure/Error: found_lowest_prices += service.method\n2026-01-27T18:51:46.1167230Z        #\u003cInstanceDouble(Packages::Items)\u003e received unexpected message :method\n2026-01-27T18:51:46.1168761Z      # ./app/helpers/prices_api_helper.rb:62\n2026-01-27T18:51:46.1253383Z Failed examples:\n2026-01-27T18:51:46.1255271Z rspec ./spec/helpers/prices_api_helper_spec.rb:289 # PricesApiHelper pax value includes pax\n\"#;\n    let failures = parse_test_failures(logs);\n    assert_eq!(failures.len(), 1);\n    assert_eq!(\n        failures[0].spec_file,\n        \"./spec/helpers/prices_api_helper_spec.rb:289\"\n    );\n    assert!(failures[0]\n        .failure_text\n        .contains(\"received unexpected message\"));\n}\n\n#[test]\nfn parse_test_failures_code_only_when_error_is_stacktrace() {\n    let logs = r#\"\nFailures:\n\n  1) Test with stack trace only\n     Failure/Error: some_method_call\n     # ./spec/test_spec.rb:5\n\nFailed examples:\n\nrspec ./spec/test_spec.rb:3 # Test with stack trace only\n\"#;\n    let failures = parse_test_failures(logs);\n    assert_eq!(failures.len(), 1);\n    // Should only have the code line since next line starts with #\n    assert_eq!(failures[0].failure_text, \"some_method_call\");\n}\n\n#[test]\nfn parse_test_failures_handles_failures_section_only() {\n    // Missing \"Failed examples:\" section\n    let logs = r#\"\nFailures:\n\n  1) Test fails\n     Failure/Error: expect(1).to eq(2)\n       expected: 2\n     # ./spec/test_spec.rb:5\n\"#;\n    let failures = parse_test_failures(logs);\n    // No failed examples section means we can't extract spec files\n    assert!(failures.is_empty());\n}\n\n#[test]\nfn parse_test_failures_handles_nested_spec_paths() {\n    let logs = r#\"\nFailures:\n\n  1) Deep path test\n     Failure/Error: fail \"deep\"\n       error msg\n\nFailed examples:\n\nrspec ./spec/features/admin/users/permissions_spec.rb:42 # Deep path test\n\"#;\n    let failures = parse_test_failures(logs);\n    assert_eq!(failures.len(), 1);\n    assert_eq!(\n        failures[0].spec_file,\n        \"./spec/features/admin/users/permissions_spec.rb:42\"\n    );\n}\n\n// extract_workflow_runs tests\n#[test]\nfn extract_workflow_runs_valid_response() {\n    let response = json!({\n        \"workflow_runs\": [\n            {\n                \"id\": 100,\n                \"name\": \"CI\",\n                \"status\": \"completed\",\n                \"conclusion\": \"success\",\n                \"head_branch\": \"main\",\n                \"html_url\": \"https://github.com/o/r/actions/runs/100\",\n                \"created_at\": \"2024-01-15T10:00:00Z\",\n                \"updated_at\": \"2024-01-15T10:05:00Z\",\n                \"run_number\": 42\n            },\n            {\n                \"id\": 101,\n                \"name\": \"Lint\",\n                \"status\": \"in_progress\",\n                \"conclusion\": null,\n                \"head_branch\": \"feature\",\n                \"html_url\": \"https://github.com/o/r/actions/runs/101\",\n                \"created_at\": \"2024-01-15T11:00:00Z\",\n                \"updated_at\": \"2024-01-15T11:01:00Z\",\n                \"run_number\": 43\n            }\n        ]\n    });\n    let runs = extract_workflow_runs(\u0026response);\n    assert_eq!(runs.len(), 2);\n    assert_eq!(runs[0].id, 100);\n    assert_eq!(runs[0].name, \"CI\");\n    assert_eq!(runs[0].conclusion, Some(\"success\".to_string()));\n    assert_eq!(runs[0].branch, \"main\");\n    assert_eq!(runs[1].id, 101);\n    assert!(runs[1].conclusion.is_none());\n}\n\n#[test]\nfn extract_workflow_runs_empty() {\n    let response = json!({\"workflow_runs\": []});\n    assert!(extract_workflow_runs(\u0026response).is_empty());\n}\n\n#[test]\nfn extract_workflow_runs_missing_key() {\n    let response = json!({});\n    assert!(extract_workflow_runs(\u0026response).is_empty());\n}\n\n#[test]\nfn extract_workflow_runs_skips_invalid() {\n    let response = json!({\n        \"workflow_runs\": [\n            {\"name\": \"no id\"},\n            {\n                \"id\": 100,\n                \"name\": \"Valid\",\n                \"status\": \"completed\",\n                \"conclusion\": \"success\",\n                \"head_branch\": \"main\",\n                \"html_url\": \"url\",\n                \"created_at\": \"c\",\n                \"updated_at\": \"u\",\n                \"run_number\": 1\n            }\n        ]\n    });\n    let runs = extract_workflow_runs(\u0026response);\n    assert_eq!(runs.len(), 1);\n    assert_eq!(runs[0].id, 100);\n}\n\n#[test]\nfn extract_workflow_runs_null_runs() {\n    let response = json!({\"workflow_runs\": null});\n    assert!(extract_workflow_runs(\u0026response).is_empty());\n}\n\n// extract_matching_prs tests\n#[test]\nfn extract_matching_prs_by_title() {\n    let response = json!([\n        {\n            \"number\": 1,\n            \"title\": \"BFR-1234 Fix login\",\n            \"html_url\": \"https://github.com/o/r/pull/1\",\n            \"state\": \"open\",\n            \"head\": {\"ref\": \"some-branch\"},\n            \"base\": {\"repo\": {\"full_name\": \"o/r\"}},\n            \"created_at\": \"c\",\n            \"updated_at\": \"u\"\n        },\n        {\n            \"number\": 2,\n            \"title\": \"Unrelated change\",\n            \"html_url\": \"https://github.com/o/r/pull/2\",\n            \"state\": \"open\",\n            \"head\": {\"ref\": \"other\"},\n            \"base\": {\"repo\": {\"full_name\": \"o/r\"}},\n            \"created_at\": \"c\",\n            \"updated_at\": \"u\"\n        }\n    ]);\n    let prs = extract_matching_prs(\u0026response, \"BFR-1234\");\n    assert_eq!(prs.len(), 1);\n    assert_eq!(prs[0].number, 1);\n}\n\n#[test]\nfn extract_matching_prs_by_branch() {\n    let response = json!([\n        {\n            \"number\": 1,\n            \"title\": \"Some PR\",\n            \"html_url\": \"url\",\n            \"state\": \"open\",\n            \"head\": {\"ref\": \"bfr-1234-fix\"},\n            \"base\": {\"repo\": {\"full_name\": \"o/r\"}},\n            \"created_at\": \"c\",\n            \"updated_at\": \"u\"\n        }\n    ]);\n    let prs = extract_matching_prs(\u0026response, \"BFR-1234\");\n    assert_eq!(prs.len(), 1);\n}\n\n#[test]\nfn extract_matching_prs_empty() {\n    let response = json!([]);\n    assert!(extract_matching_prs(\u0026response, \"BFR-1234\").is_empty());\n}\n\n#[test]\nfn extract_matching_prs_no_match() {\n    let response = json!([\n        {\n            \"number\": 1,\n            \"title\": \"Unrelated\",\n            \"html_url\": \"url\",\n            \"state\": \"open\",\n            \"head\": {\"ref\": \"other\"},\n            \"base\": {\"repo\": {\"full_name\": \"o/r\"}},\n            \"created_at\": \"c\",\n            \"updated_at\": \"u\"\n        }\n    ]);\n    assert!(extract_matching_prs(\u0026response, \"BFR-999\").is_empty());\n}\n\n#[test]\nfn extract_matching_prs_not_array() {\n    let response = json!({\"not\": \"array\"});\n    assert!(extract_matching_prs(\u0026response, \"query\").is_empty());\n}\n\n#[test]\nfn extract_matching_prs_case_insensitive() {\n    let response = json!([\n        {\n            \"number\": 1,\n            \"title\": \"bfr-1234 lowercase\",\n            \"html_url\": \"url\",\n            \"state\": \"open\",\n            \"head\": {\"ref\": \"main\"},\n            \"base\": {\"repo\": {\"full_name\": \"o/r\"}},\n            \"created_at\": \"c\",\n            \"updated_at\": \"u\"\n        }\n    ]);\n    let prs = extract_matching_prs(\u0026response, \"BFR-1234\");\n    assert_eq!(prs.len(), 1);\n}\n\n#[test]\nfn clean_ci_line_various_timestamps() {\n    // Different timestamp formats from CI\n    assert_eq!(\n        clean_ci_line(\"2026-01-27T10:00:00.000Z some text\"),\n        \"some text\"\n    );\n    assert_eq!(clean_ci_line(\"2026-01-27T10:00:00.1234567Z text\"), \"text\");\n    assert_eq!(\n        clean_ci_line(\"2020-12-31T23:59:59.9Z end of year\"),\n        \"end of year\"\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","gh","failures","mod.rs"],"content":"use anyhow::Result;\n\nuse super::cli::FailuresArgs;\nuse super::client::{parse_test_failures, GithubApi, GithubClient};\nuse super::helpers::{get_current_repo, is_test_job, parse_owner_repo};\n\n#[cfg(test)]\nmod tests;\n\n/// Handle the `hu gh failures` command\npub async fn run(args: FailuresArgs) -\u003e Result\u003c()\u003e {\n    let client = GithubClient::new()?;\n\n    // Get repo info from args or current directory\n    let (owner, repo) = if let Some(repo_arg) = \u0026args.repo {\n        parse_owner_repo(repo_arg)?\n    } else {\n        get_current_repo()?\n    };\n\n    // Determine which PR to check\n    let pr_number = if let Some(pr) = args.pr {\n        pr\n    } else {\n        get_current_branch_pr(\u0026client, \u0026owner, \u0026repo).await?\n    };\n\n    process_failures(\u0026client, \u0026owner, \u0026repo, pr_number).await\n}\n\n/// Process failures using the given API client (testable)\npub async fn process_failures(\n    client: \u0026impl GithubApi,\n    owner: \u0026str,\n    repo: \u0026str,\n    pr_number: u64,\n) -\u003e Result\u003c()\u003e {\n    eprintln!(\n        \"Fetching failures for PR #{} in {}/{}...\",\n        pr_number, owner, repo\n    );\n\n    // Get the PR's branch name\n    let branch = client.get_pr_branch(owner, repo, pr_number).await?;\n\n    // Get the latest failed workflow run for this branch\n    let run_id = client\n        .get_latest_failed_run_for_branch(owner, repo, \u0026branch)\n        .await?;\n\n    let run_id = match run_id {\n        Some(id) =\u003e id,\n        None =\u003e {\n            println!(\"No failed workflow runs found for PR #{}.\", pr_number);\n            return Ok(());\n        }\n    };\n\n    // Get failed jobs in that run\n    let failed_jobs = client.get_failed_jobs(owner, repo, run_id).await?;\n\n    if failed_jobs.is_empty() {\n        println!(\"No failed jobs found in run {}.\", run_id);\n        return Ok(());\n    }\n\n    // Only process test-related jobs (rspec, jest, etc.)\n    let test_jobs: Vec\u003c_\u003e = failed_jobs\n        .into_iter()\n        .filter(|(_, name)| is_test_job(name))\n        .collect();\n\n    if test_jobs.is_empty() {\n        println!(\"No test-related job failures found.\");\n        return Ok(());\n    }\n\n    let mut all_failures = Vec::new();\n\n    for (job_id, job_name) in test_jobs {\n        eprintln!(\"Fetching logs for job: {}\", job_name);\n\n        match client.get_job_logs(owner, repo, job_id).await {\n            Ok(logs) =\u003e {\n                let failures = parse_test_failures(\u0026logs);\n                all_failures.extend(failures);\n            }\n            Err(e) =\u003e {\n                eprintln!(\"Warning: Failed to fetch logs for {}: {}\", job_name, e);\n            }\n        }\n    }\n\n    if all_failures.is_empty() {\n        println!(\"No test failures found in logs.\");\n        return Ok(());\n    }\n\n    // Output in a format useful for Claude\n    println!(\"\\n# Test Failures\\n\");\n    for failure in \u0026all_failures {\n        println!(\"## {}\\n\", failure.spec_file);\n        println!(\"```\");\n        println!(\"{}\", failure.failure_text);\n        println!(\"```\\n\");\n    }\n\n    // Also output the rspec commands to rerun\n    println!(\"# Rerun Commands\\n\");\n    println!(\"```bash\");\n    for failure in \u0026all_failures {\n        println!(\"bundle exec rspec {}\", failure.spec_file);\n    }\n    println!(\"```\");\n\n    Ok(())\n}\n\n/// Get PR number for current branch using octocrab\nasync fn get_current_branch_pr(client: \u0026impl GithubApi, owner: \u0026str, repo: \u0026str) -\u003e Result\u003cu64\u003e {\n    let branch = super::helpers::get_current_branch()?;\n\n    match client.find_pr_for_branch(owner, repo, \u0026branch).await? {\n        Some(pr) =\u003e Ok(pr),\n        None =\u003e anyhow::bail!(\n            \"No PR found for branch '{}'. Use --pr to specify a PR number.\",\n            branch\n        ),\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":7}},{"line":38,"address":[],"length":0,"stats":{"Line":7}},{"line":39,"address":[],"length":0,"stats":{"Line":7}},{"line":44,"address":[],"length":0,"stats":{"Line":42}},{"line":47,"address":[],"length":0,"stats":{"Line":21}},{"line":48,"address":[],"length":0,"stats":{"Line":28}},{"line":49,"address":[],"length":0,"stats":{"Line":7}},{"line":51,"address":[],"length":0,"stats":{"Line":13}},{"line":52,"address":[],"length":0,"stats":{"Line":12}},{"line":54,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":60,"address":[],"length":0,"stats":{"Line":36}},{"line":62,"address":[],"length":0,"stats":{"Line":12}},{"line":63,"address":[],"length":0,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":1}},{"line":68,"address":[],"length":0,"stats":{"Line":15}},{"line":70,"address":[],"length":0,"stats":{"Line":21}},{"line":73,"address":[],"length":0,"stats":{"Line":10}},{"line":74,"address":[],"length":0,"stats":{"Line":2}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":78,"address":[],"length":0,"stats":{"Line":8}},{"line":80,"address":[],"length":0,"stats":{"Line":19}},{"line":81,"address":[],"length":0,"stats":{"Line":10}},{"line":83,"address":[],"length":0,"stats":{"Line":30}},{"line":84,"address":[],"length":0,"stats":{"Line":8}},{"line":85,"address":[],"length":0,"stats":{"Line":16}},{"line":86,"address":[],"length":0,"stats":{"Line":8}},{"line":88,"address":[],"length":0,"stats":{"Line":2}},{"line":89,"address":[],"length":0,"stats":{"Line":1}},{"line":94,"address":[],"length":0,"stats":{"Line":8}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":96,"address":[],"length":0,"stats":{"Line":2}},{"line":100,"address":[],"length":0,"stats":{"Line":4}},{"line":101,"address":[],"length":0,"stats":{"Line":11}},{"line":102,"address":[],"length":0,"stats":{"Line":9}},{"line":103,"address":[],"length":0,"stats":{"Line":9}},{"line":104,"address":[],"length":0,"stats":{"Line":9}},{"line":105,"address":[],"length":0,"stats":{"Line":3}},{"line":109,"address":[],"length":0,"stats":{"Line":4}},{"line":110,"address":[],"length":0,"stats":{"Line":4}},{"line":111,"address":[],"length":0,"stats":{"Line":11}},{"line":112,"address":[],"length":0,"stats":{"Line":3}},{"line":114,"address":[],"length":0,"stats":{"Line":4}},{"line":116,"address":[],"length":0,"stats":{"Line":2}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}}],"covered":44,"coverable":58},{"path":["/","Users","chi","Projects","hu","src","gh","failures","tests.rs"],"content":"use super::*;\n\n// Mock implementation for testing\nuse crate::gh::types::PullRequest;\n\nstruct MockGithubApi {\n    branch: String,\n    run_id: Option\u003cu64\u003e,\n    failed_jobs: Vec\u003c(u64, String)\u003e,\n    logs: String,\n}\n\nimpl GithubApi for MockGithubApi {\n    async fn list_user_prs(\u0026self) -\u003e Result\u003cVec\u003cPullRequest\u003e\u003e {\n        Ok(vec![])\n    }\n\n    async fn get_ci_status(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _pr: u64,\n    ) -\u003e Result\u003ccrate::gh::types::CiStatus\u003e {\n        Ok(crate::gh::types::CiStatus::Unknown)\n    }\n\n    async fn get_pr_branch(\u0026self, _owner: \u0026str, _repo: \u0026str, _pr: u64) -\u003e Result\u003cString\u003e {\n        Ok(self.branch.clone())\n    }\n\n    async fn get_latest_failed_run_for_branch(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _branch: \u0026str,\n    ) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n        Ok(self.run_id)\n    }\n\n    async fn get_failed_jobs(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _run_id: u64,\n    ) -\u003e Result\u003cVec\u003c(u64, String)\u003e\u003e {\n        Ok(self.failed_jobs.clone())\n    }\n\n    async fn get_job_logs(\u0026self, _owner: \u0026str, _repo: \u0026str, _job_id: u64) -\u003e Result\u003cString\u003e {\n        Ok(self.logs.clone())\n    }\n\n    async fn find_pr_for_branch(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _branch: \u0026str,\n    ) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n        Ok(None)\n    }\n\n    async fn list_workflow_runs(\n        \u0026self,\n        _query: \u0026crate::gh::types::RunsQuery\u003c'_\u003e,\n    ) -\u003e Result\u003cVec\u003ccrate::gh::types::WorkflowRun\u003e\u003e {\n        Ok(vec![])\n    }\n\n    async fn search_prs_by_title(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _query: \u0026str,\n    ) -\u003e Result\u003cVec\u003cPullRequest\u003e\u003e {\n        Ok(vec![])\n    }\n}\n\n#[tokio::test]\nasync fn process_failures_no_failed_runs() {\n    let mock = MockGithubApi {\n        branch: \"main\".to_string(),\n        run_id: None,\n        failed_jobs: vec![],\n        logs: String::new(),\n    };\n    let result = process_failures(\u0026mock, \"owner\", \"repo\", 123).await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn process_failures_no_failed_jobs() {\n    let mock = MockGithubApi {\n        branch: \"main\".to_string(),\n        run_id: Some(1),\n        failed_jobs: vec![],\n        logs: String::new(),\n    };\n    let result = process_failures(\u0026mock, \"owner\", \"repo\", 123).await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn process_failures_no_test_jobs() {\n    let mock = MockGithubApi {\n        branch: \"main\".to_string(),\n        run_id: Some(1),\n        failed_jobs: vec![(1, \"build\".to_string()), (2, \"deploy\".to_string())],\n        logs: String::new(),\n    };\n    let result = process_failures(\u0026mock, \"owner\", \"repo\", 123).await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn process_failures_with_test_failures() {\n    let mock = MockGithubApi {\n        branch: \"main\".to_string(),\n        run_id: Some(1),\n        failed_jobs: vec![(1, \"rspec-tests\".to_string())],\n        logs: r#\"\nFailures:\n\n  1) Test fails\n     Failure/Error: expect(1).to eq(2)\n       expected: 2\n\nFailed examples:\n\nrspec ./spec/test_spec.rb:10 # Test fails\n\"#\n        .to_string(),\n    };\n    let result = process_failures(\u0026mock, \"owner\", \"repo\", 123).await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn process_failures_empty_logs() {\n    let mock = MockGithubApi {\n        branch: \"main\".to_string(),\n        run_id: Some(1),\n        failed_jobs: vec![(1, \"test-suite\".to_string())],\n        logs: String::new(),\n    };\n    let result = process_failures(\u0026mock, \"owner\", \"repo\", 123).await;\n    assert!(result.is_ok());\n}\n\n// Mock with error handling\nstruct MockGithubApiWithLogError {\n    branch: String,\n    run_id: Option\u003cu64\u003e,\n    failed_jobs: Vec\u003c(u64, String)\u003e,\n}\n\nimpl GithubApi for MockGithubApiWithLogError {\n    async fn list_user_prs(\u0026self) -\u003e Result\u003cVec\u003cPullRequest\u003e\u003e {\n        Ok(vec![])\n    }\n\n    async fn get_ci_status(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _pr: u64,\n    ) -\u003e Result\u003ccrate::gh::types::CiStatus\u003e {\n        Ok(crate::gh::types::CiStatus::Unknown)\n    }\n\n    async fn get_pr_branch(\u0026self, _owner: \u0026str, _repo: \u0026str, _pr: u64) -\u003e Result\u003cString\u003e {\n        Ok(self.branch.clone())\n    }\n\n    async fn get_latest_failed_run_for_branch(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _branch: \u0026str,\n    ) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n        Ok(self.run_id)\n    }\n\n    async fn get_failed_jobs(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _run_id: u64,\n    ) -\u003e Result\u003cVec\u003c(u64, String)\u003e\u003e {\n        Ok(self.failed_jobs.clone())\n    }\n\n    async fn get_job_logs(\u0026self, _owner: \u0026str, _repo: \u0026str, _job_id: u64) -\u003e Result\u003cString\u003e {\n        Err(anyhow::anyhow!(\"Failed to fetch logs\"))\n    }\n\n    async fn find_pr_for_branch(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _branch: \u0026str,\n    ) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n        Ok(None)\n    }\n\n    async fn list_workflow_runs(\n        \u0026self,\n        _query: \u0026crate::gh::types::RunsQuery\u003c'_\u003e,\n    ) -\u003e Result\u003cVec\u003ccrate::gh::types::WorkflowRun\u003e\u003e {\n        Ok(vec![])\n    }\n\n    async fn search_prs_by_title(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _query: \u0026str,\n    ) -\u003e Result\u003cVec\u003cPullRequest\u003e\u003e {\n        Ok(vec![])\n    }\n}\n\n#[tokio::test]\nasync fn process_failures_handles_log_fetch_error() {\n    let mock = MockGithubApiWithLogError {\n        branch: \"feature\".to_string(),\n        run_id: Some(42),\n        failed_jobs: vec![(100, \"rspec-tests\".to_string())],\n    };\n    let result = process_failures(\u0026mock, \"owner\", \"repo\", 123).await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn process_failures_multiple_test_jobs() {\n    let mock = MockGithubApi {\n        branch: \"main\".to_string(),\n        run_id: Some(1),\n        failed_jobs: vec![\n            (1, \"rspec-tests\".to_string()),\n            (2, \"jest-tests\".to_string()),\n            (3, \"build\".to_string()),\n        ],\n        logs: r#\"\nFailures:\n\n  1) Test fails\n     Failure/Error: expect(1).to eq(2)\n       expected: 2\n\nFailed examples:\n\nrspec ./spec/test_spec.rb:10 # Test fails\n\"#\n        .to_string(),\n    };\n    let result = process_failures(\u0026mock, \"owner\", \"repo\", 123).await;\n    assert!(result.is_ok());\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":12}},{"line":28,"address":[],"length":0,"stats":{"Line":6}},{"line":31,"address":[],"length":0,"stats":{"Line":6}},{"line":37,"address":[],"length":0,"stats":{"Line":6}},{"line":40,"address":[],"length":0,"stats":{"Line":5}},{"line":46,"address":[],"length":0,"stats":{"Line":5}},{"line":49,"address":[],"length":0,"stats":{"Line":8}},{"line":50,"address":[],"length":0,"stats":{"Line":4}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":2}},{"line":172,"address":[],"length":0,"stats":{"Line":1}},{"line":175,"address":[],"length":0,"stats":{"Line":1}},{"line":181,"address":[],"length":0,"stats":{"Line":1}},{"line":184,"address":[],"length":0,"stats":{"Line":1}},{"line":190,"address":[],"length":0,"stats":{"Line":1}},{"line":193,"address":[],"length":0,"stats":{"Line":2}},{"line":194,"address":[],"length":0,"stats":{"Line":1}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}}],"covered":16,"coverable":36},{"path":["/","Users","chi","Projects","hu","src","gh","fix","mapping","mod.rs"],"content":"/// Strip line number suffix from a path (e.g., \"spec/foo_spec.rb:10\" -\u003e \"spec/foo_spec.rb\")\npub fn strip_line_number(path: \u0026str) -\u003e \u0026str {\n    // Find last colon followed by digits\n    if let Some(idx) = path.rfind(':') {\n        if path[idx + 1..].chars().all(|c| c.is_ascii_digit()) \u0026\u0026 !path[idx + 1..].is_empty() {\n            return \u0026path[..idx];\n        }\n    }\n    path\n}\n\n/// Detect the language/framework from a test file path\npub fn detect_language(test_file: \u0026str) -\u003e \u0026'static str {\n    let path = strip_line_number(test_file);\n\n    if path.ends_with(\"_spec.rb\") || path.starts_with(\"spec/\") || path.starts_with(\"./spec/\") {\n        \"ruby\"\n    } else if path.ends_with(\"_test.py\")\n        || (path.ends_with(\".py\") \u0026\u0026 (path.starts_with(\"tests/test_\") || path.starts_with(\"test_\")))\n    {\n        \"python\"\n    } else if path.ends_with(\".test.js\")\n        || path.ends_with(\".test.ts\")\n        || path.ends_with(\".test.tsx\")\n        || path.ends_with(\".test.jsx\")\n        || path.ends_with(\".spec.js\")\n        || path.ends_with(\".spec.ts\")\n        || path.ends_with(\".spec.tsx\")\n        || path.ends_with(\".spec.jsx\")\n    {\n        \"javascript\"\n    } else if path.ends_with(\".rs\")\n        || (path.starts_with(\"tests/\") \u0026\u0026 !path.ends_with(\".py\"))\n        || path.contains(\"/tests.rs\")\n        || path.contains(\"/tests/\")\n    {\n        \"rust\"\n    } else {\n        \"unknown\"\n    }\n}\n\n/// Map a test file path to likely source file paths\npub fn map_test_to_source(test_file: \u0026str) -\u003e Vec\u003cString\u003e {\n    let path = strip_line_number(test_file);\n    let lang = detect_language(test_file);\n\n    match lang {\n        \"ruby\" =\u003e map_rspec(path),\n        \"rust\" =\u003e map_rust(path),\n        \"python\" =\u003e map_python(path),\n        \"javascript\" =\u003e map_javascript(path),\n        _ =\u003e vec![],\n    }\n}\n\n/// Map RSpec test file to Ruby source files\n/// spec/models/user_spec.rb -\u003e app/models/user.rb\n/// spec/helpers/pricing_helper_spec.rb -\u003e app/helpers/pricing_helper.rb\nfn map_rspec(path: \u0026str) -\u003e Vec\u003cString\u003e {\n    let path = path\n        .strip_prefix(\"./\")\n        .unwrap_or(path)\n        .strip_prefix(\"spec/\")\n        .unwrap_or(path);\n\n    let path = path.strip_suffix(\"_spec.rb\").unwrap_or(path);\n\n    vec![format!(\"app/{}.rb\", path), format!(\"lib/{}.rb\", path)]\n}\n\n/// Map Rust test file to source files\n/// tests/test_sync.rs -\u003e src/sync.rs\n/// src/data/tests.rs -\u003e src/data/mod.rs\nfn map_rust(path: \u0026str) -\u003e Vec\u003cString\u003e {\n    let path = path.strip_prefix(\"./\").unwrap_or(path);\n\n    if let Some(parent) = path.strip_suffix(\"/tests.rs\") {\n        return vec![format!(\"{}/mod.rs\", parent)];\n    }\n\n    if let Some(rest) = path.strip_prefix(\"tests/\") {\n        let without_prefix = rest.strip_prefix(\"test_\").unwrap_or(rest);\n        let name = without_prefix.strip_suffix(\".rs\").unwrap_or(without_prefix);\n        return vec![format!(\"src/{}.rs\", name), format!(\"src/{}/mod.rs\", name)];\n    }\n\n    vec![]\n}\n\n/// Map Python test file to source files\n/// tests/test_utils.py -\u003e src/utils.py, utils.py\n/// utils_test.py -\u003e utils.py\nfn map_python(path: \u0026str) -\u003e Vec\u003cString\u003e {\n    let path = path.strip_prefix(\"./\").unwrap_or(path);\n\n    if path.starts_with(\"tests/test_\") || path.starts_with(\"test_\") {\n        let name = path\n            .strip_prefix(\"tests/\")\n            .unwrap_or(path)\n            .strip_prefix(\"test_\")\n            .unwrap_or(path);\n        return vec![format!(\"src/{}\", name), name.to_string()];\n    }\n\n    if let Some(base) = path.strip_suffix(\"_test.py\") {\n        return vec![format!(\"{}.py\", base), format!(\"src/{}.py\", base)];\n    }\n\n    vec![]\n}\n\n/// Map JS/TS test file to source files\n/// components/Button.test.tsx -\u003e components/Button.tsx\n/// utils/format.spec.ts -\u003e utils/format.ts\nfn map_javascript(path: \u0026str) -\u003e Vec\u003cString\u003e {\n    let path = path.strip_prefix(\"./\").unwrap_or(path);\n\n    for suffix in \u0026[\n        \".test.js\",\n        \".test.ts\",\n        \".test.tsx\",\n        \".test.jsx\",\n        \".spec.js\",\n        \".spec.ts\",\n        \".spec.tsx\",\n        \".spec.jsx\",\n    ] {\n        if let Some(base) = path.strip_suffix(suffix) {\n            let ext = \u0026suffix[suffix.rfind('.').unwrap_or(0)..];\n            return vec![format!(\"{}{}\", base, ext)];\n        }\n    }\n\n    vec![]\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[{"line":2,"address":[],"length":0,"stats":{"Line":90}},{"line":4,"address":[],"length":0,"stats":{"Line":125}},{"line":5,"address":[],"length":0,"stats":{"Line":220}},{"line":6,"address":[],"length":0,"stats":{"Line":33}},{"line":9,"address":[],"length":0,"stats":{"Line":57}},{"line":13,"address":[],"length":0,"stats":{"Line":51}},{"line":14,"address":[],"length":0,"stats":{"Line":153}},{"line":16,"address":[],"length":0,"stats":{"Line":234}},{"line":17,"address":[],"length":0,"stats":{"Line":18}},{"line":18,"address":[],"length":0,"stats":{"Line":66}},{"line":19,"address":[],"length":0,"stats":{"Line":74}},{"line":21,"address":[],"length":0,"stats":{"Line":6}},{"line":22,"address":[],"length":0,"stats":{"Line":54}},{"line":23,"address":[],"length":0,"stats":{"Line":48}},{"line":24,"address":[],"length":0,"stats":{"Line":48}},{"line":25,"address":[],"length":0,"stats":{"Line":40}},{"line":26,"address":[],"length":0,"stats":{"Line":40}},{"line":27,"address":[],"length":0,"stats":{"Line":40}},{"line":28,"address":[],"length":0,"stats":{"Line":36}},{"line":29,"address":[],"length":0,"stats":{"Line":36}},{"line":31,"address":[],"length":0,"stats":{"Line":11}},{"line":32,"address":[],"length":0,"stats":{"Line":32}},{"line":33,"address":[],"length":0,"stats":{"Line":14}},{"line":34,"address":[],"length":0,"stats":{"Line":14}},{"line":35,"address":[],"length":0,"stats":{"Line":14}},{"line":37,"address":[],"length":0,"stats":{"Line":9}},{"line":39,"address":[],"length":0,"stats":{"Line":7}},{"line":44,"address":[],"length":0,"stats":{"Line":25}},{"line":45,"address":[],"length":0,"stats":{"Line":75}},{"line":46,"address":[],"length":0,"stats":{"Line":75}},{"line":48,"address":[],"length":0,"stats":{"Line":25}},{"line":49,"address":[],"length":0,"stats":{"Line":45}},{"line":50,"address":[],"length":0,"stats":{"Line":23}},{"line":51,"address":[],"length":0,"stats":{"Line":17}},{"line":52,"address":[],"length":0,"stats":{"Line":18}},{"line":53,"address":[],"length":0,"stats":{"Line":3}},{"line":60,"address":[],"length":0,"stats":{"Line":10}},{"line":61,"address":[],"length":0,"stats":{"Line":30}},{"line":63,"address":[],"length":0,"stats":{"Line":10}},{"line":65,"address":[],"length":0,"stats":{"Line":20}},{"line":67,"address":[],"length":0,"stats":{"Line":50}},{"line":69,"address":[],"length":0,"stats":{"Line":50}},{"line":75,"address":[],"length":0,"stats":{"Line":5}},{"line":76,"address":[],"length":0,"stats":{"Line":25}},{"line":78,"address":[],"length":0,"stats":{"Line":6}},{"line":79,"address":[],"length":0,"stats":{"Line":3}},{"line":82,"address":[],"length":0,"stats":{"Line":7}},{"line":83,"address":[],"length":0,"stats":{"Line":15}},{"line":84,"address":[],"length":0,"stats":{"Line":15}},{"line":85,"address":[],"length":0,"stats":{"Line":15}},{"line":88,"address":[],"length":0,"stats":{"Line":1}},{"line":94,"address":[],"length":0,"stats":{"Line":4}},{"line":95,"address":[],"length":0,"stats":{"Line":20}},{"line":97,"address":[],"length":0,"stats":{"Line":14}},{"line":98,"address":[],"length":0,"stats":{"Line":6}},{"line":100,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":4}},{"line":103,"address":[],"length":0,"stats":{"Line":10}},{"line":106,"address":[],"length":0,"stats":{"Line":3}},{"line":107,"address":[],"length":0,"stats":{"Line":5}},{"line":110,"address":[],"length":0,"stats":{"Line":1}},{"line":116,"address":[],"length":0,"stats":{"Line":6}},{"line":117,"address":[],"length":0,"stats":{"Line":30}},{"line":119,"address":[],"length":0,"stats":{"Line":59}},{"line":120,"address":[],"length":0,"stats":{"Line":30}},{"line":121,"address":[],"length":0,"stats":{"Line":30}},{"line":122,"address":[],"length":0,"stats":{"Line":30}},{"line":123,"address":[],"length":0,"stats":{"Line":30}},{"line":124,"address":[],"length":0,"stats":{"Line":30}},{"line":125,"address":[],"length":0,"stats":{"Line":30}},{"line":126,"address":[],"length":0,"stats":{"Line":30}},{"line":127,"address":[],"length":0,"stats":{"Line":30}},{"line":129,"address":[],"length":0,"stats":{"Line":63}},{"line":130,"address":[],"length":0,"stats":{"Line":20}},{"line":131,"address":[],"length":0,"stats":{"Line":15}},{"line":135,"address":[],"length":0,"stats":{"Line":1}}],"covered":76,"coverable":76},{"path":["/","Users","chi","Projects","hu","src","gh","fix","mapping","tests.rs"],"content":"use super::*;\n\n// strip_line_number tests\n#[test]\nfn strip_line_number_with_line() {\n    assert_eq!(strip_line_number(\"spec/foo_spec.rb:10\"), \"spec/foo_spec.rb\");\n}\n\n#[test]\nfn strip_line_number_without_line() {\n    assert_eq!(strip_line_number(\"spec/foo_spec.rb\"), \"spec/foo_spec.rb\");\n}\n\n#[test]\nfn strip_line_number_colon_no_digits() {\n    assert_eq!(strip_line_number(\"foo:bar\"), \"foo:bar\");\n}\n\n#[test]\nfn strip_line_number_empty() {\n    assert_eq!(strip_line_number(\"\"), \"\");\n}\n\n#[test]\nfn strip_line_number_multiple_colons() {\n    assert_eq!(\n        strip_line_number(\"./spec/foo_spec.rb:10\"),\n        \"./spec/foo_spec.rb\"\n    );\n}\n\n#[test]\nfn strip_line_number_trailing_colon() {\n    assert_eq!(strip_line_number(\"foo:\"), \"foo:\");\n}\n\n// detect_language tests\n#[test]\nfn detect_ruby() {\n    assert_eq!(detect_language(\"spec/models/user_spec.rb\"), \"ruby\");\n    assert_eq!(detect_language(\"./spec/models/user_spec.rb:10\"), \"ruby\");\n    assert_eq!(detect_language(\"spec/helpers/foo_spec.rb\"), \"ruby\");\n}\n\n#[test]\nfn detect_rust() {\n    assert_eq!(detect_language(\"tests/test_sync.rs\"), \"rust\");\n    assert_eq!(detect_language(\"src/data/tests.rs\"), \"rust\");\n    assert_eq!(detect_language(\"src/gh/fix/tests.rs\"), \"rust\");\n}\n\n#[test]\nfn detect_python() {\n    assert_eq!(detect_language(\"tests/test_utils.py\"), \"python\");\n    assert_eq!(detect_language(\"utils_test.py\"), \"python\");\n    assert_eq!(detect_language(\"test_main.py\"), \"python\");\n}\n\n#[test]\nfn detect_javascript() {\n    assert_eq!(detect_language(\"Button.test.tsx\"), \"javascript\");\n    assert_eq!(detect_language(\"utils/format.spec.ts\"), \"javascript\");\n    assert_eq!(detect_language(\"app.test.js\"), \"javascript\");\n    assert_eq!(detect_language(\"component.spec.jsx\"), \"javascript\");\n}\n\n#[test]\nfn detect_unknown() {\n    assert_eq!(detect_language(\"README.md\"), \"unknown\");\n    assert_eq!(detect_language(\"main.go\"), \"unknown\");\n    assert_eq!(detect_language(\"\"), \"unknown\");\n}\n\n// map_test_to_source: Ruby\n#[test]\nfn map_rspec_model() {\n    let sources = map_test_to_source(\"spec/models/user_spec.rb\");\n    assert!(sources.contains(\u0026\"app/models/user.rb\".to_string()));\n    assert!(sources.contains(\u0026\"lib/models/user.rb\".to_string()));\n}\n\n#[test]\nfn map_rspec_helper() {\n    let sources = map_test_to_source(\"spec/helpers/pricing_helper_spec.rb:289\");\n    assert!(sources.contains(\u0026\"app/helpers/pricing_helper.rb\".to_string()));\n}\n\n#[test]\nfn map_rspec_with_dot_prefix() {\n    let sources = map_test_to_source(\"./spec/models/user_spec.rb:10\");\n    assert!(sources.contains(\u0026\"app/models/user.rb\".to_string()));\n}\n\n#[test]\nfn map_rspec_nested_path() {\n    let sources = map_test_to_source(\"spec/features/admin/users/permissions_spec.rb:42\");\n    assert!(sources.contains(\u0026\"app/features/admin/users/permissions.rb\".to_string()));\n}\n\n// map_test_to_source: Rust\n#[test]\nfn map_rust_integration_test() {\n    let sources = map_test_to_source(\"tests/test_sync.rs\");\n    assert!(sources.contains(\u0026\"src/sync.rs\".to_string()));\n    assert!(sources.contains(\u0026\"src/sync/mod.rs\".to_string()));\n}\n\n#[test]\nfn map_rust_module_tests() {\n    let sources = map_test_to_source(\"src/data/tests.rs\");\n    assert_eq!(sources, vec![\"src/data/mod.rs\"]);\n}\n\n#[test]\nfn map_rust_integration_test_no_prefix() {\n    let sources = map_test_to_source(\"tests/utils.rs\");\n    assert!(sources.contains(\u0026\"src/utils.rs\".to_string()));\n}\n\n// map_test_to_source: Python\n#[test]\nfn map_python_test_file() {\n    let sources = map_test_to_source(\"tests/test_utils.py\");\n    assert!(sources.contains(\u0026\"src/utils.py\".to_string()));\n    assert!(sources.contains(\u0026\"utils.py\".to_string()));\n}\n\n#[test]\nfn map_python_suffix_test() {\n    let sources = map_test_to_source(\"utils_test.py\");\n    assert!(sources.contains(\u0026\"utils.py\".to_string()));\n    assert!(sources.contains(\u0026\"src/utils.py\".to_string()));\n}\n\n#[test]\nfn map_python_bare_test() {\n    let sources = map_test_to_source(\"test_main.py\");\n    assert!(sources.contains(\u0026\"src/main.py\".to_string()));\n    assert!(sources.contains(\u0026\"main.py\".to_string()));\n}\n\n// map_test_to_source: JavaScript/TypeScript\n#[test]\nfn map_js_test() {\n    let sources = map_test_to_source(\"components/Button.test.tsx\");\n    assert_eq!(sources, vec![\"components/Button.tsx\"]);\n}\n\n#[test]\nfn map_js_spec() {\n    let sources = map_test_to_source(\"utils/format.spec.ts\");\n    assert_eq!(sources, vec![\"utils/format.ts\"]);\n}\n\n#[test]\nfn map_js_plain() {\n    let sources = map_test_to_source(\"app.test.js\");\n    assert_eq!(sources, vec![\"app.js\"]);\n}\n\n#[test]\nfn map_jsx_spec() {\n    let sources = map_test_to_source(\"component.spec.jsx\");\n    assert_eq!(sources, vec![\"component.jsx\"]);\n}\n\n// map_test_to_source: Unknown\n#[test]\nfn map_unknown_returns_empty() {\n    let sources = map_test_to_source(\"README.md\");\n    assert!(sources.is_empty());\n}\n\n#[test]\nfn map_empty_returns_empty() {\n    let sources = map_test_to_source(\"\");\n    assert!(sources.is_empty());\n}\n\n// Edge cases\n#[test]\nfn map_with_line_number_stripped() {\n    let sources = map_test_to_source(\"spec/models/user_spec.rb:42\");\n    assert!(sources.contains(\u0026\"app/models/user.rb\".to_string()));\n}\n\n#[test]\nfn detect_language_with_line_number() {\n    assert_eq!(detect_language(\"tests/test_sync.rs:100\"), \"rust\");\n    assert_eq!(detect_language(\"app.test.js:55\"), \"javascript\");\n}\n\n// Direct mapper fallback tests\n#[test]\nfn map_rust_non_test_file() {\n    assert!(map_rust(\"src/main.rs\").is_empty());\n}\n\n#[test]\nfn map_python_non_test_file() {\n    assert!(map_python(\"main.py\").is_empty());\n}\n\n#[test]\nfn map_javascript_non_test_file() {\n    assert!(map_javascript(\"index.js\").is_empty());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","gh","fix","mod.rs"],"content":"use anyhow::Result;\n\nuse super::cli::FixArgs;\nuse super::client::{parse_test_failures, GithubApi, GithubClient};\nuse super::helpers::{get_current_branch, get_current_repo, is_test_job, parse_owner_repo};\nuse super::types::{FixFailure, FixReport, TestFailure};\n\nmod mapping;\n\n#[cfg(test)]\nmod tests;\n\n/// Query parameters for building a fix report\n#[derive(Debug, Clone)]\npub struct FixQuery {\n    pub owner: String,\n    pub repo: String,\n    pub pr: Option\u003cu64\u003e,\n    pub run: Option\u003cu64\u003e,\n    pub branch: Option\u003cString\u003e,\n}\n\n/// Handle the `hu gh fix` command\n#[cfg(not(tarpaulin_include))]\npub async fn run(args: FixArgs) -\u003e Result\u003c()\u003e {\n    let client = GithubClient::new()?;\n\n    let (owner, repo) = if let Some(repo_arg) = \u0026args.repo {\n        parse_owner_repo(repo_arg)?\n    } else {\n        get_current_repo()?\n    };\n\n    let query = FixQuery {\n        owner,\n        repo,\n        pr: args.pr,\n        run: args.run,\n        branch: args.branch,\n    };\n\n    let report = build_fix_report(\u0026client, \u0026query).await?;\n\n    match report {\n        Some(r) =\u003e output_report(\u0026r, args.json),\n        None =\u003e {\n            println!(\"No failures found.\");\n            Ok(())\n        }\n    }\n}\n\n/// Build a fix report from CI failures (testable, no I/O except API calls)\npub async fn build_fix_report(\n    client: \u0026impl GithubApi,\n    query: \u0026FixQuery,\n) -\u003e Result\u003cOption\u003cFixReport\u003e\u003e {\n    let repository = format!(\"{}/{}\", query.owner, query.repo);\n    let owner = \u0026query.owner;\n    let repo = \u0026query.repo;\n\n    // Determine run_id from args\n    let (run_id, pr_number) = if let Some(run_id) = query.run {\n        (run_id, query.pr)\n    } else if let Some(pr_number) = query.pr {\n        let branch = client.get_pr_branch(owner, repo, pr_number).await?;\n        let run_id = client\n            .get_latest_failed_run_for_branch(owner, repo, \u0026branch)\n            .await?;\n        match run_id {\n            Some(id) =\u003e (id, Some(pr_number)),\n            None =\u003e return Ok(None),\n        }\n    } else {\n        // Use branch arg or current branch\n        let branch_name = match \u0026query.branch {\n            Some(b) =\u003e b.clone(),\n            None =\u003e get_current_branch()?,\n        };\n\n        let pr_number = client.find_pr_for_branch(owner, repo, \u0026branch_name).await?;\n\n        let run_id = client\n            .get_latest_failed_run_for_branch(owner, repo, \u0026branch_name)\n            .await?;\n\n        match run_id {\n            Some(id) =\u003e (id, pr_number),\n            None =\u003e return Ok(None),\n        }\n    };\n\n    // Get failed jobs\n    let failed_jobs = client.get_failed_jobs(owner, repo, run_id).await?;\n\n    if failed_jobs.is_empty() {\n        return Ok(None);\n    }\n\n    // Filter to test jobs and fetch logs\n    let test_jobs: Vec\u003c_\u003e = failed_jobs\n        .into_iter()\n        .filter(|(_, name)| is_test_job(name))\n        .collect();\n\n    if test_jobs.is_empty() {\n        return Ok(None);\n    }\n\n    let mut all_failures = Vec::new();\n\n    for (job_id, job_name) in test_jobs {\n        eprintln!(\"Fetching logs for job: {}\", job_name);\n        match client.get_job_logs(owner, repo, job_id).await {\n            Ok(logs) =\u003e {\n                let failures = parse_test_failures(\u0026logs);\n                all_failures.extend(failures);\n            }\n            Err(e) =\u003e {\n                eprintln!(\"Warning: Failed to fetch logs for {}: {}\", job_name, e);\n            }\n        }\n    }\n\n    if all_failures.is_empty() {\n        return Ok(None);\n    }\n\n    let fix_failures = enrich_failures(\u0026all_failures);\n    let test_files: Vec\u003cString\u003e = fix_failures.iter().map(|f| f.test_file.clone()).collect();\n    let source_files: Vec\u003cString\u003e = fix_failures\n        .iter()\n        .flat_map(|f| f.source_files.clone())\n        .collect::\u003cstd::collections::HashSet\u003c_\u003e\u003e()\n        .into_iter()\n        .collect();\n\n    Ok(Some(FixReport {\n        repository,\n        pr_number,\n        run_id,\n        failures: fix_failures,\n        test_files,\n        source_files,\n    }))\n}\n\n/// Enrich test failures with source file mappings (pure function)\npub fn enrich_failures(failures: \u0026[TestFailure]) -\u003e Vec\u003cFixFailure\u003e {\n    failures\n        .iter()\n        .map(|f| {\n            let language = mapping::detect_language(\u0026f.spec_file).to_string();\n            let source_files = mapping::map_test_to_source(\u0026f.spec_file);\n            let test_file = mapping::strip_line_number(\u0026f.spec_file).to_string();\n\n            FixFailure {\n                test_file,\n                source_files,\n                failure_text: f.failure_text.clone(),\n                language,\n            }\n        })\n        .collect()\n}\n\n/// Output the fix report (markdown or JSON)\nfn output_report(report: \u0026FixReport, json: bool) -\u003e Result\u003c()\u003e {\n    if json {\n        println!(\"{}\", serde_json::to_string_pretty(report)?);\n    } else {\n        print!(\"{}\", format_markdown(report));\n    }\n    Ok(())\n}\n\n/// Format report as markdown (pure function, testable)\npub fn format_markdown(report: \u0026FixReport) -\u003e String {\n    let mut out = String::new();\n\n    out.push_str(\u0026format!(\"# Fix Report: {}\\n\\n\", report.repository));\n\n    if let Some(pr) = report.pr_number {\n        out.push_str(\u0026format!(\"**PR:** #{}\\n\", pr));\n    }\n    out.push_str(\u0026format!(\"**Run:** {}\\n\", report.run_id));\n    out.push_str(\u0026format!(\"**Failures:** {}\\n\\n\", report.failures.len()));\n\n    // Failures\n    for failure in \u0026report.failures {\n        out.push_str(\u0026format!(\"## {}\\n\\n\", failure.test_file));\n        out.push_str(\u0026format!(\"**Language:** {}\\n\", failure.language));\n\n        if !failure.source_files.is_empty() {\n            out.push_str(\"**Source files:**\\n\");\n            for sf in \u0026failure.source_files {\n                out.push_str(\u0026format!(\"- `{}`\\n\", sf));\n            }\n        }\n\n        out.push_str(\"\\n```\\n\");\n        out.push_str(\u0026failure.failure_text);\n        out.push_str(\"\\n```\\n\\n\");\n    }\n\n    // Rerun commands\n    out.push_str(\u0026format_rerun_commands(\u0026report.failures));\n\n    // File lists\n    if !report.source_files.is_empty() {\n        out.push_str(\"## Source Files to Investigate\\n\\n\");\n        for f in \u0026report.source_files {\n            out.push_str(\u0026format!(\"- `{}`\\n\", f));\n        }\n        out.push('\\n');\n    }\n\n    out\n}\n\n/// Format rerun commands section (pure function, testable)\npub fn format_rerun_commands(failures: \u0026[FixFailure]) -\u003e String {\n    if failures.is_empty() {\n        return String::new();\n    }\n\n    let mut out = String::from(\"## Rerun Commands\\n\\n```bash\\n\");\n\n    for failure in failures {\n        match failure.language.as_str() {\n            \"ruby\" =\u003e out.push_str(\u0026format!(\"bundle exec rspec {}\\n\", failure.test_file)),\n            \"rust\" =\u003e out.push_str(\u0026format!(\"cargo test {}\\n\", failure.test_file)),\n            \"python\" =\u003e out.push_str(\u0026format!(\"pytest {}\\n\", failure.test_file)),\n            \"javascript\" =\u003e out.push_str(\u0026format!(\"npx jest {}\\n\", failure.test_file)),\n            _ =\u003e out.push_str(\u0026format!(\"# run {}\\n\", failure.test_file)),\n        }\n    }\n\n    out.push_str(\"```\\n\\n\");\n    out\n}\n","traces":[{"line":54,"address":[],"length":0,"stats":{"Line":10}},{"line":58,"address":[],"length":0,"stats":{"Line":30}},{"line":59,"address":[],"length":0,"stats":{"Line":20}},{"line":60,"address":[],"length":0,"stats":{"Line":20}},{"line":63,"address":[],"length":0,"stats":{"Line":25}},{"line":64,"address":[],"length":0,"stats":{"Line":1}},{"line":65,"address":[],"length":0,"stats":{"Line":15}},{"line":66,"address":[],"length":0,"stats":{"Line":36}},{"line":67,"address":[],"length":0,"stats":{"Line":18}},{"line":68,"address":[],"length":0,"stats":{"Line":24}},{"line":69,"address":[],"length":0,"stats":{"Line":6}},{"line":70,"address":[],"length":0,"stats":{"Line":6}},{"line":71,"address":[],"length":0,"stats":{"Line":10}},{"line":72,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":6}},{"line":77,"address":[],"length":0,"stats":{"Line":6}},{"line":78,"address":[],"length":0,"stats":{"Line":1}},{"line":81,"address":[],"length":0,"stats":{"Line":18}},{"line":83,"address":[],"length":0,"stats":{"Line":9}},{"line":84,"address":[],"length":0,"stats":{"Line":12}},{"line":85,"address":[],"length":0,"stats":{"Line":3}},{"line":87,"address":[],"length":0,"stats":{"Line":3}},{"line":88,"address":[],"length":0,"stats":{"Line":2}},{"line":89,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":42}},{"line":96,"address":[],"length":0,"stats":{"Line":14}},{"line":97,"address":[],"length":0,"stats":{"Line":1}},{"line":101,"address":[],"length":0,"stats":{"Line":18}},{"line":103,"address":[],"length":0,"stats":{"Line":20}},{"line":106,"address":[],"length":0,"stats":{"Line":12}},{"line":107,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":10}},{"line":112,"address":[],"length":0,"stats":{"Line":20}},{"line":113,"address":[],"length":0,"stats":{"Line":10}},{"line":114,"address":[],"length":0,"stats":{"Line":30}},{"line":115,"address":[],"length":0,"stats":{"Line":8}},{"line":116,"address":[],"length":0,"stats":{"Line":16}},{"line":117,"address":[],"length":0,"stats":{"Line":8}},{"line":119,"address":[],"length":0,"stats":{"Line":2}},{"line":120,"address":[],"length":0,"stats":{"Line":1}},{"line":125,"address":[],"length":0,"stats":{"Line":10}},{"line":126,"address":[],"length":0,"stats":{"Line":2}},{"line":129,"address":[],"length":0,"stats":{"Line":9}},{"line":130,"address":[],"length":0,"stats":{"Line":21}},{"line":131,"address":[],"length":0,"stats":{"Line":9}},{"line":133,"address":[],"length":0,"stats":{"Line":9}},{"line":138,"address":[],"length":0,"stats":{"Line":3}},{"line":139,"address":[],"length":0,"stats":{"Line":6}},{"line":140,"address":[],"length":0,"stats":{"Line":6}},{"line":141,"address":[],"length":0,"stats":{"Line":6}},{"line":142,"address":[],"length":0,"stats":{"Line":6}},{"line":143,"address":[],"length":0,"stats":{"Line":3}},{"line":144,"address":[],"length":0,"stats":{"Line":3}},{"line":149,"address":[],"length":0,"stats":{"Line":7}},{"line":150,"address":[],"length":0,"stats":{"Line":7}},{"line":152,"address":[],"length":0,"stats":{"Line":15}},{"line":153,"address":[],"length":0,"stats":{"Line":24}},{"line":154,"address":[],"length":0,"stats":{"Line":24}},{"line":155,"address":[],"length":0,"stats":{"Line":24}},{"line":157,"address":[],"length":0,"stats":{"Line":8}},{"line":158,"address":[],"length":0,"stats":{"Line":16}},{"line":159,"address":[],"length":0,"stats":{"Line":16}},{"line":160,"address":[],"length":0,"stats":{"Line":16}},{"line":161,"address":[],"length":0,"stats":{"Line":8}},{"line":168,"address":[],"length":0,"stats":{"Line":2}},{"line":169,"address":[],"length":0,"stats":{"Line":2}},{"line":170,"address":[],"length":0,"stats":{"Line":4}},{"line":172,"address":[],"length":0,"stats":{"Line":3}},{"line":174,"address":[],"length":0,"stats":{"Line":2}},{"line":178,"address":[],"length":0,"stats":{"Line":5}},{"line":179,"address":[],"length":0,"stats":{"Line":10}},{"line":181,"address":[],"length":0,"stats":{"Line":15}},{"line":183,"address":[],"length":0,"stats":{"Line":9}},{"line":184,"address":[],"length":0,"stats":{"Line":6}},{"line":186,"address":[],"length":0,"stats":{"Line":15}},{"line":187,"address":[],"length":0,"stats":{"Line":25}},{"line":190,"address":[],"length":0,"stats":{"Line":13}},{"line":191,"address":[],"length":0,"stats":{"Line":12}},{"line":192,"address":[],"length":0,"stats":{"Line":12}},{"line":194,"address":[],"length":0,"stats":{"Line":4}},{"line":195,"address":[],"length":0,"stats":{"Line":9}},{"line":196,"address":[],"length":0,"stats":{"Line":12}},{"line":197,"address":[],"length":0,"stats":{"Line":9}},{"line":201,"address":[],"length":0,"stats":{"Line":12}},{"line":202,"address":[],"length":0,"stats":{"Line":12}},{"line":203,"address":[],"length":0,"stats":{"Line":12}},{"line":207,"address":[],"length":0,"stats":{"Line":15}},{"line":210,"address":[],"length":0,"stats":{"Line":5}},{"line":211,"address":[],"length":0,"stats":{"Line":6}},{"line":212,"address":[],"length":0,"stats":{"Line":11}},{"line":213,"address":[],"length":0,"stats":{"Line":9}},{"line":215,"address":[],"length":0,"stats":{"Line":4}},{"line":218,"address":[],"length":0,"stats":{"Line":5}},{"line":222,"address":[],"length":0,"stats":{"Line":12}},{"line":223,"address":[],"length":0,"stats":{"Line":24}},{"line":224,"address":[],"length":0,"stats":{"Line":3}},{"line":227,"address":[],"length":0,"stats":{"Line":18}},{"line":229,"address":[],"length":0,"stats":{"Line":31}},{"line":230,"address":[],"length":0,"stats":{"Line":11}},{"line":231,"address":[],"length":0,"stats":{"Line":23}},{"line":232,"address":[],"length":0,"stats":{"Line":13}},{"line":233,"address":[],"length":0,"stats":{"Line":8}},{"line":234,"address":[],"length":0,"stats":{"Line":10}},{"line":235,"address":[],"length":0,"stats":{"Line":6}},{"line":239,"address":[],"length":0,"stats":{"Line":27}},{"line":240,"address":[],"length":0,"stats":{"Line":9}}],"covered":106,"coverable":106},{"path":["/","Users","chi","Projects","hu","src","gh","fix","tests.rs"],"content":"use super::*;\nuse crate::gh::client::GithubApi;\nuse crate::gh::types::{CiStatus, PullRequest};\n\n// Mock implementation\nstruct MockGithubApi {\n    branch: String,\n    run_id: Option\u003cu64\u003e,\n    failed_jobs: Vec\u003c(u64, String)\u003e,\n    logs: String,\n    pr_for_branch: Option\u003cu64\u003e,\n}\n\nimpl GithubApi for MockGithubApi {\n    async fn list_user_prs(\u0026self) -\u003e Result\u003cVec\u003cPullRequest\u003e\u003e {\n        Ok(vec![])\n    }\n\n    async fn get_ci_status(\u0026self, _owner: \u0026str, _repo: \u0026str, _pr: u64) -\u003e Result\u003cCiStatus\u003e {\n        Ok(CiStatus::Unknown)\n    }\n\n    async fn get_pr_branch(\u0026self, _owner: \u0026str, _repo: \u0026str, _pr: u64) -\u003e Result\u003cString\u003e {\n        Ok(self.branch.clone())\n    }\n\n    async fn get_latest_failed_run_for_branch(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _branch: \u0026str,\n    ) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n        Ok(self.run_id)\n    }\n\n    async fn get_failed_jobs(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _run_id: u64,\n    ) -\u003e Result\u003cVec\u003c(u64, String)\u003e\u003e {\n        Ok(self.failed_jobs.clone())\n    }\n\n    async fn get_job_logs(\u0026self, _owner: \u0026str, _repo: \u0026str, _job_id: u64) -\u003e Result\u003cString\u003e {\n        Ok(self.logs.clone())\n    }\n\n    async fn find_pr_for_branch(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _branch: \u0026str,\n    ) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n        Ok(self.pr_for_branch)\n    }\n\n    async fn list_workflow_runs(\n        \u0026self,\n        _query: \u0026crate::gh::types::RunsQuery\u003c'_\u003e,\n    ) -\u003e Result\u003cVec\u003ccrate::gh::types::WorkflowRun\u003e\u003e {\n        Ok(vec![])\n    }\n\n    async fn search_prs_by_title(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _query: \u0026str,\n    ) -\u003e Result\u003cVec\u003cPullRequest\u003e\u003e {\n        Ok(vec![])\n    }\n}\n\nfn query(owner: \u0026str, repo: \u0026str) -\u003e FixQuery {\n    FixQuery {\n        owner: owner.to_string(),\n        repo: repo.to_string(),\n        pr: None,\n        run: None,\n        branch: None,\n    }\n}\n\n// build_fix_report tests\n#[tokio::test]\nasync fn build_fix_report_no_runs() {\n    let mock = MockGithubApi {\n        branch: \"main\".to_string(),\n        run_id: None,\n        failed_jobs: vec![],\n        logs: String::new(),\n        pr_for_branch: None,\n    };\n    let mut q = query(\"owner\", \"repo\");\n    q.pr = Some(42);\n    let result = build_fix_report(\u0026mock, \u0026q).await;\n    assert!(result.unwrap().is_none());\n}\n\n#[tokio::test]\nasync fn build_fix_report_no_failed_jobs() {\n    let mock = MockGithubApi {\n        branch: \"main\".to_string(),\n        run_id: Some(100),\n        failed_jobs: vec![],\n        logs: String::new(),\n        pr_for_branch: None,\n    };\n    let mut q = query(\"owner\", \"repo\");\n    q.pr = Some(42);\n    let result = build_fix_report(\u0026mock, \u0026q).await;\n    assert!(result.unwrap().is_none());\n}\n\n#[tokio::test]\nasync fn build_fix_report_no_test_jobs() {\n    let mock = MockGithubApi {\n        branch: \"main\".to_string(),\n        run_id: Some(100),\n        failed_jobs: vec![(1, \"build\".to_string()), (2, \"deploy\".to_string())],\n        logs: String::new(),\n        pr_for_branch: None,\n    };\n    let mut q = query(\"owner\", \"repo\");\n    q.pr = Some(42);\n    let result = build_fix_report(\u0026mock, \u0026q).await;\n    assert!(result.unwrap().is_none());\n}\n\n#[tokio::test]\nasync fn build_fix_report_with_failures() {\n    let mock = MockGithubApi {\n        branch: \"feature\".to_string(),\n        run_id: Some(100),\n        failed_jobs: vec![(1, \"rspec-tests\".to_string())],\n        logs: r#\"\nFailures:\n\n  1) User model validates name\n     Failure/Error: expect(user).to be_valid\n       expected true, got false\n\nFailed examples:\n\nrspec ./spec/models/user_spec.rb:10 # User model validates name\n\"#\n        .to_string(),\n        pr_for_branch: Some(42),\n    };\n\n    let mut q = query(\"owner\", \"repo\");\n    q.pr = Some(42);\n    let result = build_fix_report(\u0026mock, \u0026q).await.unwrap();\n\n    assert!(result.is_some());\n    let report = result.unwrap();\n    assert_eq!(report.repository, \"owner/repo\");\n    assert_eq!(report.pr_number, Some(42));\n    assert_eq!(report.run_id, 100);\n    assert_eq!(report.failures.len(), 1);\n    assert_eq!(report.failures[0].test_file, \"./spec/models/user_spec.rb\");\n    assert_eq!(report.failures[0].language, \"ruby\");\n    assert!(!report.failures[0].source_files.is_empty());\n}\n\n#[tokio::test]\nasync fn build_fix_report_with_run_id() {\n    let mock = MockGithubApi {\n        branch: \"main\".to_string(),\n        run_id: Some(200),\n        failed_jobs: vec![(1, \"test-suite\".to_string())],\n        logs: r#\"\nFailures:\n\n  1) Test fails\n     Failure/Error: fail\n       err\n\nFailed examples:\n\nrspec ./spec/test_spec.rb:5 # Test fails\n\"#\n        .to_string(),\n        pr_for_branch: None,\n    };\n\n    let mut q = query(\"owner\", \"repo\");\n    q.run = Some(200);\n    let result = build_fix_report(\u0026mock, \u0026q).await.unwrap();\n\n    assert!(result.is_some());\n    let report = result.unwrap();\n    assert_eq!(report.run_id, 200);\n    assert!(report.pr_number.is_none());\n}\n\n#[tokio::test]\nasync fn build_fix_report_with_branch() {\n    let mock = MockGithubApi {\n        branch: \"feature-x\".to_string(),\n        run_id: Some(300),\n        failed_jobs: vec![(1, \"rspec\".to_string())],\n        logs: r#\"\nFailures:\n\n  1) Fail\n     Failure/Error: x\n       y\n\nFailed examples:\n\nrspec ./spec/x_spec.rb:1 # Fail\n\"#\n        .to_string(),\n        pr_for_branch: Some(99),\n    };\n\n    let mut q = query(\"o\", \"r\");\n    q.branch = Some(\"feature-x\".to_string());\n    let result = build_fix_report(\u0026mock, \u0026q).await.unwrap();\n\n    assert!(result.is_some());\n    let report = result.unwrap();\n    assert_eq!(report.pr_number, Some(99));\n}\n\n#[tokio::test]\nasync fn build_fix_report_empty_logs() {\n    let mock = MockGithubApi {\n        branch: \"main\".to_string(),\n        run_id: Some(100),\n        failed_jobs: vec![(1, \"test\".to_string())],\n        logs: String::new(),\n        pr_for_branch: None,\n    };\n    let mut q = query(\"o\", \"r\");\n    q.pr = Some(1);\n    let result = build_fix_report(\u0026mock, \u0026q).await.unwrap();\n    assert!(result.is_none());\n}\n\n// FixQuery tests\n#[test]\nfn fix_query_debug() {\n    let q = query(\"owner\", \"repo\");\n    let d = format!(\"{:?}\", q);\n    assert!(d.contains(\"FixQuery\"));\n}\n\n#[test]\nfn fix_query_clone() {\n    let q = query(\"owner\", \"repo\");\n    let c = q.clone();\n    assert_eq!(c.owner, q.owner);\n    assert_eq!(c.repo, q.repo);\n}\n\n// Mock that errors on get_job_logs\nstruct MockGithubApiWithLogError {\n    branch: String,\n    run_id: Option\u003cu64\u003e,\n    failed_jobs: Vec\u003c(u64, String)\u003e,\n    pr_for_branch: Option\u003cu64\u003e,\n}\n\nimpl GithubApi for MockGithubApiWithLogError {\n    async fn list_user_prs(\u0026self) -\u003e Result\u003cVec\u003cPullRequest\u003e\u003e {\n        Ok(vec![])\n    }\n\n    async fn get_ci_status(\u0026self, _owner: \u0026str, _repo: \u0026str, _pr: u64) -\u003e Result\u003cCiStatus\u003e {\n        Ok(CiStatus::Unknown)\n    }\n\n    async fn get_pr_branch(\u0026self, _owner: \u0026str, _repo: \u0026str, _pr: u64) -\u003e Result\u003cString\u003e {\n        Ok(self.branch.clone())\n    }\n\n    async fn get_latest_failed_run_for_branch(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _branch: \u0026str,\n    ) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n        Ok(self.run_id)\n    }\n\n    async fn get_failed_jobs(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _run_id: u64,\n    ) -\u003e Result\u003cVec\u003c(u64, String)\u003e\u003e {\n        Ok(self.failed_jobs.clone())\n    }\n\n    async fn get_job_logs(\u0026self, _owner: \u0026str, _repo: \u0026str, _job_id: u64) -\u003e Result\u003cString\u003e {\n        Err(anyhow::anyhow!(\"Failed to fetch logs\"))\n    }\n\n    async fn find_pr_for_branch(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _branch: \u0026str,\n    ) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n        Ok(self.pr_for_branch)\n    }\n\n    async fn list_workflow_runs(\n        \u0026self,\n        _query: \u0026crate::gh::types::RunsQuery\u003c'_\u003e,\n    ) -\u003e Result\u003cVec\u003ccrate::gh::types::WorkflowRun\u003e\u003e {\n        Ok(vec![])\n    }\n\n    async fn search_prs_by_title(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _query: \u0026str,\n    ) -\u003e Result\u003cVec\u003cPullRequest\u003e\u003e {\n        Ok(vec![])\n    }\n}\n\n#[tokio::test]\nasync fn build_fix_report_handles_log_error() {\n    let mock = MockGithubApiWithLogError {\n        branch: \"main\".to_string(),\n        run_id: Some(100),\n        failed_jobs: vec![(1, \"rspec-tests\".to_string())],\n        pr_for_branch: None,\n    };\n    let mut q = query(\"o\", \"r\");\n    q.pr = Some(1);\n    let result = build_fix_report(\u0026mock, \u0026q).await.unwrap();\n    // Logs failed, so no failures extracted -\u003e None\n    assert!(result.is_none());\n}\n\n#[tokio::test]\nasync fn build_fix_report_uses_current_branch() {\n    // No pr, no run, no branch -\u003e uses get_current_branch()\n    let mock = MockGithubApi {\n        branch: \"main\".to_string(),\n        run_id: None,\n        failed_jobs: vec![],\n        logs: String::new(),\n        pr_for_branch: None,\n    };\n    let q = query(\"o\", \"r\"); // no pr, run, or branch set\n    let result = build_fix_report(\u0026mock, \u0026q).await.unwrap();\n    assert!(result.is_none());\n}\n\n#[tokio::test]\nasync fn build_fix_report_branch_no_runs() {\n    let mock = MockGithubApi {\n        branch: \"main\".to_string(),\n        run_id: None,\n        failed_jobs: vec![],\n        logs: String::new(),\n        pr_for_branch: None,\n    };\n    let mut q = query(\"o\", \"r\");\n    q.branch = Some(\"feature\".to_string());\n    let result = build_fix_report(\u0026mock, \u0026q).await.unwrap();\n    assert!(result.is_none());\n}\n\n// enrich_failures tests\n#[test]\nfn enrich_failures_ruby() {\n    let failures = vec![TestFailure {\n        spec_file: \"./spec/models/user_spec.rb:10\".to_string(),\n        failure_text: \"expected true\".to_string(),\n    }];\n    let enriched = enrich_failures(\u0026failures);\n    assert_eq!(enriched.len(), 1);\n    assert_eq!(enriched[0].language, \"ruby\");\n    assert_eq!(enriched[0].test_file, \"./spec/models/user_spec.rb\");\n    assert!(enriched[0]\n        .source_files\n        .contains(\u0026\"app/models/user.rb\".to_string()));\n}\n\n#[test]\nfn enrich_failures_mixed_languages() {\n    let failures = vec![\n        TestFailure {\n            spec_file: \"spec/user_spec.rb:5\".to_string(),\n            failure_text: \"ruby error\".to_string(),\n        },\n        TestFailure {\n            spec_file: \"tests/test_sync.rs\".to_string(),\n            failure_text: \"rust error\".to_string(),\n        },\n        TestFailure {\n            spec_file: \"Button.test.tsx\".to_string(),\n            failure_text: \"js error\".to_string(),\n        },\n    ];\n    let enriched = enrich_failures(\u0026failures);\n    assert_eq!(enriched.len(), 3);\n    assert_eq!(enriched[0].language, \"ruby\");\n    assert_eq!(enriched[1].language, \"rust\");\n    assert_eq!(enriched[2].language, \"javascript\");\n}\n\n#[test]\nfn enrich_failures_empty() {\n    let enriched = enrich_failures(\u0026[]);\n    assert!(enriched.is_empty());\n}\n\n#[test]\nfn enrich_failures_unknown_language() {\n    let failures = vec![TestFailure {\n        spec_file: \"README.md\".to_string(),\n        failure_text: \"error\".to_string(),\n    }];\n    let enriched = enrich_failures(\u0026failures);\n    assert_eq!(enriched[0].language, \"unknown\");\n    assert!(enriched[0].source_files.is_empty());\n}\n\n// format_markdown tests\n#[test]\nfn format_markdown_basic() {\n    let report = FixReport {\n        repository: \"owner/repo\".to_string(),\n        pr_number: Some(42),\n        run_id: 100,\n        failures: vec![FixFailure {\n            test_file: \"spec/models/user_spec.rb\".to_string(),\n            source_files: vec![\"app/models/user.rb\".to_string()],\n            failure_text: \"expected true\".to_string(),\n            language: \"ruby\".to_string(),\n        }],\n        test_files: vec![\"spec/models/user_spec.rb\".to_string()],\n        source_files: vec![\"app/models/user.rb\".to_string()],\n    };\n\n    let md = format_markdown(\u0026report);\n    assert!(md.contains(\"# Fix Report: owner/repo\"));\n    assert!(md.contains(\"**PR:** #42\"));\n    assert!(md.contains(\"**Run:** 100\"));\n    assert!(md.contains(\"## spec/models/user_spec.rb\"));\n    assert!(md.contains(\"**Language:** ruby\"));\n    assert!(md.contains(\"`app/models/user.rb`\"));\n    assert!(md.contains(\"expected true\"));\n    assert!(md.contains(\"bundle exec rspec\"));\n}\n\n#[test]\nfn format_markdown_no_pr() {\n    let report = FixReport {\n        repository: \"o/r\".to_string(),\n        pr_number: None,\n        run_id: 1,\n        failures: vec![],\n        test_files: vec![],\n        source_files: vec![],\n    };\n\n    let md = format_markdown(\u0026report);\n    assert!(!md.contains(\"**PR:**\"));\n    assert!(md.contains(\"**Run:** 1\"));\n}\n\n#[test]\nfn format_markdown_multiple_failures() {\n    let report = FixReport {\n        repository: \"o/r\".to_string(),\n        pr_number: Some(1),\n        run_id: 1,\n        failures: vec![\n            FixFailure {\n                test_file: \"spec/a_spec.rb\".to_string(),\n                source_files: vec![\"app/a.rb\".to_string()],\n                failure_text: \"err1\".to_string(),\n                language: \"ruby\".to_string(),\n            },\n            FixFailure {\n                test_file: \"tests/test_b.rs\".to_string(),\n                source_files: vec![\"src/b.rs\".to_string()],\n                failure_text: \"err2\".to_string(),\n                language: \"rust\".to_string(),\n            },\n        ],\n        test_files: vec![\"spec/a_spec.rb\".to_string(), \"tests/test_b.rs\".to_string()],\n        source_files: vec![\"app/a.rb\".to_string(), \"src/b.rs\".to_string()],\n    };\n\n    let md = format_markdown(\u0026report);\n    assert!(md.contains(\"## spec/a_spec.rb\"));\n    assert!(md.contains(\"## tests/test_b.rs\"));\n    assert!(md.contains(\"bundle exec rspec\"));\n    assert!(md.contains(\"cargo test\"));\n}\n\n// format_rerun_commands tests\n#[test]\nfn format_rerun_commands_ruby() {\n    let failures = vec![FixFailure {\n        test_file: \"spec/user_spec.rb\".to_string(),\n        source_files: vec![],\n        failure_text: String::new(),\n        language: \"ruby\".to_string(),\n    }];\n    let cmds = format_rerun_commands(\u0026failures);\n    assert!(cmds.contains(\"bundle exec rspec spec/user_spec.rb\"));\n}\n\n#[test]\nfn format_rerun_commands_rust() {\n    let failures = vec![FixFailure {\n        test_file: \"tests/test_sync.rs\".to_string(),\n        source_files: vec![],\n        failure_text: String::new(),\n        language: \"rust\".to_string(),\n    }];\n    let cmds = format_rerun_commands(\u0026failures);\n    assert!(cmds.contains(\"cargo test tests/test_sync.rs\"));\n}\n\n#[test]\nfn format_rerun_commands_python() {\n    let failures = vec![FixFailure {\n        test_file: \"tests/test_utils.py\".to_string(),\n        source_files: vec![],\n        failure_text: String::new(),\n        language: \"python\".to_string(),\n    }];\n    let cmds = format_rerun_commands(\u0026failures);\n    assert!(cmds.contains(\"pytest tests/test_utils.py\"));\n}\n\n#[test]\nfn format_rerun_commands_javascript() {\n    let failures = vec![FixFailure {\n        test_file: \"Button.test.tsx\".to_string(),\n        source_files: vec![],\n        failure_text: String::new(),\n        language: \"javascript\".to_string(),\n    }];\n    let cmds = format_rerun_commands(\u0026failures);\n    assert!(cmds.contains(\"npx jest Button.test.tsx\"));\n}\n\n#[test]\nfn format_rerun_commands_unknown() {\n    let failures = vec![FixFailure {\n        test_file: \"foo.go\".to_string(),\n        source_files: vec![],\n        failure_text: String::new(),\n        language: \"unknown\".to_string(),\n    }];\n    let cmds = format_rerun_commands(\u0026failures);\n    assert!(cmds.contains(\"# run foo.go\"));\n}\n\n#[test]\nfn format_rerun_commands_empty() {\n    let cmds = format_rerun_commands(\u0026[]);\n    assert!(cmds.is_empty());\n}\n\n#[test]\nfn format_rerun_commands_mixed() {\n    let failures = vec![\n        FixFailure {\n            test_file: \"spec/a_spec.rb\".to_string(),\n            source_files: vec![],\n            failure_text: String::new(),\n            language: \"ruby\".to_string(),\n        },\n        FixFailure {\n            test_file: \"app.test.js\".to_string(),\n            source_files: vec![],\n            failure_text: String::new(),\n            language: \"javascript\".to_string(),\n        },\n    ];\n    let cmds = format_rerun_commands(\u0026failures);\n    assert!(cmds.contains(\"bundle exec rspec\"));\n    assert!(cmds.contains(\"npx jest\"));\n}\n\n// JSON output test\n#[test]\nfn fix_report_json_output() {\n    let report = FixReport {\n        repository: \"owner/repo\".to_string(),\n        pr_number: Some(42),\n        run_id: 100,\n        failures: vec![FixFailure {\n            test_file: \"spec/user_spec.rb\".to_string(),\n            source_files: vec![\"app/user.rb\".to_string()],\n            failure_text: \"error\".to_string(),\n            language: \"ruby\".to_string(),\n        }],\n        test_files: vec![\"spec/user_spec.rb\".to_string()],\n        source_files: vec![\"app/user.rb\".to_string()],\n    };\n\n    let json = serde_json::to_string_pretty(\u0026report).unwrap();\n    assert!(json.contains(\"\\\"repository\\\": \\\"owner/repo\\\"\"));\n    assert!(json.contains(\"\\\"pr_number\\\": 42\"));\n    assert!(json.contains(\"\\\"run_id\\\": 100\"));\n    assert!(json.contains(\"\\\"test_file\\\": \\\"spec/user_spec.rb\\\"\"));\n    assert!(json.contains(\"\\\"language\\\": \\\"ruby\\\"\"));\n}\n\n// output_report tests\n#[test]\nfn output_report_json() {\n    let report = FixReport {\n        repository: \"o/r\".to_string(),\n        pr_number: None,\n        run_id: 1,\n        failures: vec![],\n        test_files: vec![],\n        source_files: vec![],\n    };\n    let result = output_report(\u0026report, true);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_report_markdown() {\n    let report = FixReport {\n        repository: \"o/r\".to_string(),\n        pr_number: None,\n        run_id: 1,\n        failures: vec![],\n        test_files: vec![],\n        source_files: vec![],\n    };\n    let result = output_report(\u0026report, false);\n    assert!(result.is_ok());\n}\n\n// format_markdown edge cases\n#[test]\nfn format_markdown_no_source_files() {\n    let report = FixReport {\n        repository: \"o/r\".to_string(),\n        pr_number: None,\n        run_id: 1,\n        failures: vec![FixFailure {\n            test_file: \"README.md\".to_string(),\n            source_files: vec![],\n            failure_text: \"err\".to_string(),\n            language: \"unknown\".to_string(),\n        }],\n        test_files: vec![\"README.md\".to_string()],\n        source_files: vec![],\n    };\n\n    let md = format_markdown(\u0026report);\n    assert!(!md.contains(\"Source Files to Investigate\"));\n    assert!(!md.contains(\"**Source files:**\"));\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":10}},{"line":24,"address":[],"length":0,"stats":{"Line":5}},{"line":27,"address":[],"length":0,"stats":{"Line":8}},{"line":33,"address":[],"length":0,"stats":{"Line":8}},{"line":36,"address":[],"length":0,"stats":{"Line":6}},{"line":42,"address":[],"length":0,"stats":{"Line":6}},{"line":45,"address":[],"length":0,"stats":{"Line":8}},{"line":46,"address":[],"length":0,"stats":{"Line":4}},{"line":49,"address":[],"length":0,"stats":{"Line":3}},{"line":55,"address":[],"length":0,"stats":{"Line":3}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":12}},{"line":77,"address":[],"length":0,"stats":{"Line":36}},{"line":78,"address":[],"length":0,"stats":{"Line":36}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":2}},{"line":277,"address":[],"length":0,"stats":{"Line":1}},{"line":280,"address":[],"length":0,"stats":{"Line":1}},{"line":286,"address":[],"length":0,"stats":{"Line":1}},{"line":289,"address":[],"length":0,"stats":{"Line":1}},{"line":295,"address":[],"length":0,"stats":{"Line":1}},{"line":298,"address":[],"length":0,"stats":{"Line":2}},{"line":299,"address":[],"length":0,"stats":{"Line":1}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}}],"covered":21,"coverable":39},{"path":["/","Users","chi","Projects","hu","src","gh","helpers.rs"],"content":"use anyhow::{Context, Result};\n\n/// Parse owner/repo from command line argument\npub fn parse_owner_repo(repo: \u0026str) -\u003e Result\u003c(String, String)\u003e {\n    let parts: Vec\u003c\u0026str\u003e = repo.split('/').collect();\n    if parts.len() != 2 {\n        anyhow::bail!(\"Invalid repo format. Expected owner/repo, got: {}\", repo);\n    }\n    Ok((parts[0].to_string(), parts[1].to_string()))\n}\n\n/// Get owner/repo from git remote\npub fn get_current_repo() -\u003e Result\u003c(String, String)\u003e {\n    let output = run_git_command(\u0026[\"remote\", \"get-url\", \"origin\"])?;\n    parse_github_url(output.trim())\n}\n\n/// Run a git command and return stdout\npub fn run_git_command(args: \u0026[\u0026str]) -\u003e Result\u003cString\u003e {\n    let output = std::process::Command::new(\"git\")\n        .args(args)\n        .output()\n        .context(\"Failed to run git command\")?;\n\n    Ok(String::from_utf8_lossy(\u0026output.stdout).to_string())\n}\n\n/// Parse GitHub URL to extract owner/repo\npub fn parse_github_url(url: \u0026str) -\u003e Result\u003c(String, String)\u003e {\n    let url = url.trim_end_matches(\".git\").trim_end_matches('/');\n\n    if url.contains(\"github.com:\") {\n        // SSH format: git@github.com:owner/repo.git\n        let parts: Vec\u003c\u0026str\u003e = url.split(':').collect();\n        if let Some(path) = parts.last() {\n            let segments: Vec\u003c\u0026str\u003e = path.split('/').collect();\n            if segments.len() \u003e= 2 {\n                return Ok((\n                    segments[segments.len() - 2].to_string(),\n                    segments[segments.len() - 1].to_string(),\n                ));\n            }\n        }\n    } else if url.contains(\"github.com/\") {\n        // HTTPS format: https://github.com/owner/repo.git\n        let parts: Vec\u003c\u0026str\u003e = url.split(\"github.com/\").collect();\n        if let Some(path) = parts.last() {\n            let segments: Vec\u003c\u0026str\u003e = path.split('/').collect();\n            if segments.len() \u003e= 2 {\n                return Ok((segments[0].to_string(), segments[1].to_string()));\n            }\n        }\n    }\n\n    anyhow::bail!(\"Could not parse GitHub URL: {}\", url)\n}\n\n/// Check if a job name is test-related\npub fn is_test_job(name: \u0026str) -\u003e bool {\n    let name_lower = name.to_lowercase();\n    name_lower.contains(\"rspec\") || name_lower.contains(\"test\") || name_lower.contains(\"spec\")\n}\n\n/// Get current git branch name\npub fn get_current_branch() -\u003e Result\u003cString\u003e {\n    let branch = run_git_command(\u0026[\"branch\", \"--show-current\"])?;\n    let branch = branch.trim().to_string();\n    if branch.is_empty() {\n        anyhow::bail!(\"Not on a branch. Use --pr or --branch to specify.\");\n    }\n    Ok(branch)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // parse_github_url tests\n    #[test]\n    fn parse_ssh_url() {\n        let (owner, repo) = parse_github_url(\"git@github.com:owner/repo.git\").unwrap();\n        assert_eq!(owner, \"owner\");\n        assert_eq!(repo, \"repo\");\n    }\n\n    #[test]\n    fn parse_https_url() {\n        let (owner, repo) = parse_github_url(\"https://github.com/owner/repo.git\").unwrap();\n        assert_eq!(owner, \"owner\");\n        assert_eq!(repo, \"repo\");\n    }\n\n    #[test]\n    fn parse_https_url_no_git_suffix() {\n        let (owner, repo) = parse_github_url(\"https://github.com/owner/repo\").unwrap();\n        assert_eq!(owner, \"owner\");\n        assert_eq!(repo, \"repo\");\n    }\n\n    #[test]\n    fn parse_ssh_url_no_git_suffix() {\n        let (owner, repo) = parse_github_url(\"git@github.com:owner/repo\").unwrap();\n        assert_eq!(owner, \"owner\");\n        assert_eq!(repo, \"repo\");\n    }\n\n    #[test]\n    fn parse_https_url_trailing_slash() {\n        let (owner, repo) = parse_github_url(\"https://github.com/owner/repo/\").unwrap();\n        assert_eq!(owner, \"owner\");\n        assert_eq!(repo, \"repo\");\n    }\n\n    #[test]\n    fn parse_github_url_invalid() {\n        assert!(parse_github_url(\"not-a-github-url\").is_err());\n        assert!(parse_github_url(\"https://gitlab.com/owner/repo\").is_err());\n        assert!(parse_github_url(\"\").is_err());\n    }\n\n    #[test]\n    fn parse_github_url_ssh_with_org() {\n        let (owner, repo) = parse_github_url(\"git@github.com:my-org/my-repo.git\").unwrap();\n        assert_eq!(owner, \"my-org\");\n        assert_eq!(repo, \"my-repo\");\n    }\n\n    #[test]\n    fn parse_github_url_empty_string() {\n        assert!(parse_github_url(\"\").is_err());\n    }\n\n    #[test]\n    fn parse_github_url_missing_repo() {\n        assert!(parse_github_url(\"git@github.com:owner\").is_err());\n    }\n\n    // parse_owner_repo tests\n    #[test]\n    fn parse_owner_repo_valid() {\n        let (owner, repo) = parse_owner_repo(\"owner/repo\").unwrap();\n        assert_eq!(owner, \"owner\");\n        assert_eq!(repo, \"repo\");\n    }\n\n    #[test]\n    fn parse_owner_repo_with_dashes() {\n        let (owner, repo) = parse_owner_repo(\"my-org/my-repo\").unwrap();\n        assert_eq!(owner, \"my-org\");\n        assert_eq!(repo, \"my-repo\");\n    }\n\n    #[test]\n    fn parse_owner_repo_invalid_no_slash() {\n        assert!(parse_owner_repo(\"noslash\").is_err());\n    }\n\n    #[test]\n    fn parse_owner_repo_invalid_too_many_slashes() {\n        assert!(parse_owner_repo(\"a/b/c\").is_err());\n    }\n\n    #[test]\n    fn parse_owner_repo_invalid_empty() {\n        assert!(parse_owner_repo(\"\").is_err());\n    }\n\n    // is_test_job tests\n    #[test]\n    fn is_test_job_rspec() {\n        assert!(is_test_job(\"run-rspec-tests\"));\n        assert!(is_test_job(\"RSpec\"));\n    }\n\n    #[test]\n    fn is_test_job_test() {\n        assert!(is_test_job(\"unit-tests\"));\n        assert!(is_test_job(\"Test Suite\"));\n    }\n\n    #[test]\n    fn is_test_job_spec() {\n        assert!(is_test_job(\"run-specs\"));\n        assert!(is_test_job(\"Spec Runner\"));\n    }\n\n    #[test]\n    fn is_test_job_non_test() {\n        assert!(!is_test_job(\"build\"));\n        assert!(!is_test_job(\"deploy\"));\n        assert!(!is_test_job(\"lint\"));\n    }\n\n    #[test]\n    fn is_test_job_mixed_case() {\n        assert!(is_test_job(\"RSPEC\"));\n        assert!(is_test_job(\"TEST\"));\n        assert!(is_test_job(\"SPEC\"));\n    }\n\n    #[test]\n    fn is_test_job_partial_names() {\n        assert!(is_test_job(\"run-rspec-tests (3, 0)\"));\n        assert!(is_test_job(\"unit-test-suite\"));\n        assert!(is_test_job(\"integration-spec\"));\n    }\n\n    // run_git_command test\n    #[test]\n    fn run_git_command_version() {\n        let result = run_git_command(\u0026[\"--version\"]);\n        assert!(result.is_ok());\n        assert!(result.unwrap().contains(\"git version\"));\n    }\n\n    // get_current_repo test\n    #[test]\n    fn get_current_repo_returns_result() {\n        let result = get_current_repo();\n        assert!(result.is_ok() || result.is_err());\n    }\n\n    // get_current_branch test\n    #[test]\n    fn get_current_branch_returns_result() {\n        let result = get_current_branch();\n        // In a git repo on a branch, it should succeed\n        assert!(result.is_ok() || result.is_err());\n    }\n}\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":5}},{"line":5,"address":[],"length":0,"stats":{"Line":25}},{"line":6,"address":[],"length":0,"stats":{"Line":5}},{"line":7,"address":[],"length":0,"stats":{"Line":6}},{"line":9,"address":[],"length":0,"stats":{"Line":6}},{"line":13,"address":[],"length":0,"stats":{"Line":1}},{"line":14,"address":[],"length":0,"stats":{"Line":3}},{"line":15,"address":[],"length":0,"stats":{"Line":2}},{"line":19,"address":[],"length":0,"stats":{"Line":4}},{"line":20,"address":[],"length":0,"stats":{"Line":12}},{"line":21,"address":[],"length":0,"stats":{"Line":4}},{"line":25,"address":[],"length":0,"stats":{"Line":4}},{"line":29,"address":[],"length":0,"stats":{"Line":12}},{"line":30,"address":[],"length":0,"stats":{"Line":36}},{"line":32,"address":[],"length":0,"stats":{"Line":24}},{"line":34,"address":[],"length":0,"stats":{"Line":25}},{"line":35,"address":[],"length":0,"stats":{"Line":10}},{"line":36,"address":[],"length":0,"stats":{"Line":25}},{"line":37,"address":[],"length":0,"stats":{"Line":5}},{"line":38,"address":[],"length":0,"stats":{"Line":4}},{"line":39,"address":[],"length":0,"stats":{"Line":16}},{"line":40,"address":[],"length":0,"stats":{"Line":8}},{"line":44,"address":[],"length":0,"stats":{"Line":14}},{"line":46,"address":[],"length":0,"stats":{"Line":15}},{"line":47,"address":[],"length":0,"stats":{"Line":6}},{"line":48,"address":[],"length":0,"stats":{"Line":15}},{"line":49,"address":[],"length":0,"stats":{"Line":3}},{"line":50,"address":[],"length":0,"stats":{"Line":9}},{"line":55,"address":[],"length":0,"stats":{"Line":10}},{"line":59,"address":[],"length":0,"stats":{"Line":30}},{"line":60,"address":[],"length":0,"stats":{"Line":90}},{"line":61,"address":[],"length":0,"stats":{"Line":62}},{"line":65,"address":[],"length":0,"stats":{"Line":2}},{"line":66,"address":[],"length":0,"stats":{"Line":6}},{"line":67,"address":[],"length":0,"stats":{"Line":6}},{"line":68,"address":[],"length":0,"stats":{"Line":4}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":2}}],"covered":37,"coverable":38},{"path":["/","Users","chi","Projects","hu","src","gh","login.rs"],"content":"use anyhow::Result;\n\nuse super::auth;\nuse super::cli::LoginArgs;\n\n/// Handle the `hu gh login` command\npub async fn run(args: LoginArgs) -\u003e Result\u003c()\u003e {\n    let username = auth::login(\u0026args.token).await?;\n    println!(\"{}\", format_login_success(\u0026username));\n    Ok(())\n}\n\n/// Format the login success message (extracted for testability)\npub fn format_login_success(username: \u0026str) -\u003e String {\n    format!(\" Logged in as {}\", username)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn format_login_success_includes_username() {\n        let msg = format_login_success(\"testuser\");\n        assert!(msg.contains(\"testuser\"));\n        assert!(msg.contains(\"\"));\n        assert!(msg.contains(\"Logged in as\"));\n    }\n\n    #[test]\n    fn format_login_success_handles_special_chars() {\n        let msg = format_login_success(\"user-name_123\");\n        assert!(msg.contains(\"user-name_123\"));\n    }\n\n    #[test]\n    fn login_args_has_token_field() {\n        let args = LoginArgs {\n            token: \"test_token\".to_string(),\n        };\n        assert_eq!(args.token, \"test_token\");\n    }\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":2}},{"line":15,"address":[],"length":0,"stats":{"Line":4}}],"covered":2,"coverable":6},{"path":["/","Users","chi","Projects","hu","src","gh","mod.rs"],"content":"//! GitHub integration\n//!\n//! # CLI Usage\n//! Use [`run_command`] for CLI commands that format and print output.\n//!\n//! # Programmatic Usage (MCP/HTTP)\n//! Use the reusable functions that return typed data:\n//! - [`list_user_prs`] - List open PRs by current user\n//! - [`get_ci_status`] - Get CI status for a PR\n//! - [`list_workflow_runs`] - List workflow runs\n//! - [`search_prs`] - Search PRs by title/branch\n\nmod auth;\nmod cli;\nmod client;\nmod failures;\nmod fix;\nmod helpers;\nmod login;\nmod prs;\nmod runs;\nmod service;\nmod sync;\nmod types;\n\nuse anyhow::Result;\n\npub use cli::GhCommand;\npub use types::{CiStatus, PullRequest, RunsQuery, WorkflowRun};\n\n/// Run a GitHub command (CLI entry point - formats and prints)\n#[cfg(not(tarpaulin_include))]\npub async fn run_command(cmd: GhCommand) -\u003e anyhow::Result\u003c()\u003e {\n    match cmd {\n        GhCommand::Login(args) =\u003e login::run(args).await,\n        GhCommand::Prs =\u003e prs::run().await,\n        GhCommand::Failures(args) =\u003e failures::run(args).await,\n        GhCommand::Fix(args) =\u003e fix::run(args).await,\n        GhCommand::Runs(args) =\u003e runs::run(args).await,\n        GhCommand::Sync(args) =\u003e sync::run(args),\n    }\n}\n\n// ============================================================================\n// Reusable functions for MCP/HTTP - return typed data, never print\n// ============================================================================\n\n/// List open PRs authored by the current user (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn list_user_prs() -\u003e Result\u003cVec\u003cPullRequest\u003e\u003e {\n    let client = service::create_client()?;\n    service::list_user_prs(\u0026client).await\n}\n\n/// Get CI status for a PR (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn get_ci_status(owner: \u0026str, repo: \u0026str, pr_number: u64) -\u003e Result\u003cCiStatus\u003e {\n    let client = service::create_client()?;\n    service::get_ci_status(\u0026client, owner, repo, pr_number).await\n}\n\n/// List workflow runs for a repository (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn list_workflow_runs(query: \u0026RunsQuery\u003c'_\u003e) -\u003e Result\u003cVec\u003cWorkflowRun\u003e\u003e {\n    let client = service::create_client()?;\n    service::list_workflow_runs(\u0026client, query).await\n}\n\n/// Search PRs by title/branch (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn search_prs(owner: \u0026str, repo: \u0026str, query: \u0026str) -\u003e Result\u003cVec\u003cPullRequest\u003e\u003e {\n    let client = service::create_client()?;\n    service::search_prs(\u0026client, owner, repo, query).await\n}\n\n/// Find PR number for a branch (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn find_pr_for_branch(owner: \u0026str, repo: \u0026str, branch: \u0026str) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n    let client = service::create_client()?;\n    service::find_pr_for_branch(\u0026client, owner, repo, branch).await\n}\n\n/// Get failed jobs for a workflow run (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn get_failed_jobs(owner: \u0026str, repo: \u0026str, run_id: u64) -\u003e Result\u003cVec\u003c(u64, String)\u003e\u003e {\n    let client = service::create_client()?;\n    service::get_failed_jobs(\u0026client, owner, repo, run_id).await\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn gh_command_exported() {\n        // Verify GhCommand is accessible\n        let _ = std::any::type_name::\u003cGhCommand\u003e();\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":2}},{"line":16,"address":[],"length":0,"stats":{"Line":1}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":1}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}}],"covered":3,"coverable":8},{"path":["/","Users","chi","Projects","hu","src","gh","prs.rs"],"content":"use anyhow::Result;\n\nuse super::client::{GithubApi, GithubClient};\nuse super::types::CiStatus;\n\n// ANSI color codes\nconst GREEN: \u0026str = \"\\x1b[32m\";\nconst YELLOW: \u0026str = \"\\x1b[33m\";\nconst RED: \u0026str = \"\\x1b[31m\";\nconst GRAY: \u0026str = \"\\x1b[90m\";\nconst RESET: \u0026str = \"\\x1b[0m\";\n\n/// Handle the `hu gh prs` command\npub async fn run() -\u003e Result\u003c()\u003e {\n    let client = GithubClient::new()?;\n    run_with_client(\u0026client).await\n}\n\nfn get_terminal_width() -\u003e usize {\n    terminal_size::terminal_size()\n        .map(|(w, _)| w.0 as usize)\n        .unwrap_or(80)\n}\n\nfn print_prs_table(prs: \u0026[super::types::PullRequest]) {\n    let term_width = get_terminal_width();\n\n    // Calculate max link length\n    let max_link_len = prs.iter().map(|p| p.html_url.len()).max().unwrap_or(40);\n\n    // Layout:  S  Title...  Link \n    // Borders take: 1 + 1 + 3 + 3 + 1 = 9 chars ( S  ...  ... )\n    let status_col = 1;\n    let border_overhead = 10; // \" \" + \"  \" + \"  \" + \"\"\n\n    let available = term_width.saturating_sub(border_overhead + status_col + max_link_len);\n    let title_width = available.max(20);\n    let link_width = max_link_len;\n\n    // Top border\n    println!(\n        \"{}{}\",\n        \"\".repeat(title_width + 2),\n        \"\".repeat(link_width + 2)\n    );\n\n    // Rows\n    for pr in prs {\n        let status_icon = match pr.ci_status.unwrap_or(CiStatus::Unknown) {\n            CiStatus::Success =\u003e format!(\"{}{}{}\", GREEN, \"\", RESET),\n            CiStatus::Pending =\u003e format!(\"{}{}{}\", YELLOW, \"\", RESET),\n            CiStatus::Failed =\u003e format!(\"{}{}{}\", RED, \"\", RESET),\n            CiStatus::Unknown =\u003e format!(\"{}{}{}\", GRAY, \"\", RESET),\n        };\n\n        let title = truncate(\u0026pr.title, title_width);\n        let link = format!(\"{}{}{}\", GRAY, \u0026pr.html_url, RESET);\n\n        println!(\n            \" {}  {:\u003cwidth$}  {} \",\n            status_icon,\n            title,\n            link,\n            width = title_width\n        );\n    }\n\n    // Bottom border\n    println!(\n        \"{}{}\",\n        \"\".repeat(title_width + 2),\n        \"\".repeat(link_width + 2)\n    );\n}\n\nfn truncate(s: \u0026str, max_len: usize) -\u003e String {\n    if s.chars().count() \u003c= max_len {\n        s.to_string()\n    } else {\n        let truncated: String = s.chars().take(max_len.saturating_sub(1)).collect();\n        format!(\"{}\", truncated)\n    }\n}\n\n/// Fetch and display PRs using the given API client\npub async fn run_with_client(client: \u0026impl GithubApi) -\u003e Result\u003c()\u003e {\n    let mut prs = client.list_user_prs().await?;\n\n    if prs.is_empty() {\n        println!(\"No open pull requests found.\");\n        return Ok(());\n    }\n\n    // Fetch CI status for each PR\n    for pr in \u0026mut prs {\n        let parts: Vec\u003c\u0026str\u003e = pr.repo_full_name.split('/').collect();\n        if parts.len() == 2 {\n            if let Ok(status) = client.get_ci_status(parts[0], parts[1], pr.number).await {\n                pr.ci_status = Some(status);\n            }\n        }\n    }\n\n    print_prs_table(\u0026prs);\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::gh::types::PullRequest;\n\n    #[test]\n    fn truncate_short_string() {\n        assert_eq!(truncate(\"hello\", 10), \"hello\");\n    }\n\n    #[test]\n    fn truncate_long_string() {\n        assert_eq!(truncate(\"hello world\", 8), \"hello w\");\n    }\n\n    #[test]\n    fn truncate_exact_length() {\n        assert_eq!(truncate(\"hello\", 5), \"hello\");\n    }\n\n    #[test]\n    fn truncate_unicode() {\n        // Unicode chars are counted by char, not byte\n        assert_eq!(truncate(\"hllo\", 5), \"hllo\");\n        assert_eq!(truncate(\"hllo world\", 6), \"hllo\");\n    }\n\n    #[test]\n    fn truncate_empty() {\n        assert_eq!(truncate(\"\", 10), \"\");\n    }\n\n    #[test]\n    fn truncate_zero_length() {\n        // Edge case: max_len = 0 means we try to take 0 chars + ellipsis\n        // saturating_sub(1) on 0 = 0, so we get just \"\" if string is not empty\n        let result = truncate(\"hello\", 0);\n        // With max_len=0, chars.count()=5 \u003e 0, so we truncate\n        // take(0.saturating_sub(1)) = take(0), so we get \"\" + \"\" = \"\"\n        assert_eq!(result, \"\");\n    }\n\n    #[test]\n    fn status_icons_render() {\n        let _ = format!(\"{}{}\", GREEN, RESET);\n        let _ = format!(\"{}{}\", YELLOW, RESET);\n        let _ = format!(\"{}{}\", RED, RESET);\n    }\n\n    #[test]\n    fn get_terminal_width_returns_reasonable_value() {\n        let width = get_terminal_width();\n        // Should return at least 80 (default) or actual terminal width\n        assert!(width \u003e= 20);\n    }\n\n    #[test]\n    fn status_icon_formatting_success() {\n        let icon = format!(\"{}{}{}\", GREEN, \"\", RESET);\n        assert!(icon.contains(\"\"));\n        assert!(icon.starts_with(\"\\x1b[32m\"));\n        assert!(icon.ends_with(\"\\x1b[0m\"));\n    }\n\n    #[test]\n    fn status_icon_formatting_pending() {\n        let icon = format!(\"{}{}{}\", YELLOW, \"\", RESET);\n        assert!(icon.contains(\"\"));\n    }\n\n    #[test]\n    fn status_icon_formatting_failed() {\n        let icon = format!(\"{}{}{}\", RED, \"\", RESET);\n        assert!(icon.contains(\"\"));\n    }\n\n    #[test]\n    fn status_icon_formatting_unknown() {\n        let icon = format!(\"{}{}{}\", GRAY, \"\", RESET);\n        assert!(icon.contains(\"\"));\n    }\n\n    #[test]\n    fn print_prs_table_renders_without_panic() {\n        let prs = vec![\n            PullRequest {\n                number: 1,\n                title: \"Short title\".to_string(),\n                html_url: \"https://github.com/o/r/pull/1\".to_string(),\n                state: \"open\".to_string(),\n                repo_full_name: \"o/r\".to_string(),\n                created_at: \"2024-01-01T00:00:00Z\".to_string(),\n                updated_at: \"2024-01-01T00:00:00Z\".to_string(),\n                ci_status: Some(CiStatus::Success),\n            },\n            PullRequest {\n                number: 2,\n                title: \"A very long title that will definitely need truncation because it exceeds the available width\".to_string(),\n                html_url: \"https://github.com/owner/repo/pull/2\".to_string(),\n                state: \"open\".to_string(),\n                repo_full_name: \"owner/repo\".to_string(),\n                created_at: \"2024-01-01T00:00:00Z\".to_string(),\n                updated_at: \"2024-01-01T00:00:00Z\".to_string(),\n                ci_status: Some(CiStatus::Failed),\n            },\n            PullRequest {\n                number: 3,\n                title: \"Pending PR\".to_string(),\n                html_url: \"https://github.com/o/r/pull/3\".to_string(),\n                state: \"open\".to_string(),\n                repo_full_name: \"o/r\".to_string(),\n                created_at: \"2024-01-01T00:00:00Z\".to_string(),\n                updated_at: \"2024-01-01T00:00:00Z\".to_string(),\n                ci_status: Some(CiStatus::Pending),\n            },\n            PullRequest {\n                number: 4,\n                title: \"Unknown status\".to_string(),\n                html_url: \"https://github.com/o/r/pull/4\".to_string(),\n                state: \"open\".to_string(),\n                repo_full_name: \"o/r\".to_string(),\n                created_at: \"2024-01-01T00:00:00Z\".to_string(),\n                updated_at: \"2024-01-01T00:00:00Z\".to_string(),\n                ci_status: None,\n            },\n        ];\n        // This just verifies it doesn't panic\n        print_prs_table(\u0026prs);\n    }\n\n    #[test]\n    fn print_prs_table_empty_list() {\n        let prs: Vec\u003cPullRequest\u003e = vec![];\n        print_prs_table(\u0026prs);\n    }\n\n    // Mock implementation for testing\n    struct MockGithubApi {\n        prs: Vec\u003cPullRequest\u003e,\n        ci_status: CiStatus,\n    }\n\n    impl GithubApi for MockGithubApi {\n        async fn list_user_prs(\u0026self) -\u003e Result\u003cVec\u003cPullRequest\u003e\u003e {\n            Ok(self.prs.clone())\n        }\n\n        async fn get_ci_status(\u0026self, _owner: \u0026str, _repo: \u0026str, _pr: u64) -\u003e Result\u003cCiStatus\u003e {\n            Ok(self.ci_status)\n        }\n\n        async fn get_pr_branch(\u0026self, _owner: \u0026str, _repo: \u0026str, _pr: u64) -\u003e Result\u003cString\u003e {\n            Ok(\"main\".to_string())\n        }\n\n        async fn get_latest_failed_run_for_branch(\n            \u0026self,\n            _owner: \u0026str,\n            _repo: \u0026str,\n            _branch: \u0026str,\n        ) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n            Ok(None)\n        }\n\n        async fn get_failed_jobs(\n            \u0026self,\n            _owner: \u0026str,\n            _repo: \u0026str,\n            _run_id: u64,\n        ) -\u003e Result\u003cVec\u003c(u64, String)\u003e\u003e {\n            Ok(vec![])\n        }\n\n        async fn get_job_logs(\u0026self, _owner: \u0026str, _repo: \u0026str, _job_id: u64) -\u003e Result\u003cString\u003e {\n            Ok(String::new())\n        }\n\n        async fn find_pr_for_branch(\n            \u0026self,\n            _owner: \u0026str,\n            _repo: \u0026str,\n            _branch: \u0026str,\n        ) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n            Ok(None)\n        }\n\n        async fn list_workflow_runs(\n            \u0026self,\n            _query: \u0026crate::gh::types::RunsQuery\u003c'_\u003e,\n        ) -\u003e Result\u003cVec\u003ccrate::gh::types::WorkflowRun\u003e\u003e {\n            Ok(vec![])\n        }\n\n        async fn search_prs_by_title(\n            \u0026self,\n            _owner: \u0026str,\n            _repo: \u0026str,\n            _query: \u0026str,\n        ) -\u003e Result\u003cVec\u003ccrate::gh::types::PullRequest\u003e\u003e {\n            Ok(vec![])\n        }\n    }\n\n    #[tokio::test]\n    async fn run_with_client_empty_prs() {\n        let mock = MockGithubApi {\n            prs: vec![],\n            ci_status: CiStatus::Unknown,\n        };\n        let result = run_with_client(\u0026mock).await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn run_with_client_with_prs() {\n        let mock = MockGithubApi {\n            prs: vec![PullRequest {\n                number: 1,\n                title: \"Test PR\".to_string(),\n                html_url: \"https://github.com/o/r/pull/1\".to_string(),\n                state: \"open\".to_string(),\n                repo_full_name: \"o/r\".to_string(),\n                created_at: \"2024-01-01T00:00:00Z\".to_string(),\n                updated_at: \"2024-01-01T00:00:00Z\".to_string(),\n                ci_status: None,\n            }],\n            ci_status: CiStatus::Success,\n        };\n        let result = run_with_client(\u0026mock).await;\n        assert!(result.is_ok());\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":2}},{"line":15,"address":[],"length":0,"stats":{"Line":2}},{"line":16,"address":[],"length":0,"stats":{"Line":2}},{"line":19,"address":[],"length":0,"stats":{"Line":4}},{"line":20,"address":[],"length":0,"stats":{"Line":4}},{"line":21,"address":[],"length":0,"stats":{"Line":4}},{"line":25,"address":[],"length":0,"stats":{"Line":3}},{"line":26,"address":[],"length":0,"stats":{"Line":6}},{"line":29,"address":[],"length":0,"stats":{"Line":28}},{"line":33,"address":[],"length":0,"stats":{"Line":6}},{"line":34,"address":[],"length":0,"stats":{"Line":6}},{"line":36,"address":[],"length":0,"stats":{"Line":12}},{"line":37,"address":[],"length":0,"stats":{"Line":9}},{"line":38,"address":[],"length":0,"stats":{"Line":6}},{"line":41,"address":[],"length":0,"stats":{"Line":3}},{"line":42,"address":[],"length":0,"stats":{"Line":3}},{"line":43,"address":[],"length":0,"stats":{"Line":9}},{"line":44,"address":[],"length":0,"stats":{"Line":9}},{"line":48,"address":[],"length":0,"stats":{"Line":13}},{"line":49,"address":[],"length":0,"stats":{"Line":15}},{"line":50,"address":[],"length":0,"stats":{"Line":4}},{"line":51,"address":[],"length":0,"stats":{"Line":2}},{"line":52,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":56,"address":[],"length":0,"stats":{"Line":20}},{"line":57,"address":[],"length":0,"stats":{"Line":20}},{"line":59,"address":[],"length":0,"stats":{"Line":5}},{"line":60,"address":[],"length":0,"stats":{"Line":5}},{"line":69,"address":[],"length":0,"stats":{"Line":3}},{"line":70,"address":[],"length":0,"stats":{"Line":3}},{"line":71,"address":[],"length":0,"stats":{"Line":9}},{"line":72,"address":[],"length":0,"stats":{"Line":9}},{"line":76,"address":[],"length":0,"stats":{"Line":12}},{"line":77,"address":[],"length":0,"stats":{"Line":36}},{"line":78,"address":[],"length":0,"stats":{"Line":16}},{"line":80,"address":[],"length":0,"stats":{"Line":32}},{"line":81,"address":[],"length":0,"stats":{"Line":8}},{"line":86,"address":[],"length":0,"stats":{"Line":6}},{"line":87,"address":[],"length":0,"stats":{"Line":9}},{"line":89,"address":[],"length":0,"stats":{"Line":6}},{"line":90,"address":[],"length":0,"stats":{"Line":4}},{"line":91,"address":[],"length":0,"stats":{"Line":2}},{"line":95,"address":[],"length":0,"stats":{"Line":3}},{"line":96,"address":[],"length":0,"stats":{"Line":4}},{"line":97,"address":[],"length":0,"stats":{"Line":1}},{"line":98,"address":[],"length":0,"stats":{"Line":8}},{"line":99,"address":[],"length":0,"stats":{"Line":1}},{"line":104,"address":[],"length":0,"stats":{"Line":2}},{"line":105,"address":[],"length":0,"stats":{"Line":1}}],"covered":49,"coverable":49},{"path":["/","Users","chi","Projects","hu","src","gh","runs","mod.rs"],"content":"use anyhow::Result;\n\nuse super::cli::RunsArgs;\nuse super::client::{GithubApi, GithubClient};\nuse super::helpers::{get_current_repo, parse_owner_repo};\nuse super::types::{RunsQuery, WorkflowRun};\n\n#[cfg(test)]\nmod tests;\n\n// ANSI color codes\nconst GREEN: \u0026str = \"\\x1b[32m\";\nconst YELLOW: \u0026str = \"\\x1b[33m\";\nconst RED: \u0026str = \"\\x1b[31m\";\nconst GRAY: \u0026str = \"\\x1b[90m\";\nconst RESET: \u0026str = \"\\x1b[0m\";\n\n/// Handle the `hu gh runs` command\npub async fn run(args: RunsArgs) -\u003e Result\u003c()\u003e {\n    let client = GithubClient::new()?;\n    let (owner, repo) = match \u0026args.repo {\n        Some(r) =\u003e parse_owner_repo(r)?,\n        None =\u003e get_current_repo()?,\n    };\n    run_with_client(\u0026client, \u0026owner, \u0026repo, \u0026args).await\n}\n\n/// Fetch and display workflow runs using the given API client\npub async fn run_with_client(\n    client: \u0026impl GithubApi,\n    owner: \u0026str,\n    repo: \u0026str,\n    args: \u0026RunsArgs,\n) -\u003e Result\u003c()\u003e {\n    let runs = if let Some(ticket) = \u0026args.ticket {\n        fetch_runs_for_ticket(client, owner, repo, ticket, args).await?\n    } else {\n        let query = RunsQuery {\n            owner,\n            repo,\n            branch: args.branch.as_deref(),\n            status: args.status.as_deref(),\n            limit: args.limit,\n        };\n        client.list_workflow_runs(\u0026query).await?\n    };\n\n    if runs.is_empty() {\n        println!(\"No workflow runs found.\");\n        return Ok(());\n    }\n\n    if args.json {\n        print_runs_json(\u0026runs);\n    } else {\n        print_runs_table(\u0026runs);\n    }\n\n    Ok(())\n}\n\n/// Find runs associated with a ticket by searching PRs and their branches\nasync fn fetch_runs_for_ticket(\n    client: \u0026impl GithubApi,\n    owner: \u0026str,\n    repo: \u0026str,\n    ticket: \u0026str,\n    args: \u0026RunsArgs,\n) -\u003e Result\u003cVec\u003cWorkflowRun\u003e\u003e {\n    let prs = client.search_prs_by_title(owner, repo, ticket).await?;\n\n    if prs.is_empty() {\n        return Ok(vec![]);\n    }\n\n    let mut all_runs = Vec::new();\n    let mut seen_branches = std::collections::HashSet::new();\n\n    for pr in \u0026prs {\n        // Get the branch for this PR\n        let parts: Vec\u003c\u0026str\u003e = pr.repo_full_name.split('/').collect();\n        let (pr_owner, pr_repo) = if parts.len() == 2 {\n            (parts[0], parts[1])\n        } else {\n            (owner, repo)\n        };\n\n        if let Ok(branch) = client.get_pr_branch(pr_owner, pr_repo, pr.number).await {\n            if seen_branches.insert(branch.clone()) {\n                let query = RunsQuery {\n                    owner: pr_owner,\n                    repo: pr_repo,\n                    branch: Some(\u0026branch),\n                    status: args.status.as_deref(),\n                    limit: args.limit,\n                };\n                let runs = client.list_workflow_runs(\u0026query).await?;\n                all_runs.extend(runs);\n            }\n        }\n    }\n\n    // Sort by created_at descending and truncate to limit\n    all_runs.sort_by(|a, b| b.created_at.cmp(\u0026a.created_at));\n    all_runs.truncate(args.limit);\n\n    Ok(all_runs)\n}\n\n/// Get status icon with color for a workflow run\nfn status_icon(run: \u0026WorkflowRun) -\u003e String {\n    match run.conclusion.as_deref() {\n        Some(\"success\") =\u003e format!(\"{GREEN}{RESET}\"),\n        Some(\"failure\") =\u003e format!(\"{RED}{RESET}\"),\n        Some(\"cancelled\") =\u003e format!(\"{GRAY}{RESET}\"),\n        _ =\u003e match run.status.as_str() {\n            \"in_progress\" =\u003e format!(\"{YELLOW}{RESET}\"),\n            \"queued\" =\u003e format!(\"{GRAY}{RESET}\"),\n            _ =\u003e format!(\"{GRAY}{RESET}\"),\n        },\n    }\n}\n\nfn get_terminal_width() -\u003e usize {\n    terminal_size::terminal_size()\n        .map(|(w, _)| w.0 as usize)\n        .unwrap_or(80)\n}\n\nfn truncate(s: \u0026str, max_len: usize) -\u003e String {\n    if s.chars().count() \u003c= max_len {\n        s.to_string()\n    } else {\n        let truncated: String = s.chars().take(max_len.saturating_sub(1)).collect();\n        format!(\"{truncated}\")\n    }\n}\n\nfn print_runs_table(runs: \u0026[WorkflowRun]) {\n    let term_width = get_terminal_width();\n\n    let max_link_len = runs.iter().map(|r| r.html_url.len()).max().unwrap_or(40);\n    let max_branch_len = runs\n        .iter()\n        .map(|r| r.branch.len())\n        .max()\n        .unwrap_or(10)\n        .min(30);\n\n    // Layout:  S  Name  Branch  Link \n    let status_col = 1;\n    let border_overhead = 14; // \" \" + \"  \" + \"  \" + \"  \" + \"\"\n\n    let available =\n        term_width.saturating_sub(border_overhead + status_col + max_branch_len + max_link_len);\n    let name_width = available.max(15);\n    let branch_width = max_branch_len;\n    let link_width = max_link_len;\n\n    // Top border\n    println!(\n        \"{}{}{}\",\n        \"\".repeat(name_width + 2),\n        \"\".repeat(branch_width + 2),\n        \"\".repeat(link_width + 2),\n    );\n\n    for run in runs {\n        let icon = status_icon(run);\n        let name = truncate(\u0026run.name, name_width);\n        let branch = truncate(\u0026run.branch, branch_width);\n        let link = format!(\"{GRAY}{}{RESET}\", \u0026run.html_url);\n\n        println!(\n            \" {}  {:\u003cnw$}  {:\u003cbw$}  {} \",\n            icon,\n            name,\n            branch,\n            link,\n            nw = name_width,\n            bw = branch_width,\n        );\n    }\n\n    // Bottom border\n    println!(\n        \"{}{}{}\",\n        \"\".repeat(name_width + 2),\n        \"\".repeat(branch_width + 2),\n        \"\".repeat(link_width + 2),\n    );\n}\n\nfn print_runs_json(runs: \u0026[WorkflowRun]) {\n    let json = serde_json::to_string_pretty(runs).unwrap_or_default();\n    println!(\"{json}\");\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":7}},{"line":35,"address":[],"length":0,"stats":{"Line":16}},{"line":36,"address":[],"length":0,"stats":{"Line":12}},{"line":41,"address":[],"length":0,"stats":{"Line":15}},{"line":42,"address":[],"length":0,"stats":{"Line":10}},{"line":43,"address":[],"length":0,"stats":{"Line":5}},{"line":45,"address":[],"length":0,"stats":{"Line":15}},{"line":48,"address":[],"length":0,"stats":{"Line":14}},{"line":49,"address":[],"length":0,"stats":{"Line":4}},{"line":50,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":6}},{"line":54,"address":[],"length":0,"stats":{"Line":1}},{"line":56,"address":[],"length":0,"stats":{"Line":4}},{"line":59,"address":[],"length":0,"stats":{"Line":5}},{"line":63,"address":[],"length":0,"stats":{"Line":7}},{"line":70,"address":[],"length":0,"stats":{"Line":42}},{"line":72,"address":[],"length":0,"stats":{"Line":14}},{"line":73,"address":[],"length":0,"stats":{"Line":2}},{"line":76,"address":[],"length":0,"stats":{"Line":10}},{"line":77,"address":[],"length":0,"stats":{"Line":10}},{"line":79,"address":[],"length":0,"stats":{"Line":17}},{"line":81,"address":[],"length":0,"stats":{"Line":24}},{"line":82,"address":[],"length":0,"stats":{"Line":18}},{"line":83,"address":[],"length":0,"stats":{"Line":10}},{"line":85,"address":[],"length":0,"stats":{"Line":1}},{"line":88,"address":[],"length":0,"stats":{"Line":42}},{"line":89,"address":[],"length":0,"stats":{"Line":24}},{"line":93,"address":[],"length":0,"stats":{"Line":10}},{"line":94,"address":[],"length":0,"stats":{"Line":10}},{"line":95,"address":[],"length":0,"stats":{"Line":5}},{"line":97,"address":[],"length":0,"stats":{"Line":20}},{"line":98,"address":[],"length":0,"stats":{"Line":15}},{"line":104,"address":[],"length":0,"stats":{"Line":22}},{"line":105,"address":[],"length":0,"stats":{"Line":15}},{"line":107,"address":[],"length":0,"stats":{"Line":5}},{"line":111,"address":[],"length":0,"stats":{"Line":15}},{"line":112,"address":[],"length":0,"stats":{"Line":15}},{"line":113,"address":[],"length":0,"stats":{"Line":21}},{"line":114,"address":[],"length":0,"stats":{"Line":16}},{"line":115,"address":[],"length":0,"stats":{"Line":3}},{"line":116,"address":[],"length":0,"stats":{"Line":4}},{"line":117,"address":[],"length":0,"stats":{"Line":8}},{"line":118,"address":[],"length":0,"stats":{"Line":4}},{"line":119,"address":[],"length":0,"stats":{"Line":2}},{"line":124,"address":[],"length":0,"stats":{"Line":8}},{"line":125,"address":[],"length":0,"stats":{"Line":8}},{"line":126,"address":[],"length":0,"stats":{"Line":8}},{"line":130,"address":[],"length":0,"stats":{"Line":22}},{"line":131,"address":[],"length":0,"stats":{"Line":66}},{"line":132,"address":[],"length":0,"stats":{"Line":40}},{"line":134,"address":[],"length":0,"stats":{"Line":16}},{"line":135,"address":[],"length":0,"stats":{"Line":4}},{"line":139,"address":[],"length":0,"stats":{"Line":7}},{"line":140,"address":[],"length":0,"stats":{"Line":14}},{"line":142,"address":[],"length":0,"stats":{"Line":60}},{"line":143,"address":[],"length":0,"stats":{"Line":14}},{"line":145,"address":[],"length":0,"stats":{"Line":25}},{"line":151,"address":[],"length":0,"stats":{"Line":14}},{"line":152,"address":[],"length":0,"stats":{"Line":14}},{"line":154,"address":[],"length":0,"stats":{"Line":7}},{"line":155,"address":[],"length":0,"stats":{"Line":21}},{"line":156,"address":[],"length":0,"stats":{"Line":21}},{"line":157,"address":[],"length":0,"stats":{"Line":14}},{"line":158,"address":[],"length":0,"stats":{"Line":14}},{"line":161,"address":[],"length":0,"stats":{"Line":7}},{"line":162,"address":[],"length":0,"stats":{"Line":7}},{"line":163,"address":[],"length":0,"stats":{"Line":21}},{"line":164,"address":[],"length":0,"stats":{"Line":21}},{"line":165,"address":[],"length":0,"stats":{"Line":21}},{"line":168,"address":[],"length":0,"stats":{"Line":34}},{"line":169,"address":[],"length":0,"stats":{"Line":36}},{"line":170,"address":[],"length":0,"stats":{"Line":45}},{"line":171,"address":[],"length":0,"stats":{"Line":45}},{"line":172,"address":[],"length":0,"stats":{"Line":45}},{"line":174,"address":[],"length":0,"stats":{"Line":9}},{"line":175,"address":[],"length":0,"stats":{"Line":9}},{"line":176,"address":[],"length":0,"stats":{"Line":9}},{"line":177,"address":[],"length":0,"stats":{"Line":9}},{"line":178,"address":[],"length":0,"stats":{"Line":9}},{"line":179,"address":[],"length":0,"stats":{"Line":9}},{"line":180,"address":[],"length":0,"stats":{"Line":9}},{"line":181,"address":[],"length":0,"stats":{"Line":9}},{"line":186,"address":[],"length":0,"stats":{"Line":7}},{"line":187,"address":[],"length":0,"stats":{"Line":7}},{"line":188,"address":[],"length":0,"stats":{"Line":21}},{"line":189,"address":[],"length":0,"stats":{"Line":21}},{"line":190,"address":[],"length":0,"stats":{"Line":21}},{"line":194,"address":[],"length":0,"stats":{"Line":3}},{"line":195,"address":[],"length":0,"stats":{"Line":12}},{"line":196,"address":[],"length":0,"stats":{"Line":6}}],"covered":90,"coverable":96},{"path":["/","Users","chi","Projects","hu","src","gh","runs","tests.rs"],"content":"use super::*;\nuse crate::gh::client::GithubApi;\nuse crate::gh::types::{CiStatus, PullRequest, RunsQuery, WorkflowRun};\nuse anyhow::Result;\n\n// Mock implementation\nstruct MockGithubApi {\n    prs: Vec\u003cPullRequest\u003e,\n    runs: Vec\u003cWorkflowRun\u003e,\n    branches: std::collections::HashMap\u003cu64, String\u003e,\n}\n\nimpl MockGithubApi {\n    fn new() -\u003e Self {\n        Self {\n            prs: vec![],\n            runs: vec![],\n            branches: std::collections::HashMap::new(),\n        }\n    }\n\n    fn with_runs(mut self, runs: Vec\u003cWorkflowRun\u003e) -\u003e Self {\n        self.runs = runs;\n        self\n    }\n\n    fn with_prs(mut self, prs: Vec\u003cPullRequest\u003e) -\u003e Self {\n        self.prs = prs;\n        self\n    }\n\n    fn with_branch(mut self, pr_number: u64, branch: String) -\u003e Self {\n        self.branches.insert(pr_number, branch);\n        self\n    }\n}\n\nimpl GithubApi for MockGithubApi {\n    async fn list_user_prs(\u0026self) -\u003e Result\u003cVec\u003cPullRequest\u003e\u003e {\n        Ok(self.prs.clone())\n    }\n\n    async fn get_ci_status(\u0026self, _owner: \u0026str, _repo: \u0026str, _pr: u64) -\u003e Result\u003cCiStatus\u003e {\n        Ok(CiStatus::Unknown)\n    }\n\n    async fn get_pr_branch(\u0026self, _owner: \u0026str, _repo: \u0026str, pr: u64) -\u003e Result\u003cString\u003e {\n        Ok(self\n            .branches\n            .get(\u0026pr)\n            .cloned()\n            .unwrap_or_else(|| \"main\".to_string()))\n    }\n\n    async fn get_latest_failed_run_for_branch(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _branch: \u0026str,\n    ) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n        Ok(None)\n    }\n\n    async fn get_failed_jobs(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _run_id: u64,\n    ) -\u003e Result\u003cVec\u003c(u64, String)\u003e\u003e {\n        Ok(vec![])\n    }\n\n    async fn get_job_logs(\u0026self, _owner: \u0026str, _repo: \u0026str, _job_id: u64) -\u003e Result\u003cString\u003e {\n        Ok(String::new())\n    }\n\n    async fn find_pr_for_branch(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _branch: \u0026str,\n    ) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n        Ok(None)\n    }\n\n    async fn list_workflow_runs(\u0026self, query: \u0026RunsQuery\u003c'_\u003e) -\u003e Result\u003cVec\u003cWorkflowRun\u003e\u003e {\n        let mut runs: Vec\u003cWorkflowRun\u003e = self\n            .runs\n            .iter()\n            .filter(|r| query.branch.is_none_or(|b| r.branch == b))\n            .filter(|r| {\n                query\n                    .status\n                    .is_none_or(|s| r.status == s || r.conclusion.as_deref() == Some(s))\n            })\n            .cloned()\n            .collect();\n        runs.truncate(query.limit);\n        Ok(runs)\n    }\n\n    async fn search_prs_by_title(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        query: \u0026str,\n    ) -\u003e Result\u003cVec\u003cPullRequest\u003e\u003e {\n        let query_lower = query.to_lowercase();\n        Ok(self\n            .prs\n            .iter()\n            .filter(|pr| pr.title.to_lowercase().contains(\u0026query_lower))\n            .cloned()\n            .collect())\n    }\n}\n\nfn make_run(\n    id: u64,\n    name: \u0026str,\n    status: \u0026str,\n    conclusion: Option\u003c\u0026str\u003e,\n    branch: \u0026str,\n) -\u003e WorkflowRun {\n    WorkflowRun {\n        id,\n        name: name.to_string(),\n        status: status.to_string(),\n        conclusion: conclusion.map(|s| s.to_string()),\n        branch: branch.to_string(),\n        html_url: format!(\"https://github.com/o/r/actions/runs/{id}\"),\n        created_at: format!(\"2024-01-15T{:02}:00:00Z\", id % 24),\n        updated_at: format!(\"2024-01-15T{:02}:05:00Z\", id % 24),\n        run_number: id,\n    }\n}\n\nfn make_pr(number: u64, title: \u0026str) -\u003e PullRequest {\n    PullRequest {\n        number,\n        title: title.to_string(),\n        html_url: format!(\"https://github.com/o/r/pull/{number}\"),\n        state: \"open\".to_string(),\n        repo_full_name: \"o/r\".to_string(),\n        created_at: \"2024-01-01T00:00:00Z\".to_string(),\n        updated_at: \"2024-01-01T00:00:00Z\".to_string(),\n        ci_status: None,\n    }\n}\n\nfn default_args() -\u003e RunsArgs {\n    RunsArgs {\n        ticket: None,\n        status: None,\n        branch: None,\n        repo: None,\n        limit: 20,\n        json: false,\n    }\n}\n\n// status_icon tests\n#[test]\nfn status_icon_success() {\n    let run = make_run(1, \"CI\", \"completed\", Some(\"success\"), \"main\");\n    let icon = status_icon(\u0026run);\n    assert!(icon.contains(\"\"));\n    assert!(icon.contains(GREEN));\n}\n\n#[test]\nfn status_icon_failure() {\n    let run = make_run(1, \"CI\", \"completed\", Some(\"failure\"), \"main\");\n    let icon = status_icon(\u0026run);\n    assert!(icon.contains(\"\"));\n    assert!(icon.contains(RED));\n}\n\n#[test]\nfn status_icon_in_progress() {\n    let run = make_run(1, \"CI\", \"in_progress\", None, \"main\");\n    let icon = status_icon(\u0026run);\n    assert!(icon.contains(\"\"));\n    assert!(icon.contains(YELLOW));\n}\n\n#[test]\nfn status_icon_queued() {\n    let run = make_run(1, \"CI\", \"queued\", None, \"main\");\n    let icon = status_icon(\u0026run);\n    assert!(icon.contains(\"\"));\n    assert!(icon.contains(GRAY));\n}\n\n#[test]\nfn status_icon_cancelled() {\n    let run = make_run(1, \"CI\", \"completed\", Some(\"cancelled\"), \"main\");\n    let icon = status_icon(\u0026run);\n    assert!(icon.contains(\"\"));\n    assert!(icon.contains(GRAY));\n}\n\n#[test]\nfn status_icon_unknown_status() {\n    let run = make_run(1, \"CI\", \"unknown\", None, \"main\");\n    let icon = status_icon(\u0026run);\n    assert!(icon.contains(\"\"));\n}\n\n// truncate tests\n#[test]\nfn truncate_short() {\n    assert_eq!(truncate(\"hello\", 10), \"hello\");\n}\n\n#[test]\nfn truncate_long() {\n    assert_eq!(truncate(\"hello world\", 8), \"hello w\");\n}\n\n#[test]\nfn truncate_exact() {\n    assert_eq!(truncate(\"hello\", 5), \"hello\");\n}\n\n#[test]\nfn truncate_empty() {\n    assert_eq!(truncate(\"\", 10), \"\");\n}\n\n// print_runs_table tests\n#[test]\nfn print_runs_table_renders_without_panic() {\n    let runs = vec![\n        make_run(1, \"CI\", \"completed\", Some(\"success\"), \"main\"),\n        make_run(2, \"Lint\", \"completed\", Some(\"failure\"), \"feature\"),\n        make_run(3, \"Deploy\", \"in_progress\", None, \"main\"),\n    ];\n    print_runs_table(\u0026runs);\n}\n\n#[test]\nfn print_runs_table_empty() {\n    let runs: Vec\u003cWorkflowRun\u003e = vec![];\n    print_runs_table(\u0026runs);\n}\n\n#[test]\nfn print_runs_table_long_names() {\n    let runs = vec![make_run(\n        1,\n        \"A very long workflow name that should be truncated\",\n        \"completed\",\n        Some(\"success\"),\n        \"a-very-long-branch-name-too\",\n    )];\n    print_runs_table(\u0026runs);\n}\n\n// print_runs_json tests\n#[test]\nfn print_runs_json_renders() {\n    let runs = vec![make_run(1, \"CI\", \"completed\", Some(\"success\"), \"main\")];\n    print_runs_json(\u0026runs);\n}\n\n#[test]\nfn print_runs_json_empty() {\n    let runs: Vec\u003cWorkflowRun\u003e = vec![];\n    print_runs_json(\u0026runs);\n}\n\n// get_terminal_width test\n#[test]\nfn get_terminal_width_reasonable() {\n    let width = get_terminal_width();\n    assert!(width \u003e= 20);\n}\n\n// run_with_client tests\n#[tokio::test]\nasync fn run_with_client_no_runs() {\n    let mock = MockGithubApi::new();\n    let args = default_args();\n    let result = run_with_client(\u0026mock, \"o\", \"r\", \u0026args).await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn run_with_client_with_runs() {\n    let runs = vec![\n        make_run(1, \"CI\", \"completed\", Some(\"success\"), \"main\"),\n        make_run(2, \"Lint\", \"completed\", Some(\"failure\"), \"main\"),\n    ];\n    let mock = MockGithubApi::new().with_runs(runs);\n    let args = default_args();\n    let result = run_with_client(\u0026mock, \"o\", \"r\", \u0026args).await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn run_with_client_json_output() {\n    let runs = vec![make_run(1, \"CI\", \"completed\", Some(\"success\"), \"main\")];\n    let mock = MockGithubApi::new().with_runs(runs);\n    let mut args = default_args();\n    args.json = true;\n    let result = run_with_client(\u0026mock, \"o\", \"r\", \u0026args).await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn run_with_client_branch_filter() {\n    let runs = vec![\n        make_run(1, \"CI\", \"completed\", Some(\"success\"), \"main\"),\n        make_run(2, \"CI\", \"completed\", Some(\"failure\"), \"feature\"),\n    ];\n    let mock = MockGithubApi::new().with_runs(runs);\n    let mut args = default_args();\n    args.branch = Some(\"feature\".to_string());\n    let result = run_with_client(\u0026mock, \"o\", \"r\", \u0026args).await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn run_with_client_status_filter() {\n    let runs = vec![\n        make_run(1, \"CI\", \"completed\", Some(\"success\"), \"main\"),\n        make_run(2, \"CI\", \"completed\", Some(\"failure\"), \"main\"),\n    ];\n    let mock = MockGithubApi::new().with_runs(runs);\n    let mut args = default_args();\n    args.status = Some(\"failure\".to_string());\n    let result = run_with_client(\u0026mock, \"o\", \"r\", \u0026args).await;\n    assert!(result.is_ok());\n}\n\n// fetch_runs_for_ticket tests\n#[tokio::test]\nasync fn fetch_runs_for_ticket_no_prs() {\n    let mock = MockGithubApi::new();\n    let args = default_args();\n    let runs = fetch_runs_for_ticket(\u0026mock, \"o\", \"r\", \"BFR-999\", \u0026args).await;\n    assert!(runs.is_ok());\n    assert!(runs.unwrap().is_empty());\n}\n\n#[tokio::test]\nasync fn fetch_runs_for_ticket_with_prs() {\n    let pr = make_pr(1, \"BFR-1234 Fix bug\");\n    let runs = vec![\n        make_run(10, \"CI\", \"completed\", Some(\"success\"), \"bfr-1234-fix\"),\n        make_run(11, \"Lint\", \"completed\", Some(\"success\"), \"bfr-1234-fix\"),\n    ];\n    let mock = MockGithubApi::new()\n        .with_prs(vec![pr])\n        .with_runs(runs)\n        .with_branch(1, \"bfr-1234-fix\".to_string());\n    let args = default_args();\n    let result = fetch_runs_for_ticket(\u0026mock, \"o\", \"r\", \"BFR-1234\", \u0026args).await;\n    assert!(result.is_ok());\n    assert_eq!(result.unwrap().len(), 2);\n}\n\n#[tokio::test]\nasync fn fetch_runs_for_ticket_deduplicates_branches() {\n    let prs = vec![\n        make_pr(1, \"BFR-1234 First PR\"),\n        make_pr(2, \"BFR-1234 Second PR\"),\n    ];\n    let runs = vec![make_run(\n        10,\n        \"CI\",\n        \"completed\",\n        Some(\"success\"),\n        \"same-branch\",\n    )];\n    let mock = MockGithubApi::new()\n        .with_prs(prs)\n        .with_runs(runs)\n        .with_branch(1, \"same-branch\".to_string())\n        .with_branch(2, \"same-branch\".to_string());\n    let args = default_args();\n    let result = fetch_runs_for_ticket(\u0026mock, \"o\", \"r\", \"BFR-1234\", \u0026args).await;\n    assert!(result.is_ok());\n    // Should only query once since both PRs point to same branch\n    assert_eq!(result.unwrap().len(), 1);\n}\n\n#[tokio::test]\nasync fn fetch_runs_for_ticket_respects_limit() {\n    let pr = make_pr(1, \"BFR-1234 Fix\");\n    let runs: Vec\u003cWorkflowRun\u003e = (0..10)\n        .map(|i| make_run(i, \"CI\", \"completed\", Some(\"success\"), \"feature\"))\n        .collect();\n    let mock = MockGithubApi::new()\n        .with_prs(vec![pr])\n        .with_runs(runs)\n        .with_branch(1, \"feature\".to_string());\n    let mut args = default_args();\n    args.limit = 3;\n    let result = fetch_runs_for_ticket(\u0026mock, \"o\", \"r\", \"BFR-1234\", \u0026args).await;\n    assert!(result.is_ok());\n    assert!(result.unwrap().len() \u003c= 3);\n}\n\n#[tokio::test]\nasync fn run_with_client_ticket_search() {\n    let pr = make_pr(1, \"BFR-1234 Fix bug\");\n    let runs = vec![make_run(10, \"CI\", \"completed\", Some(\"success\"), \"bfr-1234\")];\n    let mock = MockGithubApi::new()\n        .with_prs(vec![pr])\n        .with_runs(runs)\n        .with_branch(1, \"bfr-1234\".to_string());\n    let mut args = default_args();\n    args.ticket = Some(\"BFR-1234\".to_string());\n    let result = run_with_client(\u0026mock, \"o\", \"r\", \u0026args).await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn fetch_runs_for_ticket_invalid_repo_name() {\n    let mut pr = make_pr(1, \"BFR-1234 Fix bug\");\n    pr.repo_full_name = \"invalid-no-slash\".to_string();\n    let runs = vec![make_run(10, \"CI\", \"completed\", Some(\"success\"), \"feature\")];\n    let mock = MockGithubApi::new()\n        .with_prs(vec![pr])\n        .with_runs(runs)\n        .with_branch(1, \"feature\".to_string());\n    let args = default_args();\n    let result = fetch_runs_for_ticket(\u0026mock, \"o\", \"r\", \"BFR-1234\", \u0026args).await;\n    assert!(result.is_ok());\n    // Should still work, falling back to owner/repo params\n    assert_eq!(result.unwrap().len(), 1);\n}\n\n#[tokio::test]\nasync fn run_with_client_ticket_no_results() {\n    let mock = MockGithubApi::new();\n    let mut args = default_args();\n    args.ticket = Some(\"NONE-999\".to_string());\n    let result = run_with_client(\u0026mock, \"o\", \"r\", \u0026args).await;\n    assert!(result.is_ok());\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":12}},{"line":16,"address":[],"length":0,"stats":{"Line":24}},{"line":17,"address":[],"length":0,"stats":{"Line":12}},{"line":18,"address":[],"length":0,"stats":{"Line":12}},{"line":22,"address":[],"length":0,"stats":{"Line":9}},{"line":23,"address":[],"length":0,"stats":{"Line":18}},{"line":24,"address":[],"length":0,"stats":{"Line":9}},{"line":27,"address":[],"length":0,"stats":{"Line":5}},{"line":28,"address":[],"length":0,"stats":{"Line":10}},{"line":29,"address":[],"length":0,"stats":{"Line":5}},{"line":32,"address":[],"length":0,"stats":{"Line":6}},{"line":33,"address":[],"length":0,"stats":{"Line":24}},{"line":34,"address":[],"length":0,"stats":{"Line":6}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":12}},{"line":48,"address":[],"length":0,"stats":{"Line":6}},{"line":49,"address":[],"length":0,"stats":{"Line":6}},{"line":50,"address":[],"length":0,"stats":{"Line":12}},{"line":51,"address":[],"length":0,"stats":{"Line":6}},{"line":52,"address":[],"length":0,"stats":{"Line":6}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":20}},{"line":87,"address":[],"length":0,"stats":{"Line":30}},{"line":88,"address":[],"length":0,"stats":{"Line":10}},{"line":90,"address":[],"length":0,"stats":{"Line":88}},{"line":91,"address":[],"length":0,"stats":{"Line":31}},{"line":92,"address":[],"length":0,"stats":{"Line":21}},{"line":93,"address":[],"length":0,"stats":{"Line":21}},{"line":94,"address":[],"length":0,"stats":{"Line":25}},{"line":98,"address":[],"length":0,"stats":{"Line":30}},{"line":99,"address":[],"length":0,"stats":{"Line":10}},{"line":102,"address":[],"length":0,"stats":{"Line":7}},{"line":108,"address":[],"length":0,"stats":{"Line":21}},{"line":109,"address":[],"length":0,"stats":{"Line":7}},{"line":110,"address":[],"length":0,"stats":{"Line":7}},{"line":111,"address":[],"length":0,"stats":{"Line":7}},{"line":112,"address":[],"length":0,"stats":{"Line":25}},{"line":113,"address":[],"length":0,"stats":{"Line":7}},{"line":114,"address":[],"length":0,"stats":{"Line":7}},{"line":118,"address":[],"length":0,"stats":{"Line":33}},{"line":127,"address":[],"length":0,"stats":{"Line":66}},{"line":128,"address":[],"length":0,"stats":{"Line":66}},{"line":129,"address":[],"length":0,"stats":{"Line":124}},{"line":130,"address":[],"length":0,"stats":{"Line":66}},{"line":131,"address":[],"length":0,"stats":{"Line":66}},{"line":132,"address":[],"length":0,"stats":{"Line":99}},{"line":133,"address":[],"length":0,"stats":{"Line":99}},{"line":138,"address":[],"length":0,"stats":{"Line":6}},{"line":141,"address":[],"length":0,"stats":{"Line":18}},{"line":142,"address":[],"length":0,"stats":{"Line":18}},{"line":143,"address":[],"length":0,"stats":{"Line":18}},{"line":144,"address":[],"length":0,"stats":{"Line":18}},{"line":145,"address":[],"length":0,"stats":{"Line":18}},{"line":146,"address":[],"length":0,"stats":{"Line":12}},{"line":151,"address":[],"length":0,"stats":{"Line":12}}],"covered":53,"coverable":65},{"path":["/","Users","chi","Projects","hu","src","gh","sync.rs"],"content":"use anyhow::Result;\n\nuse crate::git::{self, SyncOptions};\n\nuse super::cli::SyncArgs;\n\npub fn run(args: SyncArgs) -\u003e Result\u003c()\u003e {\n    let options = SyncOptions {\n        no_commit: args.no_commit,\n        no_push: args.no_push,\n        message: args.message,\n        path: args.path,\n    };\n\n    let result = git::sync(\u0026options)?;\n\n    if args.json {\n        println!(\"{}\", serde_json::to_string_pretty(\u0026result)?);\n        return Ok(());\n    }\n\n    if result.files_committed == 0 {\n        println!(\"Nothing to commit, working tree clean\");\n        return Ok(());\n    }\n\n    if let Some(hash) = \u0026result.commit_hash {\n        let branch = result.branch.as_deref().unwrap_or(\"unknown\");\n        println!(\n            \"\\x1b[32m\\u{2713}\\x1b[0m Committed {} {} [{}] {}\",\n            result.files_committed,\n            if result.files_committed == 1 {\n                \"file\"\n            } else {\n                \"files\"\n            },\n            branch,\n            hash\n        );\n    } else if args.no_commit {\n        println!(\n            \"\\x1b[33m\\u{25D0}\\x1b[0m {} {} changed (--no-commit)\",\n            result.files_committed,\n            if result.files_committed == 1 {\n                \"file\"\n            } else {\n                \"files\"\n            }\n        );\n    }\n\n    if result.pushed {\n        println!(\"\\x1b[32m\\u{2713}\\x1b[0m Pushed to origin\");\n    } else if !args.no_push \u0026\u0026 result.commit_hash.is_some() {\n        println!(\"\\x1b[33m\\u{25D0}\\x1b[0m No remote configured, skipping push\");\n    }\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::path::PathBuf;\n\n    #[test]\n    fn sync_args_to_options() {\n        let args = SyncArgs {\n            path: Some(PathBuf::from(\"/tmp\")),\n            no_commit: true,\n            no_push: true,\n            message: Some(\"test\".to_string()),\n            json: false,\n        };\n\n        let options = SyncOptions {\n            no_commit: args.no_commit,\n            no_push: args.no_push,\n            message: args.message.clone(),\n            path: args.path.clone(),\n        };\n\n        assert!(options.no_commit);\n        assert!(options.no_push);\n        assert_eq!(options.message.unwrap(), \"test\");\n        assert_eq!(options.path.unwrap(), PathBuf::from(\"/tmp\"));\n    }\n\n    #[test]\n    fn run_not_git_repo() {\n        let args = SyncArgs {\n            path: Some(PathBuf::from(\"/tmp\")),\n            no_commit: false,\n            no_push: false,\n            message: None,\n            json: false,\n        };\n        let result = run(args);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn run_json_not_repo() {\n        let args = SyncArgs {\n            path: Some(PathBuf::from(\"/tmp\")),\n            no_commit: false,\n            no_push: false,\n            message: None,\n            json: true,\n        };\n        let result = run(args);\n        assert!(result.is_err());\n    }\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":2}},{"line":9,"address":[],"length":0,"stats":{"Line":4}},{"line":10,"address":[],"length":0,"stats":{"Line":4}},{"line":11,"address":[],"length":0,"stats":{"Line":2}},{"line":12,"address":[],"length":0,"stats":{"Line":2}},{"line":15,"address":[],"length":0,"stats":{"Line":6}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}}],"covered":6,"coverable":30},{"path":["/","Users","chi","Projects","hu","src","gh","types.rs"],"content":"use serde::{Deserialize, Serialize};\n\n/// CI check status\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]\npub enum CiStatus {\n    Success,\n    Pending,\n    Failed,\n    #[default]\n    Unknown,\n}\n\n/// Pull request data for display\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PullRequest {\n    pub number: u64,\n    pub title: String,\n    pub html_url: String,\n    pub state: String,\n    pub repo_full_name: String,\n    pub created_at: String,\n    pub updated_at: String,\n    #[serde(skip)]\n    pub ci_status: Option\u003cCiStatus\u003e,\n}\n\n/// A GitHub Actions workflow run\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct WorkflowRun {\n    pub id: u64,\n    pub name: String,\n    pub status: String,\n    pub conclusion: Option\u003cString\u003e,\n    pub branch: String,\n    pub html_url: String,\n    pub created_at: String,\n    pub updated_at: String,\n    pub run_number: u64,\n}\n\n/// Parameters for listing workflow runs\n#[derive(Debug, Clone, Default)]\npub struct RunsQuery\u003c'a\u003e {\n    pub owner: \u0026'a str,\n    pub repo: \u0026'a str,\n    pub branch: Option\u003c\u0026'a str\u003e,\n    pub status: Option\u003c\u0026'a str\u003e,\n    pub limit: usize,\n}\n\n/// A test failure extracted from CI logs\n#[derive(Debug, Clone)]\npub struct TestFailure {\n    /// The spec file path (e.g., \"spec/models/user_spec.rb\")\n    pub spec_file: String,\n    /// The failure message/output\n    pub failure_text: String,\n}\n\n/// A test failure enriched with source file mapping\n#[derive(Debug, Clone, Serialize)]\npub struct FixFailure {\n    pub test_file: String,\n    pub source_files: Vec\u003cString\u003e,\n    pub failure_text: String,\n    pub language: String,\n}\n\n/// Full fix report for a failed CI run\n#[derive(Debug, Clone, Serialize)]\npub struct FixReport {\n    pub repository: String,\n    pub pr_number: Option\u003cu64\u003e,\n    pub run_id: u64,\n    pub failures: Vec\u003cFixFailure\u003e,\n    pub test_files: Vec\u003cString\u003e,\n    pub source_files: Vec\u003cString\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn pull_request_serializes() {\n        let pr = PullRequest {\n            number: 123,\n            title: \"Fix bug\".to_string(),\n            html_url: \"https://github.com/org/repo/pull/123\".to_string(),\n            state: \"open\".to_string(),\n            repo_full_name: \"org/repo\".to_string(),\n            created_at: \"2024-01-15T10:00:00Z\".to_string(),\n            updated_at: \"2024-01-15T12:00:00Z\".to_string(),\n            ci_status: None,\n        };\n\n        let json = serde_json::to_string(\u0026pr).unwrap();\n        assert!(json.contains(\"Fix bug\"));\n        assert!(json.contains(\"org/repo\"));\n    }\n\n    #[test]\n    fn pull_request_deserializes() {\n        let json = r#\"{\n            \"number\": 456,\n            \"title\": \"Add feature\",\n            \"html_url\": \"https://github.com/org/repo/pull/456\",\n            \"state\": \"open\",\n            \"repo_full_name\": \"org/repo\",\n            \"created_at\": \"2024-01-15T10:00:00Z\",\n            \"updated_at\": \"2024-01-15T12:00:00Z\"\n        }\"#;\n\n        let pr: PullRequest = serde_json::from_str(json).unwrap();\n        assert_eq!(pr.number, 456);\n        assert_eq!(pr.title, \"Add feature\");\n        assert!(pr.ci_status.is_none());\n    }\n\n    #[test]\n    fn ci_status_default_is_unknown() {\n        let status = CiStatus::default();\n        assert_eq!(status, CiStatus::Unknown);\n    }\n\n    #[test]\n    fn ci_status_equality() {\n        assert_eq!(CiStatus::Success, CiStatus::Success);\n        assert_eq!(CiStatus::Pending, CiStatus::Pending);\n        assert_eq!(CiStatus::Failed, CiStatus::Failed);\n        assert_eq!(CiStatus::Unknown, CiStatus::Unknown);\n        assert_ne!(CiStatus::Success, CiStatus::Failed);\n    }\n\n    #[test]\n    fn ci_status_clone() {\n        let status = CiStatus::Success;\n        let cloned = status;\n        assert_eq!(status, cloned);\n    }\n\n    #[test]\n    fn ci_status_debug_format() {\n        let debug_str = format!(\"{:?}\", CiStatus::Pending);\n        assert!(debug_str.contains(\"Pending\"));\n    }\n\n    #[test]\n    fn test_failure_clone() {\n        let failure = TestFailure {\n            spec_file: \"./spec/test_spec.rb:10\".to_string(),\n            failure_text: \"expected true, got false\".to_string(),\n        };\n        let cloned = failure.clone();\n        assert_eq!(cloned.spec_file, failure.spec_file);\n        assert_eq!(cloned.failure_text, failure.failure_text);\n    }\n\n    #[test]\n    fn test_failure_debug_format() {\n        let failure = TestFailure {\n            spec_file: \"./spec/test_spec.rb:10\".to_string(),\n            failure_text: \"error\".to_string(),\n        };\n        let debug_str = format!(\"{:?}\", failure);\n        assert!(debug_str.contains(\"TestFailure\"));\n        assert!(debug_str.contains(\"spec_file\"));\n    }\n\n    #[test]\n    fn pull_request_clone() {\n        let pr = PullRequest {\n            number: 123,\n            title: \"Test\".to_string(),\n            html_url: \"https://github.com/a/b/pull/123\".to_string(),\n            state: \"open\".to_string(),\n            repo_full_name: \"a/b\".to_string(),\n            created_at: \"2024-01-01T00:00:00Z\".to_string(),\n            updated_at: \"2024-01-01T00:00:00Z\".to_string(),\n            ci_status: Some(CiStatus::Success),\n        };\n        let cloned = pr.clone();\n        assert_eq!(cloned.number, pr.number);\n        assert_eq!(cloned.ci_status, pr.ci_status);\n    }\n\n    #[test]\n    fn pull_request_debug_format() {\n        let pr = PullRequest {\n            number: 1,\n            title: \"T\".to_string(),\n            html_url: \"u\".to_string(),\n            state: \"open\".to_string(),\n            repo_full_name: \"r\".to_string(),\n            created_at: \"c\".to_string(),\n            updated_at: \"u\".to_string(),\n            ci_status: None,\n        };\n        let debug_str = format!(\"{:?}\", pr);\n        assert!(debug_str.contains(\"PullRequest\"));\n    }\n\n    #[test]\n    fn fix_failure_serializes() {\n        let f = FixFailure {\n            test_file: \"spec/models/user_spec.rb:10\".to_string(),\n            source_files: vec![\"app/models/user.rb\".to_string()],\n            failure_text: \"expected true\".to_string(),\n            language: \"ruby\".to_string(),\n        };\n        let json = serde_json::to_string(\u0026f).unwrap();\n        assert!(json.contains(\"user_spec.rb\"));\n        assert!(json.contains(\"app/models/user.rb\"));\n        assert!(json.contains(\"ruby\"));\n    }\n\n    #[test]\n    fn fix_failure_clone() {\n        let f = FixFailure {\n            test_file: \"test.rb\".to_string(),\n            source_files: vec![\"src.rb\".to_string()],\n            failure_text: \"err\".to_string(),\n            language: \"ruby\".to_string(),\n        };\n        let c = f.clone();\n        assert_eq!(c.test_file, f.test_file);\n        assert_eq!(c.source_files, f.source_files);\n    }\n\n    #[test]\n    fn fix_failure_debug() {\n        let f = FixFailure {\n            test_file: \"t\".to_string(),\n            source_files: vec![],\n            failure_text: \"e\".to_string(),\n            language: \"rust\".to_string(),\n        };\n        let d = format!(\"{:?}\", f);\n        assert!(d.contains(\"FixFailure\"));\n    }\n\n    #[test]\n    fn fix_report_serializes() {\n        let r = FixReport {\n            repository: \"owner/repo\".to_string(),\n            pr_number: Some(42),\n            run_id: 123,\n            failures: vec![],\n            test_files: vec![\"spec/a_spec.rb\".to_string()],\n            source_files: vec![\"app/a.rb\".to_string()],\n        };\n        let json = serde_json::to_string(\u0026r).unwrap();\n        assert!(json.contains(\"owner/repo\"));\n        assert!(json.contains(\"42\"));\n        assert!(json.contains(\"123\"));\n    }\n\n    #[test]\n    fn fix_report_clone() {\n        let r = FixReport {\n            repository: \"o/r\".to_string(),\n            pr_number: None,\n            run_id: 1,\n            failures: vec![],\n            test_files: vec![],\n            source_files: vec![],\n        };\n        let c = r.clone();\n        assert_eq!(c.repository, r.repository);\n        assert_eq!(c.pr_number, r.pr_number);\n    }\n\n    #[test]\n    fn fix_report_debug() {\n        let r = FixReport {\n            repository: \"o/r\".to_string(),\n            pr_number: None,\n            run_id: 1,\n            failures: vec![],\n            test_files: vec![],\n            source_files: vec![],\n        };\n        let d = format!(\"{:?}\", r);\n        assert!(d.contains(\"FixReport\"));\n    }\n\n    #[test]\n    fn workflow_run_serializes() {\n        let run = WorkflowRun {\n            id: 100,\n            name: \"Test Suite\".to_string(),\n            status: \"completed\".to_string(),\n            conclusion: Some(\"success\".to_string()),\n            branch: \"main\".to_string(),\n            html_url: \"https://github.com/o/r/actions/runs/100\".to_string(),\n            created_at: \"2024-01-15T10:00:00Z\".to_string(),\n            updated_at: \"2024-01-15T10:05:00Z\".to_string(),\n            run_number: 42,\n        };\n        let json = serde_json::to_string(\u0026run).unwrap();\n        assert!(json.contains(\"Test Suite\"));\n        assert!(json.contains(\"100\"));\n        assert!(json.contains(\"main\"));\n    }\n\n    #[test]\n    fn workflow_run_deserializes() {\n        let json = r#\"{\n            \"id\": 200,\n            \"name\": \"Lint\",\n            \"status\": \"in_progress\",\n            \"conclusion\": null,\n            \"branch\": \"feature\",\n            \"html_url\": \"https://github.com/o/r/actions/runs/200\",\n            \"created_at\": \"2024-01-15T10:00:00Z\",\n            \"updated_at\": \"2024-01-15T10:05:00Z\",\n            \"run_number\": 7\n        }\"#;\n        let run: WorkflowRun = serde_json::from_str(json).unwrap();\n        assert_eq!(run.id, 200);\n        assert_eq!(run.name, \"Lint\");\n        assert!(run.conclusion.is_none());\n    }\n\n    #[test]\n    fn workflow_run_clone() {\n        let run = WorkflowRun {\n            id: 1,\n            name: \"CI\".to_string(),\n            status: \"completed\".to_string(),\n            conclusion: Some(\"failure\".to_string()),\n            branch: \"dev\".to_string(),\n            html_url: \"u\".to_string(),\n            created_at: \"c\".to_string(),\n            updated_at: \"u\".to_string(),\n            run_number: 1,\n        };\n        let cloned = run.clone();\n        assert_eq!(cloned.id, run.id);\n        assert_eq!(cloned.conclusion, run.conclusion);\n    }\n\n    #[test]\n    fn runs_query_debug() {\n        let q = RunsQuery {\n            owner: \"o\",\n            repo: \"r\",\n            branch: Some(\"main\"),\n            status: None,\n            limit: 20,\n        };\n        let d = format!(\"{:?}\", q);\n        assert!(d.contains(\"RunsQuery\"));\n    }\n\n    #[test]\n    fn runs_query_clone() {\n        let q = RunsQuery {\n            owner: \"o\",\n            repo: \"r\",\n            branch: None,\n            status: Some(\"completed\"),\n            limit: 10,\n        };\n        let c = q.clone();\n        assert_eq!(c.owner, q.owner);\n        assert_eq!(c.limit, q.limit);\n    }\n\n    #[test]\n    fn runs_query_default() {\n        let q = RunsQuery::default();\n        assert_eq!(q.owner, \"\");\n        assert_eq!(q.repo, \"\");\n        assert!(q.branch.is_none());\n        assert!(q.status.is_none());\n        assert_eq!(q.limit, 0);\n    }\n\n    #[test]\n    fn workflow_run_debug() {\n        let run = WorkflowRun {\n            id: 1,\n            name: \"N\".to_string(),\n            status: \"s\".to_string(),\n            conclusion: None,\n            branch: \"b\".to_string(),\n            html_url: \"u\".to_string(),\n            created_at: \"c\".to_string(),\n            updated_at: \"u\".to_string(),\n            run_number: 1,\n        };\n        let d = format!(\"{:?}\", run);\n        assert!(d.contains(\"WorkflowRun\"));\n    }\n\n    #[test]\n    fn fix_report_no_pr() {\n        let r = FixReport {\n            repository: \"o/r\".to_string(),\n            pr_number: None,\n            run_id: 1,\n            failures: vec![],\n            test_files: vec![],\n            source_files: vec![],\n        };\n        let json = serde_json::to_string(\u0026r).unwrap();\n        assert!(json.contains(\"null\"));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","git","mod.rs"],"content":"mod service;\nmod types;\n\npub use service::sync;\npub use types::{SyncOptions, SyncResult};\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn exports_are_accessible() {\n        let _ = std::any::type_name::\u003cSyncOptions\u003e();\n        let _ = std::any::type_name::\u003cSyncResult\u003e();\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","git","service.rs"],"content":"use anyhow::{Context, Result};\nuse chrono::Local;\nuse std::path::Path;\nuse std::process::Command;\n\nuse super::types::{GitStatus, SyncOptions, SyncResult};\n\n/// Run a git command in a directory\nfn run_git(args: \u0026[\u0026str], cwd: \u0026Path) -\u003e Result\u003cString\u003e {\n    let output = Command::new(\"git\")\n        .args(args)\n        .current_dir(cwd)\n        .output()\n        .with_context(|| format!(\"Failed to run git {:?}\", args))?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"git {:?} failed: {}\", args, stderr.trim());\n    }\n\n    Ok(String::from_utf8_lossy(\u0026output.stdout).to_string())\n}\n\n/// Check if directory is a git repository\npub fn is_git_repo(path: \u0026Path) -\u003e bool {\n    Command::new(\"git\")\n        .args([\"rev-parse\", \"--git-dir\"])\n        .current_dir(path)\n        .output()\n        .map(|o| o.status.success())\n        .unwrap_or(false)\n}\n\n/// Get current branch name\npub fn get_branch(path: \u0026Path) -\u003e Result\u003cString\u003e {\n    let output = run_git(\u0026[\"branch\", \"--show-current\"], path)?;\n    let branch = output.trim().to_string();\n    if branch.is_empty() {\n        anyhow::bail!(\"Not on a branch (detached HEAD?)\");\n    }\n    Ok(branch)\n}\n\n/// Get git status\npub fn get_status(path: \u0026Path) -\u003e Result\u003cGitStatus\u003e {\n    let output = run_git(\u0026[\"status\", \"--porcelain\"], path)?;\n    parse_status_output(\u0026output)\n}\n\n/// Parse git status --porcelain output\npub fn parse_status_output(output: \u0026str) -\u003e Result\u003cGitStatus\u003e {\n    let mut status = GitStatus {\n        modified: vec![],\n        staged: vec![],\n        untracked: vec![],\n        deleted: vec![],\n    };\n\n    for line in output.lines() {\n        if line.len() \u003c 3 {\n            continue;\n        }\n\n        let index = line.chars().next().unwrap_or(' ');\n        let worktree = line.chars().nth(1).unwrap_or(' ');\n        let file = line[3..].trim().to_string();\n        let path = std::path::PathBuf::from(\u0026file);\n\n        // Handle staged changes (index column)\n        match index {\n            'A' | 'M' | 'R' | 'C' =\u003e status.staged.push(path.clone()),\n            'D' =\u003e status.deleted.push(path.clone()),\n            _ =\u003e {}\n        }\n\n        // Handle worktree changes (second column)\n        match worktree {\n            'M' =\u003e {\n                if !status.staged.contains(\u0026path) {\n                    status.modified.push(path);\n                }\n            }\n            'D' =\u003e {\n                if !status.deleted.contains(\u0026path) {\n                    status.deleted.push(path);\n                }\n            }\n            '?' =\u003e status.untracked.push(path),\n            _ =\u003e {}\n        }\n    }\n\n    Ok(status)\n}\n\n/// Generate default commit message\npub fn generate_commit_message(file_count: usize) -\u003e String {\n    let timestamp = Local::now().format(\"%Y-%m-%d %H:%M:%S\");\n    let files_word = if file_count == 1 { \"file\" } else { \"files\" };\n    format!(\"Update {}, {} {}\", timestamp, file_count, files_word)\n}\n\n/// Stage all changes\npub fn stage_all(path: \u0026Path) -\u003e Result\u003c()\u003e {\n    run_git(\u0026[\"add\", \"-A\"], path)?;\n    Ok(())\n}\n\n/// Commit staged changes\npub fn commit(path: \u0026Path, message: \u0026str) -\u003e Result\u003cString\u003e {\n    run_git(\u0026[\"commit\", \"-m\", message], path)?;\n    let hash = run_git(\u0026[\"rev-parse\", \"--short\", \"HEAD\"], path)?;\n    Ok(hash.trim().to_string())\n}\n\n/// Push to remote\npub fn push(path: \u0026Path) -\u003e Result\u003c()\u003e {\n    run_git(\u0026[\"push\"], path)?;\n    Ok(())\n}\n\n/// Check if there's a remote configured\npub fn has_remote(path: \u0026Path) -\u003e bool {\n    run_git(\u0026[\"remote\"], path)\n        .map(|o| !o.trim().is_empty())\n        .unwrap_or(false)\n}\n\n/// Perform full sync: stage, commit, push\npub fn sync(options: \u0026SyncOptions) -\u003e Result\u003cSyncResult\u003e {\n    let path = options\n        .path\n        .clone()\n        .unwrap_or_else(|| std::env::current_dir().unwrap());\n\n    if !is_git_repo(\u0026path) {\n        anyhow::bail!(\"Not a git repository: {}\", path.display());\n    }\n\n    let status = get_status(\u0026path)?;\n    if status.is_clean() {\n        return Ok(SyncResult {\n            files_committed: 0,\n            commit_hash: None,\n            pushed: false,\n            branch: get_branch(\u0026path).ok(),\n        });\n    }\n\n    let file_count = status.file_count();\n    let mut result = SyncResult {\n        files_committed: file_count,\n        commit_hash: None,\n        pushed: false,\n        branch: get_branch(\u0026path).ok(),\n    };\n\n    if options.no_commit {\n        return Ok(result);\n    }\n\n    // Stage all changes\n    stage_all(\u0026path)?;\n\n    // Commit\n    let message = options\n        .message\n        .clone()\n        .unwrap_or_else(|| generate_commit_message(file_count));\n    let hash = commit(\u0026path, \u0026message)?;\n    result.commit_hash = Some(hash);\n\n    // Push if requested and remote exists\n    if !options.no_push \u0026\u0026 has_remote(\u0026path) {\n        push(\u0026path)?;\n        result.pushed = true;\n    }\n\n    Ok(result)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn parse_status_empty() {\n        let status = parse_status_output(\"\").unwrap();\n        assert!(status.is_clean());\n    }\n\n    #[test]\n    fn parse_status_modified() {\n        let status = parse_status_output(\" M file.txt\").unwrap();\n        assert_eq!(status.modified.len(), 1);\n        assert_eq!(status.modified[0].to_str().unwrap(), \"file.txt\");\n    }\n\n    #[test]\n    fn parse_status_staged() {\n        let status = parse_status_output(\"M  file.txt\").unwrap();\n        assert_eq!(status.staged.len(), 1);\n        assert_eq!(status.staged[0].to_str().unwrap(), \"file.txt\");\n    }\n\n    #[test]\n    fn parse_status_untracked() {\n        let status = parse_status_output(\"?? new_file.txt\").unwrap();\n        assert_eq!(status.untracked.len(), 1);\n        assert_eq!(status.untracked[0].to_str().unwrap(), \"new_file.txt\");\n    }\n\n    #[test]\n    fn parse_status_deleted() {\n        let status = parse_status_output(\"D  removed.txt\").unwrap();\n        assert_eq!(status.deleted.len(), 1);\n        assert_eq!(status.deleted[0].to_str().unwrap(), \"removed.txt\");\n    }\n\n    #[test]\n    fn parse_status_added() {\n        let status = parse_status_output(\"A  new.txt\").unwrap();\n        assert_eq!(status.staged.len(), 1);\n        assert_eq!(status.staged[0].to_str().unwrap(), \"new.txt\");\n    }\n\n    #[test]\n    fn parse_status_renamed() {\n        let status = parse_status_output(\"R  old.txt -\u003e new.txt\").unwrap();\n        assert_eq!(status.staged.len(), 1);\n    }\n\n    #[test]\n    fn parse_status_multiple() {\n        let output = \" M modified.txt\\nA  added.txt\\n?? untracked.txt\\nD  deleted.txt\";\n        let status = parse_status_output(output).unwrap();\n        assert_eq!(status.modified.len(), 1);\n        assert_eq!(status.staged.len(), 1);\n        assert_eq!(status.untracked.len(), 1);\n        assert_eq!(status.deleted.len(), 1);\n    }\n\n    #[test]\n    fn parse_status_worktree_deleted() {\n        let status = parse_status_output(\" D removed.txt\").unwrap();\n        assert_eq!(status.deleted.len(), 1);\n    }\n\n    #[test]\n    fn parse_status_both_staged_and_modified() {\n        // File is staged but also has unstaged modifications\n        let status = parse_status_output(\"MM file.txt\").unwrap();\n        // Staged takes precedence, modified is skipped to avoid duplicates\n        assert_eq!(status.staged.len(), 1);\n        assert_eq!(status.modified.len(), 0);\n    }\n\n    #[test]\n    fn parse_status_short_line() {\n        let status = parse_status_output(\"X\").unwrap();\n        assert!(status.is_clean());\n    }\n\n    #[test]\n    fn parse_status_copied() {\n        let status = parse_status_output(\"C  src.txt -\u003e dst.txt\").unwrap();\n        assert_eq!(status.staged.len(), 1);\n    }\n\n    #[test]\n    fn generate_commit_message_single() {\n        let msg = generate_commit_message(1);\n        assert!(msg.contains(\"1 file\"));\n        assert!(!msg.contains(\"1 files\"));\n    }\n\n    #[test]\n    fn generate_commit_message_multiple() {\n        let msg = generate_commit_message(5);\n        assert!(msg.contains(\"5 files\"));\n    }\n\n    #[test]\n    fn generate_commit_message_contains_date() {\n        let msg = generate_commit_message(1);\n        let today = Local::now().format(\"%Y-%m-%d\").to_string();\n        assert!(msg.contains(\u0026today));\n    }\n\n    #[test]\n    fn is_git_repo_current() {\n        // Current directory should be a git repo (we're in hu project)\n        assert!(is_git_repo(Path::new(\".\")));\n    }\n\n    #[test]\n    fn is_git_repo_not_repo() {\n        assert!(!is_git_repo(Path::new(\"/tmp\")));\n    }\n\n    #[test]\n    fn get_branch_current() {\n        let result = get_branch(Path::new(\".\"));\n        assert!(result.is_ok());\n        assert!(!result.unwrap().is_empty());\n    }\n\n    #[test]\n    fn has_remote_current() {\n        // hu project should have a remote\n        assert!(has_remote(Path::new(\".\")));\n    }\n\n    #[test]\n    fn has_remote_no_repo() {\n        assert!(!has_remote(Path::new(\"/tmp\")));\n    }\n\n    #[test]\n    fn sync_not_git_repo() {\n        let opts = SyncOptions {\n            path: Some(std::path::PathBuf::from(\"/tmp\")),\n            ..Default::default()\n        };\n        let result = sync(\u0026opts);\n        assert!(result.is_err());\n        assert!(result\n            .unwrap_err()\n            .to_string()\n            .contains(\"Not a git repository\"));\n    }\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":3}},{"line":10,"address":[],"length":0,"stats":{"Line":12}},{"line":11,"address":[],"length":0,"stats":{"Line":6}},{"line":12,"address":[],"length":0,"stats":{"Line":3}},{"line":14,"address":[],"length":0,"stats":{"Line":3}},{"line":16,"address":[],"length":0,"stats":{"Line":3}},{"line":17,"address":[],"length":0,"stats":{"Line":3}},{"line":18,"address":[],"length":0,"stats":{"Line":3}},{"line":21,"address":[],"length":0,"stats":{"Line":2}},{"line":25,"address":[],"length":0,"stats":{"Line":6}},{"line":26,"address":[],"length":0,"stats":{"Line":18}},{"line":27,"address":[],"length":0,"stats":{"Line":12}},{"line":28,"address":[],"length":0,"stats":{"Line":6}},{"line":30,"address":[],"length":0,"stats":{"Line":18}},{"line":35,"address":[],"length":0,"stats":{"Line":1}},{"line":36,"address":[],"length":0,"stats":{"Line":4}},{"line":37,"address":[],"length":0,"stats":{"Line":3}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":1}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":12}},{"line":53,"address":[],"length":0,"stats":{"Line":24}},{"line":54,"address":[],"length":0,"stats":{"Line":24}},{"line":55,"address":[],"length":0,"stats":{"Line":12}},{"line":56,"address":[],"length":0,"stats":{"Line":12}},{"line":59,"address":[],"length":0,"stats":{"Line":38}},{"line":60,"address":[],"length":0,"stats":{"Line":14}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":64,"address":[],"length":0,"stats":{"Line":52}},{"line":65,"address":[],"length":0,"stats":{"Line":52}},{"line":66,"address":[],"length":0,"stats":{"Line":39}},{"line":67,"address":[],"length":0,"stats":{"Line":39}},{"line":70,"address":[],"length":0,"stats":{"Line":13}},{"line":71,"address":[],"length":0,"stats":{"Line":24}},{"line":72,"address":[],"length":0,"stats":{"Line":8}},{"line":73,"address":[],"length":0,"stats":{"Line":5}},{"line":77,"address":[],"length":0,"stats":{"Line":13}},{"line":79,"address":[],"length":0,"stats":{"Line":8}},{"line":80,"address":[],"length":0,"stats":{"Line":4}},{"line":84,"address":[],"length":0,"stats":{"Line":3}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":88,"address":[],"length":0,"stats":{"Line":6}},{"line":89,"address":[],"length":0,"stats":{"Line":7}},{"line":93,"address":[],"length":0,"stats":{"Line":12}},{"line":97,"address":[],"length":0,"stats":{"Line":3}},{"line":98,"address":[],"length":0,"stats":{"Line":12}},{"line":99,"address":[],"length":0,"stats":{"Line":9}},{"line":100,"address":[],"length":0,"stats":{"Line":6}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":2}},{"line":124,"address":[],"length":0,"stats":{"Line":6}},{"line":125,"address":[],"length":0,"stats":{"Line":4}},{"line":130,"address":[],"length":0,"stats":{"Line":4}},{"line":131,"address":[],"length":0,"stats":{"Line":8}},{"line":132,"address":[],"length":0,"stats":{"Line":4}},{"line":134,"address":[],"length":0,"stats":{"Line":4}},{"line":136,"address":[],"length":0,"stats":{"Line":4}},{"line":137,"address":[],"length":0,"stats":{"Line":12}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}}],"covered":56,"coverable":91},{"path":["/","Users","chi","Projects","hu","src","git","types.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::path::PathBuf;\n\n/// Result of git status operation\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GitStatus {\n    /// Files that have been modified\n    pub modified: Vec\u003cPathBuf\u003e,\n    /// Files that are staged for commit\n    pub staged: Vec\u003cPathBuf\u003e,\n    /// Untracked files\n    pub untracked: Vec\u003cPathBuf\u003e,\n    /// Deleted files\n    pub deleted: Vec\u003cPathBuf\u003e,\n}\n\nimpl GitStatus {\n    /// Returns true if there are no changes\n    pub fn is_clean(\u0026self) -\u003e bool {\n        self.modified.is_empty()\n            \u0026\u0026 self.staged.is_empty()\n            \u0026\u0026 self.untracked.is_empty()\n            \u0026\u0026 self.deleted.is_empty()\n    }\n\n    /// Total number of changed files\n    pub fn file_count(\u0026self) -\u003e usize {\n        self.modified.len() + self.staged.len() + self.untracked.len() + self.deleted.len()\n    }\n}\n\n/// Result of sync operation\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SyncResult {\n    /// Number of files committed\n    pub files_committed: usize,\n    /// Commit hash (short form)\n    pub commit_hash: Option\u003cString\u003e,\n    /// Whether changes were pushed\n    pub pushed: bool,\n    /// Branch name\n    pub branch: Option\u003cString\u003e,\n}\n\n/// Options for sync operation\n#[derive(Debug, Clone, Default)]\npub struct SyncOptions {\n    /// Skip git commit\n    pub no_commit: bool,\n    /// Skip git push\n    pub no_push: bool,\n    /// Custom commit message (if None, uses default format)\n    pub message: Option\u003cString\u003e,\n    /// Working directory (if None, uses current directory)\n    pub path: Option\u003cPathBuf\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn git_status_is_clean_when_empty() {\n        let status = GitStatus {\n            modified: vec![],\n            staged: vec![],\n            untracked: vec![],\n            deleted: vec![],\n        };\n        assert!(status.is_clean());\n    }\n\n    #[test]\n    fn git_status_is_not_clean_with_modified() {\n        let status = GitStatus {\n            modified: vec![PathBuf::from(\"file.txt\")],\n            staged: vec![],\n            untracked: vec![],\n            deleted: vec![],\n        };\n        assert!(!status.is_clean());\n    }\n\n    #[test]\n    fn git_status_is_not_clean_with_staged() {\n        let status = GitStatus {\n            modified: vec![],\n            staged: vec![PathBuf::from(\"file.txt\")],\n            untracked: vec![],\n            deleted: vec![],\n        };\n        assert!(!status.is_clean());\n    }\n\n    #[test]\n    fn git_status_is_not_clean_with_untracked() {\n        let status = GitStatus {\n            modified: vec![],\n            staged: vec![],\n            untracked: vec![PathBuf::from(\"file.txt\")],\n            deleted: vec![],\n        };\n        assert!(!status.is_clean());\n    }\n\n    #[test]\n    fn git_status_is_not_clean_with_deleted() {\n        let status = GitStatus {\n            modified: vec![],\n            staged: vec![],\n            untracked: vec![],\n            deleted: vec![PathBuf::from(\"file.txt\")],\n        };\n        assert!(!status.is_clean());\n    }\n\n    #[test]\n    fn git_status_file_count() {\n        let status = GitStatus {\n            modified: vec![PathBuf::from(\"a.txt\"), PathBuf::from(\"b.txt\")],\n            staged: vec![PathBuf::from(\"c.txt\")],\n            untracked: vec![PathBuf::from(\"d.txt\")],\n            deleted: vec![],\n        };\n        assert_eq!(status.file_count(), 4);\n    }\n\n    #[test]\n    fn git_status_file_count_empty() {\n        let status = GitStatus {\n            modified: vec![],\n            staged: vec![],\n            untracked: vec![],\n            deleted: vec![],\n        };\n        assert_eq!(status.file_count(), 0);\n    }\n\n    #[test]\n    fn sync_options_default() {\n        let opts = SyncOptions::default();\n        assert!(!opts.no_commit);\n        assert!(!opts.no_push);\n        assert!(opts.message.is_none());\n        assert!(opts.path.is_none());\n    }\n\n    #[test]\n    fn sync_result_debug() {\n        let result = SyncResult {\n            files_committed: 5,\n            commit_hash: Some(\"abc1234\".to_string()),\n            pushed: true,\n            branch: Some(\"main\".to_string()),\n        };\n        let debug = format!(\"{:?}\", result);\n        assert!(debug.contains(\"abc1234\"));\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":7}},{"line":20,"address":[],"length":0,"stats":{"Line":14}},{"line":21,"address":[],"length":0,"stats":{"Line":12}},{"line":22,"address":[],"length":0,"stats":{"Line":10}},{"line":23,"address":[],"length":0,"stats":{"Line":8}},{"line":27,"address":[],"length":0,"stats":{"Line":2}},{"line":28,"address":[],"length":0,"stats":{"Line":10}}],"covered":7,"coverable":7},{"path":["/","Users","chi","Projects","hu","src","install","cli.rs"],"content":"use clap::{Args, Subcommand};\n\n#[derive(Subcommand)]\npub enum InstallCommand {\n    /// Install hooks and commands to Claude Code configuration\n    Run(InstallArgs),\n\n    /// Show what would be installed without making changes\n    Preview(InstallArgs),\n\n    /// List available components\n    List,\n}\n\n#[derive(Args)]\npub struct InstallArgs {\n    /// Install to global ~/.claude directory (default)\n    #[arg(short, long, conflicts_with = \"local\")]\n    pub global: bool,\n\n    /// Install to current project's .claude directory\n    #[arg(short, long)]\n    pub local: bool,\n\n    /// Override existing files\n    #[arg(short, long)]\n    pub force: bool,\n\n    /// Install only hooks (shell scripts)\n    #[arg(long, conflicts_with = \"commands_only\")]\n    pub hooks_only: bool,\n\n    /// Install only commands (slash command documentation)\n    #[arg(long)]\n    pub commands_only: bool,\n\n    /// Specific components to install (e.g., \"hooks/hu/pre-read\", \"commands/hu/read\")\n    #[arg(value_name = \"COMPONENT\")]\n    pub components: Vec\u003cString\u003e,\n}\n\nimpl InstallArgs {\n    pub fn target_dir(\u0026self) -\u003e TargetDir {\n        if self.local {\n            TargetDir::Local\n        } else {\n            TargetDir::Global\n        }\n    }\n\n    pub fn install_hooks(\u0026self) -\u003e bool {\n        !self.commands_only\n    }\n\n    pub fn install_commands(\u0026self) -\u003e bool {\n        !self.hooks_only\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum TargetDir {\n    Global,\n    Local,\n}\n\nimpl TargetDir {\n    pub fn path(\u0026self) -\u003e std::path::PathBuf {\n        match self {\n            TargetDir::Global =\u003e dirs::home_dir()\n                .expect(\"could not find home directory\")\n                .join(\".claude\"),\n            TargetDir::Local =\u003e std::env::current_dir()\n                .expect(\"could not get current directory\")\n                .join(\".claude\"),\n        }\n    }\n\n    pub fn display_name(\u0026self) -\u003e \u0026'static str {\n        match self {\n            TargetDir::Global =\u003e \"~/.claude (global)\",\n            TargetDir::Local =\u003e \"./.claude (local)\",\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn target_dir_defaults_to_global() {\n        let args = InstallArgs {\n            global: false,\n            local: false,\n            force: false,\n            hooks_only: false,\n            commands_only: false,\n            components: vec![],\n        };\n        assert_eq!(args.target_dir(), TargetDir::Global);\n    }\n\n    #[test]\n    fn target_dir_local_when_specified() {\n        let args = InstallArgs {\n            global: false,\n            local: true,\n            force: false,\n            hooks_only: false,\n            commands_only: false,\n            components: vec![],\n        };\n        assert_eq!(args.target_dir(), TargetDir::Local);\n    }\n\n    #[test]\n    fn install_both_by_default() {\n        let args = InstallArgs {\n            global: false,\n            local: false,\n            force: false,\n            hooks_only: false,\n            commands_only: false,\n            components: vec![],\n        };\n        assert!(args.install_hooks());\n        assert!(args.install_commands());\n    }\n\n    #[test]\n    fn hooks_only_excludes_commands() {\n        let args = InstallArgs {\n            global: false,\n            local: false,\n            force: false,\n            hooks_only: true,\n            commands_only: false,\n            components: vec![],\n        };\n        assert!(args.install_hooks());\n        assert!(!args.install_commands());\n    }\n\n    #[test]\n    fn commands_only_excludes_hooks() {\n        let args = InstallArgs {\n            global: false,\n            local: false,\n            force: false,\n            hooks_only: false,\n            commands_only: true,\n            components: vec![],\n        };\n        assert!(!args.install_hooks());\n        assert!(args.install_commands());\n    }\n}\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":1}},{"line":47,"address":[],"length":0,"stats":{"Line":1}},{"line":51,"address":[],"length":0,"stats":{"Line":3}},{"line":52,"address":[],"length":0,"stats":{"Line":3}},{"line":55,"address":[],"length":0,"stats":{"Line":3}},{"line":56,"address":[],"length":0,"stats":{"Line":3}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}}],"covered":8,"coverable":16},{"path":["/","Users","chi","Projects","hu","src","install","mod.rs"],"content":"mod cli;\nmod templates;\nmod types;\n\npub use cli::InstallCommand;\n\nuse std::fs;\nuse std::os::unix::fs::PermissionsExt;\n\nuse anyhow::{bail, Context, Result};\nuse comfy_table::{presets::UTF8_FULL_CONDENSED, Cell, Color, Table};\n\nuse cli::{InstallArgs, TargetDir};\nuse templates::{get_components, COMPONENTS};\nuse types::{Component, ComponentKind, ComponentStatus, InstallStatus};\n\npub async fn run_command(cmd: InstallCommand) -\u003e Result\u003c()\u003e {\n    match cmd {\n        InstallCommand::Run(args) =\u003e run_install(args, false),\n        InstallCommand::Preview(args) =\u003e run_install(args, true),\n        InstallCommand::List =\u003e list_components(),\n    }\n}\n\nfn list_components() -\u003e Result\u003c()\u003e {\n    let mut table = Table::new();\n    table.load_preset(UTF8_FULL_CONDENSED);\n    table.set_header(vec![\"ID\", \"Type\", \"Description\"]);\n\n    for component in COMPONENTS {\n        table.add_row(vec![\n            Cell::new(component.id),\n            Cell::new(component.kind.label()),\n            Cell::new(component.description),\n        ]);\n    }\n\n    println!(\"{table}\");\n    println!();\n    println!(\"Hooks:    {}\", templates::get_hooks().len());\n    println!(\"Commands: {}\", templates::get_commands().len());\n    Ok(())\n}\n\nfn run_install(args: InstallArgs, preview: bool) -\u003e Result\u003c()\u003e {\n    let target = args.target_dir();\n    let base_dir = target.path();\n\n    // Filter components based on args\n    let components: Vec\u003c\u0026Component\u003e = if !args.components.is_empty() {\n        // User specified specific components\n        let mut selected = Vec::new();\n        for id in \u0026args.components {\n            match COMPONENTS.iter().find(|c| c.id == id.as_str()) {\n                Some(c) =\u003e selected.push(c),\n                None =\u003e bail!(\"Unknown component: {}\", id),\n            }\n        }\n        selected\n    } else {\n        // Use flags to filter\n        get_components(args.install_hooks(), args.install_commands())\n    };\n\n    if components.is_empty() {\n        println!(\"No components selected for installation.\");\n        return Ok(());\n    }\n\n    // Check status of each component\n    let statuses: Vec\u003cComponentStatus\u003e = components\n        .iter()\n        .map(|c| check_component_status(c, \u0026base_dir))\n        .collect();\n\n    // Display status table\n    print_status_table(\u0026statuses, \u0026target);\n\n    // Determine what to install\n    let to_install: Vec\u003c_\u003e = statuses\n        .iter()\n        .filter(|s| {\n            matches!(s.status, InstallStatus::Missing)\n                || (args.force \u0026\u0026 matches!(s.status, InstallStatus::Modified))\n        })\n        .collect();\n\n    let to_skip: Vec\u003c_\u003e = statuses\n        .iter()\n        .filter(|s| !args.force \u0026\u0026 matches!(s.status, InstallStatus::Modified))\n        .collect();\n\n    if !to_skip.is_empty() {\n        println!();\n        println!(\n            \"Skipping {} modified component(s). Use --force to override.\",\n            to_skip.len()\n        );\n    }\n\n    if to_install.is_empty() {\n        println!();\n        println!(\"Nothing to install. All components are current.\");\n        return Ok(());\n    }\n\n    if preview {\n        println!();\n        println!(\n            \"Preview mode. Would install {} component(s):\",\n            to_install.len()\n        );\n        for status in \u0026to_install {\n            println!(\"  {} {}\", status.status.symbol(), status.component.id);\n        }\n        return Ok(());\n    }\n\n    // Install components\n    println!();\n    println!(\"Installing {} component(s)...\", to_install.len());\n\n    let has_hooks = to_install\n        .iter()\n        .any(|s| s.component.kind == ComponentKind::Hook);\n\n    for status in \u0026to_install {\n        install_component(status.component, \u0026base_dir)?;\n        println!(\"   {}\", status.component.id);\n    }\n\n    // Update settings.json if we installed hooks\n    if has_hooks {\n        update_settings_json(\u0026base_dir)?;\n        println!(\"   Updated settings.json with hook configuration\");\n    }\n\n    println!();\n    println!(\"Installation complete.\");\n\n    // Check if hu CLI is available\n    if !is_hu_available() {\n        println!();\n        println!(\"Warning: 'hu' CLI not found in PATH.\");\n        println!(\"Hooks require 'hu' to be installed. Run:\");\n        println!(\"  cargo install --path ~/Projects/hu\");\n    }\n\n    Ok(())\n}\n\nfn check_component_status(\n    component: \u0026'static Component,\n    base_dir: \u0026std::path::Path,\n) -\u003e ComponentStatus {\n    let target_path = component.target_path(base_dir);\n\n    let status = if !target_path.exists() {\n        InstallStatus::Missing\n    } else {\n        match fs::read_to_string(\u0026target_path) {\n            Ok(content) if content == component.content =\u003e InstallStatus::Current,\n            _ =\u003e InstallStatus::Modified,\n        }\n    };\n\n    ComponentStatus { component, status }\n}\n\nfn print_status_table(statuses: \u0026[ComponentStatus], target: \u0026TargetDir) {\n    println!(\"Target: {}\", target.display_name());\n    println!();\n\n    let mut table = Table::new();\n    table.load_preset(UTF8_FULL_CONDENSED);\n    table.set_header(vec![\"\", \"Component\", \"Status\"]);\n\n    for status in statuses {\n        let (symbol, color) = match status.status {\n            InstallStatus::Missing =\u003e (\"\", Color::Yellow),\n            InstallStatus::Current =\u003e (\"\", Color::Green),\n            InstallStatus::Modified =\u003e (\"\", Color::Cyan),\n        };\n\n        table.add_row(vec![\n            Cell::new(symbol).fg(color),\n            Cell::new(status.component.id),\n            Cell::new(status.status.label()).fg(color),\n        ]);\n    }\n\n    println!(\"{table}\");\n}\n\nfn install_component(component: \u0026Component, base_dir: \u0026std::path::Path) -\u003e Result\u003c()\u003e {\n    let target_path = component.target_path(base_dir);\n\n    // Create parent directories\n    if let Some(parent) = target_path.parent() {\n        fs::create_dir_all(parent)\n            .with_context(|| format!(\"Failed to create {}\", parent.display()))?;\n    }\n\n    // Write content\n    fs::write(\u0026target_path, component.content)\n        .with_context(|| format!(\"Failed to write {}\", target_path.display()))?;\n\n    // Make hooks executable\n    if component.kind == ComponentKind::Hook {\n        let mut perms = fs::metadata(\u0026target_path)?.permissions();\n        perms.set_mode(0o755);\n        fs::set_permissions(\u0026target_path, perms)?;\n    }\n\n    Ok(())\n}\n\nfn update_settings_json(base_dir: \u0026std::path::Path) -\u003e Result\u003c()\u003e {\n    let settings_path = base_dir.join(\"settings.json\");\n\n    // Read existing settings or create new\n    let mut settings: serde_json::Value = if settings_path.exists() {\n        let content = fs::read_to_string(\u0026settings_path)?;\n        serde_json::from_str(\u0026content)?\n    } else {\n        serde_json::json!({})\n    };\n\n    // Ensure env section exists with defaults\n    if settings.get(\"env\").is_none() {\n        settings[\"env\"] = serde_json::json!({\n            \"HU_MAX_FILE_LINES\": \"500\",\n            \"HU_MAX_GREP_RESULTS\": \"20\",\n            \"HU_CLEANUP_DAYS\": \"7\"\n        });\n    }\n\n    // Build hooks configuration\n    let hooks_dir = if base_dir.ends_with(\".claude\") {\n        base_dir.display().to_string()\n    } else {\n        format!(\"{}\", base_dir.display())\n    };\n\n    // Use ~ for home directory in paths for portability\n    let hooks_prefix = if hooks_dir.starts_with(\u0026dirs::home_dir().unwrap().display().to_string()) {\n        \"~/.claude\"\n    } else {\n        \"./.claude\"\n    };\n\n    let hooks_config = serde_json::json!({\n        \"PreToolUse\": [\n            {\n                \"matcher\": \"Read\",\n                \"hooks\": [{\n                    \"type\": \"command\",\n                    \"command\": format!(\"{}/hooks/hu/pre-read.sh\", hooks_prefix),\n                    \"timeout\": 5000\n                }]\n            },\n            {\n                \"matcher\": \"Grep\",\n                \"hooks\": [{\n                    \"type\": \"command\",\n                    \"command\": format!(\"{}/hooks/hu/pre-grep.sh\", hooks_prefix),\n                    \"timeout\": 5000\n                }]\n            },\n            {\n                \"matcher\": \"WebFetch\",\n                \"hooks\": [{\n                    \"type\": \"command\",\n                    \"command\": format!(\"{}/hooks/hu/pre-webfetch.sh\", hooks_prefix),\n                    \"timeout\": 5000\n                }]\n            },\n            {\n                \"matcher\": \"WebSearch\",\n                \"hooks\": [{\n                    \"type\": \"command\",\n                    \"command\": format!(\"{}/hooks/hu/pre-websearch.sh\", hooks_prefix),\n                    \"timeout\": 5000\n                }]\n            }\n        ],\n        \"SessionStart\": [{\n            \"hooks\": [{\n                \"type\": \"command\",\n                \"command\": format!(\"{}/hooks/hu/session-start.sh\", hooks_prefix),\n                \"timeout\": 30000\n            }]\n        }],\n        \"SessionEnd\": [{\n            \"hooks\": [{\n                \"type\": \"command\",\n                \"command\": format!(\"{}/hooks/hu/session-end.sh\", hooks_prefix),\n                \"timeout\": 10000\n            }]\n        }]\n    });\n\n    settings[\"hooks\"] = hooks_config;\n\n    // Write back with pretty formatting\n    let content = serde_json::to_string_pretty(\u0026settings)?;\n    fs::write(\u0026settings_path, content)?;\n\n    Ok(())\n}\n\nfn is_hu_available() -\u003e bool {\n    std::process::Command::new(\"hu\")\n        .arg(\"--version\")\n        .output()\n        .is_ok()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::TempDir;\n\n    #[test]\n    fn check_status_missing() {\n        let temp = TempDir::new().unwrap();\n        let component = \u0026templates::COMPONENTS[0];\n        let status = check_component_status(component, \u0026temp.path().to_path_buf());\n        assert_eq!(status.status, InstallStatus::Missing);\n    }\n\n    #[test]\n    fn check_status_current() {\n        let temp = TempDir::new().unwrap();\n        let component = \u0026templates::COMPONENTS[0];\n\n        // Create the file with matching content\n        let target = temp.path().join(component.path);\n        fs::create_dir_all(target.parent().unwrap()).unwrap();\n        fs::write(\u0026target, component.content).unwrap();\n\n        let status = check_component_status(component, \u0026temp.path().to_path_buf());\n        assert_eq!(status.status, InstallStatus::Current);\n    }\n\n    #[test]\n    fn check_status_modified() {\n        let temp = TempDir::new().unwrap();\n        let component = \u0026templates::COMPONENTS[0];\n\n        // Create the file with different content\n        let target = temp.path().join(component.path);\n        fs::create_dir_all(target.parent().unwrap()).unwrap();\n        fs::write(\u0026target, \"modified content\").unwrap();\n\n        let status = check_component_status(component, \u0026temp.path().to_path_buf());\n        assert_eq!(status.status, InstallStatus::Modified);\n    }\n\n    #[test]\n    fn install_creates_file() {\n        let temp = TempDir::new().unwrap();\n        let component = \u0026templates::COMPONENTS[0];\n\n        install_component(component, \u0026temp.path().to_path_buf()).unwrap();\n\n        let target = temp.path().join(component.path);\n        assert!(target.exists());\n        assert_eq!(fs::read_to_string(\u0026target).unwrap(), component.content);\n    }\n\n    #[test]\n    fn install_hook_is_executable() {\n        let temp = TempDir::new().unwrap();\n        let hook = templates::get_hooks()[0];\n\n        install_component(hook, \u0026temp.path().to_path_buf()).unwrap();\n\n        let target = temp.path().join(hook.path);\n        let perms = fs::metadata(\u0026target).unwrap().permissions();\n        assert_eq!(perms.mode() \u0026 0o111, 0o111); // Executable bits set\n    }\n\n    #[test]\n    fn update_settings_creates_file() {\n        let temp = TempDir::new().unwrap();\n        update_settings_json(\u0026temp.path().to_path_buf()).unwrap();\n\n        let settings_path = temp.path().join(\"settings.json\");\n        assert!(settings_path.exists());\n\n        let content: serde_json::Value =\n            serde_json::from_str(\u0026fs::read_to_string(\u0026settings_path).unwrap()).unwrap();\n        assert!(content.get(\"hooks\").is_some());\n        assert!(content.get(\"env\").is_some());\n    }\n\n    #[test]\n    fn update_settings_preserves_existing() {\n        let temp = TempDir::new().unwrap();\n        let settings_path = temp.path().join(\"settings.json\");\n\n        // Create existing settings with custom values\n        fs::write(\n            \u0026settings_path,\n            r#\"{\"model\": \"opus\", \"permissions\": {\"allow\": [\"Bash\"]}}\"#,\n        )\n        .unwrap();\n\n        update_settings_json(\u0026temp.path().to_path_buf()).unwrap();\n\n        let content: serde_json::Value =\n            serde_json::from_str(\u0026fs::read_to_string(\u0026settings_path).unwrap()).unwrap();\n\n        // Check preserved values\n        assert_eq!(content[\"model\"], \"opus\");\n        assert!(content[\"permissions\"][\"allow\"].as_array().is_some());\n\n        // Check new values added\n        assert!(content.get(\"hooks\").is_some());\n    }\n\n    #[test]\n    fn get_components_with_both() {\n        let components = get_components(true, true);\n        let has_hooks = components.iter().any(|c| c.kind == ComponentKind::Hook);\n        let has_commands = components.iter().any(|c| c.kind == ComponentKind::Command);\n        assert!(has_hooks);\n        assert!(has_commands);\n    }\n\n    #[test]\n    fn get_components_hooks_only() {\n        let components = get_components(true, false);\n        assert!(components.iter().all(|c| c.kind == ComponentKind::Hook));\n    }\n\n    #[test]\n    fn get_components_commands_only() {\n        let components = get_components(false, true);\n        assert!(components.iter().all(|c| c.kind == ComponentKind::Command));\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":3}},{"line":156,"address":[],"length":0,"stats":{"Line":12}},{"line":158,"address":[],"length":0,"stats":{"Line":6}},{"line":159,"address":[],"length":0,"stats":{"Line":1}},{"line":161,"address":[],"length":0,"stats":{"Line":4}},{"line":162,"address":[],"length":0,"stats":{"Line":5}},{"line":163,"address":[],"length":0,"stats":{"Line":1}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":2}},{"line":196,"address":[],"length":0,"stats":{"Line":8}},{"line":199,"address":[],"length":0,"stats":{"Line":4}},{"line":200,"address":[],"length":0,"stats":{"Line":4}},{"line":201,"address":[],"length":0,"stats":{"Line":2}},{"line":205,"address":[],"length":0,"stats":{"Line":6}},{"line":206,"address":[],"length":0,"stats":{"Line":2}},{"line":209,"address":[],"length":0,"stats":{"Line":2}},{"line":210,"address":[],"length":0,"stats":{"Line":8}},{"line":211,"address":[],"length":0,"stats":{"Line":4}},{"line":212,"address":[],"length":0,"stats":{"Line":6}},{"line":215,"address":[],"length":0,"stats":{"Line":2}},{"line":218,"address":[],"length":0,"stats":{"Line":2}},{"line":219,"address":[],"length":0,"stats":{"Line":6}},{"line":222,"address":[],"length":0,"stats":{"Line":6}},{"line":223,"address":[],"length":0,"stats":{"Line":3}},{"line":224,"address":[],"length":0,"stats":{"Line":2}},{"line":226,"address":[],"length":0,"stats":{"Line":1}},{"line":230,"address":[],"length":0,"stats":{"Line":6}},{"line":231,"address":[],"length":0,"stats":{"Line":6}},{"line":232,"address":[],"length":0,"stats":{"Line":4}},{"line":233,"address":[],"length":0,"stats":{"Line":2}},{"line":234,"address":[],"length":0,"stats":{"Line":2}},{"line":239,"address":[],"length":0,"stats":{"Line":6}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":8}},{"line":246,"address":[],"length":0,"stats":{"Line":8}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":2}},{"line":252,"address":[],"length":0,"stats":{"Line":4}},{"line":253,"address":[],"length":0,"stats":{"Line":2}},{"line":255,"address":[],"length":0,"stats":{"Line":2}},{"line":256,"address":[],"length":0,"stats":{"Line":2}},{"line":257,"address":[],"length":0,"stats":{"Line":2}},{"line":258,"address":[],"length":0,"stats":{"Line":6}},{"line":259,"address":[],"length":0,"stats":{"Line":2}},{"line":263,"address":[],"length":0,"stats":{"Line":2}},{"line":264,"address":[],"length":0,"stats":{"Line":2}},{"line":265,"address":[],"length":0,"stats":{"Line":2}},{"line":266,"address":[],"length":0,"stats":{"Line":6}},{"line":267,"address":[],"length":0,"stats":{"Line":2}},{"line":271,"address":[],"length":0,"stats":{"Line":2}},{"line":272,"address":[],"length":0,"stats":{"Line":2}},{"line":273,"address":[],"length":0,"stats":{"Line":2}},{"line":274,"address":[],"length":0,"stats":{"Line":6}},{"line":275,"address":[],"length":0,"stats":{"Line":2}},{"line":279,"address":[],"length":0,"stats":{"Line":2}},{"line":280,"address":[],"length":0,"stats":{"Line":2}},{"line":281,"address":[],"length":0,"stats":{"Line":2}},{"line":282,"address":[],"length":0,"stats":{"Line":6}},{"line":283,"address":[],"length":0,"stats":{"Line":2}},{"line":287,"address":[],"length":0,"stats":{"Line":2}},{"line":288,"address":[],"length":0,"stats":{"Line":2}},{"line":289,"address":[],"length":0,"stats":{"Line":2}},{"line":290,"address":[],"length":0,"stats":{"Line":6}},{"line":291,"address":[],"length":0,"stats":{"Line":2}},{"line":294,"address":[],"length":0,"stats":{"Line":2}},{"line":295,"address":[],"length":0,"stats":{"Line":2}},{"line":296,"address":[],"length":0,"stats":{"Line":2}},{"line":297,"address":[],"length":0,"stats":{"Line":6}},{"line":298,"address":[],"length":0,"stats":{"Line":2}},{"line":303,"address":[],"length":0,"stats":{"Line":4}},{"line":306,"address":[],"length":0,"stats":{"Line":6}},{"line":307,"address":[],"length":0,"stats":{"Line":6}},{"line":309,"address":[],"length":0,"stats":{"Line":2}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}}],"covered":70,"coverable":167},{"path":["/","Users","chi","Projects","hu","src","install","templates.rs"],"content":"use crate::install::types::{Component, ComponentKind};\n\n// ============================================================================\n// HOOKS\n// ============================================================================\n\npub const HOOK_PRE_READ: \u0026str = r#\"#!/bin/bash\n# Pre-Read Hook: Prevent duplicate reads and auto-truncate large files\nset -euo pipefail\n[[ \"${HU_SKIP_HOOKS:-}\" == \"1\" ]] \u0026\u0026 exit 0\n\nMAX_LINES=\"${HU_MAX_FILE_LINES:-500}\"\nINPUT=$(cat)\nFILE_PATH=$(echo \"$INPUT\" | jq -r '.file_path // empty')\n[[ -z \"$FILE_PATH\" ]] \u0026\u0026 exit 0\n\nif command -v hu \u0026\u003e/dev/null; then\n    STATUS=$(hu context check \"$FILE_PATH\" 2\u003e/dev/null || echo \"\")\n    if echo \"$STATUS\" | grep -q \"loaded\"; then\n        AGO=$(echo \"$STATUS\" | grep -oE '[0-9]+ (seconds?|minutes?|hours?) ago' || echo \"recently\")\n        echo \"File already in context (loaded $AGO). Use --force to re-read.\"\n        exit 0\n    fi\nfi\n\nif [[ -f \"$FILE_PATH\" ]]; then\n    LINE_COUNT=$(wc -l \u003c \"$FILE_PATH\" 2\u003e/dev/null || echo \"0\")\n    if [[ \"$LINE_COUNT\" -gt \"$MAX_LINES\" ]]; then\n        echo \"Warning: $FILE_PATH has $LINE_COUNT lines (\u003e${MAX_LINES} threshold).\"\n        echo \"Consider: hu read '$FILE_PATH' --outline | --interface | --around N\"\n    fi\n    command -v hu \u0026\u003e/dev/null \u0026\u0026 hu context track \"$FILE_PATH\" 2\u003e/dev/null || true\nfi\nexit 0\n\"#;\n\npub const HOOK_PRE_GREP: \u0026str = r#\"#!/bin/bash\n# Pre-Grep Hook: Warn on broad patterns\nset -euo pipefail\n[[ \"${HU_SKIP_HOOKS:-}\" == \"1\" ]] \u0026\u0026 exit 0\n\nINPUT=$(cat)\nPATTERN=$(echo \"$INPUT\" | jq -r '.pattern // empty')\n[[ -z \"$PATTERN\" ]] \u0026\u0026 exit 0\n\nBROAD_PATTERNS=(\"^.$\" \"^..$\" \"the\" \"function\" \"import\" \"return\" \"if\" \"for\" \"var\" \"let\" \"const\")\nPATTERN_LOWER=$(echo \"$PATTERN\" | tr '[:upper:]' '[:lower:]')\nfor BROAD in \"${BROAD_PATTERNS[@]}\"; do\n    if [[ \"$PATTERN_LOWER\" =~ $BROAD ]]; then\n        echo \"Warning: Pattern '$PATTERN' may match many results.\"\n        break\n    fi\ndone\nexit 0\n\"#;\n\npub const HOOK_PRE_WEBFETCH: \u0026str = r#\"#!/bin/bash\n# Pre-WebFetch Hook: Log URL fetches\nset -euo pipefail\n[[ \"${HU_SKIP_HOOKS:-}\" == \"1\" ]] \u0026\u0026 exit 0\n\nINPUT=$(cat)\nURL=$(echo \"$INPUT\" | jq -r '.url // empty')\n[[ -z \"$URL\" ]] \u0026\u0026 exit 0\n\necho \"WebFetch: $URL\"\n[[ \"$URL\" == http://* ]] \u0026\u0026 echo \"Warning: Using HTTP instead of HTTPS\"\nexit 0\n\"#;\n\npub const HOOK_PRE_WEBSEARCH: \u0026str = r#\"#!/bin/bash\n# Pre-WebSearch Hook: Log searches\nset -euo pipefail\n[[ \"${HU_SKIP_HOOKS:-}\" == \"1\" ]] \u0026\u0026 exit 0\n\nINPUT=$(cat)\nQUERY=$(echo \"$INPUT\" | jq -r '.query // empty')\n[[ -z \"$QUERY\" ]] \u0026\u0026 exit 0\n\necho \"WebSearch: \\\"$QUERY\\\"\"\n[[ ${#QUERY} -lt 5 ]] \u0026\u0026 echo \"Warning: Query is very short.\"\nexit 0\n\"#;\n\npub const HOOK_SESSION_START: \u0026str = r#\"#!/bin/bash\n# Session-Start Hook: Initialize context tracking and cleanup\nset -euo pipefail\n[[ \"${HU_SKIP_HOOKS:-}\" == \"1\" ]] \u0026\u0026 exit 0\n\nCLEANUP_DAYS=\"${HU_CLEANUP_DAYS:-7}\"\nCLAUDE_DIR=\"${HOME}/.claude\"\n\n[[ -d \"$CLAUDE_DIR/debug\" ]] \u0026\u0026 find \"$CLAUDE_DIR/debug\" -type f -mtime +$CLEANUP_DAYS -delete 2\u003e/dev/null || true\necho \"Cleaned debug files older than $CLEANUP_DAYS days\"\n\n[[ -d \"$CLAUDE_DIR/shell-snapshots\" ]] \u0026\u0026 find \"$CLAUDE_DIR/shell-snapshots\" -type f -mtime +$CLEANUP_DAYS -delete 2\u003e/dev/null || true\n[[ -d \"$CLAUDE_DIR/paste-cache\" ]] \u0026\u0026 find \"$CLAUDE_DIR/paste-cache\" -type f -mtime +$CLEANUP_DAYS -delete 2\u003e/dev/null || true\n\nif command -v hu \u0026\u003e/dev/null; then\n    hu context clear 2\u003e/dev/null || true\n    echo \"Context tracking initialized\"\nfi\n\nif [[ -d \".git\" ]] \u0026\u0026 [[ -d \"doc\" || -d \"docs\" ]]; then\n    DOC_DIR=\"doc\"; [[ -d \"docs\" ]] \u0026\u0026 DOC_DIR=\"docs\"\n    if command -v hu \u0026\u003e/dev/null; then\n        INDEX_FILE=\"/tmp/hu-docs-index-$(basename \"$(pwd)\").json\"\n        (hu utils docs-index \"$DOC_DIR\" -o \"$INDEX_FILE\" 2\u003e/dev/null \u0026)\n        echo \"Building docs index in background: $INDEX_FILE\"\n    fi\nfi\n\necho -e \"\\nSession initialized. Token-saving features active:\"\necho \"  - Context tracking: prevents duplicate file reads\"\necho \"  - Large file warnings: suggests --outline/--around\"\necho \"  - Grep limits: caps broad searches\"\necho -e \"\\nBypass with: HU_SKIP_HOOKS=1\"\nexit 0\n\"#;\n\npub const HOOK_SESSION_END: \u0026str = r#\"#!/bin/bash\n# Session-End Hook: Cleanup context tracking\nset -euo pipefail\n[[ \"${HU_SKIP_HOOKS:-}\" == \"1\" ]] \u0026\u0026 exit 0\n\nif command -v hu \u0026\u003e/dev/null; then\n    SUMMARY=$(hu context summary 2\u003e/dev/null || echo \"\")\n    if [[ -n \"$SUMMARY\" ]] \u0026\u0026 ! echo \"$SUMMARY\" | grep -q \"No files\"; then\n        echo \"Session context summary:\"\n        echo \"$SUMMARY\"\n    fi\n    hu context clear 2\u003e/dev/null || true\nfi\n\nINDEX_FILE=\"/tmp/hu-docs-index-$(basename \"$(pwd)\").json\"\n[[ -f \"$INDEX_FILE\" ]] \u0026\u0026 rm -f \"$INDEX_FILE\"\necho \"Session cleanup complete\"\nexit 0\n\"#;\n\n// ============================================================================\n// COMMANDS - Context\n// ============================================================================\n\npub const CMD_CONTEXT_TRACK: \u0026str = r#\"Track file(s) as loaded in context.\n\n```bash\nhu context track \u003cfile\u003e...\n```\n\nPrevents duplicate reads of the same files in a session.\n\"#;\n\npub const CMD_CONTEXT_CHECK: \u0026str = r#\"Check if file(s) are already in context.\n\n```bash\nhu context check \u003cfile\u003e...\n# Output: src/main.rs: loaded 5 minutes ago\n```\n\"#;\n\npub const CMD_CONTEXT_SUMMARY: \u0026str = r#\"Show summary of all tracked files in context.\n\n```bash\nhu context summary\n```\n\nShows all files currently tracked in the session context with load times.\n\"#;\n\npub const CMD_CONTEXT_CLEAR: \u0026str = r#\"Clear all tracked files from context.\n\n```bash\nhu context clear\n```\n\nResets the context tracking. Use at session end or to force re-reads.\n\"#;\n\n// ============================================================================\n// COMMANDS - Read\n// ============================================================================\n\npub const CMD_READ: \u0026str = r#\"Smart file reading with outline, interface, around, and diff modes.\n\n```bash\nhu read src/main.rs                        # Full file\nhu read src/main.rs -o                     # Outline (functions, structs, classes)\nhu read src/main.rs -i                     # Public interface only\nhu read src/main.rs -a 42                  # Lines around line 42\nhu read src/main.rs -a 42 -n 20            # 20 context lines around line 42\nhu read src/main.rs -d                     # Git diff (vs HEAD)\nhu read src/main.rs -d --commit abc123     # Diff against specific commit\n```\n\n| Flag | Description |\n|------|-------------|\n| `-o, --outline` | Show file outline (functions, structs, classes) |\n| `-i, --interface` | Public interface only (pub items in Rust, exports in JS) |\n| `-a, --around` | Show lines around a specific line number |\n| `-n, --context` | Context lines for `--around` (default: 10) |\n| `-d, --diff` | Show git diff |\n| `--commit` | Commit to diff against (default: HEAD) |\n\"#;\n\n// ============================================================================\n// COMMANDS - Jira\n// ============================================================================\n\npub const CMD_JIRA_AUTH: \u0026str = r#\"Authenticate with Jira via OAuth 2.0.\n\n```bash\nhu jira auth\n```\n\nOpens browser for OAuth flow, stores credentials in `~/.config/hu/credentials.toml`.\n\"#;\n\npub const CMD_JIRA_TICKETS: \u0026str = r#\"List my tickets in current sprint.\n\n```bash\nhu jira tickets           # List assigned tickets\nhu jira tickets -j        # JSON output\n```\n\"#;\n\npub const CMD_JIRA_SPRINT: \u0026str = r#\"Show all issues in current sprint.\n\n```bash\nhu jira sprint            # List all sprint issues\nhu jira sprint -j         # JSON output\n```\n\"#;\n\npub const CMD_JIRA_SEARCH: \u0026str = r#\"Search tickets using JQL.\n\n```bash\nhu jira search \"project = PROJ AND status = Open\"\nhu jira search \"assignee = currentUser()\" -j\n```\n\"#;\n\npub const CMD_JIRA_SHOW: \u0026str = r#\"Show ticket details.\n\n```bash\nhu jira show PROJ-123     # Show ticket details\nhu jira show PROJ-123 -j  # JSON output\n```\n\"#;\n\npub const CMD_JIRA_UPDATE: \u0026str = r#\"Update a Jira ticket.\n\n```bash\nhu jira update PROJ-123 --status \"In Progress\"\nhu jira update PROJ-123 --assignee \"user@example.com\"\nhu jira update PROJ-123 --comment \"Working on this\"\n```\n\"#;\n\n// ============================================================================\n// COMMANDS - GitHub\n// ============================================================================\n\npub const CMD_GH_LOGIN: \u0026str = r#\"Authenticate with GitHub using a Personal Access Token.\n\n```bash\nhu gh login \u003ctoken\u003e\n```\n\nStores token in `~/.config/hu/credentials.toml`.\n\"#;\n\npub const CMD_GH_PRS: \u0026str = r#\"List open pull requests authored by you.\n\n```bash\nhu gh prs                 # List your PRs\nhu gh prs -s \"search\"     # Search PRs\nhu gh prs -j              # JSON output\n```\n\"#;\n\npub const CMD_GH_RUNS: \u0026str = r#\"List GitHub workflow runs.\n\n```bash\nhu gh runs                # List recent runs\nhu gh runs -b main        # Filter by branch\nhu gh runs -j             # JSON output\n```\n\"#;\n\npub const CMD_GH_FAILURES: \u0026str = r#\"Extract test failures from CI.\n\n```bash\nhu gh failures            # Get failures from current branch\nhu gh failures --pr 123   # Get failures from PR\nhu gh failures -j         # JSON output\n```\n\"#;\n\npub const CMD_GH_FIX: \u0026str = r#\"Analyze CI failures and output investigation context.\n\n```bash\nhu gh fix                 # Analyze failures from current branch\nhu gh fix --pr 123        # Analyze failures from PR\nhu gh fix -j              # JSON output with file paths\n```\n\"#;\n\n// ============================================================================\n// COMMANDS - Slack\n// ============================================================================\n\npub const CMD_SLACK_AUTH: \u0026str = r#\"Authenticate with Slack (OAuth flow or direct token).\n\n```bash\nhu slack auth             # Start OAuth flow\nhu slack auth \u003ctoken\u003e     # Use direct token\n```\n\"#;\n\npub const CMD_SLACK_CHANNELS: \u0026str = r#\"List channels in the workspace.\n\n```bash\nhu slack channels         # List all channels\nhu slack channels -j      # JSON output\n```\n\"#;\n\npub const CMD_SLACK_INFO: \u0026str = r#\"Show channel details.\n\n```bash\nhu slack info #channel    # Show channel info\nhu slack info C123456     # By channel ID\n```\n\"#;\n\npub const CMD_SLACK_SEND: \u0026str = r#\"Send a message to a channel.\n\n```bash\nhu slack send #channel \"Hello world\"\nhu slack send C123456 \"Message text\"\n```\n\"#;\n\npub const CMD_SLACK_HISTORY: \u0026str = r#\"Show message history for a channel.\n\n```bash\nhu slack history #channel      # Recent messages\nhu slack history #channel -n 50  # Last 50 messages\n```\n\"#;\n\npub const CMD_SLACK_SEARCH: \u0026str = r#\"Search Slack messages.\n\n```bash\nhu slack search \"query\"        # Search messages\nhu slack search \"from:@user\"   # Search by user\n```\n\"#;\n\npub const CMD_SLACK_USERS: \u0026str = r#\"List users in the workspace.\n\n```bash\nhu slack users            # List all users\nhu slack users -j         # JSON output\n```\n\"#;\n\npub const CMD_SLACK_CONFIG: \u0026str = r#\"Show Slack configuration status.\n\n```bash\nhu slack config           # Show config\nhu slack config -j        # JSON output\n```\n\"#;\n\npub const CMD_SLACK_WHOAMI: \u0026str = r#\"Show current user info from token.\n\n```bash\nhu slack whoami           # Show current user\n```\n\"#;\n\npub const CMD_SLACK_TIDY: \u0026str = r#\"Mark channels as read if no direct mentions.\n\n```bash\nhu slack tidy             # Tidy all channels\nhu slack tidy -d          # Dry run\n```\n\"#;\n\n// ============================================================================\n// COMMANDS - PagerDuty\n// ============================================================================\n\npub const CMD_PD_CONFIG: \u0026str = r#\"Show PagerDuty configuration status.\n\n```bash\nhu pagerduty config       # Show config\nhu pagerduty config -j    # JSON output\n```\n\"#;\n\npub const CMD_PD_AUTH: \u0026str = r#\"Set PagerDuty API token.\n\n```bash\nhu pagerduty auth \u003ctoken\u003e\n```\n\"#;\n\npub const CMD_PD_ONCALL: \u0026str = r#\"Show who's currently on call.\n\n```bash\nhu pagerduty oncall       # Show on-call\nhu pagerduty oncall -j    # JSON output\n```\n\"#;\n\npub const CMD_PD_ALERTS: \u0026str = r#\"List active alerts (triggered + acknowledged).\n\n```bash\nhu pagerduty alerts       # List alerts\nhu pagerduty alerts -j    # JSON output\n```\n\"#;\n\npub const CMD_PD_INCIDENTS: \u0026str = r#\"List incidents with filters.\n\n```bash\nhu pagerduty incidents              # List incidents\nhu pagerduty incidents --status triggered\nhu pagerduty incidents -j           # JSON output\n```\n\"#;\n\npub const CMD_PD_SHOW: \u0026str = r#\"Show incident details.\n\n```bash\nhu pagerduty show \u003cincident-id\u003e\nhu pagerduty show \u003cincident-id\u003e -j  # JSON output\n```\n\"#;\n\npub const CMD_PD_WHOAMI: \u0026str = r#\"Show current PagerDuty user info.\n\n```bash\nhu pagerduty whoami\n```\n\"#;\n\n// ============================================================================\n// COMMANDS - Sentry\n// ============================================================================\n\npub const CMD_SENTRY_CONFIG: \u0026str = r#\"Show Sentry configuration status.\n\n```bash\nhu sentry config          # Show config\nhu sentry config -j       # JSON output\n```\n\"#;\n\npub const CMD_SENTRY_AUTH: \u0026str = r#\"Set Sentry auth token.\n\n```bash\nhu sentry auth \u003ctoken\u003e\n```\n\"#;\n\npub const CMD_SENTRY_ISSUES: \u0026str = r#\"List Sentry issues.\n\n```bash\nhu sentry issues          # List recent issues\nhu sentry issues -j       # JSON output\n```\n\"#;\n\npub const CMD_SENTRY_SHOW: \u0026str = r#\"Show Sentry issue details.\n\n```bash\nhu sentry show \u003cissue-id\u003e\nhu sentry show \u003cissue-id\u003e -j  # JSON output\n```\n\"#;\n\npub const CMD_SENTRY_EVENTS: \u0026str = r#\"List events for a Sentry issue.\n\n```bash\nhu sentry events \u003cissue-id\u003e\nhu sentry events \u003cissue-id\u003e -j  # JSON output\n```\n\"#;\n\n// ============================================================================\n// COMMANDS - NewRelic\n// ============================================================================\n\npub const CMD_NR_CONFIG: \u0026str = r#\"Show NewRelic configuration status.\n\n```bash\nhu newrelic config        # Show config\nhu newrelic config -j     # JSON output\n```\n\"#;\n\npub const CMD_NR_AUTH: \u0026str = r#\"Set NewRelic API key and account ID.\n\n```bash\nhu newrelic auth \u003capi-key\u003e \u003caccount-id\u003e\n```\n\"#;\n\npub const CMD_NR_ISSUES: \u0026str = r#\"List recent NewRelic issues.\n\n```bash\nhu newrelic issues        # List issues\nhu newrelic issues -j     # JSON output\n```\n\"#;\n\npub const CMD_NR_INCIDENTS: \u0026str = r#\"List recent NewRelic incidents.\n\n```bash\nhu newrelic incidents     # List incidents\nhu newrelic incidents -j  # JSON output\n```\n\"#;\n\npub const CMD_NR_QUERY: \u0026str = r#\"Run NRQL query.\n\n```bash\nhu newrelic query \"SELECT * FROM Transaction LIMIT 10\"\nhu newrelic query \"SELECT count(*) FROM Transaction\" -j\n```\n\"#;\n\n// ============================================================================\n// COMMANDS - EKS\n// ============================================================================\n\npub const CMD_EKS_LIST: \u0026str = r#\"List pods in the EKS cluster.\n\n```bash\nhu eks list               # List all pods\nhu eks list -n namespace  # Filter by namespace\nhu eks list -j            # JSON output\n```\n\"#;\n\npub const CMD_EKS_EXEC: \u0026str = r#\"Execute a command in a pod (interactive shell by default).\n\n```bash\nhu eks exec \u003cpod\u003e                    # Open shell\nhu eks exec \u003cpod\u003e -- ls -la          # Run command\nhu eks exec \u003cpod\u003e -n namespace       # Specify namespace\n```\n\"#;\n\npub const CMD_EKS_LOGS: \u0026str = r#\"Tail logs from a pod.\n\n```bash\nhu eks logs \u003cpod\u003e                    # Tail logs\nhu eks logs \u003cpod\u003e -f                 # Follow logs\nhu eks logs \u003cpod\u003e -n namespace       # Specify namespace\nhu eks logs \u003cpod\u003e --since 1h         # Logs from last hour\n```\n\"#;\n\n// ============================================================================\n// COMMANDS - Pipeline\n// ============================================================================\n\npub const CMD_PIPELINE_LIST: \u0026str = r#\"List all CodePipeline pipelines.\n\n```bash\nhu pipeline list          # List pipelines\nhu pipeline list -j       # JSON output\n```\n\"#;\n\npub const CMD_PIPELINE_STATUS: \u0026str = r#\"Show pipeline status (stages and actions).\n\n```bash\nhu pipeline status \u003cpipeline-name\u003e\nhu pipeline status \u003cpipeline-name\u003e -j  # JSON output\n```\n\"#;\n\npub const CMD_PIPELINE_HISTORY: \u0026str = r#\"Show pipeline execution history.\n\n```bash\nhu pipeline history \u003cpipeline-name\u003e\nhu pipeline history \u003cpipeline-name\u003e -n 10  # Last 10 executions\n```\n\"#;\n\n// ============================================================================\n// COMMANDS - Utils\n// ============================================================================\n\npub const CMD_UTILS_FETCH_HTML: \u0026str = r#\"Fetch URL and convert to markdown.\n\n```bash\nhu utils fetch-html \u003curl\u003e              # Fetch and convert\nhu utils fetch-html \u003curl\u003e -c           # Extra cleaning\nhu utils fetch-html \u003curl\u003e -s \"article\" # Target CSS selector\nhu utils fetch-html \u003curl\u003e -o out.md    # Write to file\n```\n\"#;\n\npub const CMD_UTILS_GREP: \u0026str = r#\"Smart grep with token-saving options.\n\n```bash\nhu utils grep \"pattern\" path/          # Search in path\nhu utils grep \"pattern\" -g \"*.rs\"      # Filter by glob\nhu utils grep \"pattern\" --refs         # File paths only\nhu utils grep \"pattern\" -n 20          # Limit results\n```\n\"#;\n\npub const CMD_UTILS_WEB_SEARCH: \u0026str = r#\"Web search using Brave Search API.\n\n```bash\nhu utils web-search \"query\"            # Search web\nhu utils web-search \"query\" -n 10      # Limit results\nhu utils web-search \"query\" -j         # JSON output\n```\n\"#;\n\npub const CMD_UTILS_DOCS_INDEX: \u0026str = r#\"Build heading index for markdown files.\n\n```bash\nhu utils docs-index docs/              # Build index\nhu utils docs-index docs/ -o index.json  # Output to file\n```\n\"#;\n\npub const CMD_UTILS_DOCS_SEARCH: \u0026str = r#\"Search docs index for matching sections.\n\n```bash\nhu utils docs-search \"query\" -i index.json\nhu utils docs-search \"authentication\" -i docs-index.json\n```\n\"#;\n\npub const CMD_UTILS_DOCS_SECTION: \u0026str = r#\"Extract a section from a markdown file by heading.\n\n```bash\nhu utils docs-section docs/api.md \"Authentication\"\nhu utils docs-section README.md \"Installation\"\n```\n\"#;\n\n// ============================================================================\n// COMMANDS - Data\n// ============================================================================\n\npub const CMD_DATA_SYNC: \u0026str = r#\"Sync Claude Code data to local database.\n\n```bash\nhu data sync              # Incremental sync\nhu data sync -f           # Force full sync\n```\n\"#;\n\npub const CMD_DATA_CONFIG: \u0026str = r#\"Show data configuration.\n\n```bash\nhu data config            # Show config\nhu data config -j         # JSON output\n```\n\"#;\n\npub const CMD_DATA_STATS: \u0026str = r#\"Usage statistics.\n\n```bash\nhu data stats             # Show stats\nhu data stats -j          # JSON output\n```\n\"#;\n\npub const CMD_DATA_SEARCH: \u0026str = r#\"Search messages.\n\n```bash\nhu data search \"query\"    # Search messages\nhu data search \"error\" -n 20  # Limit results\n```\n\"#;\n\npub const CMD_DATA_TODOS: \u0026str = r#\"Todo operations.\n\n```bash\nhu data todos pending     # Show pending todos\nhu data todos all         # Show all todos\nhu data todos -j          # JSON output\n```\n\"#;\n\npub const CMD_DATA_TOOLS: \u0026str = r#\"Tool usage statistics.\n\n```bash\nhu data tools             # Show tool usage\nhu data tools -j          # JSON output\n```\n\"#;\n\npub const CMD_DATA_ERRORS: \u0026str = r#\"Extract errors from debug logs.\n\n```bash\nhu data errors            # Show recent errors\nhu data errors -n 50      # Last 50 errors\n```\n\"#;\n\npub const CMD_DATA_PRICING: \u0026str = r#\"Pricing analysis.\n\n```bash\nhu data pricing           # Show pricing analysis\nhu data pricing -j        # JSON output\n```\n\"#;\n\npub const CMD_DATA_SESSION: \u0026str = r#\"Session operations.\n\n```bash\nhu data session list      # List sessions\nhu data session list -p . # Filter by project\nhu data session show \u003cid\u003e # Show session details\n```\n\"#;\n\npub const CMD_DATA_BRANCHES: \u0026str = r#\"Branch activity statistics.\n\n```bash\nhu data branches          # Show branch stats\nhu data branches -j       # JSON output\n```\n\"#;\n\n// ============================================================================\n// COMMANDS - Install\n// ============================================================================\n\npub const CMD_INSTALL_LIST: \u0026str = r#\"List available components.\n\n```bash\nhu install list           # List all components\n```\n\"#;\n\npub const CMD_INSTALL_PREVIEW: \u0026str = r#\"Show what would be installed without making changes.\n\n```bash\nhu install preview              # Preview global install\nhu install preview --local      # Preview local install\nhu install preview --hooks-only # Preview hooks only\n```\n\"#;\n\npub const CMD_INSTALL_RUN: \u0026str = r#\"Install hooks and commands to Claude Code.\n\n```bash\nhu install run                  # Install to ~/.claude (global)\nhu install run --local          # Install to ./.claude (local)\nhu install run --force          # Override modified files\nhu install run --hooks-only     # Install only hooks\nhu install run --commands-only  # Install only commands\nhu install run hooks/hu/pre-read   # Install specific component\n```\n\"#;\n\n// ============================================================================\n// COMPONENT REGISTRY\n// ============================================================================\n\n/// All available components\npub static COMPONENTS: \u0026[Component] = \u0026[\n    // Hooks (6)\n    Component {\n        id: \"hooks/hu/pre-read\",\n        kind: ComponentKind::Hook,\n        description: \"Prevents duplicate file reads, warns on large files\",\n        path: \"hooks/hu/pre-read.sh\",\n        content: HOOK_PRE_READ,\n    },\n    Component {\n        id: \"hooks/hu/pre-grep\",\n        kind: ComponentKind::Hook,\n        description: \"Warns on broad patterns, suggests efficient modes\",\n        path: \"hooks/hu/pre-grep.sh\",\n        content: HOOK_PRE_GREP,\n    },\n    Component {\n        id: \"hooks/hu/pre-webfetch\",\n        kind: ComponentKind::Hook,\n        description: \"Logs URL fetches, warns on HTTP\",\n        path: \"hooks/hu/pre-webfetch.sh\",\n        content: HOOK_PRE_WEBFETCH,\n    },\n    Component {\n        id: \"hooks/hu/pre-websearch\",\n        kind: ComponentKind::Hook,\n        description: \"Logs searches, warns on sensitive terms\",\n        path: \"hooks/hu/pre-websearch.sh\",\n        content: HOOK_PRE_WEBSEARCH,\n    },\n    Component {\n        id: \"hooks/hu/session-start\",\n        kind: ComponentKind::Hook,\n        description: \"Cleans old files, initializes context tracking\",\n        path: \"hooks/hu/session-start.sh\",\n        content: HOOK_SESSION_START,\n    },\n    Component {\n        id: \"hooks/hu/session-end\",\n        kind: ComponentKind::Hook,\n        description: \"Shows context summary, clears tracking\",\n        path: \"hooks/hu/session-end.sh\",\n        content: HOOK_SESSION_END,\n    },\n    // Context commands (4)\n    Component {\n        id: \"commands/hu/context/track\",\n        kind: ComponentKind::Command,\n        description: \"Track files as loaded in context\",\n        path: \"commands/hu/context/track.md\",\n        content: CMD_CONTEXT_TRACK,\n    },\n    Component {\n        id: \"commands/hu/context/check\",\n        kind: ComponentKind::Command,\n        description: \"Check if files are in context\",\n        path: \"commands/hu/context/check.md\",\n        content: CMD_CONTEXT_CHECK,\n    },\n    Component {\n        id: \"commands/hu/context/summary\",\n        kind: ComponentKind::Command,\n        description: \"Show context summary\",\n        path: \"commands/hu/context/summary.md\",\n        content: CMD_CONTEXT_SUMMARY,\n    },\n    Component {\n        id: \"commands/hu/context/clear\",\n        kind: ComponentKind::Command,\n        description: \"Clear context tracking\",\n        path: \"commands/hu/context/clear.md\",\n        content: CMD_CONTEXT_CLEAR,\n    },\n    // Read command (1)\n    Component {\n        id: \"commands/hu/read\",\n        kind: ComponentKind::Command,\n        description: \"Smart file reading modes\",\n        path: \"commands/hu/read.md\",\n        content: CMD_READ,\n    },\n    // Jira commands (6)\n    Component {\n        id: \"commands/hu/jira/auth\",\n        kind: ComponentKind::Command,\n        description: \"Authenticate with Jira\",\n        path: \"commands/hu/jira/auth.md\",\n        content: CMD_JIRA_AUTH,\n    },\n    Component {\n        id: \"commands/hu/jira/tickets\",\n        kind: ComponentKind::Command,\n        description: \"List my tickets in sprint\",\n        path: \"commands/hu/jira/tickets.md\",\n        content: CMD_JIRA_TICKETS,\n    },\n    Component {\n        id: \"commands/hu/jira/sprint\",\n        kind: ComponentKind::Command,\n        description: \"Show sprint issues\",\n        path: \"commands/hu/jira/sprint.md\",\n        content: CMD_JIRA_SPRINT,\n    },\n    Component {\n        id: \"commands/hu/jira/search\",\n        kind: ComponentKind::Command,\n        description: \"Search tickets with JQL\",\n        path: \"commands/hu/jira/search.md\",\n        content: CMD_JIRA_SEARCH,\n    },\n    Component {\n        id: \"commands/hu/jira/show\",\n        kind: ComponentKind::Command,\n        description: \"Show ticket details\",\n        path: \"commands/hu/jira/show.md\",\n        content: CMD_JIRA_SHOW,\n    },\n    Component {\n        id: \"commands/hu/jira/update\",\n        kind: ComponentKind::Command,\n        description: \"Update a ticket\",\n        path: \"commands/hu/jira/update.md\",\n        content: CMD_JIRA_UPDATE,\n    },\n    // GitHub commands (5)\n    Component {\n        id: \"commands/hu/gh/login\",\n        kind: ComponentKind::Command,\n        description: \"Authenticate with GitHub\",\n        path: \"commands/hu/gh/login.md\",\n        content: CMD_GH_LOGIN,\n    },\n    Component {\n        id: \"commands/hu/gh/prs\",\n        kind: ComponentKind::Command,\n        description: \"List pull requests\",\n        path: \"commands/hu/gh/prs.md\",\n        content: CMD_GH_PRS,\n    },\n    Component {\n        id: \"commands/hu/gh/runs\",\n        kind: ComponentKind::Command,\n        description: \"List workflow runs\",\n        path: \"commands/hu/gh/runs.md\",\n        content: CMD_GH_RUNS,\n    },\n    Component {\n        id: \"commands/hu/gh/failures\",\n        kind: ComponentKind::Command,\n        description: \"Extract CI test failures\",\n        path: \"commands/hu/gh/failures.md\",\n        content: CMD_GH_FAILURES,\n    },\n    Component {\n        id: \"commands/hu/gh/fix\",\n        kind: ComponentKind::Command,\n        description: \"Analyze CI failures\",\n        path: \"commands/hu/gh/fix.md\",\n        content: CMD_GH_FIX,\n    },\n    // Slack commands (10)\n    Component {\n        id: \"commands/hu/slack/auth\",\n        kind: ComponentKind::Command,\n        description: \"Authenticate with Slack\",\n        path: \"commands/hu/slack/auth.md\",\n        content: CMD_SLACK_AUTH,\n    },\n    Component {\n        id: \"commands/hu/slack/channels\",\n        kind: ComponentKind::Command,\n        description: \"List channels\",\n        path: \"commands/hu/slack/channels.md\",\n        content: CMD_SLACK_CHANNELS,\n    },\n    Component {\n        id: \"commands/hu/slack/info\",\n        kind: ComponentKind::Command,\n        description: \"Show channel info\",\n        path: \"commands/hu/slack/info.md\",\n        content: CMD_SLACK_INFO,\n    },\n    Component {\n        id: \"commands/hu/slack/send\",\n        kind: ComponentKind::Command,\n        description: \"Send message\",\n        path: \"commands/hu/slack/send.md\",\n        content: CMD_SLACK_SEND,\n    },\n    Component {\n        id: \"commands/hu/slack/history\",\n        kind: ComponentKind::Command,\n        description: \"Show message history\",\n        path: \"commands/hu/slack/history.md\",\n        content: CMD_SLACK_HISTORY,\n    },\n    Component {\n        id: \"commands/hu/slack/search\",\n        kind: ComponentKind::Command,\n        description: \"Search messages\",\n        path: \"commands/hu/slack/search.md\",\n        content: CMD_SLACK_SEARCH,\n    },\n    Component {\n        id: \"commands/hu/slack/users\",\n        kind: ComponentKind::Command,\n        description: \"List users\",\n        path: \"commands/hu/slack/users.md\",\n        content: CMD_SLACK_USERS,\n    },\n    Component {\n        id: \"commands/hu/slack/config\",\n        kind: ComponentKind::Command,\n        description: \"Show Slack config\",\n        path: \"commands/hu/slack/config.md\",\n        content: CMD_SLACK_CONFIG,\n    },\n    Component {\n        id: \"commands/hu/slack/whoami\",\n        kind: ComponentKind::Command,\n        description: \"Show current user\",\n        path: \"commands/hu/slack/whoami.md\",\n        content: CMD_SLACK_WHOAMI,\n    },\n    Component {\n        id: \"commands/hu/slack/tidy\",\n        kind: ComponentKind::Command,\n        description: \"Mark channels as read\",\n        path: \"commands/hu/slack/tidy.md\",\n        content: CMD_SLACK_TIDY,\n    },\n    // PagerDuty commands (7)\n    Component {\n        id: \"commands/hu/pagerduty/config\",\n        kind: ComponentKind::Command,\n        description: \"Show PagerDuty config\",\n        path: \"commands/hu/pagerduty/config.md\",\n        content: CMD_PD_CONFIG,\n    },\n    Component {\n        id: \"commands/hu/pagerduty/auth\",\n        kind: ComponentKind::Command,\n        description: \"Set API token\",\n        path: \"commands/hu/pagerduty/auth.md\",\n        content: CMD_PD_AUTH,\n    },\n    Component {\n        id: \"commands/hu/pagerduty/oncall\",\n        kind: ComponentKind::Command,\n        description: \"Show on-call schedule\",\n        path: \"commands/hu/pagerduty/oncall.md\",\n        content: CMD_PD_ONCALL,\n    },\n    Component {\n        id: \"commands/hu/pagerduty/alerts\",\n        kind: ComponentKind::Command,\n        description: \"List active alerts\",\n        path: \"commands/hu/pagerduty/alerts.md\",\n        content: CMD_PD_ALERTS,\n    },\n    Component {\n        id: \"commands/hu/pagerduty/incidents\",\n        kind: ComponentKind::Command,\n        description: \"List incidents\",\n        path: \"commands/hu/pagerduty/incidents.md\",\n        content: CMD_PD_INCIDENTS,\n    },\n    Component {\n        id: \"commands/hu/pagerduty/show\",\n        kind: ComponentKind::Command,\n        description: \"Show incident details\",\n        path: \"commands/hu/pagerduty/show.md\",\n        content: CMD_PD_SHOW,\n    },\n    Component {\n        id: \"commands/hu/pagerduty/whoami\",\n        kind: ComponentKind::Command,\n        description: \"Show current user\",\n        path: \"commands/hu/pagerduty/whoami.md\",\n        content: CMD_PD_WHOAMI,\n    },\n    // Sentry commands (5)\n    Component {\n        id: \"commands/hu/sentry/config\",\n        kind: ComponentKind::Command,\n        description: \"Show Sentry config\",\n        path: \"commands/hu/sentry/config.md\",\n        content: CMD_SENTRY_CONFIG,\n    },\n    Component {\n        id: \"commands/hu/sentry/auth\",\n        kind: ComponentKind::Command,\n        description: \"Set auth token\",\n        path: \"commands/hu/sentry/auth.md\",\n        content: CMD_SENTRY_AUTH,\n    },\n    Component {\n        id: \"commands/hu/sentry/issues\",\n        kind: ComponentKind::Command,\n        description: \"List issues\",\n        path: \"commands/hu/sentry/issues.md\",\n        content: CMD_SENTRY_ISSUES,\n    },\n    Component {\n        id: \"commands/hu/sentry/show\",\n        kind: ComponentKind::Command,\n        description: \"Show issue details\",\n        path: \"commands/hu/sentry/show.md\",\n        content: CMD_SENTRY_SHOW,\n    },\n    Component {\n        id: \"commands/hu/sentry/events\",\n        kind: ComponentKind::Command,\n        description: \"List issue events\",\n        path: \"commands/hu/sentry/events.md\",\n        content: CMD_SENTRY_EVENTS,\n    },\n    // NewRelic commands (5)\n    Component {\n        id: \"commands/hu/newrelic/config\",\n        kind: ComponentKind::Command,\n        description: \"Show NewRelic config\",\n        path: \"commands/hu/newrelic/config.md\",\n        content: CMD_NR_CONFIG,\n    },\n    Component {\n        id: \"commands/hu/newrelic/auth\",\n        kind: ComponentKind::Command,\n        description: \"Set API key\",\n        path: \"commands/hu/newrelic/auth.md\",\n        content: CMD_NR_AUTH,\n    },\n    Component {\n        id: \"commands/hu/newrelic/issues\",\n        kind: ComponentKind::Command,\n        description: \"List issues\",\n        path: \"commands/hu/newrelic/issues.md\",\n        content: CMD_NR_ISSUES,\n    },\n    Component {\n        id: \"commands/hu/newrelic/incidents\",\n        kind: ComponentKind::Command,\n        description: \"List incidents\",\n        path: \"commands/hu/newrelic/incidents.md\",\n        content: CMD_NR_INCIDENTS,\n    },\n    Component {\n        id: \"commands/hu/newrelic/query\",\n        kind: ComponentKind::Command,\n        description: \"Run NRQL query\",\n        path: \"commands/hu/newrelic/query.md\",\n        content: CMD_NR_QUERY,\n    },\n    // EKS commands (3)\n    Component {\n        id: \"commands/hu/eks/list\",\n        kind: ComponentKind::Command,\n        description: \"List pods\",\n        path: \"commands/hu/eks/list.md\",\n        content: CMD_EKS_LIST,\n    },\n    Component {\n        id: \"commands/hu/eks/exec\",\n        kind: ComponentKind::Command,\n        description: \"Execute in pod\",\n        path: \"commands/hu/eks/exec.md\",\n        content: CMD_EKS_EXEC,\n    },\n    Component {\n        id: \"commands/hu/eks/logs\",\n        kind: ComponentKind::Command,\n        description: \"Tail pod logs\",\n        path: \"commands/hu/eks/logs.md\",\n        content: CMD_EKS_LOGS,\n    },\n    // Pipeline commands (3)\n    Component {\n        id: \"commands/hu/pipeline/list\",\n        kind: ComponentKind::Command,\n        description: \"List pipelines\",\n        path: \"commands/hu/pipeline/list.md\",\n        content: CMD_PIPELINE_LIST,\n    },\n    Component {\n        id: \"commands/hu/pipeline/status\",\n        kind: ComponentKind::Command,\n        description: \"Show pipeline status\",\n        path: \"commands/hu/pipeline/status.md\",\n        content: CMD_PIPELINE_STATUS,\n    },\n    Component {\n        id: \"commands/hu/pipeline/history\",\n        kind: ComponentKind::Command,\n        description: \"Show execution history\",\n        path: \"commands/hu/pipeline/history.md\",\n        content: CMD_PIPELINE_HISTORY,\n    },\n    // Utils commands (6)\n    Component {\n        id: \"commands/hu/utils/fetch-html\",\n        kind: ComponentKind::Command,\n        description: \"Fetch URL as markdown\",\n        path: \"commands/hu/utils/fetch-html.md\",\n        content: CMD_UTILS_FETCH_HTML,\n    },\n    Component {\n        id: \"commands/hu/utils/grep\",\n        kind: ComponentKind::Command,\n        description: \"Smart grep\",\n        path: \"commands/hu/utils/grep.md\",\n        content: CMD_UTILS_GREP,\n    },\n    Component {\n        id: \"commands/hu/utils/web-search\",\n        kind: ComponentKind::Command,\n        description: \"Web search\",\n        path: \"commands/hu/utils/web-search.md\",\n        content: CMD_UTILS_WEB_SEARCH,\n    },\n    Component {\n        id: \"commands/hu/utils/docs-index\",\n        kind: ComponentKind::Command,\n        description: \"Build docs index\",\n        path: \"commands/hu/utils/docs-index.md\",\n        content: CMD_UTILS_DOCS_INDEX,\n    },\n    Component {\n        id: \"commands/hu/utils/docs-search\",\n        kind: ComponentKind::Command,\n        description: \"Search docs index\",\n        path: \"commands/hu/utils/docs-search.md\",\n        content: CMD_UTILS_DOCS_SEARCH,\n    },\n    Component {\n        id: \"commands/hu/utils/docs-section\",\n        kind: ComponentKind::Command,\n        description: \"Extract doc section\",\n        path: \"commands/hu/utils/docs-section.md\",\n        content: CMD_UTILS_DOCS_SECTION,\n    },\n    // Data commands (10)\n    Component {\n        id: \"commands/hu/data/sync\",\n        kind: ComponentKind::Command,\n        description: \"Sync Claude data\",\n        path: \"commands/hu/data/sync.md\",\n        content: CMD_DATA_SYNC,\n    },\n    Component {\n        id: \"commands/hu/data/config\",\n        kind: ComponentKind::Command,\n        description: \"Show data config\",\n        path: \"commands/hu/data/config.md\",\n        content: CMD_DATA_CONFIG,\n    },\n    Component {\n        id: \"commands/hu/data/stats\",\n        kind: ComponentKind::Command,\n        description: \"Usage statistics\",\n        path: \"commands/hu/data/stats.md\",\n        content: CMD_DATA_STATS,\n    },\n    Component {\n        id: \"commands/hu/data/search\",\n        kind: ComponentKind::Command,\n        description: \"Search messages\",\n        path: \"commands/hu/data/search.md\",\n        content: CMD_DATA_SEARCH,\n    },\n    Component {\n        id: \"commands/hu/data/todos\",\n        kind: ComponentKind::Command,\n        description: \"Todo operations\",\n        path: \"commands/hu/data/todos.md\",\n        content: CMD_DATA_TODOS,\n    },\n    Component {\n        id: \"commands/hu/data/tools\",\n        kind: ComponentKind::Command,\n        description: \"Tool usage stats\",\n        path: \"commands/hu/data/tools.md\",\n        content: CMD_DATA_TOOLS,\n    },\n    Component {\n        id: \"commands/hu/data/errors\",\n        kind: ComponentKind::Command,\n        description: \"Extract errors\",\n        path: \"commands/hu/data/errors.md\",\n        content: CMD_DATA_ERRORS,\n    },\n    Component {\n        id: \"commands/hu/data/pricing\",\n        kind: ComponentKind::Command,\n        description: \"Pricing analysis\",\n        path: \"commands/hu/data/pricing.md\",\n        content: CMD_DATA_PRICING,\n    },\n    Component {\n        id: \"commands/hu/data/session\",\n        kind: ComponentKind::Command,\n        description: \"Session operations\",\n        path: \"commands/hu/data/session.md\",\n        content: CMD_DATA_SESSION,\n    },\n    Component {\n        id: \"commands/hu/data/branches\",\n        kind: ComponentKind::Command,\n        description: \"Branch statistics\",\n        path: \"commands/hu/data/branches.md\",\n        content: CMD_DATA_BRANCHES,\n    },\n    // Install commands (3)\n    Component {\n        id: \"commands/hu/install/list\",\n        kind: ComponentKind::Command,\n        description: \"List components\",\n        path: \"commands/hu/install/list.md\",\n        content: CMD_INSTALL_LIST,\n    },\n    Component {\n        id: \"commands/hu/install/preview\",\n        kind: ComponentKind::Command,\n        description: \"Preview install\",\n        path: \"commands/hu/install/preview.md\",\n        content: CMD_INSTALL_PREVIEW,\n    },\n    Component {\n        id: \"commands/hu/install/run\",\n        kind: ComponentKind::Command,\n        description: \"Run install\",\n        path: \"commands/hu/install/run.md\",\n        content: CMD_INSTALL_RUN,\n    },\n];\n\n/// Get components filtered by kind\npub fn get_components(include_hooks: bool, include_commands: bool) -\u003e Vec\u003c\u0026'static Component\u003e {\n    COMPONENTS\n        .iter()\n        .filter(|c| match c.kind {\n            ComponentKind::Hook =\u003e include_hooks,\n            ComponentKind::Command =\u003e include_commands,\n        })\n        .collect()\n}\n\n/// Get hooks only\npub fn get_hooks() -\u003e Vec\u003c\u0026'static Component\u003e {\n    get_components(true, false)\n}\n\n/// Get commands only\npub fn get_commands() -\u003e Vec\u003c\u0026'static Component\u003e {\n    get_components(false, true)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn components_count() {\n        assert_eq!(COMPONENTS.len(), 74); // 6 hooks + 68 commands\n    }\n\n    #[test]\n    fn hooks_count() {\n        assert_eq!(get_hooks().len(), 6);\n    }\n\n    #[test]\n    fn commands_count() {\n        assert_eq!(get_commands().len(), 68);\n    }\n\n    #[test]\n    fn all_hooks_have_sh_extension() {\n        for c in get_hooks() {\n            assert!(c.path.ends_with(\".sh\"), \"Hook {} should end with .sh\", c.id);\n        }\n    }\n\n    #[test]\n    fn all_commands_have_md_extension() {\n        for c in get_commands() {\n            assert!(\n                c.path.ends_with(\".md\"),\n                \"Command {} should end with .md\",\n                c.id\n            );\n        }\n    }\n\n    #[test]\n    fn all_hooks_have_shebang() {\n        for c in get_hooks() {\n            assert!(\n                c.content.starts_with(\"#!/bin/bash\"),\n                \"Hook {} should start with shebang\",\n                c.id\n            );\n        }\n    }\n\n    #[test]\n    fn unique_component_ids() {\n        let mut ids: Vec\u003c_\u003e = COMPONENTS.iter().map(|c| c.id).collect();\n        ids.sort();\n        let original_len = ids.len();\n        ids.dedup();\n        assert_eq!(ids.len(), original_len, \"Component IDs must be unique\");\n    }\n\n    #[test]\n    fn unique_component_paths() {\n        let mut paths: Vec\u003c_\u003e = COMPONENTS.iter().map(|c| c.path).collect();\n        paths.sort();\n        let original_len = paths.len();\n        paths.dedup();\n        assert_eq!(paths.len(), original_len, \"Component paths must be unique\");\n    }\n}\n","traces":[{"line":1313,"address":[],"length":0,"stats":{"Line":9}},{"line":1314,"address":[],"length":0,"stats":{"Line":9}},{"line":1316,"address":[],"length":0,"stats":{"Line":675}},{"line":1317,"address":[],"length":0,"stats":{"Line":54}},{"line":1318,"address":[],"length":0,"stats":{"Line":612}},{"line":1324,"address":[],"length":0,"stats":{"Line":4}},{"line":1325,"address":[],"length":0,"stats":{"Line":4}},{"line":1329,"address":[],"length":0,"stats":{"Line":2}},{"line":1330,"address":[],"length":0,"stats":{"Line":2}}],"covered":9,"coverable":9},{"path":["/","Users","chi","Projects","hu","src","install","types.rs"],"content":"use std::path::{Path, PathBuf};\n\n/// A component that can be installed\n#[derive(Debug, Clone)]\npub struct Component {\n    pub id: \u0026'static str,\n    pub kind: ComponentKind,\n    pub description: \u0026'static str,\n    pub path: \u0026'static str,\n    pub content: \u0026'static str,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum ComponentKind {\n    Hook,\n    Command,\n}\n\nimpl ComponentKind {\n    pub fn label(\u0026self) -\u003e \u0026'static str {\n        match self {\n            ComponentKind::Hook =\u003e \"hook\",\n            ComponentKind::Command =\u003e \"command\",\n        }\n    }\n}\n\nimpl Component {\n    pub fn target_path(\u0026self, base_dir: \u0026Path) -\u003e PathBuf {\n        base_dir.join(self.path)\n    }\n}\n\n/// Result of checking a component's install status\n#[derive(Debug, Clone)]\npub struct ComponentStatus {\n    pub component: \u0026'static Component,\n    pub status: InstallStatus,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum InstallStatus {\n    /// Not installed\n    Missing,\n    /// Installed and matches\n    Current,\n    /// Installed but content differs\n    Modified,\n}\n\nimpl InstallStatus {\n    pub fn symbol(\u0026self) -\u003e \u0026'static str {\n        match self {\n            InstallStatus::Missing =\u003e \"\",\n            InstallStatus::Current =\u003e \"\",\n            InstallStatus::Modified =\u003e \"\",\n        }\n    }\n\n    pub fn label(\u0026self) -\u003e \u0026'static str {\n        match self {\n            InstallStatus::Missing =\u003e \"missing\",\n            InstallStatus::Current =\u003e \"current\",\n            InstallStatus::Modified =\u003e \"modified\",\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn component_kind_labels() {\n        assert_eq!(ComponentKind::Hook.label(), \"hook\");\n        assert_eq!(ComponentKind::Command.label(), \"command\");\n    }\n\n    #[test]\n    fn install_status_symbols() {\n        assert_eq!(InstallStatus::Missing.symbol(), \"\");\n        assert_eq!(InstallStatus::Current.symbol(), \"\");\n        assert_eq!(InstallStatus::Modified.symbol(), \"\");\n    }\n\n    #[test]\n    fn target_path_combines_base_and_component_path() {\n        let component = Component {\n            id: \"test\",\n            kind: ComponentKind::Hook,\n            description: \"Test hook\",\n            path: \"hooks/test.sh\",\n            content: \"#!/bin/bash\\necho test\",\n        };\n        let base = PathBuf::from(\"/home/user/.claude\");\n        assert_eq!(\n            component.target_path(\u0026base),\n            PathBuf::from(\"/home/user/.claude/hooks/test.sh\")\n        );\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":2}},{"line":21,"address":[],"length":0,"stats":{"Line":2}},{"line":22,"address":[],"length":0,"stats":{"Line":1}},{"line":23,"address":[],"length":0,"stats":{"Line":1}},{"line":29,"address":[],"length":0,"stats":{"Line":6}},{"line":30,"address":[],"length":0,"stats":{"Line":18}},{"line":52,"address":[],"length":0,"stats":{"Line":3}},{"line":53,"address":[],"length":0,"stats":{"Line":3}},{"line":54,"address":[],"length":0,"stats":{"Line":1}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}}],"covered":11,"coverable":16},{"path":["/","Users","chi","Projects","hu","src","jira","auth","callback.rs"],"content":"use axum::{\n    extract::{Query, State},\n    response::Html,\n    routing::get,\n    Router,\n};\nuse std::collections::HashMap;\nuse std::net::SocketAddr;\nuse std::sync::Arc;\nuse tokio::sync::Mutex;\n\nuse anyhow::{Context, Result};\n\n/// OAuth callback state\n#[derive(Debug, Clone)]\npub(super) struct CallbackState {\n    pub(super) expected_state: String,\n    pub(super) code: Option\u003cString\u003e,\n    pub(super) error: Option\u003cString\u003e,\n}\n\n/// Start the local callback server\npub(super) async fn start_callback_server(state: Arc\u003cMutex\u003cCallbackState\u003e\u003e) -\u003e Result\u003c()\u003e {\n    let app = Router::new()\n        .route(\"/callback\", get(handle_callback))\n        .with_state(state.clone());\n\n    let addr = SocketAddr::from(([127, 0, 0, 1], super::CALLBACK_PORT));\n    let listener = tokio::net::TcpListener::bind(addr)\n        .await\n        .context(\"Failed to bind callback server\")?;\n\n    axum::serve(listener, app)\n        .with_graceful_shutdown(async move {\n            // Wait until we have a code or error\n            loop {\n                tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;\n                let state_lock = state.lock().await;\n                if state_lock.code.is_some() || state_lock.error.is_some() {\n                    break;\n                }\n            }\n            // Give a moment for the response to be sent\n            tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;\n        })\n        .await\n        .context(\"Callback server failed\")?;\n\n    Ok(())\n}\n\n/// Handle the OAuth callback\nasync fn handle_callback(\n    State(state): State\u003cArc\u003cMutex\u003cCallbackState\u003e\u003e\u003e,\n    Query(params): Query\u003cHashMap\u003cString, String\u003e\u003e,\n) -\u003e Html\u003c\u0026'static str\u003e {\n    let mut state_lock = state.lock().await;\n\n    // Check for error\n    if let Some(error) = params.get(\"error\") {\n        state_lock.error = Some(error.clone());\n        return Html(\n            \"\u003chtml\u003e\u003cbody\u003e\u003ch1\u003eAuthorization Failed\u003c/h1\u003e\u003cp\u003eYou can close this window.\u003c/p\u003e\u003c/body\u003e\u003c/html\u003e\",\n        );\n    }\n\n    // Verify state parameter\n    if let Some(received_state) = params.get(\"state\") {\n        if received_state != \u0026state_lock.expected_state {\n            state_lock.error = Some(\"State mismatch - possible CSRF attack\".to_string());\n            return Html(\n                \"\u003chtml\u003e\u003cbody\u003e\u003ch1\u003eError\u003c/h1\u003e\u003cp\u003eState verification failed.\u003c/p\u003e\u003c/body\u003e\u003c/html\u003e\",\n            );\n        }\n    } else {\n        state_lock.error = Some(\"Missing state parameter\".to_string());\n        return Html(\"\u003chtml\u003e\u003cbody\u003e\u003ch1\u003eError\u003c/h1\u003e\u003cp\u003eMissing state parameter.\u003c/p\u003e\u003c/body\u003e\u003c/html\u003e\");\n    }\n\n    // Get authorization code\n    if let Some(code) = params.get(\"code\") {\n        state_lock.code = Some(code.clone());\n        Html(\"\u003chtml\u003e\u003cbody\u003e\u003ch1\u003eSuccess!\u003c/h1\u003e\u003cp\u003eYou can close this window and return to the terminal.\u003c/p\u003e\u003c/body\u003e\u003c/html\u003e\")\n    } else {\n        state_lock.error = Some(\"Missing authorization code\".to_string());\n        Html(\"\u003chtml\u003e\u003cbody\u003e\u003ch1\u003eError\u003c/h1\u003e\u003cp\u003eMissing authorization code.\u003c/p\u003e\u003c/body\u003e\u003c/html\u003e\")\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":34},{"path":["/","Users","chi","Projects","hu","src","jira","auth","mod.rs"],"content":"use anyhow::{bail, Context, Result};\nuse base64::{engine::general_purpose::URL_SAFE_NO_PAD, Engine};\nuse rand::Rng;\nuse std::sync::Arc;\nuse tokio::sync::Mutex;\n\nuse crate::util::{load_credentials, save_credentials, JiraCredentials};\n\nuse super::types::OAuthConfig;\n\nmod callback;\n\nuse callback::{start_callback_server, CallbackState};\n\n#[cfg(test)]\nmod tests;\n\nconst AUTH_URL: \u0026str = \"https://auth.atlassian.com/authorize\";\nconst TOKEN_URL: \u0026str = \"https://auth.atlassian.com/oauth/token\";\nconst RESOURCES_URL: \u0026str = \"https://api.atlassian.com/oauth/token/accessible-resources\";\nconst CALLBACK_PORT: u16 = 9876;\nconst SCOPES: \u0026str = \"read:jira-work write:jira-work read:jira-user offline_access\";\n\n/// Load OAuth config from environment or config file\npub fn load_oauth_config() -\u003e Result\u003cOAuthConfig\u003e {\n    // Try environment variables first\n    if let (Ok(client_id), Ok(client_secret)) = (\n        std::env::var(\"JIRA_CLIENT_ID\"),\n        std::env::var(\"JIRA_CLIENT_SECRET\"),\n    ) {\n        return Ok(OAuthConfig {\n            client_id,\n            client_secret,\n        });\n    }\n\n    // Try config file\n    let config_path = crate::util::config_dir()?.join(\"jira-oauth.toml\");\n    if config_path.exists() {\n        let contents = std::fs::read_to_string(\u0026config_path)\n            .with_context(|| format!(\"Failed to read {}\", config_path.display()))?;\n        let config: OAuthConfig = toml::from_str(\u0026contents)\n            .with_context(|| format!(\"Failed to parse {}\", config_path.display()))?;\n        return Ok(config);\n    }\n\n    bail!(\n        \"Jira OAuth not configured. Set JIRA_CLIENT_ID and JIRA_CLIENT_SECRET environment variables, \\\n        or create {} with client_id and client_secret fields.\",\n        crate::util::config_dir()?.join(\"jira-oauth.toml\").display()\n    )\n}\n\n/// Generate a random state string for CSRF protection\npub fn generate_state() -\u003e String {\n    let mut rng = rand::thread_rng();\n    let bytes: [u8; 32] = rng.gen();\n    URL_SAFE_NO_PAD.encode(bytes)\n}\n\n/// Build the authorization URL\npub fn build_auth_url(client_id: \u0026str, state: \u0026str) -\u003e String {\n    let redirect_uri = format!(\"http://localhost:{}/callback\", CALLBACK_PORT);\n    format!(\n        \"{}?audience=api.atlassian.com\u0026client_id={}\u0026scope={}\u0026redirect_uri={}\u0026state={}\u0026response_type=code\u0026prompt=consent\",\n        AUTH_URL,\n        client_id,\n        urlencoded(SCOPES),\n        urlencoded(\u0026redirect_uri),\n        state\n    )\n}\n\n/// URL encode a string\nfn urlencoded(s: \u0026str) -\u003e String {\n    s.chars()\n        .map(|c| match c {\n            ' ' =\u003e \"%20\".to_string(),\n            ':' =\u003e \"%3A\".to_string(),\n            '/' =\u003e \"%2F\".to_string(),\n            _ =\u003e c.to_string(),\n        })\n        .collect()\n}\n\n/// Start OAuth flow and return user display name\npub async fn login() -\u003e Result\u003cString\u003e {\n    let config = load_oauth_config()?;\n    let state = generate_state();\n\n    // Start local server to receive callback\n    let callback_state = Arc::new(Mutex::new(CallbackState {\n        expected_state: state.clone(),\n        code: None,\n        error: None,\n    }));\n\n    let server_state = callback_state.clone();\n    let server = tokio::spawn(async move { start_callback_server(server_state).await });\n\n    // Open browser for authorization\n    let auth_url = build_auth_url(\u0026config.client_id, \u0026state);\n    open::that(\u0026auth_url).context(\"Failed to open browser\")?;\n\n    // Wait for callback\n    server.await??;\n\n    // Get the authorization code\n    let state_lock = callback_state.lock().await;\n    if let Some(error) = \u0026state_lock.error {\n        bail!(\"Authorization failed: {}\", error);\n    }\n    let code = state_lock\n        .code\n        .clone()\n        .context(\"No authorization code received\")?;\n    drop(state_lock);\n\n    // Exchange code for tokens\n    let tokens = exchange_code(\u0026config, \u0026code).await?;\n\n    // Get accessible resources to find cloud ID\n    let resources = get_accessible_resources(\u0026tokens.access_token).await?;\n    let resource = resources\n        .first()\n        .context(\"No accessible Jira sites found\")?;\n\n    // Get user info\n    let user = get_current_user(\u0026tokens.access_token, \u0026resource.id).await?;\n\n    // Save credentials\n    let creds = JiraCredentials {\n        access_token: tokens.access_token,\n        refresh_token: tokens.refresh_token,\n        expires_at: tokens.expires_at,\n        cloud_id: resource.id.clone(),\n        site_url: resource.url.clone(),\n    };\n    save_jira_credentials(creds)?;\n\n    Ok(user)\n}\n\n/// Token response from Atlassian\n#[derive(Debug)]\nstruct TokenResponse {\n    access_token: String,\n    refresh_token: String,\n    expires_at: i64,\n}\n\n/// Exchange authorization code for tokens\nasync fn exchange_code(config: \u0026OAuthConfig, code: \u0026str) -\u003e Result\u003cTokenResponse\u003e {\n    let client = reqwest::Client::new();\n    let redirect_uri = format!(\"http://localhost:{}/callback\", CALLBACK_PORT);\n\n    let response = client\n        .post(TOKEN_URL)\n        .json(\u0026serde_json::json!({\n            \"grant_type\": \"authorization_code\",\n            \"client_id\": config.client_id,\n            \"client_secret\": config.client_secret,\n            \"code\": code,\n            \"redirect_uri\": redirect_uri\n        }))\n        .send()\n        .await\n        .context(\"Failed to exchange code for tokens\")?;\n\n    if !response.status().is_success() {\n        let error_text = response.text().await.unwrap_or_default();\n        bail!(\"Token exchange failed: {}\", error_text);\n    }\n\n    let json: serde_json::Value = response\n        .json()\n        .await\n        .context(\"Failed to parse token response\")?;\n\n    let access_token = json[\"access_token\"]\n        .as_str()\n        .context(\"Missing access_token\")?\n        .to_string();\n    let refresh_token = json[\"refresh_token\"]\n        .as_str()\n        .context(\"Missing refresh_token\")?\n        .to_string();\n    let expires_in = json[\"expires_in\"].as_i64().unwrap_or(3600);\n    let expires_at = chrono::Utc::now().timestamp() + expires_in;\n\n    Ok(TokenResponse {\n        access_token,\n        refresh_token,\n        expires_at,\n    })\n}\n\n/// Get accessible Jira cloud resources\nasync fn get_accessible_resources(\n    access_token: \u0026str,\n) -\u003e Result\u003cVec\u003csuper::types::AccessibleResource\u003e\u003e {\n    let client = reqwest::Client::new();\n\n    let response = client\n        .get(RESOURCES_URL)\n        .bearer_auth(access_token)\n        .send()\n        .await\n        .context(\"Failed to get accessible resources\")?;\n\n    if !response.status().is_success() {\n        let error_text = response.text().await.unwrap_or_default();\n        bail!(\"Failed to get accessible resources: {}\", error_text);\n    }\n\n    let json: serde_json::Value = response.json().await?;\n    let resources: Vec\u003csuper::types::AccessibleResource\u003e = json\n        .as_array()\n        .context(\"Expected array of resources\")?\n        .iter()\n        .filter_map(|r| {\n            Some(super::types::AccessibleResource {\n                id: r[\"id\"].as_str()?.to_string(),\n                url: r[\"url\"].as_str()?.to_string(),\n                name: r[\"name\"].as_str()?.to_string(),\n            })\n        })\n        .collect();\n\n    Ok(resources)\n}\n\n/// Get current user display name\nasync fn get_current_user(access_token: \u0026str, cloud_id: \u0026str) -\u003e Result\u003cString\u003e {\n    let client = reqwest::Client::new();\n    let url = format!(\n        \"https://api.atlassian.com/ex/jira/{}/rest/api/3/myself\",\n        cloud_id\n    );\n\n    let response = client\n        .get(\u0026url)\n        .bearer_auth(access_token)\n        .send()\n        .await\n        .context(\"Failed to get current user\")?;\n\n    if !response.status().is_success() {\n        let error_text = response.text().await.unwrap_or_default();\n        bail!(\"Failed to get current user: {}\", error_text);\n    }\n\n    let json: serde_json::Value = response.json().await?;\n    let display_name = json[\"displayName\"]\n        .as_str()\n        .context(\"Missing displayName\")?\n        .to_string();\n\n    Ok(display_name)\n}\n\n/// Refresh access token if expired or about to expire\npub async fn refresh_token_if_needed() -\u003e Result\u003cString\u003e {\n    let creds = get_credentials().context(\"Not authenticated. Run `hu jira auth` first.\")?;\n\n    // Check if token expires in the next 5 minutes\n    let now = chrono::Utc::now().timestamp();\n    if creds.expires_at \u003e now + 300 {\n        return Ok(creds.access_token);\n    }\n\n    // Need to refresh\n    let config = load_oauth_config()?;\n    let tokens = refresh_token(\u0026config, \u0026creds.refresh_token).await?;\n\n    // Save updated credentials\n    let new_creds = JiraCredentials {\n        access_token: tokens.access_token.clone(),\n        refresh_token: tokens.refresh_token,\n        expires_at: tokens.expires_at,\n        cloud_id: creds.cloud_id,\n        site_url: creds.site_url,\n    };\n    save_jira_credentials(new_creds)?;\n\n    Ok(tokens.access_token)\n}\n\n/// Refresh access token\nasync fn refresh_token(config: \u0026OAuthConfig, refresh_token: \u0026str) -\u003e Result\u003cTokenResponse\u003e {\n    let client = reqwest::Client::new();\n\n    let response = client\n        .post(TOKEN_URL)\n        .json(\u0026serde_json::json!({\n            \"grant_type\": \"refresh_token\",\n            \"client_id\": config.client_id,\n            \"client_secret\": config.client_secret,\n            \"refresh_token\": refresh_token\n        }))\n        .send()\n        .await\n        .context(\"Failed to refresh token\")?;\n\n    if !response.status().is_success() {\n        let error_text = response.text().await.unwrap_or_default();\n        bail!(\"Token refresh failed: {}\", error_text);\n    }\n\n    let json: serde_json::Value = response\n        .json()\n        .await\n        .context(\"Failed to parse token response\")?;\n\n    let access_token = json[\"access_token\"]\n        .as_str()\n        .context(\"Missing access_token\")?\n        .to_string();\n    let new_refresh_token = json[\"refresh_token\"]\n        .as_str()\n        .unwrap_or(refresh_token)\n        .to_string();\n    let expires_in = json[\"expires_in\"].as_i64().unwrap_or(3600);\n    let expires_at = chrono::Utc::now().timestamp() + expires_in;\n\n    Ok(TokenResponse {\n        access_token,\n        refresh_token: new_refresh_token,\n        expires_at,\n    })\n}\n\n/// Get stored Jira credentials\npub fn get_credentials() -\u003e Option\u003cJiraCredentials\u003e {\n    load_credentials().ok().and_then(|c| c.jira)\n}\n\n/// Save Jira credentials\nfn save_jira_credentials(jira: JiraCredentials) -\u003e Result\u003c()\u003e {\n    let mut creds = load_credentials().unwrap_or_default();\n    creds.jira = Some(jira);\n    save_credentials(\u0026creds)\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":4}},{"line":56,"address":[],"length":0,"stats":{"Line":8}},{"line":57,"address":[],"length":0,"stats":{"Line":16}},{"line":58,"address":[],"length":0,"stats":{"Line":12}},{"line":62,"address":[],"length":0,"stats":{"Line":3}},{"line":63,"address":[],"length":0,"stats":{"Line":9}},{"line":64,"address":[],"length":0,"stats":{"Line":3}},{"line":68,"address":[],"length":0,"stats":{"Line":6}},{"line":69,"address":[],"length":0,"stats":{"Line":6}},{"line":75,"address":[],"length":0,"stats":{"Line":10}},{"line":76,"address":[],"length":0,"stats":{"Line":20}},{"line":77,"address":[],"length":0,"stats":{"Line":303}},{"line":78,"address":[],"length":0,"stats":{"Line":20}},{"line":79,"address":[],"length":0,"stats":{"Line":32}},{"line":80,"address":[],"length":0,"stats":{"Line":20}},{"line":81,"address":[],"length":0,"stats":{"Line":514}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":2}},{"line":264,"address":[],"length":0,"stats":{"Line":3}},{"line":267,"address":[],"length":0,"stats":{"Line":3}},{"line":268,"address":[],"length":0,"stats":{"Line":1}},{"line":269,"address":[],"length":0,"stats":{"Line":1}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":3}},{"line":335,"address":[],"length":0,"stats":{"Line":9}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}}],"covered":23,"coverable":159},{"path":["/","Users","chi","Projects","hu","src","jira","auth","tests.rs"],"content":"use super::*;\nuse serde_json::json;\n\n#[test]\nfn generate_state_returns_nonempty_string() {\n    let state = generate_state();\n    assert!(!state.is_empty());\n}\n\n#[test]\nfn generate_state_returns_unique_values() {\n    let state1 = generate_state();\n    let state2 = generate_state();\n    assert_ne!(state1, state2);\n}\n\n#[test]\nfn generate_state_is_url_safe() {\n    let state = generate_state();\n    // URL-safe base64 only uses alphanumeric, dash, underscore\n    assert!(state\n        .chars()\n        .all(|c| c.is_alphanumeric() || c == '-' || c == '_'));\n}\n\n#[test]\nfn build_auth_url_contains_required_params() {\n    let url = build_auth_url(\"test_client_id\", \"test_state\");\n    assert!(url.contains(\"client_id=test_client_id\"));\n    assert!(url.contains(\"state=test_state\"));\n    assert!(url.contains(\"response_type=code\"));\n    assert!(url.contains(\"audience=api.atlassian.com\"));\n    assert!(url.contains(\"prompt=consent\"));\n}\n\n#[test]\nfn build_auth_url_contains_scopes() {\n    let url = build_auth_url(\"id\", \"state\");\n    assert!(url.contains(\"read%3Ajira-work\")); // read:jira-work encoded\n    assert!(url.contains(\"write%3Ajira-work\")); // write:jira-work encoded\n    assert!(url.contains(\"offline_access\"));\n}\n\n#[test]\nfn build_auth_url_contains_redirect_uri() {\n    let url = build_auth_url(\"id\", \"state\");\n    assert!(url.contains(\"redirect_uri=http%3A%2F%2Flocalhost%3A9876%2Fcallback\"));\n}\n\n#[test]\nfn urlencoded_encodes_spaces() {\n    assert_eq!(urlencoded(\"hello world\"), \"hello%20world\");\n}\n\n#[test]\nfn urlencoded_encodes_colons() {\n    assert_eq!(urlencoded(\"a:b\"), \"a%3Ab\");\n}\n\n#[test]\nfn urlencoded_encodes_slashes() {\n    assert_eq!(urlencoded(\"a/b\"), \"a%2Fb\");\n}\n\n#[test]\nfn urlencoded_preserves_alphanumeric() {\n    assert_eq!(urlencoded(\"abc123\"), \"abc123\");\n}\n\n#[test]\nfn parse_token_response_extracts_fields() {\n    let json = json!({\n        \"access_token\": \"access123\",\n        \"refresh_token\": \"refresh456\",\n        \"expires_in\": 7200\n    });\n    let (access, refresh, expires_in) = parse_token_response(\u0026json).unwrap();\n    assert_eq!(access, \"access123\");\n    assert_eq!(refresh, \"refresh456\");\n    assert_eq!(expires_in, 7200);\n}\n\n#[test]\nfn parse_token_response_uses_default_expires() {\n    let json = json!({\n        \"access_token\": \"access\",\n        \"refresh_token\": \"refresh\"\n    });\n    let (_, _, expires_in) = parse_token_response(\u0026json).unwrap();\n    assert_eq!(expires_in, 3600);\n}\n\n#[test]\nfn parse_token_response_fails_missing_access_token() {\n    let json = json!({\n        \"refresh_token\": \"refresh\"\n    });\n    let result = parse_token_response(\u0026json);\n    assert!(result.is_err());\n}\n\n#[test]\nfn parse_token_response_fails_missing_refresh_token() {\n    let json = json!({\n        \"access_token\": \"access\"\n    });\n    let result = parse_token_response(\u0026json);\n    assert!(result.is_err());\n}\n\n#[test]\nfn parse_accessible_resources_extracts_resources() {\n    let json = json!([\n        {\"id\": \"cloud1\", \"url\": \"https://a.atlassian.net\", \"name\": \"Site A\"},\n        {\"id\": \"cloud2\", \"url\": \"https://b.atlassian.net\", \"name\": \"Site B\"}\n    ]);\n    let resources = parse_accessible_resources(\u0026json);\n    assert_eq!(resources.len(), 2);\n    assert_eq!(resources[0].id, \"cloud1\");\n    assert_eq!(resources[0].url, \"https://a.atlassian.net\");\n    assert_eq!(resources[0].name, \"Site A\");\n    assert_eq!(resources[1].id, \"cloud2\");\n}\n\n#[test]\nfn parse_accessible_resources_handles_empty_array() {\n    let json = json!([]);\n    let resources = parse_accessible_resources(\u0026json);\n    assert!(resources.is_empty());\n}\n\n#[test]\nfn parse_accessible_resources_handles_non_array() {\n    let json = json!({\"not\": \"an array\"});\n    let resources = parse_accessible_resources(\u0026json);\n    assert!(resources.is_empty());\n}\n\n#[test]\nfn parse_accessible_resources_skips_incomplete_entries() {\n    let json = json!([\n        {\"id\": \"cloud1\", \"url\": \"https://a.atlassian.net\", \"name\": \"Site A\"},\n        {\"id\": \"cloud2\"}, // missing url and name\n        {\"url\": \"https://c.atlassian.net\", \"name\": \"Site C\"} // missing id\n    ]);\n    let resources = parse_accessible_resources(\u0026json);\n    assert_eq!(resources.len(), 1);\n    assert_eq!(resources[0].id, \"cloud1\");\n}\n\n#[test]\nfn parse_user_response_extracts_display_name() {\n    let json = json!({\n        \"displayName\": \"John Doe\",\n        \"accountId\": \"123\"\n    });\n    let name = parse_user_response(\u0026json);\n    assert_eq!(name, Some(\"John Doe\".to_string()));\n}\n\n#[test]\nfn parse_user_response_returns_none_for_missing_name() {\n    let json = json!({\n        \"accountId\": \"123\"\n    });\n    let name = parse_user_response(\u0026json);\n    assert!(name.is_none());\n}\n\n#[test]\nfn get_credentials_returns_option() {\n    let result = get_credentials();\n    // Result is either Some(creds) or None\n    assert!(result.is_some() || result.is_none());\n}\n\n#[test]\nfn callback_state_debug_format() {\n    let state = CallbackState {\n        expected_state: \"test\".to_string(),\n        code: None,\n        error: None,\n    };\n    let debug_str = format!(\"{:?}\", state);\n    assert!(debug_str.contains(\"CallbackState\"));\n}\n\n#[test]\nfn callback_state_clone() {\n    let state = CallbackState {\n        expected_state: \"state123\".to_string(),\n        code: Some(\"code456\".to_string()),\n        error: None,\n    };\n    let cloned = state.clone();\n    assert_eq!(cloned.expected_state, state.expected_state);\n    assert_eq!(cloned.code, state.code);\n    assert_eq!(cloned.error, state.error);\n}\n\n#[test]\nfn token_response_debug_format() {\n    let response = TokenResponse {\n        access_token: \"access\".to_string(),\n        refresh_token: \"refresh\".to_string(),\n        expires_at: 1234567890,\n    };\n    let debug_str = format!(\"{:?}\", response);\n    assert!(debug_str.contains(\"TokenResponse\"));\n}\n\n#[test]\nfn constants_are_valid() {\n    assert!(AUTH_URL.starts_with(\"https://\"));\n    assert!(TOKEN_URL.starts_with(\"https://\"));\n    assert!(RESOURCES_URL.starts_with(\"https://\"));\n    assert!(CALLBACK_PORT \u003e 0);\n    assert!(!SCOPES.is_empty());\n}\n\n#[test]\nfn scopes_contain_required_permissions() {\n    assert!(SCOPES.contains(\"read:jira-work\"));\n    assert!(SCOPES.contains(\"write:jira-work\"));\n    assert!(SCOPES.contains(\"read:jira-user\"));\n    assert!(SCOPES.contains(\"offline_access\"));\n}\n\n/// Parse token response JSON (pure function, testable)\nfn parse_token_response(json: \u0026serde_json::Value) -\u003e Result\u003c(String, String, i64)\u003e {\n    let access_token = json[\"access_token\"]\n        .as_str()\n        .context(\"Missing access_token\")?\n        .to_string();\n    let refresh_token = json[\"refresh_token\"]\n        .as_str()\n        .context(\"Missing refresh_token\")?\n        .to_string();\n    let expires_in = json[\"expires_in\"].as_i64().unwrap_or(3600);\n\n    Ok((access_token, refresh_token, expires_in))\n}\n\n/// Parse accessible resources JSON (pure function, testable)\nfn parse_accessible_resources(\n    json: \u0026serde_json::Value,\n) -\u003e Vec\u003csuper::super::types::AccessibleResource\u003e {\n    json.as_array()\n        .unwrap_or(\u0026vec![])\n        .iter()\n        .filter_map(|r| {\n            Some(super::super::types::AccessibleResource {\n                id: r[\"id\"].as_str()?.to_string(),\n                url: r[\"url\"].as_str()?.to_string(),\n                name: r[\"name\"].as_str()?.to_string(),\n            })\n        })\n        .collect()\n}\n\n/// Parse user response JSON (pure function, testable)\nfn parse_user_response(json: \u0026serde_json::Value) -\u003e Option\u003cString\u003e {\n    json[\"displayName\"].as_str().map(|s| s.to_string())\n}\n","traces":[{"line":230,"address":[],"length":0,"stats":{"Line":4}},{"line":231,"address":[],"length":0,"stats":{"Line":7}},{"line":235,"address":[],"length":0,"stats":{"Line":5}},{"line":239,"address":[],"length":0,"stats":{"Line":8}},{"line":241,"address":[],"length":0,"stats":{"Line":4}},{"line":245,"address":[],"length":0,"stats":{"Line":4}},{"line":248,"address":[],"length":0,"stats":{"Line":12}},{"line":249,"address":[],"length":0,"stats":{"Line":4}},{"line":251,"address":[],"length":0,"stats":{"Line":9}},{"line":253,"address":[],"length":0,"stats":{"Line":15}},{"line":254,"address":[],"length":0,"stats":{"Line":12}},{"line":255,"address":[],"length":0,"stats":{"Line":9}},{"line":262,"address":[],"length":0,"stats":{"Line":2}},{"line":263,"address":[],"length":0,"stats":{"Line":8}}],"covered":14,"coverable":14},{"path":["/","Users","chi","Projects","hu","src","jira","auth_handler.rs"],"content":"use anyhow::Result;\n\nuse super::auth;\n\n/// Run the jira auth command\npub async fn run() -\u003e Result\u003c()\u003e {\n    println!(\"Opening browser for Jira authorization...\");\n    let name = auth::login().await?;\n    println!(\"\\x1b[32m\\u{2713}\\x1b[0m Logged in as {}\", name);\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    // Auth handler is thin and delegates to auth module\n    // Integration testing would require mocking the browser and OAuth flow\n    // Pure function tests are in auth.rs\n\n    #[test]\n    fn module_compiles() {\n        // Verify the module structure is correct\n        assert!(true);\n    }\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["/","Users","chi","Projects","hu","src","jira","cli.rs"],"content":"use clap::Subcommand;\n\n#[derive(Debug, Subcommand)]\npub enum JiraCommand {\n    /// Authenticate with Jira via OAuth 2.0\n    Auth,\n\n    /// List my tickets in current sprint\n    Tickets,\n\n    /// Show all issues in current sprint\n    Sprint,\n\n    /// Search tickets using JQL\n    Search {\n        /// JQL query (e.g., \"project = PROJ AND status = 'In Progress'\")\n        query: String,\n    },\n\n    /// Show ticket details\n    Show {\n        /// Ticket key (e.g., PROJ-123)\n        key: String,\n    },\n\n    /// Update a ticket\n    Update {\n        /// Ticket key (e.g., PROJ-123)\n        key: String,\n\n        /// New summary/title\n        #[arg(long)]\n        summary: Option\u003cString\u003e,\n\n        /// New status (transition)\n        #[arg(long)]\n        status: Option\u003cString\u003e,\n\n        /// Assign to user (account ID or \"me\")\n        #[arg(long)]\n        assign: Option\u003cString\u003e,\n    },\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use clap::CommandFactory;\n\n    // Helper to build a command for testing\n    fn build_cmd() -\u003e clap::Command {\n        #[derive(clap::Parser)]\n        struct TestCli {\n            #[command(subcommand)]\n            cmd: JiraCommand,\n        }\n        TestCli::command()\n    }\n\n    #[test]\n    fn parses_auth() {\n        let cmd = build_cmd();\n        let matches = cmd.try_get_matches_from([\"test\", \"auth\"]);\n        assert!(matches.is_ok());\n    }\n\n    #[test]\n    fn parses_tickets() {\n        let cmd = build_cmd();\n        let matches = cmd.try_get_matches_from([\"test\", \"tickets\"]);\n        assert!(matches.is_ok());\n    }\n\n    #[test]\n    fn parses_sprint() {\n        let cmd = build_cmd();\n        let matches = cmd.try_get_matches_from([\"test\", \"sprint\"]);\n        assert!(matches.is_ok());\n    }\n\n    #[test]\n    fn parses_search() {\n        let cmd = build_cmd();\n        let matches = cmd.try_get_matches_from([\"test\", \"search\", \"project = TEST\"]);\n        assert!(matches.is_ok());\n    }\n\n    #[test]\n    fn parses_show() {\n        let cmd = build_cmd();\n        let matches = cmd.try_get_matches_from([\"test\", \"show\", \"PROJ-123\"]);\n        assert!(matches.is_ok());\n    }\n\n    #[test]\n    fn parses_update_with_summary() {\n        let cmd = build_cmd();\n        let matches =\n            cmd.try_get_matches_from([\"test\", \"update\", \"PROJ-123\", \"--summary\", \"New title\"]);\n        assert!(matches.is_ok());\n    }\n\n    #[test]\n    fn parses_update_with_status() {\n        let cmd = build_cmd();\n        let matches = cmd.try_get_matches_from([\"test\", \"update\", \"PROJ-123\", \"--status\", \"Done\"]);\n        assert!(matches.is_ok());\n    }\n\n    #[test]\n    fn parses_update_with_assign() {\n        let cmd = build_cmd();\n        let matches = cmd.try_get_matches_from([\"test\", \"update\", \"PROJ-123\", \"--assign\", \"me\"]);\n        assert!(matches.is_ok());\n    }\n\n    #[test]\n    fn parses_update_with_all_options() {\n        let cmd = build_cmd();\n        let matches = cmd.try_get_matches_from([\n            \"test\",\n            \"update\",\n            \"PROJ-123\",\n            \"--summary\",\n            \"New title\",\n            \"--status\",\n            \"In Progress\",\n            \"--assign\",\n            \"user123\",\n        ]);\n        assert!(matches.is_ok());\n    }\n\n    #[test]\n    fn update_requires_key() {\n        let cmd = build_cmd();\n        let matches = cmd.try_get_matches_from([\"test\", \"update\", \"--summary\", \"Title\"]);\n        assert!(matches.is_err());\n    }\n\n    #[test]\n    fn search_requires_query() {\n        let cmd = build_cmd();\n        let matches = cmd.try_get_matches_from([\"test\", \"search\"]);\n        assert!(matches.is_err());\n    }\n\n    #[test]\n    fn show_requires_key() {\n        let cmd = build_cmd();\n        let matches = cmd.try_get_matches_from([\"test\", \"show\"]);\n        assert!(matches.is_err());\n    }\n\n    #[test]\n    fn jira_command_debug() {\n        let cmd = JiraCommand::Auth;\n        let debug_str = format!(\"{:?}\", cmd);\n        assert!(debug_str.contains(\"Auth\"));\n    }\n\n    #[test]\n    fn tickets_command_debug() {\n        let cmd = JiraCommand::Tickets;\n        let debug_str = format!(\"{:?}\", cmd);\n        assert!(debug_str.contains(\"Tickets\"));\n    }\n\n    #[test]\n    fn sprint_command_debug() {\n        let cmd = JiraCommand::Sprint;\n        let debug_str = format!(\"{:?}\", cmd);\n        assert!(debug_str.contains(\"Sprint\"));\n    }\n\n    #[test]\n    fn search_command_debug() {\n        let cmd = JiraCommand::Search {\n            query: \"test\".to_string(),\n        };\n        let debug_str = format!(\"{:?}\", cmd);\n        assert!(debug_str.contains(\"Search\"));\n    }\n\n    #[test]\n    fn show_command_debug() {\n        let cmd = JiraCommand::Show {\n            key: \"X-1\".to_string(),\n        };\n        let debug_str = format!(\"{:?}\", cmd);\n        assert!(debug_str.contains(\"Show\"));\n    }\n\n    #[test]\n    fn update_command_debug() {\n        let cmd = JiraCommand::Update {\n            key: \"X-1\".to_string(),\n            summary: Some(\"S\".to_string()),\n            status: None,\n            assign: None,\n        };\n        let debug_str = format!(\"{:?}\", cmd);\n        assert!(debug_str.contains(\"Update\"));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","jira","client","mod.rs"],"content":"use anyhow::{bail, Context, Result};\nuse std::future::Future;\n\nuse super::auth;\nuse super::types::{Issue, IssueUpdate, Transition, User};\n\n#[cfg(test)]\nmod tests;\n\n/// Trait for Jira API operations (enables mocking in tests)\npub trait JiraApi: Send + Sync {\n    /// Get current authenticated user\n    fn get_current_user(\u0026self) -\u003e impl Future\u003cOutput = Result\u003cUser\u003e\u003e + Send;\n\n    /// Get a single issue by key\n    fn get_issue(\u0026self, key: \u0026str) -\u003e impl Future\u003cOutput = Result\u003cIssue\u003e\u003e + Send;\n\n    /// Search issues using JQL\n    fn search_issues(\u0026self, jql: \u0026str) -\u003e impl Future\u003cOutput = Result\u003cVec\u003cIssue\u003e\u003e\u003e + Send;\n\n    /// Update issue fields\n    fn update_issue(\n        \u0026self,\n        key: \u0026str,\n        update: \u0026IssueUpdate,\n    ) -\u003e impl Future\u003cOutput = Result\u003c()\u003e\u003e + Send;\n\n    /// Get available transitions for an issue\n    fn get_transitions(\u0026self, key: \u0026str) -\u003e impl Future\u003cOutput = Result\u003cVec\u003cTransition\u003e\u003e\u003e + Send;\n\n    /// Transition an issue to a new status\n    fn transition_issue(\n        \u0026self,\n        key: \u0026str,\n        transition_id: \u0026str,\n    ) -\u003e impl Future\u003cOutput = Result\u003c()\u003e\u003e + Send;\n}\n\n/// Jira API client\npub struct JiraClient {\n    client: reqwest::Client,\n    cloud_id: String,\n    access_token: String,\n}\n\nimpl JiraClient {\n    /// Create a new authenticated Jira client\n    pub async fn new() -\u003e Result\u003cSelf\u003e {\n        let access_token = auth::refresh_token_if_needed().await?;\n        let creds =\n            auth::get_credentials().context(\"Not authenticated. Run `hu jira auth` first.\")?;\n\n        Ok(Self {\n            client: reqwest::Client::new(),\n            cloud_id: creds.cloud_id,\n            access_token,\n        })\n    }\n\n    /// Build API URL for Jira REST API v3\n    fn api_url(\u0026self, path: \u0026str) -\u003e String {\n        format!(\n            \"https://api.atlassian.com/ex/jira/{}/rest/api/3{}\",\n            self.cloud_id, path\n        )\n    }\n}\n\nimpl JiraApi for JiraClient {\n    async fn get_current_user(\u0026self) -\u003e Result\u003cUser\u003e {\n        let url = self.api_url(\"/myself\");\n        let response = self\n            .client\n            .get(\u0026url)\n            .bearer_auth(\u0026self.access_token)\n            .send()\n            .await\n            .context(\"Failed to get current user\")?;\n\n        if !response.status().is_success() {\n            let error_text = response.text().await.unwrap_or_default();\n            bail!(\"Failed to get current user: {}\", error_text);\n        }\n\n        let json: serde_json::Value = response.json().await?;\n        parse_user(\u0026json).context(\"Failed to parse user response\")\n    }\n\n    async fn get_issue(\u0026self, key: \u0026str) -\u003e Result\u003cIssue\u003e {\n        let url = self.api_url(\u0026format!(\"/issue/{}\", key));\n        let response = self\n            .client\n            .get(\u0026url)\n            .bearer_auth(\u0026self.access_token)\n            .send()\n            .await\n            .context(\"Failed to get issue\")?;\n\n        if !response.status().is_success() {\n            let error_text = response.text().await.unwrap_or_default();\n            bail!(\"Failed to get issue {}: {}\", key, error_text);\n        }\n\n        let json: serde_json::Value = response.json().await?;\n        parse_single_issue(\u0026json).context(\"Failed to parse issue\")\n    }\n\n    async fn search_issues(\u0026self, jql: \u0026str) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n        // Use the new /search/jql endpoint (the old /search was deprecated)\n        let url = self.api_url(\"/search/jql\");\n        let response = self\n            .client\n            .post(\u0026url)\n            .bearer_auth(\u0026self.access_token)\n            .json(\u0026serde_json::json!({\n                \"jql\": jql,\n                \"fields\": [\"summary\", \"status\", \"issuetype\", \"assignee\", \"description\", \"updated\"]\n            }))\n            .send()\n            .await\n            .context(\"Failed to search issues\")?;\n\n        if !response.status().is_success() {\n            let error_text = response.text().await.unwrap_or_default();\n            bail!(\"Failed to search issues: {}\", error_text);\n        }\n\n        let json: serde_json::Value = response.json().await?;\n        Ok(parse_issues(\u0026json))\n    }\n\n    async fn update_issue(\u0026self, key: \u0026str, update: \u0026IssueUpdate) -\u003e Result\u003c()\u003e {\n        let url = self.api_url(\u0026format!(\"/issue/{}\", key));\n\n        let mut fields = serde_json::Map::new();\n        if let Some(summary) = \u0026update.summary {\n            fields.insert(\"summary\".to_string(), serde_json::json!(summary));\n        }\n        if let Some(description) = \u0026update.description {\n            // Jira uses ADF format for description\n            fields.insert(\n                \"description\".to_string(),\n                serde_json::json!({\n                    \"type\": \"doc\",\n                    \"version\": 1,\n                    \"content\": [{\n                        \"type\": \"paragraph\",\n                        \"content\": [{\n                            \"type\": \"text\",\n                            \"text\": description\n                        }]\n                    }]\n                }),\n            );\n        }\n        if let Some(assignee) = \u0026update.assignee {\n            fields.insert(\n                \"assignee\".to_string(),\n                serde_json::json!({ \"accountId\": assignee }),\n            );\n        }\n\n        let body = serde_json::json!({ \"fields\": fields });\n\n        let response = self\n            .client\n            .put(\u0026url)\n            .bearer_auth(\u0026self.access_token)\n            .json(\u0026body)\n            .send()\n            .await\n            .context(\"Failed to update issue\")?;\n\n        if !response.status().is_success() {\n            let error_text = response.text().await.unwrap_or_default();\n            bail!(\"Failed to update issue {}: {}\", key, error_text);\n        }\n\n        Ok(())\n    }\n\n    async fn get_transitions(\u0026self, key: \u0026str) -\u003e Result\u003cVec\u003cTransition\u003e\u003e {\n        let url = self.api_url(\u0026format!(\"/issue/{}/transitions\", key));\n        let response = self\n            .client\n            .get(\u0026url)\n            .bearer_auth(\u0026self.access_token)\n            .send()\n            .await\n            .context(\"Failed to get transitions\")?;\n\n        if !response.status().is_success() {\n            let error_text = response.text().await.unwrap_or_default();\n            bail!(\"Failed to get transitions for {}: {}\", key, error_text);\n        }\n\n        let json: serde_json::Value = response.json().await?;\n        Ok(parse_transitions(\u0026json))\n    }\n\n    async fn transition_issue(\u0026self, key: \u0026str, transition_id: \u0026str) -\u003e Result\u003c()\u003e {\n        let url = self.api_url(\u0026format!(\"/issue/{}/transitions\", key));\n        let body = serde_json::json!({\n            \"transition\": { \"id\": transition_id }\n        });\n\n        let response = self\n            .client\n            .post(\u0026url)\n            .bearer_auth(\u0026self.access_token)\n            .json(\u0026body)\n            .send()\n            .await\n            .context(\"Failed to transition issue\")?;\n\n        if !response.status().is_success() {\n            let error_text = response.text().await.unwrap_or_default();\n            bail!(\"Failed to transition issue {}: {}\", key, error_text);\n        }\n\n        Ok(())\n    }\n}\n\n/// Parse user from JSON (pure function, testable)\npub fn parse_user(json: \u0026serde_json::Value) -\u003e Option\u003cUser\u003e {\n    Some(User {\n        account_id: json[\"accountId\"].as_str()?.to_string(),\n        display_name: json[\"displayName\"].as_str()?.to_string(),\n        email_address: json[\"emailAddress\"].as_str().map(|s| s.to_string()),\n    })\n}\n\n/// Parse issues from JSON (pure function, testable)\npub fn parse_issues(json: \u0026serde_json::Value) -\u003e Vec\u003cIssue\u003e {\n    json[\"issues\"]\n        .as_array()\n        .unwrap_or(\u0026vec![])\n        .iter()\n        .filter_map(parse_single_issue)\n        .collect()\n}\n\n/// Parse a single issue from JSON (pure function, testable)\npub fn parse_single_issue(json: \u0026serde_json::Value) -\u003e Option\u003cIssue\u003e {\n    let fields = \u0026json[\"fields\"];\n    Some(Issue {\n        key: json[\"key\"].as_str()?.to_string(),\n        summary: fields[\"summary\"].as_str()?.to_string(),\n        status: fields[\"status\"][\"name\"].as_str()?.to_string(),\n        issue_type: fields[\"issuetype\"][\"name\"].as_str()?.to_string(),\n        assignee: fields[\"assignee\"][\"displayName\"]\n            .as_str()\n            .map(|s| s.to_string()),\n        description: extract_description(fields),\n        updated: fields[\"updated\"].as_str()?.to_string(),\n    })\n}\n\n/// Extract description text from ADF format\nfn extract_description(fields: \u0026serde_json::Value) -\u003e Option\u003cString\u003e {\n    // Jira uses Atlassian Document Format (ADF) for rich text\n    // For simplicity, extract text nodes recursively\n    let description = \u0026fields[\"description\"];\n    if description.is_null() {\n        return None;\n    }\n\n    // If it's a simple string, return it\n    if let Some(s) = description.as_str() {\n        return Some(s.to_string());\n    }\n\n    // Extract text from ADF content\n    let content = description[\"content\"].as_array()?;\n    let text: Vec\u003cString\u003e = content\n        .iter()\n        .filter_map(extract_text_from_adf_node)\n        .collect();\n\n    if text.is_empty() {\n        None\n    } else {\n        Some(text.join(\"\\n\"))\n    }\n}\n\n/// Extract text from an ADF node recursively\nfn extract_text_from_adf_node(node: \u0026serde_json::Value) -\u003e Option\u003cString\u003e {\n    // If this node has text, return it\n    if let Some(text) = node[\"text\"].as_str() {\n        return Some(text.to_string());\n    }\n\n    // Otherwise, recursively extract from content\n    let content = node[\"content\"].as_array()?;\n    let texts: Vec\u003cString\u003e = content\n        .iter()\n        .filter_map(extract_text_from_adf_node)\n        .collect();\n\n    if texts.is_empty() {\n        None\n    } else {\n        Some(texts.join(\"\"))\n    }\n}\n\n/// Parse transitions from JSON (pure function, testable)\npub fn parse_transitions(json: \u0026serde_json::Value) -\u003e Vec\u003cTransition\u003e {\n    json[\"transitions\"]\n        .as_array()\n        .unwrap_or(\u0026vec![])\n        .iter()\n        .filter_map(|t| {\n            Some(Transition {\n                id: t[\"id\"].as_str()?.to_string(),\n                name: t[\"name\"].as_str()?.to_string(),\n            })\n        })\n        .collect()\n}\n\n/// Build update request body (pure function, testable)\n#[cfg(test)]\npub fn build_update_body(update: \u0026IssueUpdate) -\u003e serde_json::Value {\n    let mut fields = serde_json::Map::new();\n\n    if let Some(summary) = \u0026update.summary {\n        fields.insert(\"summary\".to_string(), serde_json::json!(summary));\n    }\n    if let Some(description) = \u0026update.description {\n        fields.insert(\n            \"description\".to_string(),\n            serde_json::json!({\n                \"type\": \"doc\",\n                \"version\": 1,\n                \"content\": [{\n                    \"type\": \"paragraph\",\n                    \"content\": [{\n                        \"type\": \"text\",\n                        \"text\": description\n                    }]\n                }]\n            }),\n        );\n    }\n    if let Some(assignee) = \u0026update.assignee {\n        fields.insert(\n            \"assignee\".to_string(),\n            serde_json::json!({ \"accountId\": assignee }),\n        );\n    }\n\n    serde_json::json!({ \"fields\": fields })\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":2}},{"line":50,"address":[],"length":0,"stats":{"Line":1}},{"line":51,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":1}},{"line":54,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":62,"address":[],"length":0,"stats":{"Line":1}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":2}},{"line":110,"address":[],"length":0,"stats":{"Line":4}},{"line":111,"address":[],"length":0,"stats":{"Line":3}},{"line":112,"address":[],"length":0,"stats":{"Line":2}},{"line":113,"address":[],"length":0,"stats":{"Line":3}},{"line":114,"address":[],"length":0,"stats":{"Line":3}},{"line":115,"address":[],"length":0,"stats":{"Line":4}},{"line":116,"address":[],"length":0,"stats":{"Line":2}},{"line":117,"address":[],"length":0,"stats":{"Line":2}},{"line":120,"address":[],"length":0,"stats":{"Line":1}},{"line":123,"address":[],"length":0,"stats":{"Line":1}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":4}},{"line":129,"address":[],"length":0,"stats":{"Line":1}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":3}},{"line":228,"address":[],"length":0,"stats":{"Line":9}},{"line":229,"address":[],"length":0,"stats":{"Line":6}},{"line":230,"address":[],"length":0,"stats":{"Line":8}},{"line":235,"address":[],"length":0,"stats":{"Line":4}},{"line":236,"address":[],"length":0,"stats":{"Line":8}},{"line":238,"address":[],"length":0,"stats":{"Line":4}},{"line":240,"address":[],"length":0,"stats":{"Line":4}},{"line":245,"address":[],"length":0,"stats":{"Line":11}},{"line":246,"address":[],"length":0,"stats":{"Line":22}},{"line":248,"address":[],"length":0,"stats":{"Line":33}},{"line":249,"address":[],"length":0,"stats":{"Line":30}},{"line":250,"address":[],"length":0,"stats":{"Line":30}},{"line":251,"address":[],"length":0,"stats":{"Line":30}},{"line":252,"address":[],"length":0,"stats":{"Line":10}},{"line":253,"address":[],"length":0,"stats":{"Line":10}},{"line":254,"address":[],"length":0,"stats":{"Line":26}},{"line":255,"address":[],"length":0,"stats":{"Line":20}},{"line":256,"address":[],"length":0,"stats":{"Line":30}},{"line":261,"address":[],"length":0,"stats":{"Line":14}},{"line":264,"address":[],"length":0,"stats":{"Line":28}},{"line":265,"address":[],"length":0,"stats":{"Line":28}},{"line":266,"address":[],"length":0,"stats":{"Line":5}},{"line":270,"address":[],"length":0,"stats":{"Line":10}},{"line":271,"address":[],"length":0,"stats":{"Line":1}},{"line":275,"address":[],"length":0,"stats":{"Line":24}},{"line":276,"address":[],"length":0,"stats":{"Line":24}},{"line":278,"address":[],"length":0,"stats":{"Line":8}},{"line":281,"address":[],"length":0,"stats":{"Line":16}},{"line":282,"address":[],"length":0,"stats":{"Line":1}},{"line":284,"address":[],"length":0,"stats":{"Line":14}},{"line":289,"address":[],"length":0,"stats":{"Line":107}},{"line":291,"address":[],"length":0,"stats":{"Line":149}},{"line":292,"address":[],"length":0,"stats":{"Line":42}},{"line":296,"address":[],"length":0,"stats":{"Line":195}},{"line":297,"address":[],"length":0,"stats":{"Line":192}},{"line":299,"address":[],"length":0,"stats":{"Line":64}},{"line":302,"address":[],"length":0,"stats":{"Line":128}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":128}},{"line":310,"address":[],"length":0,"stats":{"Line":3}},{"line":311,"address":[],"length":0,"stats":{"Line":6}},{"line":313,"address":[],"length":0,"stats":{"Line":3}},{"line":315,"address":[],"length":0,"stats":{"Line":6}},{"line":317,"address":[],"length":0,"stats":{"Line":9}},{"line":318,"address":[],"length":0,"stats":{"Line":9}},{"line":326,"address":[],"length":0,"stats":{"Line":5}},{"line":327,"address":[],"length":0,"stats":{"Line":10}},{"line":329,"address":[],"length":0,"stats":{"Line":9}},{"line":330,"address":[],"length":0,"stats":{"Line":8}},{"line":332,"address":[],"length":0,"stats":{"Line":9}},{"line":333,"address":[],"length":0,"stats":{"Line":6}},{"line":334,"address":[],"length":0,"stats":{"Line":6}},{"line":335,"address":[],"length":0,"stats":{"Line":4}},{"line":336,"address":[],"length":0,"stats":{"Line":4}},{"line":337,"address":[],"length":0,"stats":{"Line":4}},{"line":338,"address":[],"length":0,"stats":{"Line":4}},{"line":339,"address":[],"length":0,"stats":{"Line":4}},{"line":340,"address":[],"length":0,"stats":{"Line":4}},{"line":341,"address":[],"length":0,"stats":{"Line":2}},{"line":342,"address":[],"length":0,"stats":{"Line":2}},{"line":348,"address":[],"length":0,"stats":{"Line":9}},{"line":349,"address":[],"length":0,"stats":{"Line":6}},{"line":350,"address":[],"length":0,"stats":{"Line":6}},{"line":351,"address":[],"length":0,"stats":{"Line":2}},{"line":355,"address":[],"length":0,"stats":{"Line":10}}],"covered":88,"coverable":172},{"path":["/","Users","chi","Projects","hu","src","jira","client","tests.rs"],"content":"use super::*;\nuse serde_json::json;\n\n#[test]\nfn parse_user_extracts_fields() {\n    let json = json!({\n        \"accountId\": \"123\",\n        \"displayName\": \"John Doe\",\n        \"emailAddress\": \"john@example.com\"\n    });\n    let user = parse_user(\u0026json).unwrap();\n    assert_eq!(user.account_id, \"123\");\n    assert_eq!(user.display_name, \"John Doe\");\n    assert_eq!(user.email_address, Some(\"john@example.com\".to_string()));\n}\n\n#[test]\nfn parse_user_without_email() {\n    let json = json!({\n        \"accountId\": \"456\",\n        \"displayName\": \"Jane\"\n    });\n    let user = parse_user(\u0026json).unwrap();\n    assert_eq!(user.account_id, \"456\");\n    assert!(user.email_address.is_none());\n}\n\n#[test]\nfn parse_user_returns_none_for_missing_fields() {\n    let json = json!({\n        \"displayName\": \"Missing ID\"\n    });\n    let user = parse_user(\u0026json);\n    assert!(user.is_none());\n}\n\n#[test]\nfn parse_issues_extracts_issues() {\n    let json = json!({\n        \"issues\": [{\n            \"key\": \"PROJ-123\",\n            \"fields\": {\n                \"summary\": \"Fix bug\",\n                \"status\": {\"name\": \"In Progress\"},\n                \"issuetype\": {\"name\": \"Bug\"},\n                \"assignee\": {\"displayName\": \"John\"},\n                \"updated\": \"2024-01-15T10:00:00Z\"\n            }\n        }]\n    });\n    let issues = parse_issues(\u0026json);\n    assert_eq!(issues.len(), 1);\n    assert_eq!(issues[0].key, \"PROJ-123\");\n    assert_eq!(issues[0].summary, \"Fix bug\");\n    assert_eq!(issues[0].status, \"In Progress\");\n    assert_eq!(issues[0].issue_type, \"Bug\");\n    assert_eq!(issues[0].assignee, Some(\"John\".to_string()));\n}\n\n#[test]\nfn parse_issues_handles_unassigned() {\n    let json = json!({\n        \"issues\": [{\n            \"key\": \"PROJ-456\",\n            \"fields\": {\n                \"summary\": \"Task\",\n                \"status\": {\"name\": \"Open\"},\n                \"issuetype\": {\"name\": \"Task\"},\n                \"assignee\": null,\n                \"updated\": \"2024-01-15T12:00:00Z\"\n            }\n        }]\n    });\n    let issues = parse_issues(\u0026json);\n    assert_eq!(issues.len(), 1);\n    assert!(issues[0].assignee.is_none());\n}\n\n#[test]\nfn parse_issues_handles_empty() {\n    let json = json!({\"issues\": []});\n    let issues = parse_issues(\u0026json);\n    assert!(issues.is_empty());\n}\n\n#[test]\nfn parse_single_issue_extracts_fields() {\n    let json = json!({\n        \"key\": \"TEST-1\",\n        \"fields\": {\n            \"summary\": \"Test issue\",\n            \"status\": {\"name\": \"Done\"},\n            \"issuetype\": {\"name\": \"Story\"},\n            \"assignee\": {\"displayName\": \"Tester\"},\n            \"description\": {\n                \"type\": \"doc\",\n                \"content\": [{\n                    \"type\": \"paragraph\",\n                    \"content\": [{\"type\": \"text\", \"text\": \"Description text\"}]\n                }]\n            },\n            \"updated\": \"2024-01-01T00:00:00Z\"\n        }\n    });\n    let issue = parse_single_issue(\u0026json).unwrap();\n    assert_eq!(issue.key, \"TEST-1\");\n    assert_eq!(issue.summary, \"Test issue\");\n    assert_eq!(issue.status, \"Done\");\n    assert_eq!(issue.issue_type, \"Story\");\n    assert_eq!(issue.assignee, Some(\"Tester\".to_string()));\n    assert_eq!(issue.description, Some(\"Description text\".to_string()));\n}\n\n#[test]\nfn parse_single_issue_returns_none_for_missing_key() {\n    let json = json!({\n        \"fields\": {\n            \"summary\": \"No key\",\n            \"status\": {\"name\": \"Open\"},\n            \"issuetype\": {\"name\": \"Task\"},\n            \"updated\": \"2024-01-01T00:00:00Z\"\n        }\n    });\n    let issue = parse_single_issue(\u0026json);\n    assert!(issue.is_none());\n}\n\n#[test]\nfn parse_single_issue_handles_null_description() {\n    let json = json!({\n        \"key\": \"X-1\",\n        \"fields\": {\n            \"summary\": \"S\",\n            \"status\": {\"name\": \"Open\"},\n            \"issuetype\": {\"name\": \"Task\"},\n            \"description\": null,\n            \"updated\": \"2024-01-01T00:00:00Z\"\n        }\n    });\n    let issue = parse_single_issue(\u0026json).unwrap();\n    assert!(issue.description.is_none());\n}\n\n#[test]\nfn extract_description_handles_string() {\n    let fields = json!({\"description\": \"Simple string\"});\n    let desc = extract_description(\u0026fields);\n    assert_eq!(desc, Some(\"Simple string\".to_string()));\n}\n\n#[test]\nfn extract_description_handles_adf() {\n    let fields = json!({\n        \"description\": {\n            \"type\": \"doc\",\n            \"content\": [{\n                \"type\": \"paragraph\",\n                \"content\": [\n                    {\"type\": \"text\", \"text\": \"Hello \"},\n                    {\"type\": \"text\", \"text\": \"world\"}\n                ]\n            }]\n        }\n    });\n    let desc = extract_description(\u0026fields);\n    assert_eq!(desc, Some(\"Hello world\".to_string()));\n}\n\n#[test]\nfn extract_description_handles_null() {\n    let fields = json!({\"description\": null});\n    let desc = extract_description(\u0026fields);\n    assert!(desc.is_none());\n}\n\n#[test]\nfn extract_description_handles_empty_content() {\n    let fields = json!({\n        \"description\": {\n            \"type\": \"doc\",\n            \"content\": []\n        }\n    });\n    let desc = extract_description(\u0026fields);\n    assert!(desc.is_none());\n}\n\n#[test]\nfn extract_text_from_adf_node_gets_text() {\n    let node = json!({\"type\": \"text\", \"text\": \"Hello\"});\n    let text = extract_text_from_adf_node(\u0026node);\n    assert_eq!(text, Some(\"Hello\".to_string()));\n}\n\n#[test]\nfn extract_text_from_adf_node_recurses() {\n    let node = json!({\n        \"type\": \"paragraph\",\n        \"content\": [\n            {\"type\": \"text\", \"text\": \"A\"},\n            {\"type\": \"text\", \"text\": \"B\"}\n        ]\n    });\n    let text = extract_text_from_adf_node(\u0026node);\n    assert_eq!(text, Some(\"AB\".to_string()));\n}\n\n#[test]\nfn extract_text_from_adf_node_handles_no_content() {\n    let node = json!({\"type\": \"hardBreak\"});\n    let text = extract_text_from_adf_node(\u0026node);\n    assert!(text.is_none());\n}\n\n#[test]\nfn parse_transitions_extracts_transitions() {\n    let json = json!({\n        \"transitions\": [\n            {\"id\": \"11\", \"name\": \"To Do\"},\n            {\"id\": \"21\", \"name\": \"In Progress\"},\n            {\"id\": \"31\", \"name\": \"Done\"}\n        ]\n    });\n    let transitions = parse_transitions(\u0026json);\n    assert_eq!(transitions.len(), 3);\n    assert_eq!(transitions[0].id, \"11\");\n    assert_eq!(transitions[0].name, \"To Do\");\n    assert_eq!(transitions[2].id, \"31\");\n    assert_eq!(transitions[2].name, \"Done\");\n}\n\n#[test]\nfn parse_transitions_handles_empty() {\n    let json = json!({\"transitions\": []});\n    let transitions = parse_transitions(\u0026json);\n    assert!(transitions.is_empty());\n}\n\n#[test]\nfn parse_transitions_handles_missing() {\n    let json = json!({});\n    let transitions = parse_transitions(\u0026json);\n    assert!(transitions.is_empty());\n}\n\n#[test]\nfn build_update_body_with_summary() {\n    let update = IssueUpdate {\n        summary: Some(\"New summary\".to_string()),\n        description: None,\n        assignee: None,\n    };\n    let body = build_update_body(\u0026update);\n    assert_eq!(body[\"fields\"][\"summary\"], \"New summary\");\n}\n\n#[test]\nfn build_update_body_with_description() {\n    let update = IssueUpdate {\n        summary: None,\n        description: Some(\"New description\".to_string()),\n        assignee: None,\n    };\n    let body = build_update_body(\u0026update);\n    assert_eq!(body[\"fields\"][\"description\"][\"type\"], \"doc\");\n    assert_eq!(body[\"fields\"][\"description\"][\"version\"], 1);\n}\n\n#[test]\nfn build_update_body_with_assignee() {\n    let update = IssueUpdate {\n        summary: None,\n        description: None,\n        assignee: Some(\"user123\".to_string()),\n    };\n    let body = build_update_body(\u0026update);\n    assert_eq!(body[\"fields\"][\"assignee\"][\"accountId\"], \"user123\");\n}\n\n#[test]\nfn build_update_body_with_all_fields() {\n    let update = IssueUpdate {\n        summary: Some(\"Sum\".to_string()),\n        description: Some(\"Desc\".to_string()),\n        assignee: Some(\"user\".to_string()),\n    };\n    let body = build_update_body(\u0026update);\n    assert_eq!(body[\"fields\"][\"summary\"], \"Sum\");\n    assert!(body[\"fields\"][\"description\"].is_object());\n    assert_eq!(body[\"fields\"][\"assignee\"][\"accountId\"], \"user\");\n}\n\n#[test]\nfn build_update_body_empty() {\n    let update = IssueUpdate::default();\n    let body = build_update_body(\u0026update);\n    assert_eq!(body[\"fields\"], json!({}));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","jira","mod.rs"],"content":"//! Jira integration\n//!\n//! # CLI Usage\n//! Use [`run_command`] for CLI commands that format and print output.\n//!\n//! # Programmatic Usage (MCP/HTTP)\n//! Use the reusable functions that return typed data:\n//! - [`get_issue`] - Get a single issue\n//! - [`search_issues`] - Search with JQL\n//! - [`get_current_user`] - Get authenticated user\n//! - [`update_issue`] - Update issue fields\n//! - [`get_transitions`] - Get available transitions\n//! - [`transition_issue`] - Change issue status\n\nmod auth;\nmod auth_handler;\nmod cli;\nmod client;\nmod search;\nmod service;\nmod show;\nmod sprint;\nmod tickets;\nmod types;\nmod update;\n\nuse anyhow::Result;\n\npub use cli::JiraCommand;\npub use types::{Issue, IssueUpdate, Transition, User};\n\nuse update::UpdateArgs;\n\n/// Run a Jira command (CLI entry point - formats and prints)\n#[cfg(not(tarpaulin_include))]\npub async fn run_command(cmd: JiraCommand) -\u003e anyhow::Result\u003c()\u003e {\n    match cmd {\n        JiraCommand::Auth =\u003e auth_handler::run().await,\n        JiraCommand::Tickets =\u003e tickets::run().await,\n        JiraCommand::Sprint =\u003e sprint::run(sprint::SprintArgs::default()).await,\n        JiraCommand::Search { query } =\u003e search::run(\u0026query).await,\n        JiraCommand::Show { key } =\u003e show::run(\u0026key).await,\n        JiraCommand::Update {\n            key,\n            summary,\n            status,\n            assign,\n        } =\u003e {\n            update::run(UpdateArgs {\n                key,\n                summary,\n                status,\n                assign,\n            })\n            .await\n        }\n    }\n}\n\n// ============================================================================\n// Reusable functions for MCP/HTTP - return typed data, never print\n// ============================================================================\n\n/// Get a single issue by key (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn get_issue(key: \u0026str) -\u003e Result\u003cIssue\u003e {\n    let client = service::create_client().await?;\n    service::get_issue(\u0026client, key).await\n}\n\n/// Search issues using JQL (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn search_issues(jql: \u0026str) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n    let client = service::create_client().await?;\n    service::search_issues(\u0026client, jql).await\n}\n\n/// Get current authenticated user (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn get_current_user() -\u003e Result\u003cUser\u003e {\n    let client = service::create_client().await?;\n    service::get_current_user(\u0026client).await\n}\n\n/// Update issue fields (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn update_issue(key: \u0026str, update: \u0026IssueUpdate) -\u003e Result\u003c()\u003e {\n    let client = service::create_client().await?;\n    service::update_issue(\u0026client, key, update).await\n}\n\n/// Get available transitions for an issue (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn get_transitions(key: \u0026str) -\u003e Result\u003cVec\u003cTransition\u003e\u003e {\n    let client = service::create_client().await?;\n    service::get_transitions(\u0026client, key).await\n}\n\n/// Transition an issue to a new status (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn transition_issue(key: \u0026str, transition_id: \u0026str) -\u003e Result\u003c()\u003e {\n    let client = service::create_client().await?;\n    service::transition_issue(\u0026client, key, transition_id).await\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn jira_command_exported() {\n        // Verify JiraCommand is re-exported\n        let _cmd = JiraCommand::Auth;\n    }\n\n    #[test]\n    fn update_args_created() {\n        let args = UpdateArgs {\n            key: \"X-1\".to_string(),\n            summary: None,\n            status: None,\n            assign: None,\n        };\n        assert_eq!(args.key, \"X-1\");\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":2}},{"line":17,"address":[],"length":0,"stats":{"Line":1}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":1}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}}],"covered":3,"coverable":17},{"path":["/","Users","chi","Projects","hu","src","jira","search.rs"],"content":"use anyhow::Result;\n\nuse super::client::{JiraApi, JiraClient};\nuse super::types::Issue;\n\n/// Run the jira search command\npub async fn run(query: \u0026str) -\u003e Result\u003c()\u003e {\n    let client = JiraClient::new().await?;\n    let output = process_search(\u0026client, query).await?;\n    print!(\"{}\", output);\n    Ok(())\n}\n\n/// Process search command (business logic, testable)\npub async fn process_search(client: \u0026impl JiraApi, query: \u0026str) -\u003e Result\u003cString\u003e {\n    let issues = client.search_issues(query).await?;\n    Ok(format_search_results(\u0026issues, query))\n}\n\n/// Format search results\nfn format_search_results(issues: \u0026[Issue], query: \u0026str) -\u003e String {\n    let mut output = String::new();\n\n    if issues.is_empty() {\n        output.push_str(\u0026format!(\"No issues found for: {}\\n\", query));\n        return output;\n    }\n\n    output.push_str(\u0026format!(\n        \"Found {} issue{} for: {}\\n\\n\",\n        issues.len(),\n        if issues.len() == 1 { \"\" } else { \"s\" },\n        query\n    ));\n\n    // Calculate column widths\n    let key_width = issues.iter().map(|i| i.key.len()).max().unwrap_or(0).max(4);\n    let status_width = issues\n        .iter()\n        .map(|i| i.status.len())\n        .max()\n        .unwrap_or(0)\n        .max(6);\n\n    for issue in issues {\n        let assignee = issue.assignee.as_deref().unwrap_or(\"-\");\n        let status_color = match issue.status.as_str() {\n            \"Done\" =\u003e \"\\x1b[32m\",        // green\n            \"In Progress\" =\u003e \"\\x1b[33m\", // yellow\n            _ =\u003e \"\\x1b[34m\",             // blue\n        };\n\n        output.push_str(\u0026format!(\n            \"{:\u003ckey_w$}  {}{:\u003cstatus_w$}\\x1b[0m  {}\\n\",\n            issue.key,\n            status_color,\n            issue.status,\n            truncate(\u0026issue.summary, 50),\n            key_w = key_width,\n            status_w = status_width,\n        ));\n        output.push_str(\u0026format!(\n            \"{:\u003ckey_w$}  \\x1b[90m{} | {}\\x1b[0m\\n\",\n            \"\",\n            issue.issue_type,\n            assignee,\n            key_w = key_width,\n        ));\n    }\n\n    output\n}\n\n/// Truncate string to max length with ellipsis\nfn truncate(s: \u0026str, max_len: usize) -\u003e String {\n    if s.len() \u003c= max_len {\n        s.to_string()\n    } else {\n        format!(\"{}...\", \u0026s[..max_len.saturating_sub(3)])\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::super::types::{IssueUpdate, Transition, User};\n    use super::*;\n\n    #[test]\n    fn truncate_short_string_unchanged() {\n        assert_eq!(truncate(\"hello\", 10), \"hello\");\n    }\n\n    #[test]\n    fn truncate_exact_length_unchanged() {\n        assert_eq!(truncate(\"hello\", 5), \"hello\");\n    }\n\n    #[test]\n    fn truncate_long_string_adds_ellipsis() {\n        assert_eq!(truncate(\"hello world\", 8), \"hello...\");\n    }\n\n    #[test]\n    fn truncate_very_short_max() {\n        assert_eq!(truncate(\"hello\", 3), \"...\");\n    }\n\n    #[test]\n    fn truncate_zero_max() {\n        assert_eq!(truncate(\"hello\", 0), \"...\");\n    }\n\n    #[test]\n    fn format_search_results_empty() {\n        let issues: Vec\u003cIssue\u003e = vec![];\n        let output = format_search_results(\u0026issues, \"project = TEST\");\n        assert!(output.contains(\"No issues found\"));\n        assert!(output.contains(\"project = TEST\"));\n    }\n\n    #[test]\n    fn format_search_results_single() {\n        let issues = vec![Issue {\n            key: \"TEST-1\".to_string(),\n            summary: \"Test issue\".to_string(),\n            status: \"Open\".to_string(),\n            issue_type: \"Bug\".to_string(),\n            assignee: Some(\"Alice\".to_string()),\n            description: None,\n            updated: \"2024-01-01T00:00:00Z\".to_string(),\n        }];\n        let output = format_search_results(\u0026issues, \"jql\");\n        assert!(output.contains(\"Found 1 issue for\"));\n        assert!(output.contains(\"TEST-1\"));\n        assert!(output.contains(\"Test issue\"));\n        assert!(output.contains(\"Bug\"));\n        assert!(output.contains(\"Alice\"));\n    }\n\n    #[test]\n    fn format_search_results_multiple() {\n        let issues = vec![\n            Issue {\n                key: \"A-1\".to_string(),\n                summary: \"First\".to_string(),\n                status: \"Done\".to_string(),\n                issue_type: \"Task\".to_string(),\n                assignee: None,\n                description: None,\n                updated: \"U\".to_string(),\n            },\n            Issue {\n                key: \"A-2\".to_string(),\n                summary: \"Second\".to_string(),\n                status: \"In Progress\".to_string(),\n                issue_type: \"Story\".to_string(),\n                assignee: Some(\"Bob\".to_string()),\n                description: None,\n                updated: \"U\".to_string(),\n            },\n        ];\n        let output = format_search_results(\u0026issues, \"q\");\n        assert!(output.contains(\"Found 2 issues\"));\n        assert!(output.contains(\"A-1\"));\n        assert!(output.contains(\"A-2\"));\n        assert!(output.contains(\"-\")); // unassigned\n        assert!(output.contains(\"Bob\"));\n    }\n\n    #[test]\n    fn format_search_results_truncates_long_summary() {\n        let issues = vec![Issue {\n            key: \"X-1\".to_string(),\n            summary: \"This is a very long summary that should be truncated to fit on screen\"\n                .to_string(),\n            status: \"Open\".to_string(),\n            issue_type: \"Task\".to_string(),\n            assignee: None,\n            description: None,\n            updated: \"U\".to_string(),\n        }];\n        let output = format_search_results(\u0026issues, \"q\");\n        assert!(output.contains(\"...\"));\n    }\n\n    #[test]\n    fn format_search_results_colors_status() {\n        let issues = vec![\n            Issue {\n                key: \"A-1\".to_string(),\n                summary: \"Done\".to_string(),\n                status: \"Done\".to_string(),\n                issue_type: \"T\".to_string(),\n                assignee: None,\n                description: None,\n                updated: \"U\".to_string(),\n            },\n            Issue {\n                key: \"A-2\".to_string(),\n                summary: \"In Progress\".to_string(),\n                status: \"In Progress\".to_string(),\n                issue_type: \"T\".to_string(),\n                assignee: None,\n                description: None,\n                updated: \"U\".to_string(),\n            },\n            Issue {\n                key: \"A-3\".to_string(),\n                summary: \"Other\".to_string(),\n                status: \"Other\".to_string(),\n                issue_type: \"T\".to_string(),\n                assignee: None,\n                description: None,\n                updated: \"U\".to_string(),\n            },\n        ];\n        let output = format_search_results(\u0026issues, \"q\");\n        assert!(output.contains(\"\\x1b[32m\")); // green for Done\n        assert!(output.contains(\"\\x1b[33m\")); // yellow for In Progress\n        assert!(output.contains(\"\\x1b[34m\")); // blue for other\n    }\n\n    // Mock client for testing process_search\n    struct MockJiraClient {\n        issues: Vec\u003cIssue\u003e,\n    }\n\n    impl JiraApi for MockJiraClient {\n        async fn get_current_user(\u0026self) -\u003e Result\u003cUser\u003e {\n            unimplemented!()\n        }\n\n        async fn get_issue(\u0026self, _key: \u0026str) -\u003e Result\u003cIssue\u003e {\n            unimplemented!()\n        }\n\n        async fn search_issues(\u0026self, _jql: \u0026str) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n            Ok(self.issues.clone())\n        }\n\n        async fn update_issue(\u0026self, _key: \u0026str, _update: \u0026IssueUpdate) -\u003e Result\u003c()\u003e {\n            unimplemented!()\n        }\n\n        async fn get_transitions(\u0026self, _key: \u0026str) -\u003e Result\u003cVec\u003cTransition\u003e\u003e {\n            unimplemented!()\n        }\n\n        async fn transition_issue(\u0026self, _key: \u0026str, _transition_id: \u0026str) -\u003e Result\u003c()\u003e {\n            unimplemented!()\n        }\n    }\n\n    #[tokio::test]\n    async fn process_search_returns_formatted_results() {\n        let client = MockJiraClient {\n            issues: vec![Issue {\n                key: \"TEST-123\".to_string(),\n                summary: \"Test issue\".to_string(),\n                status: \"Open\".to_string(),\n                issue_type: \"Bug\".to_string(),\n                assignee: Some(\"Tester\".to_string()),\n                description: None,\n                updated: \"2024-01-01T00:00:00Z\".to_string(),\n            }],\n        };\n\n        let output = process_search(\u0026client, \"project = TEST\").await.unwrap();\n        assert!(output.contains(\"TEST-123\"));\n        assert!(output.contains(\"Test issue\"));\n    }\n\n    #[tokio::test]\n    async fn process_search_empty_results() {\n        let client = MockJiraClient { issues: vec![] };\n\n        let output = process_search(\u0026client, \"nonexistent\").await.unwrap();\n        assert!(output.contains(\"No issues found\"));\n    }\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":4}},{"line":16,"address":[],"length":0,"stats":{"Line":8}},{"line":17,"address":[],"length":0,"stats":{"Line":4}},{"line":21,"address":[],"length":0,"stats":{"Line":7}},{"line":22,"address":[],"length":0,"stats":{"Line":14}},{"line":24,"address":[],"length":0,"stats":{"Line":14}},{"line":25,"address":[],"length":0,"stats":{"Line":6}},{"line":26,"address":[],"length":0,"stats":{"Line":2}},{"line":29,"address":[],"length":0,"stats":{"Line":15}},{"line":30,"address":[],"length":0,"stats":{"Line":5}},{"line":31,"address":[],"length":0,"stats":{"Line":10}},{"line":32,"address":[],"length":0,"stats":{"Line":10}},{"line":37,"address":[],"length":0,"stats":{"Line":51}},{"line":38,"address":[],"length":0,"stats":{"Line":10}},{"line":40,"address":[],"length":0,"stats":{"Line":21}},{"line":45,"address":[],"length":0,"stats":{"Line":21}},{"line":46,"address":[],"length":0,"stats":{"Line":40}},{"line":47,"address":[],"length":0,"stats":{"Line":16}},{"line":48,"address":[],"length":0,"stats":{"Line":10}},{"line":49,"address":[],"length":0,"stats":{"Line":8}},{"line":50,"address":[],"length":0,"stats":{"Line":4}},{"line":53,"address":[],"length":0,"stats":{"Line":32}},{"line":54,"address":[],"length":0,"stats":{"Line":16}},{"line":55,"address":[],"length":0,"stats":{"Line":8}},{"line":56,"address":[],"length":0,"stats":{"Line":8}},{"line":57,"address":[],"length":0,"stats":{"Line":8}},{"line":58,"address":[],"length":0,"stats":{"Line":8}},{"line":59,"address":[],"length":0,"stats":{"Line":8}},{"line":60,"address":[],"length":0,"stats":{"Line":8}},{"line":62,"address":[],"length":0,"stats":{"Line":24}},{"line":63,"address":[],"length":0,"stats":{"Line":8}},{"line":64,"address":[],"length":0,"stats":{"Line":8}},{"line":65,"address":[],"length":0,"stats":{"Line":8}},{"line":66,"address":[],"length":0,"stats":{"Line":8}},{"line":67,"address":[],"length":0,"stats":{"Line":8}},{"line":71,"address":[],"length":0,"stats":{"Line":5}},{"line":75,"address":[],"length":0,"stats":{"Line":13}},{"line":76,"address":[],"length":0,"stats":{"Line":26}},{"line":77,"address":[],"length":0,"stats":{"Line":18}},{"line":79,"address":[],"length":0,"stats":{"Line":16}}],"covered":40,"coverable":45},{"path":["/","Users","chi","Projects","hu","src","jira","show.rs"],"content":"use anyhow::Result;\n\nuse super::client::{JiraApi, JiraClient};\nuse super::types::Issue;\n\n/// Run the jira show command\npub async fn run(key: \u0026str) -\u003e Result\u003c()\u003e {\n    let client = JiraClient::new().await?;\n    let output = process_show(\u0026client, key).await?;\n    print!(\"{}\", output);\n    Ok(())\n}\n\n/// Process show command (business logic, testable)\npub async fn process_show(client: \u0026impl JiraApi, key: \u0026str) -\u003e Result\u003cString\u003e {\n    let issue = client.get_issue(key).await?;\n    Ok(format_issue(\u0026issue))\n}\n\n/// Format issue for display\nfn format_issue(issue: \u0026Issue) -\u003e String {\n    let mut output = String::new();\n\n    // Header\n    output.push_str(\u0026format!(\"\\x1b[1m{}\\x1b[0m {}\\n\", issue.key, issue.summary));\n    output.push('\\n');\n\n    // Metadata\n    output.push_str(\u0026format!(\"Type:     {}\\n\", issue.issue_type));\n    output.push_str(\u0026format!(\"Status:   {}\\n\", format_status(\u0026issue.status)));\n    output.push_str(\u0026format!(\n        \"Assignee: {}\\n\",\n        issue.assignee.as_deref().unwrap_or(\"Unassigned\")\n    ));\n    output.push_str(\u0026format!(\"Updated:  {}\\n\", format_date(\u0026issue.updated)));\n\n    // Description\n    if let Some(desc) = \u0026issue.description {\n        output.push('\\n');\n        output.push_str(\"Description:\\n\");\n        output.push_str(\u0026format_description(desc));\n    }\n\n    output\n}\n\n/// Format status with color\nfn format_status(status: \u0026str) -\u003e String {\n    let color = match status {\n        \"Done\" =\u003e \"\\x1b[32m\",        // green\n        \"In Progress\" =\u003e \"\\x1b[33m\", // yellow\n        \"To Do\" =\u003e \"\\x1b[34m\",       // blue\n        \"In Review\" =\u003e \"\\x1b[35m\",   // magenta\n        _ =\u003e \"\\x1b[36m\",             // cyan\n    };\n    format!(\"{}{}\\x1b[0m\", color, status)\n}\n\n/// Format date for display\nfn format_date(date: \u0026str) -\u003e String {\n    // Parse ISO date and format nicely\n    // Input: \"2024-01-15T10:30:00.000+0000\"\n    if let Some((date_part, time_part)) = date.split_once('T') {\n        if let Some((time, _)) = time_part.split_once('.') {\n            return format!(\"{} {}\", date_part, time);\n        }\n        return format!(\n            \"{} {}\",\n            date_part,\n            time_part.split('+').next().unwrap_or(time_part)\n        );\n    }\n    date.to_string()\n}\n\n/// Format description with indentation\nfn format_description(desc: \u0026str) -\u003e String {\n    desc.lines().map(|line| format!(\"  {}\\n\", line)).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn format_issue_shows_key_and_summary() {\n        let issue = Issue {\n            key: \"PROJ-123\".to_string(),\n            summary: \"Fix the bug\".to_string(),\n            status: \"In Progress\".to_string(),\n            issue_type: \"Bug\".to_string(),\n            assignee: Some(\"John\".to_string()),\n            description: None,\n            updated: \"2024-01-15T10:30:00.000+0000\".to_string(),\n        };\n        let output = format_issue(\u0026issue);\n        assert!(output.contains(\"PROJ-123\"));\n        assert!(output.contains(\"Fix the bug\"));\n        assert!(output.contains(\"Bug\"));\n        assert!(output.contains(\"In Progress\"));\n        assert!(output.contains(\"John\"));\n    }\n\n    #[test]\n    fn format_issue_shows_unassigned() {\n        let issue = Issue {\n            key: \"X-1\".to_string(),\n            summary: \"S\".to_string(),\n            status: \"Open\".to_string(),\n            issue_type: \"Task\".to_string(),\n            assignee: None,\n            description: None,\n            updated: \"2024-01-01T00:00:00Z\".to_string(),\n        };\n        let output = format_issue(\u0026issue);\n        assert!(output.contains(\"Unassigned\"));\n    }\n\n    #[test]\n    fn format_issue_shows_description() {\n        let issue = Issue {\n            key: \"X-1\".to_string(),\n            summary: \"S\".to_string(),\n            status: \"Open\".to_string(),\n            issue_type: \"Task\".to_string(),\n            assignee: None,\n            description: Some(\"This is the description.\\nWith multiple lines.\".to_string()),\n            updated: \"2024-01-01T00:00:00Z\".to_string(),\n        };\n        let output = format_issue(\u0026issue);\n        assert!(output.contains(\"Description:\"));\n        assert!(output.contains(\"This is the description.\"));\n        assert!(output.contains(\"With multiple lines.\"));\n    }\n\n    #[test]\n    fn format_status_colors_done() {\n        let output = format_status(\"Done\");\n        assert!(output.contains(\"\\x1b[32m\")); // green\n        assert!(output.contains(\"Done\"));\n    }\n\n    #[test]\n    fn format_status_colors_in_progress() {\n        let output = format_status(\"In Progress\");\n        assert!(output.contains(\"\\x1b[33m\")); // yellow\n    }\n\n    #[test]\n    fn format_status_colors_to_do() {\n        let output = format_status(\"To Do\");\n        assert!(output.contains(\"\\x1b[34m\")); // blue\n    }\n\n    #[test]\n    fn format_status_colors_in_review() {\n        let output = format_status(\"In Review\");\n        assert!(output.contains(\"\\x1b[35m\")); // magenta\n    }\n\n    #[test]\n    fn format_status_colors_other() {\n        let output = format_status(\"Unknown Status\");\n        assert!(output.contains(\"\\x1b[36m\")); // cyan\n    }\n\n    #[test]\n    fn format_date_parses_full_iso() {\n        let date = \"2024-01-15T10:30:00.000+0000\";\n        let output = format_date(date);\n        assert_eq!(output, \"2024-01-15 10:30:00\");\n    }\n\n    #[test]\n    fn format_date_parses_iso_with_z() {\n        let date = \"2024-01-15T10:30:00Z\";\n        let output = format_date(date);\n        assert_eq!(output, \"2024-01-15 10:30:00Z\");\n    }\n\n    #[test]\n    fn format_date_handles_simple() {\n        let date = \"2024-01-15\";\n        let output = format_date(date);\n        assert_eq!(output, \"2024-01-15\");\n    }\n\n    #[test]\n    fn format_description_indents_lines() {\n        let desc = \"Line 1\\nLine 2\\nLine 3\";\n        let output = format_description(desc);\n        assert!(output.contains(\"  Line 1\\n\"));\n        assert!(output.contains(\"  Line 2\\n\"));\n        assert!(output.contains(\"  Line 3\\n\"));\n    }\n\n    #[test]\n    fn format_description_handles_empty() {\n        let output = format_description(\"\");\n        // Empty string produces empty output (no lines to format)\n        assert_eq!(output, \"\");\n    }\n\n    #[test]\n    fn format_description_handles_single_line() {\n        let output = format_description(\"Only one line\");\n        assert_eq!(output, \"  Only one line\\n\");\n    }\n\n    use super::super::types::{IssueUpdate, Transition, User};\n\n    // Mock client for testing process_show\n    struct MockJiraClient {\n        issue: Issue,\n    }\n\n    impl JiraApi for MockJiraClient {\n        async fn get_current_user(\u0026self) -\u003e Result\u003cUser\u003e {\n            unimplemented!()\n        }\n\n        async fn get_issue(\u0026self, _key: \u0026str) -\u003e Result\u003cIssue\u003e {\n            Ok(self.issue.clone())\n        }\n\n        async fn search_issues(\u0026self, _jql: \u0026str) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n            unimplemented!()\n        }\n\n        async fn update_issue(\u0026self, _key: \u0026str, _update: \u0026IssueUpdate) -\u003e Result\u003c()\u003e {\n            unimplemented!()\n        }\n\n        async fn get_transitions(\u0026self, _key: \u0026str) -\u003e Result\u003cVec\u003cTransition\u003e\u003e {\n            unimplemented!()\n        }\n\n        async fn transition_issue(\u0026self, _key: \u0026str, _transition_id: \u0026str) -\u003e Result\u003c()\u003e {\n            unimplemented!()\n        }\n    }\n\n    #[tokio::test]\n    async fn process_show_returns_formatted_issue() {\n        let client = MockJiraClient {\n            issue: Issue {\n                key: \"TEST-999\".to_string(),\n                summary: \"Test issue\".to_string(),\n                status: \"Done\".to_string(),\n                issue_type: \"Story\".to_string(),\n                assignee: Some(\"Tester\".to_string()),\n                description: Some(\"Test description\".to_string()),\n                updated: \"2024-01-01T00:00:00Z\".to_string(),\n            },\n        };\n\n        let output = process_show(\u0026client, \"TEST-999\").await.unwrap();\n        assert!(output.contains(\"TEST-999\"));\n        assert!(output.contains(\"Test issue\"));\n        assert!(output.contains(\"Done\"));\n        assert!(output.contains(\"Story\"));\n        assert!(output.contains(\"Tester\"));\n        assert!(output.contains(\"Test description\"));\n    }\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":2}},{"line":16,"address":[],"length":0,"stats":{"Line":4}},{"line":17,"address":[],"length":0,"stats":{"Line":1}},{"line":21,"address":[],"length":0,"stats":{"Line":4}},{"line":22,"address":[],"length":0,"stats":{"Line":8}},{"line":25,"address":[],"length":0,"stats":{"Line":12}},{"line":26,"address":[],"length":0,"stats":{"Line":8}},{"line":29,"address":[],"length":0,"stats":{"Line":12}},{"line":30,"address":[],"length":0,"stats":{"Line":20}},{"line":31,"address":[],"length":0,"stats":{"Line":16}},{"line":32,"address":[],"length":0,"stats":{"Line":8}},{"line":33,"address":[],"length":0,"stats":{"Line":12}},{"line":35,"address":[],"length":0,"stats":{"Line":20}},{"line":38,"address":[],"length":0,"stats":{"Line":8}},{"line":39,"address":[],"length":0,"stats":{"Line":6}},{"line":40,"address":[],"length":0,"stats":{"Line":8}},{"line":41,"address":[],"length":0,"stats":{"Line":6}},{"line":44,"address":[],"length":0,"stats":{"Line":4}},{"line":48,"address":[],"length":0,"stats":{"Line":9}},{"line":49,"address":[],"length":0,"stats":{"Line":18}},{"line":50,"address":[],"length":0,"stats":{"Line":11}},{"line":51,"address":[],"length":0,"stats":{"Line":9}},{"line":52,"address":[],"length":0,"stats":{"Line":6}},{"line":53,"address":[],"length":0,"stats":{"Line":5}},{"line":54,"address":[],"length":0,"stats":{"Line":3}},{"line":56,"address":[],"length":0,"stats":{"Line":18}},{"line":60,"address":[],"length":0,"stats":{"Line":7}},{"line":63,"address":[],"length":0,"stats":{"Line":19}},{"line":64,"address":[],"length":0,"stats":{"Line":8}},{"line":65,"address":[],"length":0,"stats":{"Line":4}},{"line":67,"address":[],"length":0,"stats":{"Line":4}},{"line":68,"address":[],"length":0,"stats":{"Line":4}},{"line":70,"address":[],"length":0,"stats":{"Line":16}},{"line":73,"address":[],"length":0,"stats":{"Line":2}},{"line":77,"address":[],"length":0,"stats":{"Line":5}},{"line":78,"address":[],"length":0,"stats":{"Line":34}}],"covered":36,"coverable":41},{"path":["/","Users","chi","Projects","hu","src","jira","sprint.rs"],"content":"use anyhow::Result;\n\nuse super::client::{JiraApi, JiraClient};\nuse super::types::Issue;\n\n/// Arguments for sprint command\n#[derive(Debug, Clone, Default)]\npub struct SprintArgs {\n    // Reserved for future options (e.g., filter by project)\n    pub _placeholder: Option\u003c()\u003e,\n}\n\n/// Run the jira sprint command\npub async fn run(_args: SprintArgs) -\u003e Result\u003c()\u003e {\n    let client = JiraClient::new().await?;\n    let output = process_sprint(\u0026client).await?;\n    print!(\"{}\", output);\n    Ok(())\n}\n\n/// Process sprint command (business logic, testable)\npub async fn process_sprint(client: \u0026impl JiraApi) -\u003e Result\u003cString\u003e {\n    // Use JQL to find all issues in active sprints\n    let jql = \"sprint in openSprints() ORDER BY status ASC, updated DESC\";\n    let issues = client.search_issues(jql).await?;\n\n    Ok(format_sprint_output(\u0026issues))\n}\n\n/// Format sprint output\nfn format_sprint_output(issues: \u0026[Issue]) -\u003e String {\n    let mut output = String::new();\n\n    // Header\n    output.push_str(\u0026format!(\n        \"\\x1b[1mActive Sprint Issues\\x1b[0m ({} total)\\n\\n\",\n        issues.len()\n    ));\n\n    if issues.is_empty() {\n        output.push_str(\"No issues in active sprints\\n\");\n        return output;\n    }\n\n    // Group by status\n    let mut by_status: std::collections::HashMap\u003c\u0026str, Vec\u003c\u0026Issue\u003e\u003e =\n        std::collections::HashMap::new();\n    for issue in issues {\n        by_status.entry(\u0026issue.status).or_default().push(issue);\n    }\n\n    // Status order preference\n    let status_order = [\"To Do\", \"In Progress\", \"In Review\", \"CODE REVIEW\", \"Done\"];\n\n    // Output in order, then any remaining\n    for status in \u0026status_order {\n        if let Some(issues) = by_status.remove(*status) {\n            output.push_str(\u0026format_status_section(status, \u0026issues));\n        }\n    }\n\n    // Remaining statuses\n    let mut remaining: Vec\u003c_\u003e = by_status.into_iter().collect();\n    remaining.sort_by_key(|(status, _)| *status);\n    for (status, issues) in remaining {\n        output.push_str(\u0026format_status_section(status, \u0026issues));\n    }\n\n    output\n}\n\n/// Format a status section\nfn format_status_section(status: \u0026str, issues: \u0026[\u0026Issue]) -\u003e String {\n    let mut output = String::new();\n    let status_color = match status {\n        \"Done\" =\u003e \"\\x1b[32m\",                                      // green\n        \"In Progress\" | \"In Review\" | \"CODE REVIEW\" =\u003e \"\\x1b[33m\", // yellow\n        _ =\u003e \"\\x1b[34m\",                                           // blue\n    };\n    output.push_str(\u0026format!(\n        \"{}{}\\x1b[0m ({})\\n\",\n        status_color,\n        status,\n        issues.len()\n    ));\n\n    for issue in issues {\n        let assignee = issue.assignee.as_deref().unwrap_or(\"Unassigned\");\n        output.push_str(\u0026format!(\n            \"  {} {} \\x1b[90m({})\\x1b[0m\\n\",\n            issue.key, issue.summary, assignee\n        ));\n    }\n    output.push('\\n');\n    output\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn sprint_args_debug() {\n        let args = SprintArgs::default();\n        let debug_str = format!(\"{:?}\", args);\n        assert!(debug_str.contains(\"SprintArgs\"));\n    }\n\n    #[test]\n    fn sprint_args_clone() {\n        let args = SprintArgs::default();\n        let cloned = args.clone();\n        assert_eq!(cloned._placeholder, args._placeholder);\n    }\n\n    #[test]\n    fn format_sprint_output_shows_header() {\n        let issues = vec![];\n        let output = format_sprint_output(\u0026issues);\n        assert!(output.contains(\"Active Sprint Issues\"));\n        assert!(output.contains(\"0 total\"));\n        assert!(output.contains(\"No issues in active sprints\"));\n    }\n\n    #[test]\n    fn format_sprint_output_groups_by_status() {\n        let issues = vec![\n            Issue {\n                key: \"A-1\".to_string(),\n                summary: \"Task 1\".to_string(),\n                status: \"To Do\".to_string(),\n                issue_type: \"Task\".to_string(),\n                assignee: Some(\"Alice\".to_string()),\n                description: None,\n                updated: \"2024-01-01T00:00:00Z\".to_string(),\n            },\n            Issue {\n                key: \"A-2\".to_string(),\n                summary: \"Task 2\".to_string(),\n                status: \"In Progress\".to_string(),\n                issue_type: \"Task\".to_string(),\n                assignee: Some(\"Bob\".to_string()),\n                description: None,\n                updated: \"2024-01-01T00:00:00Z\".to_string(),\n            },\n            Issue {\n                key: \"A-3\".to_string(),\n                summary: \"Task 3\".to_string(),\n                status: \"Done\".to_string(),\n                issue_type: \"Task\".to_string(),\n                assignee: None,\n                description: None,\n                updated: \"2024-01-01T00:00:00Z\".to_string(),\n            },\n        ];\n        let output = format_sprint_output(\u0026issues);\n        assert!(output.contains(\"A-1\"));\n        assert!(output.contains(\"Task 1\"));\n        assert!(output.contains(\"Alice\"));\n        assert!(output.contains(\"A-2\"));\n        assert!(output.contains(\"Bob\"));\n        assert!(output.contains(\"A-3\"));\n        assert!(output.contains(\"Unassigned\"));\n    }\n\n    #[test]\n    fn format_status_section_shows_count() {\n        let issue1 = Issue {\n            key: \"X-1\".to_string(),\n            summary: \"S1\".to_string(),\n            status: \"Open\".to_string(),\n            issue_type: \"T\".to_string(),\n            assignee: None,\n            description: None,\n            updated: \"U\".to_string(),\n        };\n        let issue2 = Issue {\n            key: \"X-2\".to_string(),\n            summary: \"S2\".to_string(),\n            status: \"Open\".to_string(),\n            issue_type: \"T\".to_string(),\n            assignee: Some(\"User\".to_string()),\n            description: None,\n            updated: \"U\".to_string(),\n        };\n        let issues = vec![\u0026issue1, \u0026issue2];\n        let output = format_status_section(\"Open\", \u0026issues);\n        assert!(output.contains(\"Open\"));\n        assert!(output.contains(\"(2)\"));\n        assert!(output.contains(\"X-1\"));\n        assert!(output.contains(\"X-2\"));\n    }\n\n    #[test]\n    fn format_status_section_color_codes() {\n        let empty: Vec\u003c\u0026Issue\u003e = vec![];\n        let done_output = format_status_section(\"Done\", \u0026empty);\n        assert!(done_output.contains(\"\\x1b[32m\")); // green\n\n        let progress_output = format_status_section(\"In Progress\", \u0026empty);\n        assert!(progress_output.contains(\"\\x1b[33m\")); // yellow\n\n        let other_output = format_status_section(\"Other\", \u0026empty);\n        assert!(other_output.contains(\"\\x1b[34m\")); // blue\n    }\n\n    use super::super::types::{IssueUpdate, Transition, User};\n\n    // Mock client for testing process_sprint\n    struct MockJiraClient {\n        issues: Vec\u003cIssue\u003e,\n    }\n\n    impl JiraApi for MockJiraClient {\n        async fn get_current_user(\u0026self) -\u003e Result\u003cUser\u003e {\n            unimplemented!()\n        }\n\n        async fn get_issue(\u0026self, _key: \u0026str) -\u003e Result\u003cIssue\u003e {\n            unimplemented!()\n        }\n\n        async fn search_issues(\u0026self, _jql: \u0026str) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n            Ok(self.issues.clone())\n        }\n\n        async fn update_issue(\u0026self, _key: \u0026str, _update: \u0026IssueUpdate) -\u003e Result\u003c()\u003e {\n            unimplemented!()\n        }\n\n        async fn get_transitions(\u0026self, _key: \u0026str) -\u003e Result\u003cVec\u003cTransition\u003e\u003e {\n            unimplemented!()\n        }\n\n        async fn transition_issue(\u0026self, _key: \u0026str, _transition_id: \u0026str) -\u003e Result\u003c()\u003e {\n            unimplemented!()\n        }\n    }\n\n    #[tokio::test]\n    async fn process_sprint_returns_issues() {\n        let client = MockJiraClient {\n            issues: vec![Issue {\n                key: \"TEST-1\".to_string(),\n                summary: \"Test issue\".to_string(),\n                status: \"In Progress\".to_string(),\n                issue_type: \"Task\".to_string(),\n                assignee: Some(\"Dev\".to_string()),\n                description: None,\n                updated: \"2024-01-01\".to_string(),\n            }],\n        };\n\n        let output = process_sprint(\u0026client).await.unwrap();\n        assert!(output.contains(\"TEST-1\"));\n        assert!(output.contains(\"Test issue\"));\n        assert!(output.contains(\"In Progress\"));\n    }\n\n    #[tokio::test]\n    async fn process_sprint_handles_empty() {\n        let client = MockJiraClient { issues: vec![] };\n\n        let output = process_sprint(\u0026client).await.unwrap();\n        assert!(output.contains(\"No issues in active sprints\"));\n    }\n\n    #[test]\n    fn format_sprint_output_handles_unknown_status() {\n        // Test that unknown statuses (not in status_order) are still displayed\n        let issues = vec![\n            Issue {\n                key: \"A-1\".to_string(),\n                summary: \"Task with custom status\".to_string(),\n                status: \"Custom Status\".to_string(),\n                issue_type: \"Task\".to_string(),\n                assignee: Some(\"Alice\".to_string()),\n                description: None,\n                updated: \"2024-01-01T00:00:00Z\".to_string(),\n            },\n            Issue {\n                key: \"A-2\".to_string(),\n                summary: \"Task with another status\".to_string(),\n                status: \"Another Custom\".to_string(),\n                issue_type: \"Task\".to_string(),\n                assignee: None,\n                description: None,\n                updated: \"2024-01-01T00:00:00Z\".to_string(),\n            },\n        ];\n        let output = format_sprint_output(\u0026issues);\n        assert!(output.contains(\"Custom Status\"));\n        assert!(output.contains(\"A-1\"));\n        assert!(output.contains(\"Another Custom\"));\n        assert!(output.contains(\"A-2\"));\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":4}},{"line":24,"address":[],"length":0,"stats":{"Line":4}},{"line":25,"address":[],"length":0,"stats":{"Line":8}},{"line":27,"address":[],"length":0,"stats":{"Line":2}},{"line":31,"address":[],"length":0,"stats":{"Line":5}},{"line":32,"address":[],"length":0,"stats":{"Line":10}},{"line":35,"address":[],"length":0,"stats":{"Line":20}},{"line":36,"address":[],"length":0,"stats":{"Line":10}},{"line":37,"address":[],"length":0,"stats":{"Line":5}},{"line":40,"address":[],"length":0,"stats":{"Line":10}},{"line":41,"address":[],"length":0,"stats":{"Line":6}},{"line":42,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":6}},{"line":47,"address":[],"length":0,"stats":{"Line":3}},{"line":48,"address":[],"length":0,"stats":{"Line":21}},{"line":49,"address":[],"length":0,"stats":{"Line":24}},{"line":53,"address":[],"length":0,"stats":{"Line":12}},{"line":56,"address":[],"length":0,"stats":{"Line":33}},{"line":57,"address":[],"length":0,"stats":{"Line":38}},{"line":58,"address":[],"length":0,"stats":{"Line":16}},{"line":63,"address":[],"length":0,"stats":{"Line":15}},{"line":64,"address":[],"length":0,"stats":{"Line":6}},{"line":65,"address":[],"length":0,"stats":{"Line":11}},{"line":66,"address":[],"length":0,"stats":{"Line":8}},{"line":69,"address":[],"length":0,"stats":{"Line":3}},{"line":73,"address":[],"length":0,"stats":{"Line":10}},{"line":74,"address":[],"length":0,"stats":{"Line":20}},{"line":75,"address":[],"length":0,"stats":{"Line":20}},{"line":76,"address":[],"length":0,"stats":{"Line":12}},{"line":77,"address":[],"length":0,"stats":{"Line":21}},{"line":78,"address":[],"length":0,"stats":{"Line":5}},{"line":80,"address":[],"length":0,"stats":{"Line":40}},{"line":81,"address":[],"length":0,"stats":{"Line":20}},{"line":82,"address":[],"length":0,"stats":{"Line":10}},{"line":83,"address":[],"length":0,"stats":{"Line":10}},{"line":84,"address":[],"length":0,"stats":{"Line":10}},{"line":87,"address":[],"length":0,"stats":{"Line":34}},{"line":88,"address":[],"length":0,"stats":{"Line":48}},{"line":89,"address":[],"length":0,"stats":{"Line":24}},{"line":90,"address":[],"length":0,"stats":{"Line":8}},{"line":91,"address":[],"length":0,"stats":{"Line":8}},{"line":94,"address":[],"length":0,"stats":{"Line":20}},{"line":95,"address":[],"length":0,"stats":{"Line":10}}],"covered":43,"coverable":48},{"path":["/","Users","chi","Projects","hu","src","jira","tickets.rs"],"content":"use anyhow::Result;\n\nuse super::client::{JiraApi, JiraClient};\nuse super::types::Issue;\n\n// ANSI color codes\nconst GREEN: \u0026str = \"\\x1b[32m\";\nconst YELLOW: \u0026str = \"\\x1b[33m\";\nconst BLUE: \u0026str = \"\\x1b[34m\";\nconst GRAY: \u0026str = \"\\x1b[90m\";\nconst BOLD: \u0026str = \"\\x1b[1m\";\nconst RESET: \u0026str = \"\\x1b[0m\";\n\n/// Run the jira tickets command (list current sprint tickets assigned to me)\npub async fn run() -\u003e Result\u003c()\u003e {\n    let client = JiraClient::new().await?;\n    let output = process_tickets(\u0026client).await?;\n    print!(\"{}\", output);\n    Ok(())\n}\n\n/// Process tickets command (business logic, testable)\npub async fn process_tickets(client: \u0026impl JiraApi) -\u003e Result\u003cString\u003e {\n    // Use JQL to find issues in active sprints assigned to current user\n    let jql =\n        \"sprint in openSprints() AND assignee = currentUser() ORDER BY status ASC, updated DESC\";\n    let issues = client.search_issues(jql).await?;\n\n    Ok(format_tickets(\u0026issues))\n}\n\nfn get_terminal_width() -\u003e usize {\n    terminal_size::terminal_size()\n        .map(|(w, _)| w.0 as usize)\n        .unwrap_or(120)\n}\n\n/// Format tickets as a table\nfn format_tickets(issues: \u0026[Issue]) -\u003e String {\n    let mut output = String::new();\n    let term_width = get_terminal_width();\n\n    // Header\n    output.push_str(\u0026format!(\n        \"{}My Sprint Tickets{} ({} issues)\\n\\n\",\n        BOLD,\n        RESET,\n        issues.len()\n    ));\n\n    if issues.is_empty() {\n        output.push_str(\"No tickets assigned to you in active sprints\\n\");\n        return output;\n    }\n\n    // Calculate column widths based on content\n    let key_width = issues\n        .iter()\n        .map(|i| i.key.chars().count())\n        .max()\n        .unwrap_or(4)\n        .max(4);\n    let status_width = issues\n        .iter()\n        .map(|i| i.status.chars().count())\n        .max()\n        .unwrap_or(6)\n        .max(6);\n    let type_width = issues\n        .iter()\n        .map(|i| i.issue_type.chars().count())\n        .max()\n        .unwrap_or(4)\n        .max(4);\n\n    // Layout:  Key  Status  Type  Summary \n    // Borders take: 5 separators  3 chars = 15 chars\n    let border_overhead = 15;\n    let fixed_cols = key_width + status_width + type_width;\n    let available_for_summary = term_width\n        .saturating_sub(border_overhead + fixed_cols)\n        .max(20);\n\n    // Top border\n    output.push_str(\u0026format!(\n        \"{}{}{}{}\\n\",\n        \"\".repeat(key_width + 2),\n        \"\".repeat(status_width + 2),\n        \"\".repeat(type_width + 2),\n        \"\".repeat(available_for_summary + 2)\n    ));\n\n    // Header row\n    output.push_str(\u0026format!(\n        \" {}{:\u003ckey_w$}{}  {}{:\u003cstatus_w$}{}  {}{:\u003ctype_w$}{}  {}{:\u003csum_w$}{} \\n\",\n        BOLD,\n        \"Key\",\n        RESET,\n        BOLD,\n        \"Status\",\n        RESET,\n        BOLD,\n        \"Type\",\n        RESET,\n        BOLD,\n        \"Summary\",\n        RESET,\n        key_w = key_width,\n        status_w = status_width,\n        type_w = type_width,\n        sum_w = available_for_summary,\n    ));\n\n    // Header separator\n    output.push_str(\u0026format!(\n        \"{}{}{}{}\\n\",\n        \"\".repeat(key_width + 2),\n        \"\".repeat(status_width + 2),\n        \"\".repeat(type_width + 2),\n        \"\".repeat(available_for_summary + 2)\n    ));\n\n    // Data rows\n    for issue in issues {\n        let status_color = match issue.status.as_str() {\n            \"Done\" =\u003e GREEN,\n            \"In Progress\" | \"In Review\" | \"CODE REVIEW\" =\u003e YELLOW,\n            _ =\u003e BLUE,\n        };\n\n        let summary_display = truncate(\u0026issue.summary, available_for_summary);\n\n        output.push_str(\u0026format!(\n            \" {:\u003ckey_w$}  {}{:\u003cstatus_w$}{}  {}{:\u003ctype_w$}{}  {:\u003csum_w$} \\n\",\n            issue.key,\n            status_color,\n            truncate(\u0026issue.status, status_width),\n            RESET,\n            GRAY,\n            truncate(\u0026issue.issue_type, type_width),\n            RESET,\n            summary_display,\n            key_w = key_width,\n            status_w = status_width,\n            type_w = type_width,\n            sum_w = available_for_summary,\n        ));\n    }\n\n    // Bottom border\n    output.push_str(\u0026format!(\n        \"{}{}{}{}\\n\",\n        \"\".repeat(key_width + 2),\n        \"\".repeat(status_width + 2),\n        \"\".repeat(type_width + 2),\n        \"\".repeat(available_for_summary + 2)\n    ));\n\n    output\n}\n\n/// Truncate string to max length with ellipsis\nfn truncate(s: \u0026str, max_len: usize) -\u003e String {\n    if s.chars().count() \u003c= max_len {\n        s.to_string()\n    } else {\n        let truncated: String = s.chars().take(max_len.saturating_sub(1)).collect();\n        format!(\"{}\", truncated)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::super::types::{IssueUpdate, Transition, User};\n    use super::*;\n\n    #[test]\n    fn truncate_short_unchanged() {\n        assert_eq!(truncate(\"hello\", 10), \"hello\");\n    }\n\n    #[test]\n    fn truncate_long_adds_ellipsis() {\n        assert_eq!(truncate(\"hello world\", 8), \"hello w\");\n    }\n\n    #[test]\n    fn truncate_unicode() {\n        assert_eq!(truncate(\"hllo\", 5), \"hllo\");\n        assert_eq!(truncate(\"hllo world\", 6), \"hllo\");\n    }\n\n    #[test]\n    fn truncate_exact_length() {\n        assert_eq!(truncate(\"hello\", 5), \"hello\");\n    }\n\n    #[test]\n    fn get_terminal_width_returns_reasonable_value() {\n        let width = get_terminal_width();\n        assert!(width \u003e= 20);\n    }\n\n    #[test]\n    fn format_tickets_empty() {\n        let issues: Vec\u003cIssue\u003e = vec![];\n        let output = format_tickets(\u0026issues);\n        assert!(output.contains(\"My Sprint Tickets\"));\n        assert!(output.contains(\"0 issues\"));\n        assert!(output.contains(\"No tickets assigned\"));\n    }\n\n    #[test]\n    fn format_tickets_with_issues() {\n        let issues = vec![\n            Issue {\n                key: \"A-1\".to_string(),\n                summary: \"First task\".to_string(),\n                status: \"Done\".to_string(),\n                issue_type: \"Task\".to_string(),\n                assignee: Some(\"Alice\".to_string()),\n                description: None,\n                updated: \"U\".to_string(),\n            },\n            Issue {\n                key: \"A-2\".to_string(),\n                summary: \"Second task\".to_string(),\n                status: \"In Progress\".to_string(),\n                issue_type: \"Bug\".to_string(),\n                assignee: None,\n                description: None,\n                updated: \"U\".to_string(),\n            },\n        ];\n        let output = format_tickets(\u0026issues);\n        assert!(output.contains(\"My Sprint Tickets\"));\n        assert!(output.contains(\"2 issues\"));\n        assert!(output.contains(\"A-1\"));\n        assert!(output.contains(\"A-2\"));\n        assert!(output.contains(\"First task\"));\n        assert!(output.contains(\"Second task\"));\n        assert!(output.contains(\"Task\"));\n        assert!(output.contains(\"Bug\"));\n        // Box-drawing characters\n        assert!(output.contains(\"\"));\n        assert!(output.contains(\"\"));\n        assert!(output.contains(\"\"));\n        assert!(output.contains(\"\"));\n        assert!(output.contains(\"\"));\n        assert!(output.contains(\"\"));\n    }\n\n    #[test]\n    fn format_tickets_colors_status() {\n        let issues = vec![\n            Issue {\n                key: \"X-1\".to_string(),\n                summary: \"S\".to_string(),\n                status: \"Done\".to_string(),\n                issue_type: \"T\".to_string(),\n                assignee: None,\n                description: None,\n                updated: \"U\".to_string(),\n            },\n            Issue {\n                key: \"X-2\".to_string(),\n                summary: \"S\".to_string(),\n                status: \"In Progress\".to_string(),\n                issue_type: \"T\".to_string(),\n                assignee: None,\n                description: None,\n                updated: \"U\".to_string(),\n            },\n            Issue {\n                key: \"X-3\".to_string(),\n                summary: \"S\".to_string(),\n                status: \"To Do\".to_string(),\n                issue_type: \"T\".to_string(),\n                assignee: None,\n                description: None,\n                updated: \"U\".to_string(),\n            },\n        ];\n        let output = format_tickets(\u0026issues);\n        assert!(output.contains(GREEN)); // Done\n        assert!(output.contains(YELLOW)); // In Progress\n        assert!(output.contains(BLUE)); // To Do\n    }\n\n    #[test]\n    fn format_tickets_handles_long_summary() {\n        // Summary must be \u003e200 chars to ensure truncation even on wide terminals\n        let issues = vec![Issue {\n            key: \"LONG-123\".to_string(),\n            summary: \"A\".repeat(250),\n            status: \"Open\".to_string(),\n            issue_type: \"Story\".to_string(),\n            assignee: Some(\"A Very Long Username\".to_string()),\n            description: None,\n            updated: \"U\".to_string(),\n        }];\n        let output = format_tickets(\u0026issues);\n        // Should contain truncation indicator\n        assert!(output.contains(\"\"));\n    }\n\n    // Mock client for testing\n    struct MockJiraClient {\n        issues: Vec\u003cIssue\u003e,\n    }\n\n    impl JiraApi for MockJiraClient {\n        async fn get_current_user(\u0026self) -\u003e Result\u003cUser\u003e {\n            unimplemented!()\n        }\n\n        async fn get_issue(\u0026self, _key: \u0026str) -\u003e Result\u003cIssue\u003e {\n            unimplemented!()\n        }\n\n        async fn search_issues(\u0026self, _jql: \u0026str) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n            Ok(self.issues.clone())\n        }\n\n        async fn update_issue(\u0026self, _key: \u0026str, _update: \u0026IssueUpdate) -\u003e Result\u003c()\u003e {\n            unimplemented!()\n        }\n\n        async fn get_transitions(\u0026self, _key: \u0026str) -\u003e Result\u003cVec\u003cTransition\u003e\u003e {\n            unimplemented!()\n        }\n\n        async fn transition_issue(\u0026self, _key: \u0026str, _transition_id: \u0026str) -\u003e Result\u003c()\u003e {\n            unimplemented!()\n        }\n    }\n\n    #[tokio::test]\n    async fn process_tickets_returns_issues() {\n        let client = MockJiraClient {\n            issues: vec![Issue {\n                key: \"TEST-1\".to_string(),\n                summary: \"Test issue\".to_string(),\n                status: \"Open\".to_string(),\n                issue_type: \"Task\".to_string(),\n                assignee: Some(\"Me\".to_string()),\n                description: None,\n                updated: \"2024-01-01\".to_string(),\n            }],\n        };\n\n        let output = process_tickets(\u0026client).await.unwrap();\n        assert!(output.contains(\"TEST-1\"));\n        assert!(output.contains(\"Test issue\"));\n    }\n\n    #[tokio::test]\n    async fn process_tickets_handles_empty() {\n        let client = MockJiraClient { issues: vec![] };\n\n        let output = process_tickets(\u0026client).await.unwrap();\n        assert!(output.contains(\"No tickets assigned\"));\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":2}},{"line":16,"address":[],"length":0,"stats":{"Line":2}},{"line":17,"address":[],"length":0,"stats":{"Line":3}},{"line":18,"address":[],"length":0,"stats":{"Line":2}},{"line":19,"address":[],"length":0,"stats":{"Line":1}},{"line":23,"address":[],"length":0,"stats":{"Line":6}},{"line":25,"address":[],"length":0,"stats":{"Line":3}},{"line":26,"address":[],"length":0,"stats":{"Line":3}},{"line":27,"address":[],"length":0,"stats":{"Line":12}},{"line":29,"address":[],"length":0,"stats":{"Line":3}},{"line":32,"address":[],"length":0,"stats":{"Line":8}},{"line":33,"address":[],"length":0,"stats":{"Line":8}},{"line":34,"address":[],"length":0,"stats":{"Line":8}},{"line":39,"address":[],"length":0,"stats":{"Line":7}},{"line":40,"address":[],"length":0,"stats":{"Line":14}},{"line":41,"address":[],"length":0,"stats":{"Line":14}},{"line":44,"address":[],"length":0,"stats":{"Line":28}},{"line":45,"address":[],"length":0,"stats":{"Line":14}},{"line":46,"address":[],"length":0,"stats":{"Line":7}},{"line":47,"address":[],"length":0,"stats":{"Line":7}},{"line":48,"address":[],"length":0,"stats":{"Line":7}},{"line":51,"address":[],"length":0,"stats":{"Line":14}},{"line":52,"address":[],"length":0,"stats":{"Line":6}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":57,"address":[],"length":0,"stats":{"Line":10}},{"line":59,"address":[],"length":0,"stats":{"Line":31}},{"line":63,"address":[],"length":0,"stats":{"Line":10}},{"line":65,"address":[],"length":0,"stats":{"Line":31}},{"line":69,"address":[],"length":0,"stats":{"Line":10}},{"line":71,"address":[],"length":0,"stats":{"Line":31}},{"line":78,"address":[],"length":0,"stats":{"Line":10}},{"line":79,"address":[],"length":0,"stats":{"Line":10}},{"line":80,"address":[],"length":0,"stats":{"Line":10}},{"line":81,"address":[],"length":0,"stats":{"Line":10}},{"line":85,"address":[],"length":0,"stats":{"Line":20}},{"line":86,"address":[],"length":0,"stats":{"Line":10}},{"line":87,"address":[],"length":0,"stats":{"Line":20}},{"line":88,"address":[],"length":0,"stats":{"Line":20}},{"line":89,"address":[],"length":0,"stats":{"Line":20}},{"line":90,"address":[],"length":0,"stats":{"Line":10}},{"line":94,"address":[],"length":0,"stats":{"Line":15}},{"line":95,"address":[],"length":0,"stats":{"Line":5}},{"line":96,"address":[],"length":0,"stats":{"Line":5}},{"line":97,"address":[],"length":0,"stats":{"Line":5}},{"line":98,"address":[],"length":0,"stats":{"Line":5}},{"line":99,"address":[],"length":0,"stats":{"Line":5}},{"line":100,"address":[],"length":0,"stats":{"Line":5}},{"line":101,"address":[],"length":0,"stats":{"Line":5}},{"line":102,"address":[],"length":0,"stats":{"Line":5}},{"line":103,"address":[],"length":0,"stats":{"Line":5}},{"line":104,"address":[],"length":0,"stats":{"Line":5}},{"line":105,"address":[],"length":0,"stats":{"Line":5}},{"line":106,"address":[],"length":0,"stats":{"Line":5}},{"line":107,"address":[],"length":0,"stats":{"Line":5}},{"line":108,"address":[],"length":0,"stats":{"Line":5}},{"line":109,"address":[],"length":0,"stats":{"Line":5}},{"line":110,"address":[],"length":0,"stats":{"Line":5}},{"line":111,"address":[],"length":0,"stats":{"Line":5}},{"line":115,"address":[],"length":0,"stats":{"Line":20}},{"line":116,"address":[],"length":0,"stats":{"Line":10}},{"line":117,"address":[],"length":0,"stats":{"Line":20}},{"line":118,"address":[],"length":0,"stats":{"Line":20}},{"line":119,"address":[],"length":0,"stats":{"Line":20}},{"line":120,"address":[],"length":0,"stats":{"Line":10}},{"line":124,"address":[],"length":0,"stats":{"Line":31}},{"line":125,"address":[],"length":0,"stats":{"Line":26}},{"line":126,"address":[],"length":0,"stats":{"Line":20}},{"line":127,"address":[],"length":0,"stats":{"Line":16}},{"line":128,"address":[],"length":0,"stats":{"Line":4}},{"line":131,"address":[],"length":0,"stats":{"Line":52}},{"line":133,"address":[],"length":0,"stats":{"Line":52}},{"line":134,"address":[],"length":0,"stats":{"Line":26}},{"line":135,"address":[],"length":0,"stats":{"Line":13}},{"line":136,"address":[],"length":0,"stats":{"Line":13}},{"line":137,"address":[],"length":0,"stats":{"Line":52}},{"line":138,"address":[],"length":0,"stats":{"Line":13}},{"line":139,"address":[],"length":0,"stats":{"Line":13}},{"line":140,"address":[],"length":0,"stats":{"Line":26}},{"line":141,"address":[],"length":0,"stats":{"Line":13}},{"line":142,"address":[],"length":0,"stats":{"Line":13}},{"line":143,"address":[],"length":0,"stats":{"Line":13}},{"line":144,"address":[],"length":0,"stats":{"Line":13}},{"line":145,"address":[],"length":0,"stats":{"Line":13}},{"line":146,"address":[],"length":0,"stats":{"Line":13}},{"line":151,"address":[],"length":0,"stats":{"Line":20}},{"line":152,"address":[],"length":0,"stats":{"Line":10}},{"line":153,"address":[],"length":0,"stats":{"Line":20}},{"line":154,"address":[],"length":0,"stats":{"Line":20}},{"line":155,"address":[],"length":0,"stats":{"Line":20}},{"line":156,"address":[],"length":0,"stats":{"Line":10}},{"line":159,"address":[],"length":0,"stats":{"Line":5}},{"line":163,"address":[],"length":0,"stats":{"Line":44}},{"line":164,"address":[],"length":0,"stats":{"Line":132}},{"line":165,"address":[],"length":0,"stats":{"Line":82}},{"line":167,"address":[],"length":0,"stats":{"Line":24}},{"line":168,"address":[],"length":0,"stats":{"Line":6}}],"covered":96,"coverable":96},{"path":["/","Users","chi","Projects","hu","src","jira","types.rs"],"content":"use serde::{Deserialize, Serialize};\n\n/// Jira user\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct User {\n    pub account_id: String,\n    pub display_name: String,\n    pub email_address: Option\u003cString\u003e,\n}\n\n/// Jira issue\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Issue {\n    pub key: String,\n    pub summary: String,\n    pub status: String,\n    pub issue_type: String,\n    pub assignee: Option\u003cString\u003e,\n    pub description: Option\u003cString\u003e,\n    pub updated: String,\n}\n\n/// Fields to update on an issue\n#[derive(Debug, Clone, Default)]\npub struct IssueUpdate {\n    pub summary: Option\u003cString\u003e,\n    pub description: Option\u003cString\u003e,\n    pub assignee: Option\u003cString\u003e,\n}\n\n/// Issue transition (status change)\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Transition {\n    pub id: String,\n    pub name: String,\n}\n\n/// OAuth configuration for Jira\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct OAuthConfig {\n    pub client_id: String,\n    pub client_secret: String,\n}\n\n/// Accessible Jira Cloud resource\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AccessibleResource {\n    pub id: String,\n    pub url: String,\n    pub name: String,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn user_clone() {\n        let user = User {\n            account_id: \"123\".to_string(),\n            display_name: \"John Doe\".to_string(),\n            email_address: Some(\"john@example.com\".to_string()),\n        };\n        let cloned = user.clone();\n        assert_eq!(cloned.account_id, user.account_id);\n        assert_eq!(cloned.display_name, user.display_name);\n        assert_eq!(cloned.email_address, user.email_address);\n    }\n\n    #[test]\n    fn user_without_email() {\n        let user = User {\n            account_id: \"456\".to_string(),\n            display_name: \"Jane\".to_string(),\n            email_address: None,\n        };\n        assert!(user.email_address.is_none());\n    }\n\n    #[test]\n    fn user_debug_format() {\n        let user = User {\n            account_id: \"id\".to_string(),\n            display_name: \"name\".to_string(),\n            email_address: None,\n        };\n        let debug_str = format!(\"{:?}\", user);\n        assert!(debug_str.contains(\"User\"));\n    }\n\n    #[test]\n    fn user_serialize() {\n        let user = User {\n            account_id: \"123\".to_string(),\n            display_name: \"John\".to_string(),\n            email_address: Some(\"john@test.com\".to_string()),\n        };\n        let json = serde_json::to_string(\u0026user).unwrap();\n        assert!(json.contains(\"account_id\"));\n        assert!(json.contains(\"123\"));\n    }\n\n    #[test]\n    fn user_deserialize() {\n        let json = r#\"{\"account_id\":\"abc\",\"display_name\":\"Test\",\"email_address\":null}\"#;\n        let user: User = serde_json::from_str(json).unwrap();\n        assert_eq!(user.account_id, \"abc\");\n        assert_eq!(user.display_name, \"Test\");\n        assert!(user.email_address.is_none());\n    }\n\n    #[test]\n    fn issue_clone() {\n        let issue = Issue {\n            key: \"PROJ-123\".to_string(),\n            summary: \"Fix bug\".to_string(),\n            status: \"In Progress\".to_string(),\n            issue_type: \"Bug\".to_string(),\n            assignee: Some(\"john\".to_string()),\n            description: Some(\"A bug description\".to_string()),\n            updated: \"2024-01-15T10:00:00Z\".to_string(),\n        };\n        let cloned = issue.clone();\n        assert_eq!(cloned.key, issue.key);\n        assert_eq!(cloned.summary, issue.summary);\n        assert_eq!(cloned.status, issue.status);\n    }\n\n    #[test]\n    fn issue_without_optional_fields() {\n        let issue = Issue {\n            key: \"PROJ-456\".to_string(),\n            summary: \"Task\".to_string(),\n            status: \"Open\".to_string(),\n            issue_type: \"Task\".to_string(),\n            assignee: None,\n            description: None,\n            updated: \"2024-01-15T12:00:00Z\".to_string(),\n        };\n        assert!(issue.assignee.is_none());\n        assert!(issue.description.is_none());\n    }\n\n    #[test]\n    fn issue_debug_format() {\n        let issue = Issue {\n            key: \"K\".to_string(),\n            summary: \"S\".to_string(),\n            status: \"St\".to_string(),\n            issue_type: \"T\".to_string(),\n            assignee: None,\n            description: None,\n            updated: \"U\".to_string(),\n        };\n        let debug_str = format!(\"{:?}\", issue);\n        assert!(debug_str.contains(\"Issue\"));\n    }\n\n    #[test]\n    fn issue_serialize() {\n        let issue = Issue {\n            key: \"TEST-1\".to_string(),\n            summary: \"Test issue\".to_string(),\n            status: \"Done\".to_string(),\n            issue_type: \"Story\".to_string(),\n            assignee: Some(\"user\".to_string()),\n            description: Some(\"desc\".to_string()),\n            updated: \"2024-01-01T00:00:00Z\".to_string(),\n        };\n        let json = serde_json::to_string(\u0026issue).unwrap();\n        assert!(json.contains(\"TEST-1\"));\n        assert!(json.contains(\"Test issue\"));\n    }\n\n    #[test]\n    fn issue_deserialize() {\n        let json = r#\"{\n            \"key\": \"X-1\",\n            \"summary\": \"Sum\",\n            \"status\": \"Open\",\n            \"issue_type\": \"Bug\",\n            \"assignee\": null,\n            \"description\": null,\n            \"updated\": \"2024-01-01T00:00:00Z\"\n        }\"#;\n        let issue: Issue = serde_json::from_str(json).unwrap();\n        assert_eq!(issue.key, \"X-1\");\n        assert_eq!(issue.summary, \"Sum\");\n    }\n\n    #[test]\n    fn issue_update_default() {\n        let update = IssueUpdate::default();\n        assert!(update.summary.is_none());\n        assert!(update.description.is_none());\n        assert!(update.assignee.is_none());\n    }\n\n    #[test]\n    fn issue_update_clone() {\n        let update = IssueUpdate {\n            summary: Some(\"New summary\".to_string()),\n            description: Some(\"New desc\".to_string()),\n            assignee: Some(\"user123\".to_string()),\n        };\n        let cloned = update.clone();\n        assert_eq!(cloned.summary, update.summary);\n        assert_eq!(cloned.description, update.description);\n        assert_eq!(cloned.assignee, update.assignee);\n    }\n\n    #[test]\n    fn issue_update_debug_format() {\n        let update = IssueUpdate::default();\n        let debug_str = format!(\"{:?}\", update);\n        assert!(debug_str.contains(\"IssueUpdate\"));\n    }\n\n    #[test]\n    fn issue_update_partial() {\n        let update = IssueUpdate {\n            summary: Some(\"Only summary\".to_string()),\n            description: None,\n            assignee: None,\n        };\n        assert!(update.summary.is_some());\n        assert!(update.description.is_none());\n    }\n\n    #[test]\n    fn transition_clone() {\n        let transition = Transition {\n            id: \"31\".to_string(),\n            name: \"In Progress\".to_string(),\n        };\n        let cloned = transition.clone();\n        assert_eq!(cloned.id, transition.id);\n        assert_eq!(cloned.name, transition.name);\n    }\n\n    #[test]\n    fn transition_debug_format() {\n        let transition = Transition {\n            id: \"1\".to_string(),\n            name: \"T\".to_string(),\n        };\n        let debug_str = format!(\"{:?}\", transition);\n        assert!(debug_str.contains(\"Transition\"));\n    }\n\n    #[test]\n    fn transition_serialize() {\n        let transition = Transition {\n            id: \"21\".to_string(),\n            name: \"Done\".to_string(),\n        };\n        let json = serde_json::to_string(\u0026transition).unwrap();\n        assert!(json.contains(\"21\"));\n        assert!(json.contains(\"Done\"));\n    }\n\n    #[test]\n    fn transition_deserialize() {\n        let json = r#\"{\"id\": \"11\", \"name\": \"To Do\"}\"#;\n        let transition: Transition = serde_json::from_str(json).unwrap();\n        assert_eq!(transition.id, \"11\");\n        assert_eq!(transition.name, \"To Do\");\n    }\n\n    #[test]\n    fn oauth_config_clone() {\n        let config = OAuthConfig {\n            client_id: \"id123\".to_string(),\n            client_secret: \"secret456\".to_string(),\n        };\n        let cloned = config.clone();\n        assert_eq!(cloned.client_id, config.client_id);\n        assert_eq!(cloned.client_secret, config.client_secret);\n    }\n\n    #[test]\n    fn oauth_config_debug_format() {\n        let config = OAuthConfig {\n            client_id: \"id\".to_string(),\n            client_secret: \"secret\".to_string(),\n        };\n        let debug_str = format!(\"{:?}\", config);\n        assert!(debug_str.contains(\"OAuthConfig\"));\n    }\n\n    #[test]\n    fn oauth_config_serialize() {\n        let config = OAuthConfig {\n            client_id: \"test_id\".to_string(),\n            client_secret: \"test_secret\".to_string(),\n        };\n        let json = serde_json::to_string(\u0026config).unwrap();\n        assert!(json.contains(\"test_id\"));\n        assert!(json.contains(\"test_secret\"));\n    }\n\n    #[test]\n    fn oauth_config_deserialize() {\n        let json = r#\"{\"client_id\": \"cid\", \"client_secret\": \"csec\"}\"#;\n        let config: OAuthConfig = serde_json::from_str(json).unwrap();\n        assert_eq!(config.client_id, \"cid\");\n        assert_eq!(config.client_secret, \"csec\");\n    }\n\n    #[test]\n    fn accessible_resource_clone() {\n        let resource = AccessibleResource {\n            id: \"cloud-123\".to_string(),\n            url: \"https://example.atlassian.net\".to_string(),\n            name: \"Example Site\".to_string(),\n        };\n        let cloned = resource.clone();\n        assert_eq!(cloned.id, resource.id);\n        assert_eq!(cloned.url, resource.url);\n        assert_eq!(cloned.name, resource.name);\n    }\n\n    #[test]\n    fn accessible_resource_debug_format() {\n        let resource = AccessibleResource {\n            id: \"id\".to_string(),\n            url: \"url\".to_string(),\n            name: \"name\".to_string(),\n        };\n        let debug_str = format!(\"{:?}\", resource);\n        assert!(debug_str.contains(\"AccessibleResource\"));\n    }\n\n    #[test]\n    fn accessible_resource_serialize() {\n        let resource = AccessibleResource {\n            id: \"res-id\".to_string(),\n            url: \"https://test.atlassian.net\".to_string(),\n            name: \"Test Site\".to_string(),\n        };\n        let json = serde_json::to_string(\u0026resource).unwrap();\n        assert!(json.contains(\"res-id\"));\n        assert!(json.contains(\"https://test.atlassian.net\"));\n    }\n\n    #[test]\n    fn accessible_resource_deserialize() {\n        let json = r#\"{\"id\": \"abc\", \"url\": \"https://x.atlassian.net\", \"name\": \"X\"}\"#;\n        let resource: AccessibleResource = serde_json::from_str(json).unwrap();\n        assert_eq!(resource.id, \"abc\");\n        assert_eq!(resource.url, \"https://x.atlassian.net\");\n        assert_eq!(resource.name, \"X\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","jira","update","mod.rs"],"content":"use anyhow::{bail, Result};\n\nuse super::client::{JiraApi, JiraClient};\nuse super::types::{IssueUpdate, Transition};\n\n#[cfg(test)]\nmod tests;\n\n/// Arguments for update command\n#[derive(Debug, Clone)]\npub struct UpdateArgs {\n    pub key: String,\n    pub summary: Option\u003cString\u003e,\n    pub status: Option\u003cString\u003e,\n    pub assign: Option\u003cString\u003e,\n}\n\n/// Run the jira update command\npub async fn run(args: UpdateArgs) -\u003e Result\u003c()\u003e {\n    let client = JiraClient::new().await?;\n    let output = process_update(\u0026client, \u0026args).await?;\n    print!(\"{}\", output);\n    Ok(())\n}\n\n/// Process update command (business logic, testable)\npub async fn process_update(client: \u0026impl JiraApi, args: \u0026UpdateArgs) -\u003e Result\u003cString\u003e {\n    let mut output = String::new();\n    let mut changes_made = false;\n\n    // Handle field updates\n    let has_field_updates = args.summary.is_some() || args.assign.is_some();\n    if has_field_updates {\n        let assignee = match \u0026args.assign {\n            Some(a) if a == \"me\" =\u003e {\n                let user = client.get_current_user().await?;\n                Some(user.account_id)\n            }\n            Some(a) =\u003e Some(a.clone()),\n            None =\u003e None,\n        };\n\n        let update = IssueUpdate {\n            summary: args.summary.clone(),\n            description: None,\n            assignee,\n        };\n\n        client.update_issue(\u0026args.key, \u0026update).await?;\n        changes_made = true;\n\n        if let Some(summary) = \u0026args.summary {\n            output.push_str(\u0026format!(\n                \"\\x1b[32m\\u{2713}\\x1b[0m Updated summary: \\\"{}\\\"\\n\",\n                summary\n            ));\n        }\n        if args.assign.is_some() {\n            output.push_str(\"\\x1b[32m\\u{2713}\\x1b[0m Updated assignee\\n\");\n        }\n    }\n\n    // Handle status transition\n    if let Some(target_status) = \u0026args.status {\n        let transitions = client.get_transitions(\u0026args.key).await?;\n        let transition = find_transition(\u0026transitions, target_status)?;\n\n        client.transition_issue(\u0026args.key, \u0026transition.id).await?;\n        changes_made = true;\n\n        output.push_str(\u0026format!(\n            \"\\x1b[32m\\u{2713}\\x1b[0m Transitioned to: {}\\n\",\n            transition.name\n        ));\n    }\n\n    if !changes_made {\n        bail!(\"No changes specified. Use --summary, --status, or --assign.\");\n    }\n\n    Ok(output)\n}\n\n/// Find a transition by name (case-insensitive)\nfn find_transition\u003c'a\u003e(transitions: \u0026'a [Transition], target: \u0026str) -\u003e Result\u003c\u0026'a Transition\u003e {\n    let target_lower = target.to_lowercase();\n\n    // Exact match first\n    if let Some(t) = transitions\n        .iter()\n        .find(|t| t.name.to_lowercase() == target_lower)\n    {\n        return Ok(t);\n    }\n\n    // Partial match\n    if let Some(t) = transitions\n        .iter()\n        .find(|t| t.name.to_lowercase().contains(\u0026target_lower))\n    {\n        return Ok(t);\n    }\n\n    // Build error message with available transitions\n    let available: Vec\u003c_\u003e = transitions.iter().map(|t| t.name.as_str()).collect();\n    bail!(\n        \"Status '{}' not found. Available transitions: {}\",\n        target,\n        available.join(\", \")\n    )\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":12}},{"line":28,"address":[],"length":0,"stats":{"Line":12}},{"line":29,"address":[],"length":0,"stats":{"Line":12}},{"line":32,"address":[],"length":0,"stats":{"Line":26}},{"line":33,"address":[],"length":0,"stats":{"Line":6}},{"line":34,"address":[],"length":0,"stats":{"Line":7}},{"line":35,"address":[],"length":0,"stats":{"Line":8}},{"line":36,"address":[],"length":0,"stats":{"Line":6}},{"line":37,"address":[],"length":0,"stats":{"Line":2}},{"line":39,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":1}},{"line":44,"address":[],"length":0,"stats":{"Line":12}},{"line":49,"address":[],"length":0,"stats":{"Line":16}},{"line":50,"address":[],"length":0,"stats":{"Line":4}},{"line":52,"address":[],"length":0,"stats":{"Line":8}},{"line":53,"address":[],"length":0,"stats":{"Line":6}},{"line":54,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":11}},{"line":59,"address":[],"length":0,"stats":{"Line":6}},{"line":64,"address":[],"length":0,"stats":{"Line":8}},{"line":65,"address":[],"length":0,"stats":{"Line":8}},{"line":66,"address":[],"length":0,"stats":{"Line":8}},{"line":68,"address":[],"length":0,"stats":{"Line":8}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":71,"address":[],"length":0,"stats":{"Line":6}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":2}},{"line":77,"address":[],"length":0,"stats":{"Line":6}},{"line":78,"address":[],"length":0,"stats":{"Line":2}},{"line":81,"address":[],"length":0,"stats":{"Line":5}},{"line":85,"address":[],"length":0,"stats":{"Line":8}},{"line":86,"address":[],"length":0,"stats":{"Line":24}},{"line":89,"address":[],"length":0,"stats":{"Line":13}},{"line":91,"address":[],"length":0,"stats":{"Line":34}},{"line":93,"address":[],"length":0,"stats":{"Line":5}},{"line":97,"address":[],"length":0,"stats":{"Line":4}},{"line":99,"address":[],"length":0,"stats":{"Line":12}},{"line":101,"address":[],"length":0,"stats":{"Line":1}},{"line":105,"address":[],"length":0,"stats":{"Line":16}},{"line":106,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":4}}],"covered":42,"coverable":48},{"path":["/","Users","chi","Projects","hu","src","jira","update","tests.rs"],"content":"use super::super::types::User;\nuse super::*;\n\n#[test]\nfn update_args_debug() {\n    let args = UpdateArgs {\n        key: \"X-1\".to_string(),\n        summary: Some(\"New\".to_string()),\n        status: None,\n        assign: None,\n    };\n    let debug_str = format!(\"{:?}\", args);\n    assert!(debug_str.contains(\"UpdateArgs\"));\n}\n\n#[test]\nfn update_args_clone() {\n    let args = UpdateArgs {\n        key: \"X-1\".to_string(),\n        summary: Some(\"S\".to_string()),\n        status: Some(\"Done\".to_string()),\n        assign: Some(\"user\".to_string()),\n    };\n    let cloned = args.clone();\n    assert_eq!(cloned.key, args.key);\n    assert_eq!(cloned.summary, args.summary);\n    assert_eq!(cloned.status, args.status);\n    assert_eq!(cloned.assign, args.assign);\n}\n\n#[test]\nfn find_transition_exact_match() {\n    let transitions = vec![\n        Transition {\n            id: \"11\".to_string(),\n            name: \"To Do\".to_string(),\n        },\n        Transition {\n            id: \"21\".to_string(),\n            name: \"In Progress\".to_string(),\n        },\n        Transition {\n            id: \"31\".to_string(),\n            name: \"Done\".to_string(),\n        },\n    ];\n\n    let t = find_transition(\u0026transitions, \"Done\").unwrap();\n    assert_eq!(t.id, \"31\");\n    assert_eq!(t.name, \"Done\");\n}\n\n#[test]\nfn find_transition_case_insensitive() {\n    let transitions = vec![Transition {\n        id: \"21\".to_string(),\n        name: \"In Progress\".to_string(),\n    }];\n\n    let t = find_transition(\u0026transitions, \"in progress\").unwrap();\n    assert_eq!(t.id, \"21\");\n\n    let t2 = find_transition(\u0026transitions, \"IN PROGRESS\").unwrap();\n    assert_eq!(t2.id, \"21\");\n}\n\n#[test]\nfn find_transition_partial_match() {\n    let transitions = vec![\n        Transition {\n            id: \"11\".to_string(),\n            name: \"Start Progress\".to_string(),\n        },\n        Transition {\n            id: \"21\".to_string(),\n            name: \"In Progress\".to_string(),\n        },\n    ];\n\n    let t = find_transition(\u0026transitions, \"progress\").unwrap();\n    assert!(t.name.contains(\"Progress\"));\n}\n\n#[test]\nfn find_transition_not_found() {\n    let transitions = vec![\n        Transition {\n            id: \"11\".to_string(),\n            name: \"To Do\".to_string(),\n        },\n        Transition {\n            id: \"31\".to_string(),\n            name: \"Done\".to_string(),\n        },\n    ];\n\n    let result = find_transition(\u0026transitions, \"In Progress\");\n    assert!(result.is_err());\n    let err = result.unwrap_err().to_string();\n    assert!(err.contains(\"In Progress\"));\n    assert!(err.contains(\"To Do\"));\n    assert!(err.contains(\"Done\"));\n}\n\n#[test]\nfn find_transition_empty_list() {\n    let transitions: Vec\u003cTransition\u003e = vec![];\n    let result = find_transition(\u0026transitions, \"Done\");\n    assert!(result.is_err());\n}\n\n// Mock client for testing process_update\nstruct MockJiraClient {\n    user: User,\n    transitions: Vec\u003cTransition\u003e,\n    updated_fields: std::sync::Mutex\u003cOption\u003cIssueUpdate\u003e\u003e,\n    transitioned_to: std::sync::Mutex\u003cOption\u003cString\u003e\u003e,\n}\n\nimpl JiraApi for MockJiraClient {\n    async fn get_current_user(\u0026self) -\u003e Result\u003cUser\u003e {\n        Ok(self.user.clone())\n    }\n\n    async fn get_issue(\u0026self, _key: \u0026str) -\u003e Result\u003csuper::super::types::Issue\u003e {\n        unimplemented!()\n    }\n\n    async fn search_issues(\u0026self, _jql: \u0026str) -\u003e Result\u003cVec\u003csuper::super::types::Issue\u003e\u003e {\n        unimplemented!()\n    }\n\n    async fn update_issue(\u0026self, _key: \u0026str, update: \u0026IssueUpdate) -\u003e Result\u003c()\u003e {\n        *self.updated_fields.lock().unwrap() = Some(update.clone());\n        Ok(())\n    }\n\n    async fn get_transitions(\u0026self, _key: \u0026str) -\u003e Result\u003cVec\u003cTransition\u003e\u003e {\n        Ok(self.transitions.clone())\n    }\n\n    async fn transition_issue(\u0026self, _key: \u0026str, transition_id: \u0026str) -\u003e Result\u003c()\u003e {\n        *self.transitioned_to.lock().unwrap() = Some(transition_id.to_string());\n        Ok(())\n    }\n}\n\n#[tokio::test]\nasync fn process_update_changes_summary() {\n    let client = MockJiraClient {\n        user: User {\n            account_id: \"me123\".to_string(),\n            display_name: \"Me\".to_string(),\n            email_address: None,\n        },\n        transitions: vec![],\n        updated_fields: std::sync::Mutex::new(None),\n        transitioned_to: std::sync::Mutex::new(None),\n    };\n\n    let args = UpdateArgs {\n        key: \"X-1\".to_string(),\n        summary: Some(\"New summary\".to_string()),\n        status: None,\n        assign: None,\n    };\n\n    let output = process_update(\u0026client, \u0026args).await.unwrap();\n    assert!(output.contains(\"Updated summary\"));\n    assert!(output.contains(\"New summary\"));\n\n    let updated = client.updated_fields.lock().unwrap();\n    assert!(updated.is_some());\n    assert_eq!(\n        updated.as_ref().unwrap().summary,\n        Some(\"New summary\".to_string())\n    );\n}\n\n#[tokio::test]\nasync fn process_update_assigns_to_me() {\n    let client = MockJiraClient {\n        user: User {\n            account_id: \"my-account-id\".to_string(),\n            display_name: \"Me\".to_string(),\n            email_address: None,\n        },\n        transitions: vec![],\n        updated_fields: std::sync::Mutex::new(None),\n        transitioned_to: std::sync::Mutex::new(None),\n    };\n\n    let args = UpdateArgs {\n        key: \"X-1\".to_string(),\n        summary: None,\n        status: None,\n        assign: Some(\"me\".to_string()),\n    };\n\n    let output = process_update(\u0026client, \u0026args).await.unwrap();\n    assert!(output.contains(\"Updated assignee\"));\n\n    let updated = client.updated_fields.lock().unwrap();\n    assert_eq!(\n        updated.as_ref().unwrap().assignee,\n        Some(\"my-account-id\".to_string())\n    );\n}\n\n#[tokio::test]\nasync fn process_update_assigns_to_user() {\n    let client = MockJiraClient {\n        user: User {\n            account_id: \"me\".to_string(),\n            display_name: \"Me\".to_string(),\n            email_address: None,\n        },\n        transitions: vec![],\n        updated_fields: std::sync::Mutex::new(None),\n        transitioned_to: std::sync::Mutex::new(None),\n    };\n\n    let args = UpdateArgs {\n        key: \"X-1\".to_string(),\n        summary: None,\n        status: None,\n        assign: Some(\"other-user-123\".to_string()),\n    };\n\n    let output = process_update(\u0026client, \u0026args).await.unwrap();\n    assert!(output.contains(\"Updated assignee\"));\n\n    let updated = client.updated_fields.lock().unwrap();\n    assert_eq!(\n        updated.as_ref().unwrap().assignee,\n        Some(\"other-user-123\".to_string())\n    );\n}\n\n#[tokio::test]\nasync fn process_update_transitions_status() {\n    let client = MockJiraClient {\n        user: User {\n            account_id: \"me\".to_string(),\n            display_name: \"Me\".to_string(),\n            email_address: None,\n        },\n        transitions: vec![\n            Transition {\n                id: \"11\".to_string(),\n                name: \"To Do\".to_string(),\n            },\n            Transition {\n                id: \"21\".to_string(),\n                name: \"In Progress\".to_string(),\n            },\n            Transition {\n                id: \"31\".to_string(),\n                name: \"Done\".to_string(),\n            },\n        ],\n        updated_fields: std::sync::Mutex::new(None),\n        transitioned_to: std::sync::Mutex::new(None),\n    };\n\n    let args = UpdateArgs {\n        key: \"X-1\".to_string(),\n        summary: None,\n        status: Some(\"Done\".to_string()),\n        assign: None,\n    };\n\n    let output = process_update(\u0026client, \u0026args).await.unwrap();\n    assert!(output.contains(\"Transitioned to: Done\"));\n\n    let transitioned = client.transitioned_to.lock().unwrap();\n    assert_eq!(transitioned.as_ref().unwrap(), \"31\");\n}\n\n#[tokio::test]\nasync fn process_update_fails_no_changes() {\n    let client = MockJiraClient {\n        user: User {\n            account_id: \"me\".to_string(),\n            display_name: \"Me\".to_string(),\n            email_address: None,\n        },\n        transitions: vec![],\n        updated_fields: std::sync::Mutex::new(None),\n        transitioned_to: std::sync::Mutex::new(None),\n    };\n\n    let args = UpdateArgs {\n        key: \"X-1\".to_string(),\n        summary: None,\n        status: None,\n        assign: None,\n    };\n\n    let result = process_update(\u0026client, \u0026args).await;\n    assert!(result.is_err());\n    assert!(result\n        .unwrap_err()\n        .to_string()\n        .contains(\"No changes specified\"));\n}\n\n#[tokio::test]\nasync fn process_update_multiple_changes() {\n    let client = MockJiraClient {\n        user: User {\n            account_id: \"me123\".to_string(),\n            display_name: \"Me\".to_string(),\n            email_address: None,\n        },\n        transitions: vec![Transition {\n            id: \"31\".to_string(),\n            name: \"Done\".to_string(),\n        }],\n        updated_fields: std::sync::Mutex::new(None),\n        transitioned_to: std::sync::Mutex::new(None),\n    };\n\n    let args = UpdateArgs {\n        key: \"X-1\".to_string(),\n        summary: Some(\"Updated\".to_string()),\n        status: Some(\"Done\".to_string()),\n        assign: Some(\"me\".to_string()),\n    };\n\n    let output = process_update(\u0026client, \u0026args).await.unwrap();\n    assert!(output.contains(\"Updated summary\"));\n    assert!(output.contains(\"Updated assignee\"));\n    assert!(output.contains(\"Transitioned to: Done\"));\n}\n","traces":[{"line":121,"address":[],"length":0,"stats":{"Line":4}},{"line":122,"address":[],"length":0,"stats":{"Line":2}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":8}},{"line":134,"address":[],"length":0,"stats":{"Line":12}},{"line":135,"address":[],"length":0,"stats":{"Line":4}},{"line":138,"address":[],"length":0,"stats":{"Line":4}},{"line":139,"address":[],"length":0,"stats":{"Line":2}},{"line":142,"address":[],"length":0,"stats":{"Line":4}},{"line":143,"address":[],"length":0,"stats":{"Line":6}},{"line":144,"address":[],"length":0,"stats":{"Line":2}}],"covered":10,"coverable":12},{"path":["/","Users","chi","Projects","hu","src","main.rs"],"content":"use clap::{CommandFactory, Parser};\n\nmod cli;\nmod context;\nmod data;\nmod docs;\nmod eks;\nmod gh;\nmod git;\nmod install;\nmod jira;\nmod newrelic;\nmod pagerduty;\nmod pipeline;\nmod read;\nmod sentry;\nmod slack;\nmod util;\nmod utils;\n\nuse cli::{Cli, Command};\n\n#[tokio::main]\nasync fn main() -\u003e anyhow::Result\u003c()\u003e {\n    let cli = Cli::parse();\n\n    match cli.command {\n        Some(cmd) =\u003e run_command(cmd).await,\n        None =\u003e {\n            Cli::command().print_help()?;\n            println!();\n            Ok(())\n        }\n    }\n}\n\nasync fn run_command(cmd: Command) -\u003e anyhow::Result\u003c()\u003e {\n    match cmd {\n        Command::Jira { cmd: Some(cmd) } =\u003e {\n            return jira::run_command(cmd).await;\n        }\n        Command::Jira { cmd: None } =\u003e {\n            print_subcommand_help(\"jira\")?;\n        }\n        Command::Gh { cmd: Some(cmd) } =\u003e {\n            return gh::run_command(cmd).await;\n        }\n        Command::Gh { cmd: None } =\u003e {\n            print_subcommand_help(\"gh\")?;\n        }\n        Command::Slack { cmd: Some(cmd) } =\u003e {\n            return slack::run(cmd).await;\n        }\n        Command::Slack { cmd: None } =\u003e {\n            print_subcommand_help(\"slack\")?;\n        }\n        Command::PagerDuty { cmd: Some(cmd) } =\u003e {\n            return pagerduty::run(cmd).await;\n        }\n        Command::PagerDuty { cmd: None } =\u003e {\n            print_subcommand_help(\"pagerduty\")?;\n        }\n        Command::Sentry { cmd: Some(cmd) } =\u003e {\n            return sentry::run(cmd).await;\n        }\n        Command::Sentry { cmd: None } =\u003e {\n            print_subcommand_help(\"sentry\")?;\n        }\n        Command::NewRelic { cmd: Some(cmd) } =\u003e {\n            return newrelic::run(cmd).await;\n        }\n        Command::NewRelic { cmd: None } =\u003e {\n            print_subcommand_help(\"newrelic\")?;\n        }\n        Command::Eks { cmd: Some(cmd) } =\u003e {\n            return eks::run(cmd).await;\n        }\n        Command::Eks { cmd: None } =\u003e {\n            print_subcommand_help(\"eks\")?;\n        }\n        Command::Pipeline { cmd: Some(cmd) } =\u003e {\n            return pipeline::run(cmd).await;\n        }\n        Command::Pipeline { cmd: None } =\u003e {\n            print_subcommand_help(\"pipeline\")?;\n        }\n        Command::Utils { cmd: Some(cmd) } =\u003e {\n            return utils::run_command(cmd).await;\n        }\n        Command::Utils { cmd: None } =\u003e {\n            print_subcommand_help(\"utils\")?;\n        }\n        Command::Context { cmd: Some(cmd) } =\u003e {\n            return context::run_command(cmd).await;\n        }\n        Command::Context { cmd: None } =\u003e {\n            print_subcommand_help(\"context\")?;\n        }\n        Command::Read(args) =\u003e {\n            return read::run(args);\n        }\n        Command::Data { cmd: Some(cmd) } =\u003e {\n            return data::run_command(cmd).await;\n        }\n        Command::Data { cmd: None } =\u003e {\n            print_subcommand_help(\"data\")?;\n        }\n        Command::Install { cmd: Some(cmd) } =\u003e {\n            return install::run_command(cmd).await;\n        }\n        Command::Install { cmd: None } =\u003e {\n            print_subcommand_help(\"install\")?;\n        }\n        Command::Docs { cmd: Some(cmd) } =\u003e {\n            return docs::run_command(cmd).await;\n        }\n        Command::Docs { cmd: None } =\u003e {\n            print_subcommand_help(\"docs\")?;\n        }\n    }\n    Ok(())\n}\n\nfn print_subcommand_help(name: \u0026str) -\u003e anyhow::Result\u003c()\u003e {\n    let mut cmd = Cli::command();\n    for sub in cmd.get_subcommands_mut() {\n        if sub.get_name() == name {\n            sub.print_help()?;\n            println!();\n            return Ok(());\n        }\n    }\n    unreachable!(\"unknown subcommand: {}\", name)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn parses_no_args() {\n        let cli = Cli::try_parse_from::\u003c[\u0026str; 0], \u0026str\u003e([]).unwrap();\n        assert!(cli.command.is_none());\n    }\n\n    #[test]\n    fn parses_subcommand_without_action() {\n        let cli = Cli::try_parse_from([\"hu\", \"jira\"]).unwrap();\n        assert!(matches!(cli.command, Some(Command::Jira { cmd: None })));\n    }\n\n    #[test]\n    fn parses_command_aliases() {\n        // pd -\u003e pagerduty\n        let cli = Cli::try_parse_from([\"hu\", \"pd\", \"oncall\"]).unwrap();\n        assert!(matches!(cli.command, Some(Command::PagerDuty { .. })));\n\n        // nr -\u003e newrelic\n        let cli = Cli::try_parse_from([\"hu\", \"nr\", \"incidents\"]).unwrap();\n        assert!(matches!(cli.command, Some(Command::NewRelic { .. })));\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":66}},{"line":25,"address":[],"length":0,"stats":{"Line":66}},{"line":27,"address":[],"length":0,"stats":{"Line":66}},{"line":28,"address":[],"length":0,"stats":{"Line":90}},{"line":29,"address":[],"length":0,"stats":{"Line":33}},{"line":30,"address":[],"length":0,"stats":{"Line":61}},{"line":31,"address":[],"length":0,"stats":{"Line":47}},{"line":32,"address":[],"length":0,"stats":{"Line":47}},{"line":37,"address":[],"length":0,"stats":{"Line":38}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":39,"address":[],"length":0,"stats":{"Line":1}},{"line":40,"address":[],"length":0,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":1}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":2}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":4}},{"line":61,"address":[],"length":0,"stats":{"Line":2}},{"line":63,"address":[],"length":0,"stats":{"Line":1}},{"line":64,"address":[],"length":0,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":2}},{"line":69,"address":[],"length":0,"stats":{"Line":1}},{"line":70,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":2}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":2}},{"line":79,"address":[],"length":0,"stats":{"Line":2}},{"line":81,"address":[],"length":0,"stats":{"Line":1}},{"line":82,"address":[],"length":0,"stats":{"Line":2}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":87,"address":[],"length":0,"stats":{"Line":2}},{"line":88,"address":[],"length":0,"stats":{"Line":4}},{"line":91,"address":[],"length":0,"stats":{"Line":2}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":9}},{"line":124,"address":[],"length":0,"stats":{"Line":9}},{"line":125,"address":[],"length":0,"stats":{"Line":18}},{"line":126,"address":[],"length":0,"stats":{"Line":63}},{"line":127,"address":[],"length":0,"stats":{"Line":45}},{"line":128,"address":[],"length":0,"stats":{"Line":18}},{"line":129,"address":[],"length":0,"stats":{"Line":9}},{"line":130,"address":[],"length":0,"stats":{"Line":9}}],"covered":43,"coverable":59},{"path":["/","Users","chi","Projects","hu","src","newrelic","client","mod.rs"],"content":"//! New Relic NerdGraph client\n\nuse anyhow::Result;\nuse reqwest::Client;\nuse serde::{Deserialize, Serialize};\nuse std::future::Future;\nuse std::time::Duration;\nuse tokio::time::sleep;\n\nuse super::config::{load_config, NewRelicConfig};\nuse super::types::{Incident, Issue};\n\n#[cfg(test)]\nmod tests;\n\nconst NERDGRAPH_URL: \u0026str = \"https://api.newrelic.com/graphql\";\n\n/// Trait for New Relic API operations (enables testing with mocks)\npub trait NewRelicApi {\n    /// List recent issues\n    fn list_issues(\u0026self, limit: usize) -\u003e impl Future\u003cOutput = Result\u003cVec\u003cIssue\u003e\u003e\u003e + Send;\n\n    /// List recent incidents\n    fn list_incidents(\u0026self, limit: usize) -\u003e impl Future\u003cOutput = Result\u003cVec\u003cIncident\u003e\u003e\u003e + Send;\n\n    /// Run NRQL query\n    fn run_nrql(\u0026self, nrql: \u0026str) -\u003e impl Future\u003cOutput = Result\u003cVec\u003cserde_json::Value\u003e\u003e\u003e + Send;\n}\nconst MAX_RETRIES: u32 = 3;\nconst DEFAULT_RETRY_SECS: u64 = 5;\n\n/// GraphQL request\n#[derive(Debug, Serialize, Deserialize)]\nstruct GraphQLRequest {\n    query: String,\n    variables: serde_json::Value,\n}\n\n/// GraphQL response\n#[derive(Debug, Deserialize)]\nstruct GraphQLResponse\u003cT\u003e {\n    data: Option\u003cT\u003e,\n    errors: Option\u003cVec\u003cGraphQLError\u003e\u003e,\n}\n\n/// GraphQL error\n#[derive(Debug, Deserialize)]\nstruct GraphQLError {\n    message: String,\n}\n\n/// New Relic client\npub struct NewRelicClient {\n    config: NewRelicConfig,\n    http: Client,\n}\n\nimpl NewRelicClient {\n    /// Create a new client\n    pub fn new() -\u003e Result\u003cSelf\u003e {\n        let config = load_config()?;\n        let http = Client::builder().user_agent(\"hu-cli/0.1.0\").build()?;\n        Ok(Self { config, http })\n    }\n\n    /// Get API key\n    fn api_key(\u0026self) -\u003e Result\u003c\u0026str\u003e {\n        self.config\n            .api_key\n            .as_deref()\n            .ok_or_else(|| anyhow::anyhow!(\"New Relic API key not configured\"))\n    }\n\n    /// Get account ID\n    fn account_id(\u0026self) -\u003e Result\u003ci64\u003e {\n        self.config\n            .account_id\n            .ok_or_else(|| anyhow::anyhow!(\"New Relic account ID not configured\"))\n    }\n\n    /// List recent issues\n    pub async fn list_issues(\u0026self, limit: usize) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n        let account_id = self.account_id()?;\n\n        let query = r#\"\n            query($accountId: Int!, $cursor: String) {\n                actor {\n                    account(id: $accountId) {\n                        aiIssues {\n                            issues(cursor: $cursor) {\n                                issues {\n                                    issueId\n                                    title\n                                    priority\n                                    state\n                                    entityNames\n                                    createdAt\n                                    closedAt\n                                    activatedAt\n                                }\n                                nextCursor\n                            }\n                        }\n                    }\n                }\n            }\n        \"#;\n\n        let variables = serde_json::json!({\n            \"accountId\": account_id,\n            \"cursor\": null\n        });\n\n        #[derive(Deserialize)]\n        struct IssuesResponse {\n            actor: Actor,\n        }\n\n        #[derive(Deserialize)]\n        struct Actor {\n            account: Account,\n        }\n\n        #[derive(Deserialize)]\n        #[serde(rename_all = \"camelCase\")]\n        struct Account {\n            ai_issues: AiIssues,\n        }\n\n        #[derive(Deserialize)]\n        struct AiIssues {\n            issues: IssuesData,\n        }\n\n        #[derive(Deserialize)]\n        #[serde(rename_all = \"camelCase\")]\n        struct IssuesData {\n            issues: Vec\u003cIssue\u003e,\n            #[allow(dead_code)]\n            next_cursor: Option\u003cString\u003e,\n        }\n\n        let response: IssuesResponse = self.execute_graphql(query, variables).await?;\n        let mut issues = response.actor.account.ai_issues.issues.issues;\n        issues.truncate(limit);\n        Ok(issues)\n    }\n\n    /// List recent incidents\n    pub async fn list_incidents(\u0026self, limit: usize) -\u003e Result\u003cVec\u003cIncident\u003e\u003e {\n        let account_id = self.account_id()?;\n\n        let query = r#\"\n            query($accountId: Int!, $cursor: String) {\n                actor {\n                    account(id: $accountId) {\n                        aiIssues {\n                            incidents(cursor: $cursor) {\n                                incidents {\n                                    incidentId\n                                    title\n                                    priority\n                                    state\n                                    accountIds\n                                    createdAt\n                                    closedAt\n                                }\n                                nextCursor\n                            }\n                        }\n                    }\n                }\n            }\n        \"#;\n\n        let variables = serde_json::json!({\n            \"accountId\": account_id,\n            \"cursor\": null\n        });\n\n        #[derive(Deserialize)]\n        struct IncidentsResponse {\n            actor: Actor,\n        }\n\n        #[derive(Deserialize)]\n        struct Actor {\n            account: Account,\n        }\n\n        #[derive(Deserialize)]\n        #[serde(rename_all = \"camelCase\")]\n        struct Account {\n            ai_issues: AiIssues,\n        }\n\n        #[derive(Deserialize)]\n        struct AiIssues {\n            incidents: IncidentsData,\n        }\n\n        #[derive(Deserialize)]\n        #[serde(rename_all = \"camelCase\")]\n        struct IncidentsData {\n            incidents: Vec\u003cIncident\u003e,\n            #[allow(dead_code)]\n            next_cursor: Option\u003cString\u003e,\n        }\n\n        let response: IncidentsResponse = self.execute_graphql(query, variables).await?;\n        let mut incidents = response.actor.account.ai_issues.incidents.incidents;\n        incidents.truncate(limit);\n        Ok(incidents)\n    }\n\n    /// Run NRQL query\n    pub async fn run_nrql(\u0026self, nrql: \u0026str) -\u003e Result\u003cVec\u003cserde_json::Value\u003e\u003e {\n        let account_id = self.account_id()?;\n\n        let query = r#\"\n            query($accountId: Int!, $nrql: Nrql!) {\n                actor {\n                    account(id: $accountId) {\n                        nrql(query: $nrql) {\n                            results\n                        }\n                    }\n                }\n            }\n        \"#;\n\n        let variables = serde_json::json!({\n            \"accountId\": account_id,\n            \"nrql\": nrql\n        });\n\n        #[derive(Deserialize)]\n        struct NrqlResponse {\n            actor: Actor,\n        }\n\n        #[derive(Deserialize)]\n        struct Actor {\n            account: Account,\n        }\n\n        #[derive(Deserialize)]\n        struct Account {\n            nrql: NrqlData,\n        }\n\n        #[derive(Deserialize)]\n        struct NrqlData {\n            results: Vec\u003cserde_json::Value\u003e,\n        }\n\n        let response: NrqlResponse = self.execute_graphql(query, variables).await?;\n        Ok(response.actor.account.nrql.results)\n    }\n\n    /// Execute GraphQL query\n    async fn execute_graphql\u003cT: for\u003c'de\u003e Deserialize\u003c'de\u003e\u003e(\n        \u0026self,\n        query: \u0026str,\n        variables: serde_json::Value,\n    ) -\u003e Result\u003cT\u003e {\n        let api_key = self.api_key()?.to_string();\n\n        let request = GraphQLRequest {\n            query: query.to_string(),\n            variables,\n        };\n\n        let body = serde_json::to_string(\u0026request)?;\n\n        let mut retries = 0;\n\n        loop {\n            let response = self\n                .http\n                .post(NERDGRAPH_URL)\n                .header(\"Api-Key\", \u0026api_key)\n                .header(\"Content-Type\", \"application/json\")\n                .body(body.clone())\n                .send()\n                .await?;\n\n            let status = response.status();\n\n            if status == reqwest::StatusCode::TOO_MANY_REQUESTS {\n                if retries \u003e= MAX_RETRIES {\n                    return Err(anyhow::anyhow!(\n                        \"Rate limited after {} retries\",\n                        MAX_RETRIES\n                    ));\n                }\n\n                let retry_after = response\n                    .headers()\n                    .get(\"retry-after\")\n                    .and_then(|v| v.to_str().ok())\n                    .and_then(|s| s.parse::\u003cu64\u003e().ok())\n                    .unwrap_or(DEFAULT_RETRY_SECS);\n\n                eprintln!(\n                    \"Rate limited, waiting {} seconds... (retry {}/{})\",\n                    retry_after,\n                    retries + 1,\n                    MAX_RETRIES\n                );\n                sleep(Duration::from_secs(retry_after)).await;\n                retries += 1;\n                continue;\n            }\n\n            if !status.is_success() {\n                let body = response.text().await.unwrap_or_default();\n                return Err(anyhow::anyhow!(\"HTTP {}: {}\", status.as_u16(), body));\n            }\n\n            let text = response.text().await?;\n            let gql_response: GraphQLResponse\u003cT\u003e = serde_json::from_str(\u0026text).map_err(|e| {\n                anyhow::anyhow!(\"Parse error: {}: {}\", e, \u0026text[..text.len().min(200)])\n            })?;\n\n            if let Some(errors) = gql_response.errors {\n                let messages: Vec\u003c_\u003e = errors.iter().map(|e| e.message.as_str()).collect();\n                return Err(anyhow::anyhow!(\"GraphQL errors: {}\", messages.join(\", \")));\n            }\n\n            return gql_response\n                .data\n                .ok_or_else(|| anyhow::anyhow!(\"No data in response\"));\n        }\n    }\n\n    /// Create client from provided config (for testing)\n    #[cfg(test)]\n    pub fn with_config(config: NewRelicConfig) -\u003e Result\u003cSelf\u003e {\n        let http = Client::builder().user_agent(\"hu-cli/0.1.0\").build()?;\n        Ok(Self { config, http })\n    }\n\n    /// Get config reference (for testing)\n    #[cfg(test)]\n    pub fn config(\u0026self) -\u003e \u0026NewRelicConfig {\n        \u0026self.config\n    }\n}\n\nimpl NewRelicApi for NewRelicClient {\n    async fn list_issues(\u0026self, limit: usize) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n        NewRelicClient::list_issues(self, limit).await\n    }\n\n    async fn list_incidents(\u0026self, limit: usize) -\u003e Result\u003cVec\u003cIncident\u003e\u003e {\n        NewRelicClient::list_incidents(self, limit).await\n    }\n\n    async fn run_nrql(\u0026self, nrql: \u0026str) -\u003e Result\u003cVec\u003cserde_json::Value\u003e\u003e {\n        NewRelicClient::run_nrql(self, nrql).await\n    }\n}\n","traces":[{"line":47,"address":[],"length":0,"stats":{"Line":1}},{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":4}},{"line":50,"address":[],"length":0,"stats":{"Line":1}},{"line":54,"address":[],"length":0,"stats":{"Line":6}},{"line":55,"address":[],"length":0,"stats":{"Line":6}},{"line":59,"address":[],"length":0,"stats":{"Line":3}},{"line":60,"address":[],"length":0,"stats":{"Line":3}},{"line":61,"address":[],"length":0,"stats":{"Line":3}},{"line":63,"address":[],"length":0,"stats":{"Line":5}},{"line":67,"address":[],"length":0,"stats":{"Line":3}},{"line":68,"address":[],"length":0,"stats":{"Line":3}},{"line":69,"address":[],"length":0,"stats":{"Line":3}},{"line":70,"address":[],"length":0,"stats":{"Line":5}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":8}},{"line":332,"address":[],"length":0,"stats":{"Line":32}},{"line":333,"address":[],"length":0,"stats":{"Line":8}}],"covered":17,"coverable":124},{"path":["/","Users","chi","Projects","hu","src","newrelic","client","tests.rs"],"content":"use super::*;\nuse anyhow::Result;\nuse serde::Deserialize;\n\n/// Parse issues from GraphQL response JSON\nfn parse_issues_response(json: \u0026str) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n    #[derive(Deserialize)]\n    struct IssuesResponse {\n        actor: Actor,\n    }\n\n    #[derive(Deserialize)]\n    struct Actor {\n        account: Account,\n    }\n\n    #[derive(Deserialize)]\n    #[serde(rename_all = \"camelCase\")]\n    struct Account {\n        ai_issues: AiIssues,\n    }\n\n    #[derive(Deserialize)]\n    struct AiIssues {\n        issues: IssuesData,\n    }\n\n    #[derive(Deserialize)]\n    #[serde(rename_all = \"camelCase\")]\n    struct IssuesData {\n        issues: Vec\u003cIssue\u003e,\n        #[allow(dead_code)]\n        next_cursor: Option\u003cString\u003e,\n    }\n\n    let response: IssuesResponse = serde_json::from_str(json)?;\n    Ok(response.actor.account.ai_issues.issues.issues)\n}\n\n/// Parse incidents from GraphQL response JSON\nfn parse_incidents_response(json: \u0026str) -\u003e Result\u003cVec\u003cIncident\u003e\u003e {\n    #[derive(Deserialize)]\n    struct IncidentsResponse {\n        actor: Actor,\n    }\n\n    #[derive(Deserialize)]\n    struct Actor {\n        account: Account,\n    }\n\n    #[derive(Deserialize)]\n    #[serde(rename_all = \"camelCase\")]\n    struct Account {\n        ai_issues: AiIssues,\n    }\n\n    #[derive(Deserialize)]\n    struct AiIssues {\n        incidents: IncidentsData,\n    }\n\n    #[derive(Deserialize)]\n    #[serde(rename_all = \"camelCase\")]\n    struct IncidentsData {\n        incidents: Vec\u003cIncident\u003e,\n        #[allow(dead_code)]\n        next_cursor: Option\u003cString\u003e,\n    }\n\n    let response: IncidentsResponse = serde_json::from_str(json)?;\n    Ok(response.actor.account.ai_issues.incidents.incidents)\n}\n\n/// Parse NRQL results from GraphQL response JSON\nfn parse_nrql_response(json: \u0026str) -\u003e Result\u003cVec\u003cserde_json::Value\u003e\u003e {\n    #[derive(Deserialize)]\n    struct NrqlResponse {\n        actor: Actor,\n    }\n\n    #[derive(Deserialize)]\n    struct Actor {\n        account: Account,\n    }\n\n    #[derive(Deserialize)]\n    struct Account {\n        nrql: NrqlData,\n    }\n\n    #[derive(Deserialize)]\n    struct NrqlData {\n        results: Vec\u003cserde_json::Value\u003e,\n    }\n\n    let response: NrqlResponse = serde_json::from_str(json)?;\n    Ok(response.actor.account.nrql.results)\n}\n\n/// Build GraphQL request body\nfn build_graphql_request(query: \u0026str, variables: serde_json::Value) -\u003e Result\u003cString\u003e {\n    let request = GraphQLRequest {\n        query: query.to_string(),\n        variables,\n    };\n    Ok(serde_json::to_string(\u0026request)?)\n}\n\n/// Parse GraphQL errors from response\nfn parse_graphql_errors(json: \u0026str) -\u003e Option\u003cVec\u003cString\u003e\u003e {\n    #[derive(Deserialize)]\n    struct ErrorResponse {\n        errors: Option\u003cVec\u003cGraphQLError\u003e\u003e,\n    }\n\n    let response: ErrorResponse = serde_json::from_str(json).ok()?;\n    response\n        .errors\n        .map(|errs| errs.into_iter().map(|e| e.message).collect())\n}\n\n#[test]\nfn test_graphql_request_serialize() {\n    let request = GraphQLRequest {\n        query: \"query { test }\".to_string(),\n        variables: serde_json::json!({\"id\": 123}),\n    };\n    let json = serde_json::to_string(\u0026request).unwrap();\n    assert!(json.contains(\"query\"));\n    assert!(json.contains(\"variables\"));\n    assert!(json.contains(\"test\"));\n    assert!(json.contains(\"123\"));\n}\n\n#[test]\nfn test_graphql_request_deserialize() {\n    let json = r#\"{\"query\":\"query { test }\",\"variables\":{\"id\":456}}\"#;\n    let request: GraphQLRequest = serde_json::from_str(json).unwrap();\n    assert_eq!(request.query, \"query { test }\");\n    assert_eq!(request.variables[\"id\"], 456);\n}\n\n#[test]\nfn test_graphql_request_debug() {\n    let request = GraphQLRequest {\n        query: \"test\".to_string(),\n        variables: serde_json::json!({}),\n    };\n    let debug = format!(\"{:?}\", request);\n    assert!(debug.contains(\"GraphQLRequest\"));\n}\n\n#[test]\nfn test_graphql_response_with_data() {\n    let json = r#\"{\"data\":{\"value\":42},\"errors\":null}\"#;\n    let response: GraphQLResponse\u003cserde_json::Value\u003e = serde_json::from_str(json).unwrap();\n    assert!(response.data.is_some());\n    assert!(response.errors.is_none());\n    assert_eq!(response.data.unwrap()[\"value\"], 42);\n}\n\n#[test]\nfn test_graphql_response_with_errors() {\n    let json = r#\"{\"data\":null,\"errors\":[{\"message\":\"Something went wrong\"}]}\"#;\n    let response: GraphQLResponse\u003cserde_json::Value\u003e = serde_json::from_str(json).unwrap();\n    assert!(response.data.is_none());\n    assert!(response.errors.is_some());\n    let errors = response.errors.unwrap();\n    assert_eq!(errors.len(), 1);\n    assert_eq!(errors[0].message, \"Something went wrong\");\n}\n\n#[test]\nfn test_graphql_response_debug() {\n    let json = r#\"{\"data\":null,\"errors\":null}\"#;\n    let response: GraphQLResponse\u003cserde_json::Value\u003e = serde_json::from_str(json).unwrap();\n    let debug = format!(\"{:?}\", response);\n    assert!(debug.contains(\"GraphQLResponse\"));\n}\n\n#[test]\nfn test_graphql_error_debug() {\n    let json = r#\"{\"message\":\"Error!\"}\"#;\n    let error: GraphQLError = serde_json::from_str(json).unwrap();\n    let debug = format!(\"{:?}\", error);\n    assert!(debug.contains(\"GraphQLError\"));\n    assert!(debug.contains(\"Error!\"));\n}\n\n#[test]\nfn test_parse_issues_response() {\n    let json = r#\"{\n        \"actor\": {\n            \"account\": {\n                \"aiIssues\": {\n                    \"issues\": {\n                        \"issues\": [\n                            {\n                                \"issueId\": \"ISS-001\",\n                                \"title\": [\"Issue Title\"],\n                                \"priority\": \"HIGH\",\n                                \"state\": \"ACTIVATED\",\n                                \"entityNames\": [\"svc-a\"],\n                                \"createdAt\": 1700000000000,\n                                \"closedAt\": null,\n                                \"activatedAt\": 1700000100000\n                            }\n                        ],\n                        \"nextCursor\": null\n                    }\n                }\n            }\n        }\n    }\"#;\n    let issues = parse_issues_response(json).unwrap();\n    assert_eq!(issues.len(), 1);\n    assert_eq!(issues[0].issue_id, \"ISS-001\");\n    assert_eq!(issues[0].priority, \"HIGH\");\n}\n\n#[test]\nfn test_parse_issues_response_empty() {\n    let json = r#\"{\n        \"actor\": {\n            \"account\": {\n                \"aiIssues\": {\n                    \"issues\": {\n                        \"issues\": [],\n                        \"nextCursor\": null\n                    }\n                }\n            }\n        }\n    }\"#;\n    let issues = parse_issues_response(json).unwrap();\n    assert!(issues.is_empty());\n}\n\n#[test]\nfn test_parse_issues_response_with_cursor() {\n    let json = r#\"{\n        \"actor\": {\n            \"account\": {\n                \"aiIssues\": {\n                    \"issues\": {\n                        \"issues\": [],\n                        \"nextCursor\": \"abc123\"\n                    }\n                }\n            }\n        }\n    }\"#;\n    let issues = parse_issues_response(json).unwrap();\n    assert!(issues.is_empty());\n}\n\n#[test]\nfn test_parse_issues_response_invalid() {\n    let json = r#\"{\"invalid\":\"json\"}\"#;\n    let result = parse_issues_response(json);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_parse_incidents_response() {\n    let json = r#\"{\n        \"actor\": {\n            \"account\": {\n                \"aiIssues\": {\n                    \"incidents\": {\n                        \"incidents\": [\n                            {\n                                \"incidentId\": \"INC-001\",\n                                \"title\": \"Incident Title\",\n                                \"priority\": \"CRITICAL\",\n                                \"state\": \"CLOSED\",\n                                \"accountIds\": [12345],\n                                \"createdAt\": 1700000000000,\n                                \"closedAt\": 1700001000000\n                            }\n                        ],\n                        \"nextCursor\": null\n                    }\n                }\n            }\n        }\n    }\"#;\n    let incidents = parse_incidents_response(json).unwrap();\n    assert_eq!(incidents.len(), 1);\n    assert_eq!(incidents[0].incident_id, \"INC-001\");\n    assert_eq!(incidents[0].priority, \"CRITICAL\");\n}\n\n#[test]\nfn test_parse_incidents_response_empty() {\n    let json = r#\"{\n        \"actor\": {\n            \"account\": {\n                \"aiIssues\": {\n                    \"incidents\": {\n                        \"incidents\": [],\n                        \"nextCursor\": null\n                    }\n                }\n            }\n        }\n    }\"#;\n    let incidents = parse_incidents_response(json).unwrap();\n    assert!(incidents.is_empty());\n}\n\n#[test]\nfn test_parse_incidents_response_invalid() {\n    let json = r#\"{\"malformed\":\"response\"}\"#;\n    let result = parse_incidents_response(json);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_parse_nrql_response() {\n    let json = r#\"{\n        \"actor\": {\n            \"account\": {\n                \"nrql\": {\n                    \"results\": [\n                        {\"count\": 42, \"name\": \"test1\"},\n                        {\"count\": 100, \"name\": \"test2\"}\n                    ]\n                }\n            }\n        }\n    }\"#;\n    let results = parse_nrql_response(json).unwrap();\n    assert_eq!(results.len(), 2);\n    assert_eq!(results[0][\"count\"], 42);\n    assert_eq!(results[1][\"name\"], \"test2\");\n}\n\n#[test]\nfn test_parse_nrql_response_empty() {\n    let json = r#\"{\n        \"actor\": {\n            \"account\": {\n                \"nrql\": {\n                    \"results\": []\n                }\n            }\n        }\n    }\"#;\n    let results = parse_nrql_response(json).unwrap();\n    assert!(results.is_empty());\n}\n\n#[test]\nfn test_parse_nrql_response_invalid() {\n    let json = r#\"{\"not\":\"valid\"}\"#;\n    let result = parse_nrql_response(json);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_build_graphql_request() {\n    let query = \"query { test }\";\n    let variables = serde_json::json!({\"accountId\": 12345});\n    let body = build_graphql_request(query, variables).unwrap();\n\n    let parsed: serde_json::Value = serde_json::from_str(\u0026body).unwrap();\n    assert_eq!(parsed[\"query\"], \"query { test }\");\n    assert_eq!(parsed[\"variables\"][\"accountId\"], 12345);\n}\n\n#[test]\nfn test_build_graphql_request_complex_variables() {\n    let query = \"mutation { create }\";\n    let variables = serde_json::json!({\n        \"input\": {\n            \"name\": \"Test\",\n            \"values\": [1, 2, 3]\n        }\n    });\n    let body = build_graphql_request(query, variables).unwrap();\n    let parsed: serde_json::Value = serde_json::from_str(\u0026body).unwrap();\n    assert_eq!(parsed[\"variables\"][\"input\"][\"name\"], \"Test\");\n}\n\n#[test]\nfn test_parse_graphql_errors_present() {\n    let json = r#\"{\"errors\":[{\"message\":\"Error 1\"},{\"message\":\"Error 2\"}]}\"#;\n    let errors = parse_graphql_errors(json).unwrap();\n    assert_eq!(errors.len(), 2);\n    assert_eq!(errors[0], \"Error 1\");\n    assert_eq!(errors[1], \"Error 2\");\n}\n\n#[test]\nfn test_parse_graphql_errors_none() {\n    let json = r#\"{\"data\":{\"result\":\"ok\"}}\"#;\n    let errors = parse_graphql_errors(json);\n    assert!(errors.is_none());\n}\n\n#[test]\nfn test_parse_graphql_errors_null() {\n    let json = r#\"{\"errors\":null}\"#;\n    let errors = parse_graphql_errors(json);\n    assert!(errors.is_none());\n}\n\n#[test]\nfn test_parse_graphql_errors_invalid_json() {\n    let json = \"not valid json\";\n    let errors = parse_graphql_errors(json);\n    assert!(errors.is_none());\n}\n\n#[test]\nfn test_client_with_config_no_api_key() {\n    let config = NewRelicConfig {\n        api_key: None,\n        account_id: Some(12345),\n    };\n    let client = NewRelicClient::with_config(config).unwrap();\n    assert!(client.api_key().is_err());\n    assert!(client.account_id().is_ok());\n}\n\n#[test]\nfn test_client_with_config_no_account_id() {\n    let config = NewRelicConfig {\n        api_key: Some(\"NRAK-test\".to_string()),\n        account_id: None,\n    };\n    let client = NewRelicClient::with_config(config).unwrap();\n    assert!(client.api_key().is_ok());\n    assert!(client.account_id().is_err());\n}\n\n#[test]\nfn test_client_with_config_both() {\n    let config = NewRelicConfig {\n        api_key: Some(\"NRAK-both\".to_string()),\n        account_id: Some(99999),\n    };\n    let client = NewRelicClient::with_config(config).unwrap();\n    assert_eq!(client.api_key().unwrap(), \"NRAK-both\");\n    assert_eq!(client.account_id().unwrap(), 99999);\n}\n\n#[test]\nfn test_client_config_ref() {\n    let config = NewRelicConfig {\n        api_key: Some(\"NRAK-ref\".to_string()),\n        account_id: Some(11111),\n    };\n    let client = NewRelicClient::with_config(config).unwrap();\n    let config_ref = client.config();\n    assert_eq!(config_ref.api_key, Some(\"NRAK-ref\".to_string()));\n    assert_eq!(config_ref.account_id, Some(11111));\n}\n\n#[test]\nfn test_constants() {\n    assert_eq!(NERDGRAPH_URL, \"https://api.newrelic.com/graphql\");\n    assert_eq!(MAX_RETRIES, 3);\n    assert_eq!(DEFAULT_RETRY_SECS, 5);\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":4}},{"line":36,"address":[],"length":0,"stats":{"Line":15}},{"line":37,"address":[],"length":0,"stats":{"Line":3}},{"line":41,"address":[],"length":0,"stats":{"Line":3}},{"line":71,"address":[],"length":0,"stats":{"Line":11}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":76,"address":[],"length":0,"stats":{"Line":3}},{"line":97,"address":[],"length":0,"stats":{"Line":11}},{"line":98,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":2}},{"line":104,"address":[],"length":0,"stats":{"Line":4}},{"line":107,"address":[],"length":0,"stats":{"Line":4}},{"line":111,"address":[],"length":0,"stats":{"Line":4}},{"line":117,"address":[],"length":0,"stats":{"Line":19}},{"line":118,"address":[],"length":0,"stats":{"Line":3}},{"line":119,"address":[],"length":0,"stats":{"Line":3}},{"line":120,"address":[],"length":0,"stats":{"Line":7}}],"covered":17,"coverable":17},{"path":["/","Users","chi","Projects","hu","src","newrelic","config.rs"],"content":"//! New Relic configuration\n\nuse anyhow::Result;\nuse serde::{Deserialize, Serialize};\nuse std::fs;\nuse std::path::PathBuf;\n\n/// New Relic configuration\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct NewRelicConfig {\n    /// API key (NRAK-...)\n    pub api_key: Option\u003cString\u003e,\n    /// Account ID\n    pub account_id: Option\u003ci64\u003e,\n}\n\nimpl NewRelicConfig {\n    /// Check if configured\n    #[must_use]\n    pub fn is_configured(\u0026self) -\u003e bool {\n        self.api_key.is_some() \u0026\u0026 self.account_id.is_some()\n    }\n}\n\n/// Settings file structure\n#[derive(Debug, Default, Deserialize)]\nstruct SettingsFile {\n    newrelic: Option\u003cNewRelicConfig\u003e,\n}\n\n/// Get path to config file\npub fn config_path() -\u003e Option\u003cPathBuf\u003e {\n    dirs::home_dir().map(|p| p.join(\".config\").join(\"hu\").join(\"settings.toml\"))\n}\n\n/// Load config from settings file and environment\npub fn load_config() -\u003e Result\u003cNewRelicConfig\u003e {\n    let mut config = NewRelicConfig::default();\n\n    // Load from settings file\n    if let Some(path) = config_path() {\n        if path.exists() {\n            let contents = fs::read_to_string(\u0026path)?;\n            let settings: SettingsFile = toml::from_str(\u0026contents)?;\n            if let Some(nr) = settings.newrelic {\n                config = nr;\n            }\n        }\n    }\n\n    // Override with environment variables\n    if let Ok(key) = std::env::var(\"NEW_RELIC_API_KEY\") {\n        config.api_key = Some(key);\n    }\n    if let Ok(id) = std::env::var(\"NEW_RELIC_ACCOUNT_ID\") {\n        if let Ok(parsed) = id.parse() {\n            config.account_id = Some(parsed);\n        }\n    }\n\n    Ok(config)\n}\n\n/// Save config to file\npub fn save_config(api_key: \u0026str, account_id: i64) -\u003e Result\u003c()\u003e {\n    let path = config_path().ok_or_else(|| anyhow::anyhow!(\"Cannot determine config directory\"))?;\n\n    let contents = if path.exists() {\n        fs::read_to_string(\u0026path)?\n    } else {\n        String::new()\n    };\n\n    let mut doc: toml::Value =\n        toml::from_str(\u0026contents).unwrap_or_else(|_| toml::Value::Table(toml::map::Map::new()));\n\n    let table = doc\n        .as_table_mut()\n        .ok_or_else(|| anyhow::anyhow!(\"Config is not a table\"))?;\n\n    if !table.contains_key(\"newrelic\") {\n        table.insert(\n            \"newrelic\".to_string(),\n            toml::Value::Table(toml::map::Map::new()),\n        );\n    }\n\n    let nr = table\n        .get_mut(\"newrelic\")\n        .and_then(|v| v.as_table_mut())\n        .ok_or_else(|| anyhow::anyhow!(\"newrelic section is not a table\"))?;\n\n    nr.insert(\n        \"api_key\".to_string(),\n        toml::Value::String(api_key.to_string()),\n    );\n    nr.insert(\"account_id\".to_string(), toml::Value::Integer(account_id));\n\n    let output = toml::to_string_pretty(\u0026doc)?;\n\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent)?;\n    }\n\n    fs::write(\u0026path, output)?;\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_newrelic_config_is_configured_both_set() {\n        let config = NewRelicConfig {\n            api_key: Some(\"NRAK-12345\".to_string()),\n            account_id: Some(12345),\n        };\n        assert!(config.is_configured());\n    }\n\n    #[test]\n    fn test_newrelic_config_is_configured_only_api_key() {\n        let config = NewRelicConfig {\n            api_key: Some(\"NRAK-12345\".to_string()),\n            account_id: None,\n        };\n        assert!(!config.is_configured());\n    }\n\n    #[test]\n    fn test_newrelic_config_is_configured_only_account_id() {\n        let config = NewRelicConfig {\n            api_key: None,\n            account_id: Some(12345),\n        };\n        assert!(!config.is_configured());\n    }\n\n    #[test]\n    fn test_newrelic_config_is_configured_neither() {\n        let config = NewRelicConfig {\n            api_key: None,\n            account_id: None,\n        };\n        assert!(!config.is_configured());\n    }\n\n    #[test]\n    fn test_newrelic_config_default() {\n        let config = NewRelicConfig::default();\n        assert!(config.api_key.is_none());\n        assert!(config.account_id.is_none());\n        assert!(!config.is_configured());\n    }\n\n    #[test]\n    fn test_config_path_returns_some() {\n        let path = config_path();\n        if let Some(p) = path {\n            assert!(p.to_string_lossy().contains(\"settings.toml\"));\n        }\n    }\n\n    #[test]\n    fn test_newrelic_config_serialization() {\n        let config = NewRelicConfig {\n            api_key: Some(\"NRAK-test123\".to_string()),\n            account_id: Some(99999),\n        };\n\n        let serialized = serde_json::to_string(\u0026config).unwrap();\n        assert!(serialized.contains(\"api_key\"));\n        assert!(serialized.contains(\"NRAK-test123\"));\n        assert!(serialized.contains(\"account_id\"));\n        assert!(serialized.contains(\"99999\"));\n    }\n\n    #[test]\n    fn test_newrelic_config_deserialization() {\n        let json = r#\"{\"api_key\":\"NRAK-abc\",\"account_id\":12345}\"#;\n        let config: NewRelicConfig = serde_json::from_str(json).unwrap();\n        assert_eq!(config.api_key, Some(\"NRAK-abc\".to_string()));\n        assert_eq!(config.account_id, Some(12345));\n    }\n\n    #[test]\n    fn test_newrelic_config_deserialization_null_fields() {\n        let json = r#\"{\"api_key\":null,\"account_id\":null}\"#;\n        let config: NewRelicConfig = serde_json::from_str(json).unwrap();\n        assert!(config.api_key.is_none());\n        assert!(config.account_id.is_none());\n        assert!(!config.is_configured());\n    }\n\n    #[test]\n    fn test_newrelic_config_deserialization_empty_object() {\n        let json = r#\"{}\"#;\n        let config: NewRelicConfig = serde_json::from_str(json).unwrap();\n        assert!(config.api_key.is_none());\n        assert!(config.account_id.is_none());\n    }\n\n    #[test]\n    fn test_newrelic_config_clone() {\n        let config = NewRelicConfig {\n            api_key: Some(\"NRAK-xyz\".to_string()),\n            account_id: Some(54321),\n        };\n        let cloned = config.clone();\n        assert_eq!(cloned.api_key, config.api_key);\n        assert_eq!(cloned.account_id, config.account_id);\n    }\n\n    #[test]\n    fn test_newrelic_config_debug() {\n        let config = NewRelicConfig {\n            api_key: Some(\"NRAK-key\".to_string()),\n            account_id: Some(11111),\n        };\n        let debug = format!(\"{:?}\", config);\n        assert!(debug.contains(\"NewRelicConfig\"));\n        assert!(debug.contains(\"api_key\"));\n        assert!(debug.contains(\"account_id\"));\n    }\n\n    #[test]\n    fn test_settings_file_deserialization_with_newrelic() {\n        let toml = r#\"\n[newrelic]\napi_key = \"NRAK-fromfile\"\naccount_id = 777\n\"#;\n        let settings: SettingsFile = toml::from_str(toml).unwrap();\n        assert!(settings.newrelic.is_some());\n        let nr = settings.newrelic.unwrap();\n        assert_eq!(nr.api_key, Some(\"NRAK-fromfile\".to_string()));\n        assert_eq!(nr.account_id, Some(777));\n    }\n\n    #[test]\n    fn test_settings_file_deserialization_empty() {\n        let toml = \"\";\n        let settings: SettingsFile = toml::from_str(toml).unwrap();\n        assert!(settings.newrelic.is_none());\n    }\n\n    #[test]\n    fn test_settings_file_deserialization_without_newrelic() {\n        let toml = r#\"\n[sentry]\nauth_token = \"secret\"\n\"#;\n        let settings: SettingsFile = toml::from_str(toml).unwrap();\n        assert!(settings.newrelic.is_none());\n    }\n\n    #[test]\n    fn test_settings_file_debug() {\n        let settings = SettingsFile { newrelic: None };\n        let debug = format!(\"{:?}\", settings);\n        assert!(debug.contains(\"SettingsFile\"));\n    }\n\n    #[test]\n    fn test_settings_file_default() {\n        let settings = SettingsFile::default();\n        assert!(settings.newrelic.is_none());\n    }\n\n    #[test]\n    fn test_config_path_hu_directory() {\n        if let Some(path) = config_path() {\n            // Should be in ~/.config/hu/settings.toml\n            let path_str = path.to_string_lossy();\n            assert!(path_str.contains(\".config\"));\n            assert!(path_str.contains(\"hu\"));\n            assert!(path_str.ends_with(\"settings.toml\"));\n        }\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":11}},{"line":21,"address":[],"length":0,"stats":{"Line":30}},{"line":32,"address":[],"length":0,"stats":{"Line":3}},{"line":33,"address":[],"length":0,"stats":{"Line":12}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":41,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":1}},{"line":43,"address":[],"length":0,"stats":{"Line":3}},{"line":44,"address":[],"length":0,"stats":{"Line":4}},{"line":45,"address":[],"length":0,"stats":{"Line":1}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":1}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}}],"covered":14,"coverable":43},{"path":["/","Users","chi","Projects","hu","src","newrelic","display","mod.rs"],"content":"//! New Relic output formatting\n\nuse anyhow::{Context, Result};\nuse comfy_table::{presets::UTF8_FULL_CONDENSED, Cell, Color, ContentArrangement, Table};\n\nuse super::types::{Incident, Issue, OutputFormat};\n\n#[cfg(test)]\nmod tests;\n\n/// Format timestamp from epoch millis\nfn format_time(ts: Option\u003ci64\u003e) -\u003e String {\n    let Some(ms) = ts else {\n        return \"-\".to_string();\n    };\n\n    let secs = ms / 1000;\n    let Some(dt) = chrono::DateTime::from_timestamp(secs, 0) else {\n        return \"-\".to_string();\n    };\n\n    let now = chrono::Utc::now();\n    let duration = now.signed_duration_since(dt);\n\n    if duration.num_days() \u003e 0 {\n        format!(\"{}d ago\", duration.num_days())\n    } else if duration.num_hours() \u003e 0 {\n        format!(\"{}h ago\", duration.num_hours())\n    } else if duration.num_minutes() \u003e 0 {\n        format!(\"{}m ago\", duration.num_minutes())\n    } else {\n        \"just now\".to_string()\n    }\n}\n\n/// Truncate string\nfn truncate(s: \u0026str, max_len: usize) -\u003e String {\n    if s.len() \u003c= max_len {\n        s.to_string()\n    } else {\n        format!(\"{}...\", \u0026s[..max_len.saturating_sub(3)])\n    }\n}\n\n/// Color for priority\nfn priority_color(priority: \u0026str) -\u003e Color {\n    match priority.to_uppercase().as_str() {\n        \"CRITICAL\" =\u003e Color::Red,\n        \"HIGH\" =\u003e Color::Yellow,\n        \"MEDIUM\" =\u003e Color::Blue,\n        _ =\u003e Color::White,\n    }\n}\n\n/// Color for state\nfn state_color(state: \u0026str) -\u003e Color {\n    match state.to_uppercase().as_str() {\n        \"CLOSED\" =\u003e Color::Green,\n        \"ACTIVATED\" | \"ACTIVE\" =\u003e Color::Red,\n        _ =\u003e Color::White,\n    }\n}\n\n/// Output issues list\npub fn output_issues(issues: \u0026[Issue], format: OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            if issues.is_empty() {\n                println!(\"No issues found.\");\n                return Ok(());\n            }\n\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_content_arrangement(ContentArrangement::Dynamic);\n            table.set_header(vec![\n                \"ID\", \"Priority\", \"State\", \"Title\", \"Entities\", \"Created\",\n            ]);\n\n            for issue in issues {\n                let title = issue.title.join(\", \");\n                let entities = issue.entity_names.join(\", \");\n\n                table.add_row(vec![\n                    Cell::new(\u0026issue.issue_id[..issue.issue_id.len().min(12)]).fg(Color::Cyan),\n                    Cell::new(\u0026issue.priority).fg(priority_color(\u0026issue.priority)),\n                    Cell::new(\u0026issue.state).fg(state_color(\u0026issue.state)),\n                    Cell::new(truncate(\u0026title, 40)),\n                    Cell::new(truncate(\u0026entities, 20)),\n                    Cell::new(format_time(issue.created_at)),\n                ]);\n            }\n\n            println!(\"{table}\");\n            println!(\"\\n{} issues\", issues.len());\n        }\n        OutputFormat::Json =\u003e {\n            let json = serde_json::to_string_pretty(issues).context(\"Failed to serialize\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n\n/// Output incidents list\npub fn output_incidents(incidents: \u0026[Incident], format: OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            if incidents.is_empty() {\n                println!(\"No incidents found.\");\n                return Ok(());\n            }\n\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_content_arrangement(ContentArrangement::Dynamic);\n            table.set_header(vec![\"ID\", \"Priority\", \"State\", \"Title\", \"Created\"]);\n\n            for incident in incidents {\n                table.add_row(vec![\n                    Cell::new(\u0026incident.incident_id[..incident.incident_id.len().min(12)])\n                        .fg(Color::Cyan),\n                    Cell::new(\u0026incident.priority).fg(priority_color(\u0026incident.priority)),\n                    Cell::new(\u0026incident.state).fg(state_color(\u0026incident.state)),\n                    Cell::new(truncate(\u0026incident.title, 50)),\n                    Cell::new(format_time(incident.created_at)),\n                ]);\n            }\n\n            println!(\"{table}\");\n            println!(\"\\n{} incidents\", incidents.len());\n        }\n        OutputFormat::Json =\u003e {\n            let json = serde_json::to_string_pretty(incidents).context(\"Failed to serialize\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n\n/// Output NRQL results\npub fn output_nrql(results: \u0026[serde_json::Value], format: OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            if results.is_empty() {\n                println!(\"No results.\");\n                return Ok(());\n            }\n\n            // Try to create table from results\n            if let Some(first) = results.first() {\n                if let Some(obj) = first.as_object() {\n                    let mut table = Table::new();\n                    table.load_preset(UTF8_FULL_CONDENSED);\n                    table.set_content_arrangement(ContentArrangement::Dynamic);\n\n                    // Headers from first object\n                    let headers: Vec\u003c_\u003e = obj.keys().collect();\n                    table.set_header(headers.iter().map(|h| h.as_str()).collect::\u003cVec\u003c_\u003e\u003e());\n\n                    // Rows\n                    for result in results {\n                        if let Some(obj) = result.as_object() {\n                            let row: Vec\u003c_\u003e = headers\n                                .iter()\n                                .map(|h| {\n                                    obj.get(*h)\n                                        .map(format_json_value)\n                                        .unwrap_or_else(|| \"-\".to_string())\n                                })\n                                .collect();\n                            table.add_row(row);\n                        }\n                    }\n\n                    println!(\"{table}\");\n                    println!(\"\\n{} results\", results.len());\n                    return Ok(());\n                }\n            }\n\n            // Fallback to JSON\n            let json = serde_json::to_string_pretty(results)?;\n            println!(\"{json}\");\n        }\n        OutputFormat::Json =\u003e {\n            let json = serde_json::to_string_pretty(results).context(\"Failed to serialize\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n\n/// Format JSON value for table display\nfn format_json_value(v: \u0026serde_json::Value) -\u003e String {\n    match v {\n        serde_json::Value::Null =\u003e \"-\".to_string(),\n        serde_json::Value::String(s) =\u003e s.clone(),\n        serde_json::Value::Number(n) =\u003e n.to_string(),\n        serde_json::Value::Bool(b) =\u003e b.to_string(),\n        _ =\u003e v.to_string(),\n    }\n}\n\n/// Output config status\npub fn output_config_status(config: \u0026super::config::NewRelicConfig) {\n    println!(\"New Relic Configuration\");\n    println!(\"{}\", \"-\".repeat(40));\n    println!(\n        \"API key:    {}\",\n        if config.api_key.is_some() {\n            \"Yes\"\n        } else {\n            \"No\"\n        }\n    );\n    println!(\n        \"Account ID: {}\",\n        config\n            .account_id\n            .map(|id| id.to_string())\n            .unwrap_or_else(|| \"Not set\".to_string())\n    );\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":9}},{"line":13,"address":[],"length":0,"stats":{"Line":17}},{"line":14,"address":[],"length":0,"stats":{"Line":2}},{"line":17,"address":[],"length":0,"stats":{"Line":16}},{"line":18,"address":[],"length":0,"stats":{"Line":15}},{"line":19,"address":[],"length":0,"stats":{"Line":2}},{"line":22,"address":[],"length":0,"stats":{"Line":14}},{"line":23,"address":[],"length":0,"stats":{"Line":28}},{"line":25,"address":[],"length":0,"stats":{"Line":7}},{"line":26,"address":[],"length":0,"stats":{"Line":12}},{"line":27,"address":[],"length":0,"stats":{"Line":4}},{"line":28,"address":[],"length":0,"stats":{"Line":4}},{"line":29,"address":[],"length":0,"stats":{"Line":3}},{"line":30,"address":[],"length":0,"stats":{"Line":4}},{"line":32,"address":[],"length":0,"stats":{"Line":4}},{"line":37,"address":[],"length":0,"stats":{"Line":9}},{"line":38,"address":[],"length":0,"stats":{"Line":18}},{"line":39,"address":[],"length":0,"stats":{"Line":6}},{"line":41,"address":[],"length":0,"stats":{"Line":24}},{"line":46,"address":[],"length":0,"stats":{"Line":9}},{"line":47,"address":[],"length":0,"stats":{"Line":9}},{"line":48,"address":[],"length":0,"stats":{"Line":11}},{"line":49,"address":[],"length":0,"stats":{"Line":9}},{"line":50,"address":[],"length":0,"stats":{"Line":7}},{"line":51,"address":[],"length":0,"stats":{"Line":3}},{"line":56,"address":[],"length":0,"stats":{"Line":8}},{"line":57,"address":[],"length":0,"stats":{"Line":8}},{"line":58,"address":[],"length":0,"stats":{"Line":10}},{"line":59,"address":[],"length":0,"stats":{"Line":14}},{"line":60,"address":[],"length":0,"stats":{"Line":3}},{"line":65,"address":[],"length":0,"stats":{"Line":3}},{"line":66,"address":[],"length":0,"stats":{"Line":3}},{"line":68,"address":[],"length":0,"stats":{"Line":4}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":2}},{"line":74,"address":[],"length":0,"stats":{"Line":3}},{"line":75,"address":[],"length":0,"stats":{"Line":3}},{"line":76,"address":[],"length":0,"stats":{"Line":3}},{"line":77,"address":[],"length":0,"stats":{"Line":5}},{"line":80,"address":[],"length":0,"stats":{"Line":4}},{"line":81,"address":[],"length":0,"stats":{"Line":4}},{"line":82,"address":[],"length":0,"stats":{"Line":4}},{"line":84,"address":[],"length":0,"stats":{"Line":4}},{"line":85,"address":[],"length":0,"stats":{"Line":7}},{"line":86,"address":[],"length":0,"stats":{"Line":6}},{"line":87,"address":[],"length":0,"stats":{"Line":6}},{"line":88,"address":[],"length":0,"stats":{"Line":4}},{"line":89,"address":[],"length":0,"stats":{"Line":4}},{"line":90,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":2}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":98,"address":[],"length":0,"stats":{"Line":4}},{"line":99,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":2}},{"line":106,"address":[],"length":0,"stats":{"Line":3}},{"line":107,"address":[],"length":0,"stats":{"Line":3}},{"line":109,"address":[],"length":0,"stats":{"Line":4}},{"line":110,"address":[],"length":0,"stats":{"Line":2}},{"line":111,"address":[],"length":0,"stats":{"Line":1}},{"line":114,"address":[],"length":0,"stats":{"Line":2}},{"line":115,"address":[],"length":0,"stats":{"Line":3}},{"line":116,"address":[],"length":0,"stats":{"Line":3}},{"line":117,"address":[],"length":0,"stats":{"Line":7}},{"line":119,"address":[],"length":0,"stats":{"Line":4}},{"line":120,"address":[],"length":0,"stats":{"Line":4}},{"line":121,"address":[],"length":0,"stats":{"Line":5}},{"line":122,"address":[],"length":0,"stats":{"Line":3}},{"line":123,"address":[],"length":0,"stats":{"Line":6}},{"line":124,"address":[],"length":0,"stats":{"Line":6}},{"line":125,"address":[],"length":0,"stats":{"Line":4}},{"line":126,"address":[],"length":0,"stats":{"Line":2}},{"line":130,"address":[],"length":0,"stats":{"Line":2}},{"line":131,"address":[],"length":0,"stats":{"Line":4}},{"line":134,"address":[],"length":0,"stats":{"Line":4}},{"line":135,"address":[],"length":0,"stats":{"Line":2}},{"line":138,"address":[],"length":0,"stats":{"Line":2}},{"line":142,"address":[],"length":0,"stats":{"Line":5}},{"line":143,"address":[],"length":0,"stats":{"Line":5}},{"line":145,"address":[],"length":0,"stats":{"Line":8}},{"line":146,"address":[],"length":0,"stats":{"Line":2}},{"line":147,"address":[],"length":0,"stats":{"Line":1}},{"line":151,"address":[],"length":0,"stats":{"Line":6}},{"line":152,"address":[],"length":0,"stats":{"Line":5}},{"line":153,"address":[],"length":0,"stats":{"Line":4}},{"line":154,"address":[],"length":0,"stats":{"Line":6}},{"line":155,"address":[],"length":0,"stats":{"Line":6}},{"line":158,"address":[],"length":0,"stats":{"Line":10}},{"line":159,"address":[],"length":0,"stats":{"Line":18}},{"line":162,"address":[],"length":0,"stats":{"Line":10}},{"line":163,"address":[],"length":0,"stats":{"Line":8}},{"line":164,"address":[],"length":0,"stats":{"Line":12}},{"line":166,"address":[],"length":0,"stats":{"Line":12}},{"line":167,"address":[],"length":0,"stats":{"Line":24}},{"line":168,"address":[],"length":0,"stats":{"Line":8}},{"line":169,"address":[],"length":0,"stats":{"Line":10}},{"line":172,"address":[],"length":0,"stats":{"Line":12}},{"line":176,"address":[],"length":0,"stats":{"Line":4}},{"line":177,"address":[],"length":0,"stats":{"Line":8}},{"line":178,"address":[],"length":0,"stats":{"Line":2}},{"line":183,"address":[],"length":0,"stats":{"Line":3}},{"line":184,"address":[],"length":0,"stats":{"Line":2}},{"line":187,"address":[],"length":0,"stats":{"Line":4}},{"line":188,"address":[],"length":0,"stats":{"Line":2}},{"line":191,"address":[],"length":0,"stats":{"Line":2}},{"line":195,"address":[],"length":0,"stats":{"Line":15}},{"line":196,"address":[],"length":0,"stats":{"Line":15}},{"line":197,"address":[],"length":0,"stats":{"Line":2}},{"line":198,"address":[],"length":0,"stats":{"Line":9}},{"line":199,"address":[],"length":0,"stats":{"Line":21}},{"line":200,"address":[],"length":0,"stats":{"Line":6}},{"line":201,"address":[],"length":0,"stats":{"Line":4}},{"line":206,"address":[],"length":0,"stats":{"Line":3}},{"line":207,"address":[],"length":0,"stats":{"Line":6}},{"line":208,"address":[],"length":0,"stats":{"Line":12}},{"line":209,"address":[],"length":0,"stats":{"Line":3}},{"line":210,"address":[],"length":0,"stats":{"Line":3}},{"line":211,"address":[],"length":0,"stats":{"Line":6}},{"line":212,"address":[],"length":0,"stats":{"Line":2}},{"line":214,"address":[],"length":0,"stats":{"Line":1}},{"line":217,"address":[],"length":0,"stats":{"Line":3}},{"line":218,"address":[],"length":0,"stats":{"Line":3}},{"line":219,"address":[],"length":0,"stats":{"Line":3}},{"line":220,"address":[],"length":0,"stats":{"Line":3}},{"line":221,"address":[],"length":0,"stats":{"Line":5}},{"line":222,"address":[],"length":0,"stats":{"Line":7}}],"covered":126,"coverable":126},{"path":["/","Users","chi","Projects","hu","src","newrelic","display","tests.rs"],"content":"use super::*;\n\n#[test]\nfn test_format_time_none() {\n    assert_eq!(format_time(None), \"-\");\n}\n\n#[test]\nfn test_format_time_days_ago() {\n    let now = chrono::Utc::now();\n    let two_days_ago = now - chrono::Duration::days(2);\n    let ms = two_days_ago.timestamp() * 1000;\n    assert_eq!(format_time(Some(ms)), \"2d ago\");\n}\n\n#[test]\nfn test_format_time_hours_ago() {\n    let now = chrono::Utc::now();\n    let two_hours_ago = now - chrono::Duration::hours(2);\n    let ms = two_hours_ago.timestamp() * 1000;\n    assert_eq!(format_time(Some(ms)), \"2h ago\");\n}\n\n#[test]\nfn test_format_time_minutes_ago() {\n    let now = chrono::Utc::now();\n    let five_mins_ago = now - chrono::Duration::minutes(5);\n    let ms = five_mins_ago.timestamp() * 1000;\n    assert_eq!(format_time(Some(ms)), \"5m ago\");\n}\n\n#[test]\nfn test_format_time_just_now() {\n    let now = chrono::Utc::now();\n    let ms = now.timestamp() * 1000;\n    assert_eq!(format_time(Some(ms)), \"just now\");\n}\n\n#[test]\nfn test_truncate_short() {\n    assert_eq!(truncate(\"hello\", 10), \"hello\");\n}\n\n#[test]\nfn test_truncate_exact() {\n    assert_eq!(truncate(\"hello\", 5), \"hello\");\n}\n\n#[test]\nfn test_truncate_long() {\n    assert_eq!(truncate(\"hello world\", 8), \"hello...\");\n}\n\n#[test]\nfn test_priority_color_critical() {\n    assert_eq!(priority_color(\"CRITICAL\"), Color::Red);\n    assert_eq!(priority_color(\"critical\"), Color::Red);\n}\n\n#[test]\nfn test_priority_color_high() {\n    assert_eq!(priority_color(\"HIGH\"), Color::Yellow);\n    assert_eq!(priority_color(\"high\"), Color::Yellow);\n}\n\n#[test]\nfn test_priority_color_medium() {\n    assert_eq!(priority_color(\"MEDIUM\"), Color::Blue);\n}\n\n#[test]\nfn test_priority_color_other() {\n    assert_eq!(priority_color(\"LOW\"), Color::White);\n    assert_eq!(priority_color(\"unknown\"), Color::White);\n}\n\n#[test]\nfn test_state_color_closed() {\n    assert_eq!(state_color(\"CLOSED\"), Color::Green);\n    assert_eq!(state_color(\"closed\"), Color::Green);\n}\n\n#[test]\nfn test_state_color_active() {\n    assert_eq!(state_color(\"ACTIVATED\"), Color::Red);\n    assert_eq!(state_color(\"ACTIVE\"), Color::Red);\n    assert_eq!(state_color(\"active\"), Color::Red);\n}\n\n#[test]\nfn test_state_color_other() {\n    assert_eq!(state_color(\"PENDING\"), Color::White);\n}\n\n#[test]\nfn test_format_json_value_null() {\n    assert_eq!(format_json_value(\u0026serde_json::Value::Null), \"-\");\n}\n\n#[test]\nfn test_format_json_value_string() {\n    assert_eq!(\n        format_json_value(\u0026serde_json::Value::String(\"hello\".to_string())),\n        \"hello\"\n    );\n}\n\n#[test]\nfn test_format_json_value_number() {\n    assert_eq!(format_json_value(\u0026serde_json::json!(42)), \"42\");\n    assert_eq!(format_json_value(\u0026serde_json::json!(3.14)), \"3.14\");\n}\n\n#[test]\nfn test_format_json_value_bool() {\n    assert_eq!(format_json_value(\u0026serde_json::json!(true)), \"true\");\n    assert_eq!(format_json_value(\u0026serde_json::json!(false)), \"false\");\n}\n\n#[test]\nfn test_format_json_value_array() {\n    let arr = serde_json::json!([1, 2, 3]);\n    assert_eq!(format_json_value(\u0026arr), \"[1,2,3]\");\n}\n\n#[test]\nfn test_output_issues_empty() {\n    let issues: Vec\u003cIssue\u003e = vec![];\n    let result = output_issues(\u0026issues, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_issues_json() {\n    let issues = vec![Issue {\n        issue_id: \"12345678901234567890\".to_string(),\n        priority: \"HIGH\".to_string(),\n        state: \"ACTIVATED\".to_string(),\n        title: vec![\"Test Issue\".to_string()],\n        entity_names: vec![\"my-service\".to_string()],\n        created_at: Some(chrono::Utc::now().timestamp() * 1000),\n        closed_at: None,\n        activated_at: Some(chrono::Utc::now().timestamp() * 1000),\n    }];\n    let result = output_issues(\u0026issues, OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_incidents_empty() {\n    let incidents: Vec\u003cIncident\u003e = vec![];\n    let result = output_incidents(\u0026incidents, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_incidents_json() {\n    let incidents = vec![Incident {\n        incident_id: \"12345678901234567890\".to_string(),\n        priority: \"CRITICAL\".to_string(),\n        state: \"CLOSED\".to_string(),\n        title: \"Test Incident\".to_string(),\n        account_ids: vec![12345],\n        created_at: Some(chrono::Utc::now().timestamp() * 1000),\n        closed_at: None,\n    }];\n    let result = output_incidents(\u0026incidents, OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_nrql_empty() {\n    let results: Vec\u003cserde_json::Value\u003e = vec![];\n    let result = output_nrql(\u0026results, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_nrql_json() {\n    let results = vec![serde_json::json!({\"count\": 42, \"name\": \"test\"})];\n    let result = output_nrql(\u0026results, OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_nrql_table() {\n    let results = vec![\n        serde_json::json!({\"count\": 42, \"name\": \"test1\"}),\n        serde_json::json!({\"count\": 10, \"name\": \"test2\"}),\n    ];\n    let result = output_nrql(\u0026results, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_nrql_table_non_object() {\n    // Test fallback to JSON when results are not objects\n    let results = vec![serde_json::json!(\"string value\"), serde_json::json!(123)];\n    let result = output_nrql(\u0026results, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_nrql_table_missing_keys() {\n    // Test when second object is missing keys from first\n    let results = vec![\n        serde_json::json!({\"a\": 1, \"b\": 2}),\n        serde_json::json!({\"a\": 3}), // missing \"b\"\n    ];\n    let result = output_nrql(\u0026results, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_issues_table_with_data() {\n    let issues = vec![Issue {\n        issue_id: \"123456789012345678901234567890\".to_string(), // long ID\n        priority: \"MEDIUM\".to_string(),\n        state: \"CREATED\".to_string(),\n        title: vec![\n            \"This is a very long title that should be truncated for display purposes\".to_string(),\n        ],\n        entity_names: vec![\"service-one\".to_string(), \"service-two\".to_string()],\n        created_at: Some(chrono::Utc::now().timestamp() * 1000 - 86400000), // 1 day ago\n        closed_at: None,\n        activated_at: None,\n    }];\n    let result = output_issues(\u0026issues, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_incidents_table_with_data() {\n    let incidents = vec![Incident {\n        incident_id: \"INC-VERYLONGIDTHATWILLBETRUNCATED\".to_string(),\n        priority: \"LOW\".to_string(),\n        state: \"PENDING\".to_string(),\n        title: \"This incident title is also quite long and needs truncation\".to_string(),\n        account_ids: vec![1, 2, 3],\n        created_at: Some(chrono::Utc::now().timestamp() * 1000),\n        closed_at: Some(chrono::Utc::now().timestamp() * 1000),\n    }];\n    let result = output_incidents(\u0026incidents, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_format_time_invalid_timestamp() {\n    // Very old timestamp that might be invalid\n    let result = format_time(Some(-1000000000000000));\n    // Should still return something, not crash\n    assert!(!result.is_empty());\n}\n\n#[test]\nfn test_format_time_out_of_range() {\n    // Timestamp so large that DateTime::from_timestamp returns None\n    // i64::MAX / 1000 = ~292 billion years, way beyond chrono's range\n    let result = format_time(Some(i64::MAX));\n    assert_eq!(result, \"-\");\n}\n\n#[test]\nfn test_format_json_value_object() {\n    let obj = serde_json::json!({\"key\": \"value\"});\n    let formatted = format_json_value(\u0026obj);\n    assert!(formatted.contains(\"key\"));\n    assert!(formatted.contains(\"value\"));\n}\n\n#[test]\nfn test_truncate_empty() {\n    assert_eq!(truncate(\"\", 10), \"\");\n}\n\n#[test]\nfn test_truncate_very_short_max() {\n    // Test edge case where max_len is very small\n    assert_eq!(truncate(\"hello\", 3), \"...\");\n}\n\n#[test]\nfn test_truncate_zero() {\n    // Test edge case where max_len is 0\n    let result = truncate(\"hello\", 0);\n    // Should handle gracefully\n    assert!(result.len() \u003c= 3); // \"...\" or empty\n}\n\n#[test]\nfn test_output_config_status_configured() {\n    let config = super::super::config::NewRelicConfig {\n        api_key: Some(\"NRAK-test\".to_string()),\n        account_id: Some(12345),\n    };\n    // Just verify it doesn't panic\n    output_config_status(\u0026config);\n}\n\n#[test]\nfn test_output_config_status_not_configured() {\n    let config = super::super::config::NewRelicConfig {\n        api_key: None,\n        account_id: None,\n    };\n    output_config_status(\u0026config);\n}\n\n#[test]\nfn test_output_config_status_partial() {\n    let config = super::super::config::NewRelicConfig {\n        api_key: Some(\"NRAK-partial\".to_string()),\n        account_id: None,\n    };\n    output_config_status(\u0026config);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","newrelic","mod.rs"],"content":"//! New Relic integration\n//!\n//! Query incidents and run NRQL queries via NerdGraph.\n//!\n//! # CLI Usage\n//! Use [`run`] for CLI commands that format and print output.\n//!\n//! # Programmatic Usage (MCP/HTTP)\n//! Use the reusable functions that return typed data:\n//! - [`get_config`] - Get configuration status\n//! - [`list_issues`] - List recent issues\n//! - [`list_incidents`] - List recent incidents\n//! - [`run_nrql`] - Run NRQL query\n\nmod client;\nmod config;\nmod display;\nmod service;\npub mod types;\n\nuse anyhow::Result;\nuse clap::Subcommand;\n\nuse client::NewRelicClient;\npub use config::NewRelicConfig;\nuse types::OutputFormat;\npub use types::{Incident, Issue};\n\n/// New Relic subcommands\n#[derive(Debug, Subcommand)]\npub enum NewRelicCommand {\n    /// Show configuration status\n    Config,\n\n    /// Set API key and account ID\n    Auth {\n        /// API key (NRAK-...)\n        key: String,\n\n        /// Account ID\n        #[arg(short, long)]\n        account: i64,\n    },\n\n    /// List recent issues\n    Issues {\n        /// Maximum number of issues\n        #[arg(short, long, default_value = \"25\")]\n        limit: usize,\n\n        /// Output as JSON\n        #[arg(long)]\n        json: bool,\n    },\n\n    /// List recent incidents\n    Incidents {\n        /// Maximum number of incidents\n        #[arg(short, long, default_value = \"25\")]\n        limit: usize,\n\n        /// Output as JSON\n        #[arg(long)]\n        json: bool,\n    },\n\n    /// Run NRQL query\n    Query {\n        /// NRQL query string\n        nrql: String,\n\n        /// Output as JSON\n        #[arg(long)]\n        json: bool,\n    },\n}\n\n/// Run a New Relic command (CLI entry point - formats and prints)\n#[cfg(not(tarpaulin_include))]\npub async fn run(cmd: NewRelicCommand) -\u003e Result\u003c()\u003e {\n    match cmd {\n        NewRelicCommand::Config =\u003e cmd_config(),\n        NewRelicCommand::Auth { key, account } =\u003e cmd_auth(\u0026key, account),\n        NewRelicCommand::Issues { limit, json } =\u003e cmd_issues(limit, json).await,\n        NewRelicCommand::Incidents { limit, json } =\u003e cmd_incidents(limit, json).await,\n        NewRelicCommand::Query { nrql, json } =\u003e cmd_query(\u0026nrql, json).await,\n    }\n}\n\n// ============================================================================\n// Reusable functions for MCP/HTTP - return typed data, never print\n// ============================================================================\n\n/// Get New Relic configuration status (for MCP/HTTP)\n#[allow(dead_code)]\npub fn get_config() -\u003e Result\u003cNewRelicConfig\u003e {\n    service::get_config()\n}\n\n/// List recent issues (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn list_issues(limit: usize) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n    let client = NewRelicClient::new()?;\n    service::list_issues(\u0026client, limit).await\n}\n\n/// List recent incidents (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn list_incidents(limit: usize) -\u003e Result\u003cVec\u003cIncident\u003e\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n    let client = NewRelicClient::new()?;\n    service::list_incidents(\u0026client, limit).await\n}\n\n/// Run NRQL query (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn run_nrql(nrql: \u0026str) -\u003e Result\u003cVec\u003cserde_json::Value\u003e\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n    let client = NewRelicClient::new()?;\n    service::run_nrql(\u0026client, nrql).await\n}\n\n// ============================================================================\n// CLI command handlers - create client, call service, format and print\n// ============================================================================\n\n/// Show config status\nfn cmd_config() -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    display::output_config_status(\u0026config);\n    Ok(())\n}\n\n/// Set auth\nfn cmd_auth(key: \u0026str, account_id: i64) -\u003e Result\u003c()\u003e {\n    service::save_auth(key, account_id)?;\n    println!(\"New Relic API key saved for account: {}\", account_id);\n    Ok(())\n}\n\n/// List issues\nasync fn cmd_issues(limit: usize, json: bool) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n\n    let client = NewRelicClient::new()?;\n    let issues = service::list_issues(\u0026client, limit).await?;\n\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n\n    display::output_issues(\u0026issues, format)?;\n    Ok(())\n}\n\n/// List incidents\nasync fn cmd_incidents(limit: usize, json: bool) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n\n    let client = NewRelicClient::new()?;\n    let incidents = service::list_incidents(\u0026client, limit).await?;\n\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n\n    display::output_incidents(\u0026incidents, format)?;\n    Ok(())\n}\n\n/// Run NRQL query\nasync fn cmd_query(nrql: \u0026str, json: bool) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n\n    let client = NewRelicClient::new()?;\n    let results = service::run_nrql(\u0026client, nrql).await?;\n\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n\n    display::output_nrql(\u0026results, format)?;\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_newrelic_command_config_variant() {\n        let cmd = NewRelicCommand::Config;\n        let debug = format!(\"{:?}\", cmd);\n        assert!(debug.contains(\"Config\"));\n    }\n\n    #[test]\n    fn test_newrelic_command_auth_variant() {\n        let cmd = NewRelicCommand::Auth {\n            key: \"NRAK-test\".to_string(),\n            account: 12345,\n        };\n        let debug = format!(\"{:?}\", cmd);\n        assert!(debug.contains(\"Auth\"));\n        assert!(debug.contains(\"NRAK-test\"));\n        assert!(debug.contains(\"12345\"));\n    }\n\n    #[test]\n    fn test_newrelic_command_issues_variant() {\n        let cmd = NewRelicCommand::Issues {\n            limit: 50,\n            json: true,\n        };\n        let debug = format!(\"{:?}\", cmd);\n        assert!(debug.contains(\"Issues\"));\n        assert!(debug.contains(\"50\"));\n        assert!(debug.contains(\"true\"));\n    }\n\n    #[test]\n    fn test_newrelic_command_incidents_variant() {\n        let cmd = NewRelicCommand::Incidents {\n            limit: 10,\n            json: false,\n        };\n        let debug = format!(\"{:?}\", cmd);\n        assert!(debug.contains(\"Incidents\"));\n        assert!(debug.contains(\"10\"));\n        assert!(debug.contains(\"false\"));\n    }\n\n    #[test]\n    fn test_newrelic_command_query_variant() {\n        let cmd = NewRelicCommand::Query {\n            nrql: \"SELECT count(*) FROM Transaction\".to_string(),\n            json: true,\n        };\n        let debug = format!(\"{:?}\", cmd);\n        assert!(debug.contains(\"Query\"));\n        assert!(debug.contains(\"SELECT\"));\n        assert!(debug.contains(\"Transaction\"));\n    }\n\n    #[test]\n    fn test_ensure_configured_with_configured() {\n        let config = config::NewRelicConfig {\n            api_key: Some(\"NRAK-configured\".to_string()),\n            account_id: Some(99999),\n        };\n        let result = service::ensure_configured(\u0026config);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_ensure_configured_with_unconfigured() {\n        let config = config::NewRelicConfig {\n            api_key: None,\n            account_id: None,\n        };\n        let result = service::ensure_configured(\u0026config);\n        assert!(result.is_err());\n        let err_msg = result.unwrap_err().to_string();\n        assert!(err_msg.contains(\"not configured\"));\n    }\n\n    #[test]\n    fn test_ensure_configured_partial_api_key_only() {\n        let config = config::NewRelicConfig {\n            api_key: Some(\"NRAK-partial\".to_string()),\n            account_id: None,\n        };\n        let result = service::ensure_configured(\u0026config);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_ensure_configured_partial_account_only() {\n        let config = config::NewRelicConfig {\n            api_key: None,\n            account_id: Some(12345),\n        };\n        let result = service::ensure_configured(\u0026config);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_output_format_from_json_flag_true() {\n        let json = true;\n        let format = if json {\n            OutputFormat::Json\n        } else {\n            OutputFormat::Table\n        };\n        assert!(matches!(format, OutputFormat::Json));\n    }\n\n    #[test]\n    fn test_output_format_from_json_flag_false() {\n        let json = false;\n        let format = if json {\n            OutputFormat::Json\n        } else {\n            OutputFormat::Table\n        };\n        assert!(matches!(format, OutputFormat::Table));\n    }\n}\n","traces":[{"line":66,"address":[],"length":0,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":1}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":5}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":5}},{"line":78,"address":[],"length":0,"stats":{"Line":5}},{"line":79,"address":[],"length":0,"stats":{"Line":4}},{"line":80,"address":[],"length":0,"stats":{"Line":4}},{"line":81,"address":[],"length":0,"stats":{"Line":4}},{"line":84,"address":[],"length":0,"stats":{"Line":1}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":2}},{"line":120,"address":[],"length":0,"stats":{"Line":2}},{"line":121,"address":[],"length":0,"stats":{"Line":3}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}}],"covered":12,"coverable":48},{"path":["/","Users","chi","Projects","hu","src","newrelic","types.rs"],"content":"//! New Relic data types\n\nuse serde::{Deserialize, Serialize};\n\n/// New Relic incident\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Incident {\n    /// Incident ID\n    pub incident_id: String,\n    /// Title\n    pub title: String,\n    /// Priority (CRITICAL, HIGH, MEDIUM, LOW)\n    #[serde(default)]\n    pub priority: String,\n    /// State (CREATED, ACTIVATED, CLOSED)\n    #[serde(default)]\n    pub state: String,\n    /// Account ID\n    pub account_ids: Vec\u003ci64\u003e,\n    /// Created at timestamp\n    #[serde(default)]\n    pub created_at: Option\u003ci64\u003e,\n    /// Closed at timestamp\n    #[serde(default)]\n    pub closed_at: Option\u003ci64\u003e,\n}\n\n/// New Relic issue (groups incidents)\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Issue {\n    /// Issue ID\n    pub issue_id: String,\n    /// Title\n    pub title: Vec\u003cString\u003e,\n    /// Priority\n    #[serde(default)]\n    pub priority: String,\n    /// State\n    #[serde(default)]\n    pub state: String,\n    /// Entity names\n    #[serde(default)]\n    pub entity_names: Vec\u003cString\u003e,\n    /// Created at\n    pub created_at: Option\u003ci64\u003e,\n    /// Closed at\n    pub closed_at: Option\u003ci64\u003e,\n    /// Activated at\n    pub activated_at: Option\u003ci64\u003e,\n}\n\n/// Output format\n#[derive(Debug, Clone, Copy, Default)]\npub enum OutputFormat {\n    #[default]\n    Table,\n    Json,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_incident_debug() {\n        let incident = Incident {\n            incident_id: \"INC123\".to_string(),\n            title: \"Test Incident\".to_string(),\n            priority: \"CRITICAL\".to_string(),\n            state: \"CLOSED\".to_string(),\n            account_ids: vec![12345],\n            created_at: Some(1704067200000),\n            closed_at: None,\n        };\n        let debug = format!(\"{:?}\", incident);\n        assert!(debug.contains(\"Incident\"));\n        assert!(debug.contains(\"INC123\"));\n    }\n\n    #[test]\n    fn test_incident_clone() {\n        let incident = Incident {\n            incident_id: \"INC123\".to_string(),\n            title: \"Test\".to_string(),\n            priority: \"HIGH\".to_string(),\n            state: \"ACTIVATED\".to_string(),\n            account_ids: vec![1, 2, 3],\n            created_at: None,\n            closed_at: None,\n        };\n        let cloned = incident.clone();\n        assert_eq!(cloned.incident_id, incident.incident_id);\n        assert_eq!(cloned.account_ids, incident.account_ids);\n    }\n\n    #[test]\n    fn test_issue_debug() {\n        let issue = Issue {\n            issue_id: \"ISS123\".to_string(),\n            title: vec![\"Test Issue\".to_string()],\n            priority: \"MEDIUM\".to_string(),\n            state: \"CREATED\".to_string(),\n            entity_names: vec![\"service-a\".to_string()],\n            created_at: Some(1704067200000),\n            closed_at: None,\n            activated_at: None,\n        };\n        let debug = format!(\"{:?}\", issue);\n        assert!(debug.contains(\"Issue\"));\n        assert!(debug.contains(\"ISS123\"));\n    }\n\n    #[test]\n    fn test_issue_clone() {\n        let issue = Issue {\n            issue_id: \"ISS123\".to_string(),\n            title: vec![\"Title 1\".to_string(), \"Title 2\".to_string()],\n            priority: \"LOW\".to_string(),\n            state: \"CLOSED\".to_string(),\n            entity_names: vec![],\n            created_at: None,\n            closed_at: Some(1704067200000),\n            activated_at: Some(1704067100000),\n        };\n        let cloned = issue.clone();\n        assert_eq!(cloned.issue_id, issue.issue_id);\n        assert_eq!(cloned.title, issue.title);\n    }\n\n    #[test]\n    fn test_output_format_default() {\n        let format = OutputFormat::default();\n        assert!(matches!(format, OutputFormat::Table));\n    }\n\n    #[test]\n    fn test_output_format_clone() {\n        let format = OutputFormat::Json;\n        let cloned = format.clone();\n        assert!(matches!(cloned, OutputFormat::Json));\n    }\n\n    #[test]\n    fn test_output_format_debug() {\n        let format = OutputFormat::Table;\n        let debug = format!(\"{:?}\", format);\n        assert_eq!(debug, \"Table\");\n    }\n\n    #[test]\n    fn test_incident_serde_default() {\n        // Test that serde default works for optional fields\n        let json = r#\"{\"incidentId\":\"INC1\",\"title\":\"Test\",\"accountIds\":[1]}\"#;\n        let incident: Incident = serde_json::from_str(json).unwrap();\n        assert_eq!(incident.priority, \"\");\n        assert_eq!(incident.state, \"\");\n        assert!(incident.created_at.is_none());\n    }\n\n    #[test]\n    fn test_issue_serde_default() {\n        let json = r#\"{\"issueId\":\"ISS1\",\"title\":[\"Test\"]}\"#;\n        let issue: Issue = serde_json::from_str(json).unwrap();\n        assert_eq!(issue.priority, \"\");\n        assert_eq!(issue.state, \"\");\n        assert!(issue.entity_names.is_empty());\n    }\n\n    #[test]\n    fn test_incident_serialize() {\n        let incident = Incident {\n            incident_id: \"INC-001\".to_string(),\n            title: \"Test\".to_string(),\n            priority: \"HIGH\".to_string(),\n            state: \"ACTIVE\".to_string(),\n            account_ids: vec![111, 222],\n            created_at: Some(1704067200000),\n            closed_at: None,\n        };\n        let json = serde_json::to_string(\u0026incident).unwrap();\n        // Should use camelCase\n        assert!(json.contains(\"incidentId\"));\n        assert!(json.contains(\"accountIds\"));\n        assert!(json.contains(\"createdAt\"));\n        assert!(!json.contains(\"incident_id\")); // Not snake_case\n    }\n\n    #[test]\n    fn test_issue_serialize() {\n        let issue = Issue {\n            issue_id: \"ISS-001\".to_string(),\n            title: vec![\"Title 1\".to_string()],\n            priority: \"CRITICAL\".to_string(),\n            state: \"CLOSED\".to_string(),\n            entity_names: vec![\"entity\".to_string()],\n            created_at: Some(1704067200000),\n            closed_at: Some(1704067300000),\n            activated_at: Some(1704067100000),\n        };\n        let json = serde_json::to_string(\u0026issue).unwrap();\n        // Should use camelCase\n        assert!(json.contains(\"issueId\"));\n        assert!(json.contains(\"entityNames\"));\n        assert!(json.contains(\"activatedAt\"));\n    }\n\n    #[test]\n    fn test_incident_full_deserialize() {\n        let json = r#\"{\n            \"incidentId\": \"INC-FULL\",\n            \"title\": \"Full incident\",\n            \"priority\": \"CRITICAL\",\n            \"state\": \"CLOSED\",\n            \"accountIds\": [1, 2, 3],\n            \"createdAt\": 1704067200000,\n            \"closedAt\": 1704067300000\n        }\"#;\n        let incident: Incident = serde_json::from_str(json).unwrap();\n        assert_eq!(incident.incident_id, \"INC-FULL\");\n        assert_eq!(incident.title, \"Full incident\");\n        assert_eq!(incident.priority, \"CRITICAL\");\n        assert_eq!(incident.state, \"CLOSED\");\n        assert_eq!(incident.account_ids, vec![1, 2, 3]);\n        assert_eq!(incident.created_at, Some(1704067200000));\n        assert_eq!(incident.closed_at, Some(1704067300000));\n    }\n\n    #[test]\n    fn test_issue_full_deserialize() {\n        let json = r#\"{\n            \"issueId\": \"ISS-FULL\",\n            \"title\": [\"Title A\", \"Title B\"],\n            \"priority\": \"HIGH\",\n            \"state\": \"ACTIVATED\",\n            \"entityNames\": [\"svc-a\", \"svc-b\"],\n            \"createdAt\": 1704067200000,\n            \"closedAt\": null,\n            \"activatedAt\": 1704067150000\n        }\"#;\n        let issue: Issue = serde_json::from_str(json).unwrap();\n        assert_eq!(issue.issue_id, \"ISS-FULL\");\n        assert_eq!(issue.title, vec![\"Title A\", \"Title B\"]);\n        assert_eq!(issue.priority, \"HIGH\");\n        assert_eq!(issue.state, \"ACTIVATED\");\n        assert_eq!(issue.entity_names, vec![\"svc-a\", \"svc-b\"]);\n        assert_eq!(issue.created_at, Some(1704067200000));\n        assert!(issue.closed_at.is_none());\n        assert_eq!(issue.activated_at, Some(1704067150000));\n    }\n\n    #[test]\n    fn test_incident_empty_account_ids() {\n        let json = r#\"{\"incidentId\":\"INC\",\"title\":\"T\",\"accountIds\":[]}\"#;\n        let incident: Incident = serde_json::from_str(json).unwrap();\n        assert!(incident.account_ids.is_empty());\n    }\n\n    #[test]\n    fn test_issue_empty_titles() {\n        let json = r#\"{\"issueId\":\"ISS\",\"title\":[]}\"#;\n        let issue: Issue = serde_json::from_str(json).unwrap();\n        assert!(issue.title.is_empty());\n    }\n\n    #[test]\n    fn test_output_format_copy() {\n        let format = OutputFormat::Json;\n        let copied = format;\n        assert!(matches!(copied, OutputFormat::Json));\n    }\n\n    #[test]\n    fn test_incident_roundtrip() {\n        let original = Incident {\n            incident_id: \"RT-001\".to_string(),\n            title: \"Roundtrip test\".to_string(),\n            priority: \"MEDIUM\".to_string(),\n            state: \"CREATED\".to_string(),\n            account_ids: vec![42],\n            created_at: Some(1700000000000),\n            closed_at: None,\n        };\n        let json = serde_json::to_string(\u0026original).unwrap();\n        let deserialized: Incident = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(deserialized.incident_id, original.incident_id);\n        assert_eq!(deserialized.title, original.title);\n        assert_eq!(deserialized.priority, original.priority);\n        assert_eq!(deserialized.state, original.state);\n        assert_eq!(deserialized.account_ids, original.account_ids);\n        assert_eq!(deserialized.created_at, original.created_at);\n        assert_eq!(deserialized.closed_at, original.closed_at);\n    }\n\n    #[test]\n    fn test_issue_roundtrip() {\n        let original = Issue {\n            issue_id: \"RT-ISS\".to_string(),\n            title: vec![\"Round\".to_string(), \"Trip\".to_string()],\n            priority: \"LOW\".to_string(),\n            state: \"PENDING\".to_string(),\n            entity_names: vec![\"e1\".to_string()],\n            created_at: Some(1600000000000),\n            closed_at: Some(1600001000000),\n            activated_at: None,\n        };\n        let json = serde_json::to_string(\u0026original).unwrap();\n        let deserialized: Issue = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(deserialized.issue_id, original.issue_id);\n        assert_eq!(deserialized.title, original.title);\n        assert_eq!(deserialized.priority, original.priority);\n        assert_eq!(deserialized.entity_names, original.entity_names);\n        assert_eq!(deserialized.created_at, original.created_at);\n        assert_eq!(deserialized.closed_at, original.closed_at);\n        assert_eq!(deserialized.activated_at, original.activated_at);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","pagerduty","cli.rs"],"content":"//! PagerDuty CLI commands\n\nuse clap::{Subcommand, ValueEnum};\n\n/// Incident status filter\n#[derive(Debug, Clone, Copy, ValueEnum)]\npub enum StatusFilter {\n    /// Only triggered incidents\n    Triggered,\n    /// Only acknowledged incidents\n    Acknowledged,\n    /// Only resolved incidents\n    Resolved,\n    /// Triggered and acknowledged (active)\n    Active,\n}\n\n#[derive(Debug, Subcommand)]\npub enum PagerDutyCommand {\n    /// Show configuration status\n    Config,\n\n    /// Set API token\n    Auth {\n        /// PagerDuty API token\n        token: String,\n    },\n\n    /// Show who's currently on call\n    Oncall {\n        /// Filter by escalation policy ID\n        #[arg(short = 'p', long)]\n        policy: Option\u003cString\u003e,\n\n        /// Filter by schedule ID\n        #[arg(short, long)]\n        schedule: Option\u003cString\u003e,\n\n        /// Output as JSON\n        #[arg(long)]\n        json: bool,\n    },\n\n    /// List active alerts (triggered + acknowledged incidents)\n    Alerts {\n        /// Maximum number to show\n        #[arg(short, long, default_value = \"25\")]\n        limit: usize,\n\n        /// Output as JSON\n        #[arg(long)]\n        json: bool,\n    },\n\n    /// List incidents with filters\n    Incidents {\n        /// Filter by status\n        #[arg(short, long, value_enum)]\n        status: Option\u003cStatusFilter\u003e,\n\n        /// Maximum number to show\n        #[arg(short, long, default_value = \"25\")]\n        limit: usize,\n\n        /// Output as JSON\n        #[arg(long)]\n        json: bool,\n    },\n\n    /// Show incident details\n    Show {\n        /// Incident ID\n        id: String,\n\n        /// Output as JSON\n        #[arg(long)]\n        json: bool,\n    },\n\n    /// Show current user info\n    Whoami {\n        /// Output as JSON\n        #[arg(long)]\n        json: bool,\n    },\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use clap::{CommandFactory, Parser};\n\n    #[derive(Parser)]\n    struct TestCli {\n        #[command(subcommand)]\n        cmd: PagerDutyCommand,\n    }\n\n    #[test]\n    fn parses_config() {\n        let cli = TestCli::try_parse_from([\"test\", \"config\"]).unwrap();\n        assert!(matches!(cli.cmd, PagerDutyCommand::Config));\n    }\n\n    #[test]\n    fn parses_auth() {\n        let cli = TestCli::try_parse_from([\"test\", \"auth\", \"my-token\"]).unwrap();\n        match cli.cmd {\n            PagerDutyCommand::Auth { token } =\u003e assert_eq!(token, \"my-token\"),\n            _ =\u003e panic!(\"Expected Auth command\"),\n        }\n    }\n\n    #[test]\n    fn parses_oncall_no_args() {\n        let cli = TestCli::try_parse_from([\"test\", \"oncall\"]).unwrap();\n        match cli.cmd {\n            PagerDutyCommand::Oncall {\n                policy,\n                schedule,\n                json,\n            } =\u003e {\n                assert!(policy.is_none());\n                assert!(schedule.is_none());\n                assert!(!json);\n            }\n            _ =\u003e panic!(\"Expected Oncall command\"),\n        }\n    }\n\n    #[test]\n    fn parses_oncall_with_policy() {\n        let cli = TestCli::try_parse_from([\"test\", \"oncall\", \"-p\", \"EP123\"]).unwrap();\n        match cli.cmd {\n            PagerDutyCommand::Oncall { policy, .. } =\u003e {\n                assert_eq!(policy, Some(\"EP123\".to_string()));\n            }\n            _ =\u003e panic!(\"Expected Oncall command\"),\n        }\n    }\n\n    #[test]\n    fn parses_oncall_with_schedule() {\n        let cli = TestCli::try_parse_from([\"test\", \"oncall\", \"--schedule\", \"S456\"]).unwrap();\n        match cli.cmd {\n            PagerDutyCommand::Oncall { schedule, .. } =\u003e {\n                assert_eq!(schedule, Some(\"S456\".to_string()));\n            }\n            _ =\u003e panic!(\"Expected Oncall command\"),\n        }\n    }\n\n    #[test]\n    fn parses_oncall_json() {\n        let cli = TestCli::try_parse_from([\"test\", \"oncall\", \"--json\"]).unwrap();\n        match cli.cmd {\n            PagerDutyCommand::Oncall { json, .. } =\u003e assert!(json),\n            _ =\u003e panic!(\"Expected Oncall command\"),\n        }\n    }\n\n    #[test]\n    fn parses_alerts_default_limit() {\n        let cli = TestCli::try_parse_from([\"test\", \"alerts\"]).unwrap();\n        match cli.cmd {\n            PagerDutyCommand::Alerts { limit, json } =\u003e {\n                assert_eq!(limit, 25);\n                assert!(!json);\n            }\n            _ =\u003e panic!(\"Expected Alerts command\"),\n        }\n    }\n\n    #[test]\n    fn parses_alerts_custom_limit() {\n        let cli = TestCli::try_parse_from([\"test\", \"alerts\", \"-l\", \"50\"]).unwrap();\n        match cli.cmd {\n            PagerDutyCommand::Alerts { limit, .. } =\u003e assert_eq!(limit, 50),\n            _ =\u003e panic!(\"Expected Alerts command\"),\n        }\n    }\n\n    #[test]\n    fn parses_incidents_no_filter() {\n        let cli = TestCli::try_parse_from([\"test\", \"incidents\"]).unwrap();\n        match cli.cmd {\n            PagerDutyCommand::Incidents {\n                status,\n                limit,\n                json,\n            } =\u003e {\n                assert!(status.is_none());\n                assert_eq!(limit, 25);\n                assert!(!json);\n            }\n            _ =\u003e panic!(\"Expected Incidents command\"),\n        }\n    }\n\n    #[test]\n    fn parses_incidents_status_triggered() {\n        let cli = TestCli::try_parse_from([\"test\", \"incidents\", \"-s\", \"triggered\"]).unwrap();\n        match cli.cmd {\n            PagerDutyCommand::Incidents { status, .. } =\u003e {\n                assert!(matches!(status, Some(StatusFilter::Triggered)));\n            }\n            _ =\u003e panic!(\"Expected Incidents command\"),\n        }\n    }\n\n    #[test]\n    fn parses_incidents_status_acknowledged() {\n        let cli =\n            TestCli::try_parse_from([\"test\", \"incidents\", \"--status\", \"acknowledged\"]).unwrap();\n        match cli.cmd {\n            PagerDutyCommand::Incidents { status, .. } =\u003e {\n                assert!(matches!(status, Some(StatusFilter::Acknowledged)));\n            }\n            _ =\u003e panic!(\"Expected Incidents command\"),\n        }\n    }\n\n    #[test]\n    fn parses_incidents_status_resolved() {\n        let cli = TestCli::try_parse_from([\"test\", \"incidents\", \"-s\", \"resolved\"]).unwrap();\n        match cli.cmd {\n            PagerDutyCommand::Incidents { status, .. } =\u003e {\n                assert!(matches!(status, Some(StatusFilter::Resolved)));\n            }\n            _ =\u003e panic!(\"Expected Incidents command\"),\n        }\n    }\n\n    #[test]\n    fn parses_incidents_status_active() {\n        let cli = TestCli::try_parse_from([\"test\", \"incidents\", \"-s\", \"active\"]).unwrap();\n        match cli.cmd {\n            PagerDutyCommand::Incidents { status, .. } =\u003e {\n                assert!(matches!(status, Some(StatusFilter::Active)));\n            }\n            _ =\u003e panic!(\"Expected Incidents command\"),\n        }\n    }\n\n    #[test]\n    fn parses_show() {\n        let cli = TestCli::try_parse_from([\"test\", \"show\", \"INC123\"]).unwrap();\n        match cli.cmd {\n            PagerDutyCommand::Show { id, json } =\u003e {\n                assert_eq!(id, \"INC123\");\n                assert!(!json);\n            }\n            _ =\u003e panic!(\"Expected Show command\"),\n        }\n    }\n\n    #[test]\n    fn parses_show_json() {\n        let cli = TestCli::try_parse_from([\"test\", \"show\", \"INC123\", \"--json\"]).unwrap();\n        match cli.cmd {\n            PagerDutyCommand::Show { id, json } =\u003e {\n                assert_eq!(id, \"INC123\");\n                assert!(json);\n            }\n            _ =\u003e panic!(\"Expected Show command\"),\n        }\n    }\n\n    #[test]\n    fn status_filter_debug() {\n        let filter = StatusFilter::Triggered;\n        let debug = format!(\"{:?}\", filter);\n        assert!(debug.contains(\"Triggered\"));\n    }\n\n    #[test]\n    fn status_filter_clone() {\n        let filter = StatusFilter::Active;\n        let cloned = filter;\n        assert!(matches!(cloned, StatusFilter::Active));\n    }\n\n    #[test]\n    fn command_debug() {\n        let cmd = PagerDutyCommand::Config;\n        let debug = format!(\"{:?}\", cmd);\n        assert!(debug.contains(\"Config\"));\n    }\n\n    #[test]\n    fn command_has_help() {\n        // Verify help text is generated without panic\n        let mut cmd = TestCli::command();\n        let help = cmd.render_help();\n        assert!(!help.to_string().is_empty());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","pagerduty","client","mod.rs"],"content":"//! PagerDuty API client\n\nuse anyhow::Result;\nuse reqwest::Client;\nuse serde::de::DeserializeOwned;\nuse std::future::Future;\nuse std::time::Duration;\nuse tokio::time::sleep;\n\nuse super::config::{load_config, PagerDutyConfig};\nuse super::types::{\n    CurrentUserResponse, Incident, IncidentResponse, IncidentStatus, IncidentsResponse, Oncall,\n    OncallsResponse, Service, ServicesResponse, User,\n};\n\n#[cfg(test)]\nmod tests;\n\nconst PAGERDUTY_API_URL: \u0026str = \"https://api.pagerduty.com\";\nconst MAX_RETRIES: u32 = 3;\nconst DEFAULT_RETRY_SECS: u64 = 5;\n\n/// PagerDuty API trait for testability\n#[allow(dead_code)]\npub trait PagerDutyApi: Send + Sync {\n    /// Get current user\n    fn get_current_user(\u0026self) -\u003e impl Future\u003cOutput = Result\u003cUser\u003e\u003e + Send;\n\n    /// List who's on call\n    fn list_oncalls(\n        \u0026self,\n        schedule_ids: Option\u003c\u0026[String]\u003e,\n        escalation_policy_ids: Option\u003c\u0026[String]\u003e,\n    ) -\u003e impl Future\u003cOutput = Result\u003cVec\u003cOncall\u003e\u003e\u003e + Send;\n\n    /// List incidents\n    fn list_incidents(\n        \u0026self,\n        statuses: \u0026[IncidentStatus],\n        limit: usize,\n    ) -\u003e impl Future\u003cOutput = Result\u003cVec\u003cIncident\u003e\u003e\u003e + Send;\n\n    /// Get single incident\n    fn get_incident(\u0026self, id: \u0026str) -\u003e impl Future\u003cOutput = Result\u003cIncident\u003e\u003e + Send;\n\n    /// List services\n    fn list_services(\u0026self) -\u003e impl Future\u003cOutput = Result\u003cVec\u003cService\u003e\u003e\u003e + Send;\n}\n\n/// PagerDuty HTTP client\npub struct PagerDutyClient {\n    config: PagerDutyConfig,\n    http: Client,\n}\n\nimpl PagerDutyClient {\n    /// Create a new client\n    pub fn new() -\u003e Result\u003cSelf\u003e {\n        let config = load_config()?;\n        let http = Client::builder().user_agent(\"hu-cli/0.1.0\").build()?;\n        Ok(Self { config, http })\n    }\n\n    /// Get API token\n    fn api_token(\u0026self) -\u003e Result\u003c\u0026str\u003e {\n        self.config\n            .api_token\n            .as_deref()\n            .ok_or_else(|| anyhow::anyhow!(\"PagerDuty API token not configured\"))\n    }\n\n    /// Make authenticated GET request\n    async fn get\u003cT: DeserializeOwned\u003e(\u0026self, path: \u0026str) -\u003e Result\u003cT\u003e {\n        self.get_with_params(path, \u0026[]).await\n    }\n\n    /// Make authenticated GET request with query parameters\n    async fn get_with_params\u003cT: DeserializeOwned\u003e(\n        \u0026self,\n        path: \u0026str,\n        params: \u0026[(\u0026str, String)],\n    ) -\u003e Result\u003cT\u003e {\n        let token = self.api_token()?.to_string();\n        let url = format!(\"{}{}\", PAGERDUTY_API_URL, path);\n        let params: Vec\u003c(String, String)\u003e = params\n            .iter()\n            .map(|(k, v)| (k.to_string(), v.clone()))\n            .collect();\n\n        self.execute_with_retry(|| {\n            self.http\n                .get(\u0026url)\n                .header(\"Authorization\", format!(\"Token token={}\", token))\n                .header(\"Content-Type\", \"application/json\")\n                .query(\u0026params)\n                .send()\n        })\n        .await\n    }\n\n    /// Execute request with retry on rate limit\n    async fn execute_with_retry\u003cF, Fut, T\u003e(\u0026self, request_fn: F) -\u003e Result\u003cT\u003e\n    where\n        F: Fn() -\u003e Fut,\n        Fut: std::future::Future\u003cOutput = Result\u003creqwest::Response, reqwest::Error\u003e\u003e,\n        T: DeserializeOwned,\n    {\n        let mut retries = 0;\n\n        loop {\n            let response = request_fn().await?;\n            let status = response.status();\n\n            if status == reqwest::StatusCode::TOO_MANY_REQUESTS {\n                if retries \u003e= MAX_RETRIES {\n                    return Err(anyhow::anyhow!(\n                        \"Rate limited after {} retries\",\n                        MAX_RETRIES\n                    ));\n                }\n\n                let retry_after = response\n                    .headers()\n                    .get(\"retry-after\")\n                    .and_then(|v| v.to_str().ok())\n                    .and_then(|s| s.parse::\u003cu64\u003e().ok())\n                    .unwrap_or(DEFAULT_RETRY_SECS);\n\n                eprintln!(\n                    \"Rate limited, waiting {} seconds... (retry {}/{})\",\n                    retry_after,\n                    retries + 1,\n                    MAX_RETRIES\n                );\n                sleep(Duration::from_secs(retry_after)).await;\n                retries += 1;\n                continue;\n            }\n\n            if !status.is_success() {\n                let body = response.text().await.unwrap_or_default();\n                return Err(anyhow::anyhow!(\"HTTP {}: {}\", status.as_u16(), body));\n            }\n\n            let text = response.text().await?;\n            return serde_json::from_str(\u0026text).map_err(|e| {\n                anyhow::anyhow!(\"Parse error: {}: {}\", e, \u0026text[..text.len().min(200)])\n            });\n        }\n    }\n}\n\nimpl PagerDutyApi for PagerDutyClient {\n    async fn get_current_user(\u0026self) -\u003e Result\u003cUser\u003e {\n        let resp: CurrentUserResponse = self.get(\"/users/me\").await?;\n        Ok(resp.user)\n    }\n\n    async fn list_oncalls(\n        \u0026self,\n        schedule_ids: Option\u003c\u0026[String]\u003e,\n        escalation_policy_ids: Option\u003c\u0026[String]\u003e,\n    ) -\u003e Result\u003cVec\u003cOncall\u003e\u003e {\n        let params = build_oncall_params(schedule_ids, escalation_policy_ids);\n        let resp: OncallsResponse = self.get_with_params(\"/oncalls\", \u0026params).await?;\n        Ok(resp.oncalls)\n    }\n\n    async fn list_incidents(\n        \u0026self,\n        statuses: \u0026[IncidentStatus],\n        limit: usize,\n    ) -\u003e Result\u003cVec\u003cIncident\u003e\u003e {\n        let params = build_incidents_params(statuses, limit);\n        let resp: IncidentsResponse = self.get_with_params(\"/incidents\", \u0026params).await?;\n        Ok(resp.incidents)\n    }\n\n    async fn get_incident(\u0026self, id: \u0026str) -\u003e Result\u003cIncident\u003e {\n        let path = format!(\"/incidents/{}\", id);\n        let resp: IncidentResponse = self.get(\u0026path).await?;\n        Ok(resp.incident)\n    }\n\n    async fn list_services(\u0026self) -\u003e Result\u003cVec\u003cService\u003e\u003e {\n        let resp: ServicesResponse = self.get(\"/services\").await?;\n        Ok(resp.services)\n    }\n}\n\n/// Build query parameters for oncalls endpoint\nfn build_oncall_params(\n    schedule_ids: Option\u003c\u0026[String]\u003e,\n    escalation_policy_ids: Option\u003c\u0026[String]\u003e,\n) -\u003e Vec\u003c(\u0026'static str, String)\u003e {\n    let mut params = Vec::new();\n\n    if let Some(ids) = schedule_ids {\n        for id in ids {\n            params.push((\"schedule_ids[]\", id.clone()));\n        }\n    }\n\n    if let Some(ids) = escalation_policy_ids {\n        for id in ids {\n            params.push((\"escalation_policy_ids[]\", id.clone()));\n        }\n    }\n\n    params\n}\n\n/// Build query parameters for incidents endpoint\nfn build_incidents_params(\n    statuses: \u0026[IncidentStatus],\n    limit: usize,\n) -\u003e Vec\u003c(\u0026'static str, String)\u003e {\n    let mut params = vec![(\"limit\", limit.to_string())];\n\n    for status in statuses {\n        params.push((\"statuses[]\", status.as_str().to_string()));\n    }\n\n    params\n}\n","traces":[{"line":58,"address":[],"length":0,"stats":{"Line":5}},{"line":59,"address":[],"length":0,"stats":{"Line":10}},{"line":60,"address":[],"length":0,"stats":{"Line":20}},{"line":61,"address":[],"length":0,"stats":{"Line":5}},{"line":65,"address":[],"length":0,"stats":{"Line":2}},{"line":66,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":1}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":72,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":1}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":4}},{"line":201,"address":[],"length":0,"stats":{"Line":8}},{"line":203,"address":[],"length":0,"stats":{"Line":6}},{"line":204,"address":[],"length":0,"stats":{"Line":11}},{"line":205,"address":[],"length":0,"stats":{"Line":9}},{"line":209,"address":[],"length":0,"stats":{"Line":6}},{"line":210,"address":[],"length":0,"stats":{"Line":8}},{"line":211,"address":[],"length":0,"stats":{"Line":8}},{"line":215,"address":[],"length":0,"stats":{"Line":4}},{"line":219,"address":[],"length":0,"stats":{"Line":3}},{"line":223,"address":[],"length":0,"stats":{"Line":9}},{"line":225,"address":[],"length":0,"stats":{"Line":12}},{"line":226,"address":[],"length":0,"stats":{"Line":12}},{"line":229,"address":[],"length":0,"stats":{"Line":3}}],"covered":24,"coverable":85},{"path":["/","Users","chi","Projects","hu","src","pagerduty","client","tests.rs"],"content":"use super::*;\n\n#[test]\nfn build_oncall_params_empty() {\n    let params = build_oncall_params(None, None);\n    assert!(params.is_empty());\n}\n\n#[test]\nfn build_oncall_params_with_schedule() {\n    let schedules = vec![\"S1\".to_string(), \"S2\".to_string()];\n    let params = build_oncall_params(Some(\u0026schedules), None);\n    assert_eq!(params.len(), 2);\n    assert_eq!(params[0], (\"schedule_ids[]\", \"S1\".to_string()));\n    assert_eq!(params[1], (\"schedule_ids[]\", \"S2\".to_string()));\n}\n\n#[test]\nfn build_oncall_params_with_policy() {\n    let policies = vec![\"EP1\".to_string()];\n    let params = build_oncall_params(None, Some(\u0026policies));\n    assert_eq!(params.len(), 1);\n    assert_eq!(params[0], (\"escalation_policy_ids[]\", \"EP1\".to_string()));\n}\n\n#[test]\nfn build_oncall_params_with_both() {\n    let schedules = vec![\"S1\".to_string()];\n    let policies = vec![\"EP1\".to_string()];\n    let params = build_oncall_params(Some(\u0026schedules), Some(\u0026policies));\n    assert_eq!(params.len(), 2);\n}\n\n#[test]\nfn build_incidents_params_basic() {\n    let statuses = vec![IncidentStatus::Triggered];\n    let params = build_incidents_params(\u0026statuses, 25);\n    assert_eq!(params.len(), 2);\n    assert_eq!(params[0], (\"limit\", \"25\".to_string()));\n    assert_eq!(params[1], (\"statuses[]\", \"triggered\".to_string()));\n}\n\n#[test]\nfn build_incidents_params_multiple_statuses() {\n    let statuses = vec![IncidentStatus::Triggered, IncidentStatus::Acknowledged];\n    let params = build_incidents_params(\u0026statuses, 10);\n    assert_eq!(params.len(), 3);\n    assert_eq!(params[0], (\"limit\", \"10\".to_string()));\n    assert_eq!(params[1], (\"statuses[]\", \"triggered\".to_string()));\n    assert_eq!(params[2], (\"statuses[]\", \"acknowledged\".to_string()));\n}\n\n#[test]\nfn build_incidents_params_empty_statuses() {\n    let statuses: Vec\u003cIncidentStatus\u003e = vec![];\n    let params = build_incidents_params(\u0026statuses, 50);\n    assert_eq!(params.len(), 1);\n    assert_eq!(params[0], (\"limit\", \"50\".to_string()));\n}\n\n// Mock implementation for testing handlers\npub struct MockPagerDutyApi {\n    pub oncalls: Vec\u003cOncall\u003e,\n    pub incidents: Vec\u003cIncident\u003e,\n    pub services: Vec\u003cService\u003e,\n    pub current_user: Option\u003cUser\u003e,\n}\n\nimpl MockPagerDutyApi {\n    pub fn new() -\u003e Self {\n        Self {\n            oncalls: vec![],\n            incidents: vec![],\n            services: vec![],\n            current_user: None,\n        }\n    }\n\n    pub fn with_oncalls(mut self, oncalls: Vec\u003cOncall\u003e) -\u003e Self {\n        self.oncalls = oncalls;\n        self\n    }\n\n    pub fn with_incidents(mut self, incidents: Vec\u003cIncident\u003e) -\u003e Self {\n        self.incidents = incidents;\n        self\n    }\n\n    pub fn with_services(mut self, services: Vec\u003cService\u003e) -\u003e Self {\n        self.services = services;\n        self\n    }\n\n    pub fn with_user(mut self, user: User) -\u003e Self {\n        self.current_user = Some(user);\n        self\n    }\n}\n\nimpl PagerDutyApi for MockPagerDutyApi {\n    async fn get_current_user(\u0026self) -\u003e Result\u003cUser\u003e {\n        self.current_user\n            .clone()\n            .ok_or_else(|| anyhow::anyhow!(\"No user configured\"))\n    }\n\n    async fn list_oncalls(\n        \u0026self,\n        _schedule_ids: Option\u003c\u0026[String]\u003e,\n        _escalation_policy_ids: Option\u003c\u0026[String]\u003e,\n    ) -\u003e Result\u003cVec\u003cOncall\u003e\u003e {\n        Ok(self.oncalls.clone())\n    }\n\n    async fn list_incidents(\n        \u0026self,\n        _statuses: \u0026[IncidentStatus],\n        limit: usize,\n    ) -\u003e Result\u003cVec\u003cIncident\u003e\u003e {\n        Ok(self.incidents.iter().take(limit).cloned().collect())\n    }\n\n    async fn get_incident(\u0026self, id: \u0026str) -\u003e Result\u003cIncident\u003e {\n        self.incidents\n            .iter()\n            .find(|i| i.id == id)\n            .cloned()\n            .ok_or_else(|| anyhow::anyhow!(\"Incident not found: {}\", id))\n    }\n\n    async fn list_services(\u0026self) -\u003e Result\u003cVec\u003cService\u003e\u003e {\n        Ok(self.services.clone())\n    }\n}\n\n#[tokio::test]\nasync fn mock_list_oncalls() {\n    let oncall = make_test_oncall(\"U1\", \"Alice\");\n    let mock = MockPagerDutyApi::new().with_oncalls(vec![oncall]);\n\n    let result = mock.list_oncalls(None, None).await.unwrap();\n    assert_eq!(result.len(), 1);\n    assert_eq!(result[0].user.display_name(), \"Alice\");\n}\n\n#[tokio::test]\nasync fn mock_list_incidents_respects_limit() {\n    let incidents = vec![\n        make_test_incident(\"1\"),\n        make_test_incident(\"2\"),\n        make_test_incident(\"3\"),\n    ];\n    let mock = MockPagerDutyApi::new().with_incidents(incidents);\n\n    let result = mock\n        .list_incidents(\u0026[IncidentStatus::Triggered], 2)\n        .await\n        .unwrap();\n    assert_eq!(result.len(), 2);\n}\n\n#[tokio::test]\nasync fn mock_get_incident() {\n    let incidents = vec![make_test_incident(\"INC1\"), make_test_incident(\"INC2\")];\n    let mock = MockPagerDutyApi::new().with_incidents(incidents);\n\n    let result = mock.get_incident(\"INC1\").await.unwrap();\n    assert_eq!(result.id, \"INC1\");\n}\n\n#[tokio::test]\nasync fn mock_get_incident_not_found() {\n    let mock = MockPagerDutyApi::new();\n    let result = mock.get_incident(\"MISSING\").await;\n    assert!(result.is_err());\n}\n\n#[tokio::test]\nasync fn mock_get_current_user() {\n    let user = make_test_user(\"U1\", \"Alice\");\n    let mock = MockPagerDutyApi::new().with_user(user);\n\n    let result = mock.get_current_user().await.unwrap();\n    assert_eq!(result.display_name(), \"Alice\");\n}\n\n#[tokio::test]\nasync fn mock_get_current_user_not_configured() {\n    let mock = MockPagerDutyApi::new();\n    let result = mock.get_current_user().await;\n    assert!(result.is_err());\n}\n\n#[tokio::test]\nasync fn mock_list_services() {\n    let services = vec![make_test_service(\"S1\", \"Production\")];\n    let mock = MockPagerDutyApi::new().with_services(services);\n\n    let result = mock.list_services().await.unwrap();\n    assert_eq!(result.len(), 1);\n    assert_eq!(result[0].name, \"Production\");\n}\n\n#[test]\nfn client_new_creates_instance() {\n    // This tests the happy path of client creation\n    let result = PagerDutyClient::new();\n    assert!(result.is_ok());\n}\n\n#[test]\nfn api_token_returns_error_when_not_set() {\n    let client = PagerDutyClient::new().unwrap();\n    // If no token is configured, api_token() should return error\n    // This depends on whether PAGERDUTY_API_TOKEN env var is set\n    let result = client.api_token();\n    // Just exercise the code path\n    let _ = result;\n}\n\n#[test]\nfn mock_builder_pattern() {\n    // Test that all builder methods work correctly\n    let user = make_test_user(\"U1\", \"Alice\");\n    let oncalls = vec![make_test_oncall(\"U1\", \"Alice\")];\n    let incidents = vec![make_test_incident(\"INC1\")];\n    let services = vec![make_test_service(\"S1\", \"Production\")];\n\n    let mock = MockPagerDutyApi::new()\n        .with_user(user.clone())\n        .with_oncalls(oncalls.clone())\n        .with_incidents(incidents.clone())\n        .with_services(services.clone());\n\n    assert_eq!(mock.current_user.as_ref().unwrap().id, \"U1\");\n    assert_eq!(mock.oncalls.len(), 1);\n    assert_eq!(mock.incidents.len(), 1);\n    assert_eq!(mock.services.len(), 1);\n}\n\n// Test data helpers\nfn make_test_user(id: \u0026str, name: \u0026str) -\u003e User {\n    User {\n        id: id.to_string(),\n        name: Some(name.to_string()),\n        summary: None,\n        email: format!(\"{}@example.com\", name.to_lowercase()),\n        html_url: String::new(),\n    }\n}\n\nfn make_test_oncall(user_id: \u0026str, user_name: \u0026str) -\u003e Oncall {\n    use super::super::types::{EscalationPolicy, Schedule};\n\n    Oncall {\n        user: make_test_user(user_id, user_name),\n        schedule: Some(Schedule {\n            id: \"S1\".to_string(),\n            name: \"Weekly Rotation\".to_string(),\n            html_url: String::new(),\n        }),\n        escalation_policy: EscalationPolicy {\n            id: \"EP1\".to_string(),\n            name: \"Primary\".to_string(),\n            html_url: String::new(),\n        },\n        escalation_level: 1,\n        start: Some(\"2026-01-01T00:00:00Z\".to_string()),\n        end: Some(\"2026-01-08T00:00:00Z\".to_string()),\n    }\n}\n\nfn make_test_incident(id: \u0026str) -\u003e Incident {\n    use super::super::types::Urgency;\n\n    Incident {\n        id: id.to_string(),\n        incident_number: id.parse().unwrap_or(1),\n        title: format!(\"Test incident {}\", id),\n        status: IncidentStatus::Triggered,\n        urgency: Urgency::High,\n        created_at: \"2026-01-01T12:00:00Z\".to_string(),\n        html_url: String::new(),\n        service: make_test_service(\"S1\", \"Production\"),\n        assignments: vec![],\n    }\n}\n\nfn make_test_service(id: \u0026str, name: \u0026str) -\u003e Service {\n    Service {\n        id: id.to_string(),\n        name: name.to_string(),\n        status: \"active\".to_string(),\n        html_url: String::new(),\n    }\n}\n","traces":[{"line":70,"address":[],"length":0,"stats":{"Line":8}},{"line":72,"address":[],"length":0,"stats":{"Line":16}},{"line":73,"address":[],"length":0,"stats":{"Line":16}},{"line":74,"address":[],"length":0,"stats":{"Line":8}},{"line":79,"address":[],"length":0,"stats":{"Line":2}},{"line":80,"address":[],"length":0,"stats":{"Line":4}},{"line":81,"address":[],"length":0,"stats":{"Line":2}},{"line":84,"address":[],"length":0,"stats":{"Line":3}},{"line":85,"address":[],"length":0,"stats":{"Line":6}},{"line":86,"address":[],"length":0,"stats":{"Line":3}},{"line":89,"address":[],"length":0,"stats":{"Line":2}},{"line":90,"address":[],"length":0,"stats":{"Line":4}},{"line":91,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":2}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":96,"address":[],"length":0,"stats":{"Line":2}},{"line":101,"address":[],"length":0,"stats":{"Line":4}},{"line":102,"address":[],"length":0,"stats":{"Line":2}},{"line":104,"address":[],"length":0,"stats":{"Line":4}},{"line":107,"address":[],"length":0,"stats":{"Line":1}},{"line":112,"address":[],"length":0,"stats":{"Line":1}},{"line":115,"address":[],"length":0,"stats":{"Line":1}},{"line":120,"address":[],"length":0,"stats":{"Line":4}},{"line":123,"address":[],"length":0,"stats":{"Line":4}},{"line":124,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":4}},{"line":128,"address":[],"length":0,"stats":{"Line":4}},{"line":131,"address":[],"length":0,"stats":{"Line":2}},{"line":132,"address":[],"length":0,"stats":{"Line":1}},{"line":249,"address":[],"length":0,"stats":{"Line":4}},{"line":251,"address":[],"length":0,"stats":{"Line":12}},{"line":252,"address":[],"length":0,"stats":{"Line":8}},{"line":254,"address":[],"length":0,"stats":{"Line":16}},{"line":255,"address":[],"length":0,"stats":{"Line":4}},{"line":259,"address":[],"length":0,"stats":{"Line":2}},{"line":263,"address":[],"length":0,"stats":{"Line":8}},{"line":264,"address":[],"length":0,"stats":{"Line":4}},{"line":269,"address":[],"length":0,"stats":{"Line":4}},{"line":275,"address":[],"length":0,"stats":{"Line":4}},{"line":276,"address":[],"length":0,"stats":{"Line":2}},{"line":280,"address":[],"length":0,"stats":{"Line":6}},{"line":284,"address":[],"length":0,"stats":{"Line":18}},{"line":285,"address":[],"length":0,"stats":{"Line":24}},{"line":286,"address":[],"length":0,"stats":{"Line":18}},{"line":289,"address":[],"length":0,"stats":{"Line":18}},{"line":290,"address":[],"length":0,"stats":{"Line":12}},{"line":291,"address":[],"length":0,"stats":{"Line":18}},{"line":292,"address":[],"length":0,"stats":{"Line":6}},{"line":296,"address":[],"length":0,"stats":{"Line":8}},{"line":298,"address":[],"length":0,"stats":{"Line":24}},{"line":299,"address":[],"length":0,"stats":{"Line":24}},{"line":300,"address":[],"length":0,"stats":{"Line":16}},{"line":301,"address":[],"length":0,"stats":{"Line":8}}],"covered":53,"coverable":53},{"path":["/","Users","chi","Projects","hu","src","pagerduty","config.rs"],"content":"//! PagerDuty configuration\n//!\n//! Loads configuration from `~/.config/hu/settings.toml`\n\nuse anyhow::Result;\nuse serde::{Deserialize, Serialize};\nuse std::fs;\nuse std::path::PathBuf;\n\n/// PagerDuty configuration\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct PagerDutyConfig {\n    /// API token\n    pub api_token: Option\u003cString\u003e,\n    /// Default escalation policy IDs (for filtering oncall)\n    #[serde(default)]\n    pub escalation_policy_ids: Vec\u003cString\u003e,\n    /// Default schedule IDs (for filtering oncall)\n    #[serde(default)]\n    pub schedule_ids: Vec\u003cString\u003e,\n}\n\nimpl PagerDutyConfig {\n    /// Check if configured with API token\n    #[must_use]\n    pub fn is_configured(\u0026self) -\u003e bool {\n        self.api_token.is_some()\n    }\n}\n\n/// Settings file structure\n#[derive(Debug, Default, Deserialize)]\nstruct SettingsFile {\n    pagerduty: Option\u003cPagerDutyConfig\u003e,\n}\n\n/// Get path to config file\npub fn config_path() -\u003e Option\u003cPathBuf\u003e {\n    dirs::home_dir().map(|p| p.join(\".config\").join(\"hu\").join(\"settings.toml\"))\n}\n\n/// Load PagerDuty config from settings file and environment\npub fn load_config() -\u003e Result\u003cPagerDutyConfig\u003e {\n    let mut config = PagerDutyConfig::default();\n\n    // Load from settings file\n    if let Some(path) = config_path() {\n        if path.exists() {\n            let contents = fs::read_to_string(\u0026path)?;\n            config = parse_config(\u0026contents)?;\n        }\n    }\n\n    // Override with environment variables\n    if let Ok(token) = std::env::var(\"PAGERDUTY_API_TOKEN\") {\n        config.api_token = Some(token);\n    }\n\n    Ok(config)\n}\n\n/// Parse config from TOML string\nfn parse_config(contents: \u0026str) -\u003e Result\u003cPagerDutyConfig\u003e {\n    let settings: SettingsFile = toml::from_str(contents)?;\n    Ok(settings.pagerduty.unwrap_or_default())\n}\n\n/// Save API token to config file\npub fn save_config(api_token: \u0026str) -\u003e Result\u003c()\u003e {\n    let path = config_path().ok_or_else(|| anyhow::anyhow!(\"Cannot determine config directory\"))?;\n\n    // Read existing or create new\n    let contents = if path.exists() {\n        fs::read_to_string(\u0026path)?\n    } else {\n        String::new()\n    };\n\n    let output = update_config_toml(\u0026contents, api_token)?;\n\n    // Ensure parent directory exists\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent)?;\n    }\n\n    fs::write(\u0026path, output)?;\n    Ok(())\n}\n\n/// Update TOML config with new API token\nfn update_config_toml(contents: \u0026str, api_token: \u0026str) -\u003e Result\u003cString\u003e {\n    // Parse as TOML value\n    let mut doc: toml::Value =\n        toml::from_str(contents).unwrap_or_else(|_| toml::Value::Table(toml::map::Map::new()));\n\n    // Ensure pagerduty section exists\n    let table = doc\n        .as_table_mut()\n        .ok_or_else(|| anyhow::anyhow!(\"Config is not a table\"))?;\n\n    if !table.contains_key(\"pagerduty\") {\n        table.insert(\n            \"pagerduty\".to_string(),\n            toml::Value::Table(toml::map::Map::new()),\n        );\n    }\n\n    let pagerduty = table\n        .get_mut(\"pagerduty\")\n        .and_then(|v| v.as_table_mut())\n        .ok_or_else(|| anyhow::anyhow!(\"pagerduty section is not a table\"))?;\n\n    pagerduty.insert(\n        \"api_token\".to_string(),\n        toml::Value::String(api_token.to_string()),\n    );\n\n    toml::to_string_pretty(\u0026doc).map_err(Into::into)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn config_is_configured_with_token() {\n        let config = PagerDutyConfig {\n            api_token: Some(\"token\".to_string()),\n            ..Default::default()\n        };\n        assert!(config.is_configured());\n    }\n\n    #[test]\n    fn config_is_not_configured_without_token() {\n        let config = PagerDutyConfig::default();\n        assert!(!config.is_configured());\n    }\n\n    #[test]\n    fn config_default_has_empty_vectors() {\n        let config = PagerDutyConfig::default();\n        assert!(config.escalation_policy_ids.is_empty());\n        assert!(config.schedule_ids.is_empty());\n    }\n\n    #[test]\n    fn config_path_returns_some() {\n        // May return None in CI without home dir, just verify no panic\n        let _ = config_path();\n    }\n\n    #[test]\n    fn parse_config_empty() {\n        let config = parse_config(\"\").unwrap();\n        assert!(!config.is_configured());\n    }\n\n    #[test]\n    fn parse_config_with_pagerduty_section() {\n        let toml = r#\"\n[pagerduty]\napi_token = \"test-token\"\n\"#;\n        let config = parse_config(toml).unwrap();\n        assert!(config.is_configured());\n        assert_eq!(config.api_token.as_deref(), Some(\"test-token\"));\n    }\n\n    #[test]\n    fn parse_config_with_policy_ids() {\n        let toml = r#\"\n[pagerduty]\napi_token = \"test-token\"\nescalation_policy_ids = [\"EP1\", \"EP2\"]\nschedule_ids = [\"S1\"]\n\"#;\n        let config = parse_config(toml).unwrap();\n        assert_eq!(config.escalation_policy_ids, vec![\"EP1\", \"EP2\"]);\n        assert_eq!(config.schedule_ids, vec![\"S1\"]);\n    }\n\n    #[test]\n    fn parse_config_other_sections_ignored() {\n        let toml = r#\"\n[sentry]\nauth_token = \"sentry-token\"\n\n[pagerduty]\napi_token = \"pd-token\"\n\"#;\n        let config = parse_config(toml).unwrap();\n        assert_eq!(config.api_token.as_deref(), Some(\"pd-token\"));\n    }\n\n    #[test]\n    fn update_config_toml_empty() {\n        let result = update_config_toml(\"\", \"new-token\").unwrap();\n        assert!(result.contains(\"api_token = \\\"new-token\\\"\"));\n        assert!(result.contains(\"[pagerduty]\"));\n    }\n\n    #[test]\n    fn update_config_toml_existing_section() {\n        let existing = r#\"\n[pagerduty]\napi_token = \"old-token\"\n\"#;\n        let result = update_config_toml(existing, \"new-token\").unwrap();\n        assert!(result.contains(\"api_token = \\\"new-token\\\"\"));\n        assert!(!result.contains(\"old-token\"));\n    }\n\n    #[test]\n    fn update_config_toml_preserves_other_sections() {\n        let existing = r#\"\n[sentry]\nauth_token = \"sentry-token\"\n\"#;\n        let result = update_config_toml(existing, \"pd-token\").unwrap();\n        assert!(result.contains(\"sentry-token\"));\n        assert!(result.contains(\"pd-token\"));\n    }\n\n    #[test]\n    fn update_config_toml_preserves_other_pagerduty_fields() {\n        let existing = r#\"\n[pagerduty]\napi_token = \"old-token\"\nescalation_policy_ids = [\"EP1\"]\n\"#;\n        let result = update_config_toml(existing, \"new-token\").unwrap();\n        assert!(result.contains(\"api_token = \\\"new-token\\\"\"));\n        assert!(result.contains(\"EP1\"));\n    }\n\n    #[test]\n    fn config_debug() {\n        let config = PagerDutyConfig::default();\n        let debug = format!(\"{:?}\", config);\n        assert!(debug.contains(\"PagerDutyConfig\"));\n    }\n\n    #[test]\n    fn config_clone() {\n        let config = PagerDutyConfig {\n            api_token: Some(\"token\".to_string()),\n            escalation_policy_ids: vec![\"EP1\".to_string()],\n            schedule_ids: vec![\"S1\".to_string()],\n        };\n        let cloned = config.clone();\n        assert_eq!(cloned.api_token, config.api_token);\n        assert_eq!(cloned.escalation_policy_ids, config.escalation_policy_ids);\n    }\n\n    #[test]\n    fn load_config_returns_default_when_no_file() {\n        // load_config should work even when config file doesn't exist\n        // It will return default config (possibly with env var override)\n        let result = load_config();\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn load_config_env_override() {\n        // Test that environment variable overrides config file\n        // Save current value and restore after test\n        let original = std::env::var(\"PAGERDUTY_API_TOKEN\").ok();\n\n        std::env::set_var(\"PAGERDUTY_API_TOKEN\", \"env-token-test-12345\");\n        let result = load_config();\n        assert!(result.is_ok());\n        let config = result.unwrap();\n        assert_eq!(config.api_token.as_deref(), Some(\"env-token-test-12345\"));\n\n        // Restore original value\n        match original {\n            Some(val) =\u003e std::env::set_var(\"PAGERDUTY_API_TOKEN\", val),\n            None =\u003e std::env::remove_var(\"PAGERDUTY_API_TOKEN\"),\n        }\n    }\n\n    #[test]\n    fn parse_config_invalid_toml() {\n        let invalid = \"this is not valid [[[toml\";\n        let result = parse_config(invalid);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn parse_config_wrong_type_for_pagerduty() {\n        // pagerduty is a string instead of a table\n        let toml = r#\"pagerduty = \"not a table\"\"#;\n        let result = parse_config(toml);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn update_config_toml_invalid_existing() {\n        // Invalid TOML should still work - it creates a new table\n        let invalid = \"this is not valid [[[toml\";\n        let result = update_config_toml(invalid, \"new-token\");\n        // Should succeed by creating fresh config\n        assert!(result.is_ok());\n        assert!(result.unwrap().contains(\"api_token\"));\n    }\n\n    #[test]\n    fn settings_file_default() {\n        let settings = SettingsFile::default();\n        assert!(settings.pagerduty.is_none());\n    }\n\n    #[test]\n    fn settings_file_debug() {\n        let settings = SettingsFile::default();\n        let debug = format!(\"{:?}\", settings);\n        assert!(debug.contains(\"SettingsFile\"));\n    }\n\n    #[test]\n    fn config_serialize() {\n        let config = PagerDutyConfig {\n            api_token: Some(\"token\".to_string()),\n            escalation_policy_ids: vec![\"EP1\".to_string()],\n            schedule_ids: vec![],\n        };\n        let json = serde_json::to_string(\u0026config).unwrap();\n        assert!(json.contains(\"token\"));\n        assert!(json.contains(\"EP1\"));\n    }\n\n    #[test]\n    fn config_deserialize() {\n        let json = r#\"{\n            \"api_token\": \"test-token\",\n            \"escalation_policy_ids\": [\"EP1\"],\n            \"schedule_ids\": []\n        }\"#;\n        let config: PagerDutyConfig = serde_json::from_str(json).unwrap();\n        assert_eq!(config.api_token.as_deref(), Some(\"test-token\"));\n        assert_eq!(config.escalation_policy_ids, vec![\"EP1\"]);\n    }\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":7}},{"line":27,"address":[],"length":0,"stats":{"Line":14}},{"line":38,"address":[],"length":0,"stats":{"Line":12}},{"line":39,"address":[],"length":0,"stats":{"Line":48}},{"line":43,"address":[],"length":0,"stats":{"Line":10}},{"line":44,"address":[],"length":0,"stats":{"Line":20}},{"line":47,"address":[],"length":0,"stats":{"Line":20}},{"line":48,"address":[],"length":0,"stats":{"Line":10}},{"line":49,"address":[],"length":0,"stats":{"Line":30}},{"line":50,"address":[],"length":0,"stats":{"Line":30}},{"line":55,"address":[],"length":0,"stats":{"Line":12}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":59,"address":[],"length":0,"stats":{"Line":10}},{"line":63,"address":[],"length":0,"stats":{"Line":16}},{"line":64,"address":[],"length":0,"stats":{"Line":62}},{"line":65,"address":[],"length":0,"stats":{"Line":14}},{"line":69,"address":[],"length":0,"stats":{"Line":1}},{"line":70,"address":[],"length":0,"stats":{"Line":3}},{"line":73,"address":[],"length":0,"stats":{"Line":2}},{"line":74,"address":[],"length":0,"stats":{"Line":2}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":4}},{"line":82,"address":[],"length":0,"stats":{"Line":2}},{"line":83,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":3}},{"line":87,"address":[],"length":0,"stats":{"Line":1}},{"line":91,"address":[],"length":0,"stats":{"Line":6}},{"line":93,"address":[],"length":0,"stats":{"Line":12}},{"line":94,"address":[],"length":0,"stats":{"Line":19}},{"line":97,"address":[],"length":0,"stats":{"Line":12}},{"line":99,"address":[],"length":0,"stats":{"Line":6}},{"line":101,"address":[],"length":0,"stats":{"Line":15}},{"line":102,"address":[],"length":0,"stats":{"Line":9}},{"line":103,"address":[],"length":0,"stats":{"Line":6}},{"line":104,"address":[],"length":0,"stats":{"Line":3}},{"line":108,"address":[],"length":0,"stats":{"Line":12}},{"line":110,"address":[],"length":0,"stats":{"Line":18}},{"line":111,"address":[],"length":0,"stats":{"Line":6}},{"line":113,"address":[],"length":0,"stats":{"Line":12}},{"line":114,"address":[],"length":0,"stats":{"Line":12}},{"line":115,"address":[],"length":0,"stats":{"Line":6}},{"line":118,"address":[],"length":0,"stats":{"Line":18}}],"covered":41,"coverable":42},{"path":["/","Users","chi","Projects","hu","src","pagerduty","display","mod.rs"],"content":"//! PagerDuty output formatting\n\nuse anyhow::{Context, Result};\nuse comfy_table::{presets::UTF8_FULL_CONDENSED, Cell, Color, ContentArrangement, Table};\n\nuse super::config::PagerDutyConfig;\nuse super::types::{Incident, IncidentStatus, Oncall, OutputFormat};\n\n#[cfg(test)]\nmod tests;\n\n/// Color for incident status\nfn status_color(status: IncidentStatus) -\u003e Color {\n    match status {\n        IncidentStatus::Triggered =\u003e Color::Red,\n        IncidentStatus::Acknowledged =\u003e Color::Yellow,\n        IncidentStatus::Resolved =\u003e Color::Green,\n    }\n}\n\n/// Status icon\nfn status_icon(status: IncidentStatus) -\u003e \u0026'static str {\n    match status {\n        IncidentStatus::Triggered =\u003e \"!\",\n        IncidentStatus::Acknowledged =\u003e \"~\",\n        IncidentStatus::Resolved =\u003e \"\",\n    }\n}\n\n/// Format relative time from ISO8601 timestamp\nfn time_ago(timestamp: \u0026str) -\u003e String {\n    let Ok(dt) = chrono::DateTime::parse_from_rfc3339(timestamp) else {\n        return timestamp.to_string();\n    };\n\n    let now = chrono::Utc::now();\n    let duration = now.signed_duration_since(dt);\n\n    if duration.num_days() \u003e 0 {\n        format!(\"{}d ago\", duration.num_days())\n    } else if duration.num_hours() \u003e 0 {\n        format!(\"{}h ago\", duration.num_hours())\n    } else if duration.num_minutes() \u003e 0 {\n        format!(\"{}m ago\", duration.num_minutes())\n    } else {\n        \"just now\".to_string()\n    }\n}\n\n/// Truncate string to max length\nfn truncate(s: \u0026str, max_len: usize) -\u003e String {\n    if s.len() \u003c= max_len {\n        s.to_string()\n    } else {\n        format!(\"{}...\", \u0026s[..max_len.saturating_sub(3)])\n    }\n}\n\n/// Output oncalls list\npub fn output_oncalls(oncalls: \u0026[Oncall], format: OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            if oncalls.is_empty() {\n                println!(\"No one is currently on call.\");\n                return Ok(());\n            }\n\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_content_arrangement(ContentArrangement::Dynamic);\n            table.set_header(vec![\"User\", \"Email\", \"Policy\", \"Level\", \"Schedule\"]);\n\n            for oncall in oncalls {\n                let schedule_name = oncall\n                    .schedule\n                    .as_ref()\n                    .map(|s| s.name.as_str())\n                    .unwrap_or(\"-\");\n\n                table.add_row(vec![\n                    Cell::new(oncall.user.display_name()).fg(Color::Cyan),\n                    Cell::new(\u0026oncall.user.email),\n                    Cell::new(truncate(\u0026oncall.escalation_policy.name, 25)),\n                    Cell::new(oncall.escalation_level.to_string()),\n                    Cell::new(truncate(schedule_name, 20)),\n                ]);\n            }\n\n            println!(\"{table}\");\n            println!(\"\\n{} on-call\", oncalls.len());\n        }\n        OutputFormat::Json =\u003e {\n            let json =\n                serde_json::to_string_pretty(oncalls).context(\"Failed to serialize oncalls\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n\n/// Output incidents list\npub fn output_incidents(incidents: \u0026[Incident], format: OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            if incidents.is_empty() {\n                println!(\"No incidents found.\");\n                return Ok(());\n            }\n\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_content_arrangement(ContentArrangement::Dynamic);\n            table.set_header(vec![\n                \"#\", \"Status\", \"Urgency\", \"Service\", \"Title\", \"Created\",\n            ]);\n\n            for incident in incidents {\n                let status_text = format!(\"{} {:?}\", status_icon(incident.status), incident.status);\n\n                table.add_row(vec![\n                    Cell::new(incident.incident_number.to_string()).fg(Color::Cyan),\n                    Cell::new(\u0026status_text).fg(status_color(incident.status)),\n                    Cell::new(format!(\"{:?}\", incident.urgency)),\n                    Cell::new(truncate(\u0026incident.service.name, 20)),\n                    Cell::new(truncate(\u0026incident.title, 40)),\n                    Cell::new(time_ago(\u0026incident.created_at)),\n                ]);\n            }\n\n            println!(\"{table}\");\n            println!(\"\\n{} incidents\", incidents.len());\n        }\n        OutputFormat::Json =\u003e {\n            let json =\n                serde_json::to_string_pretty(incidents).context(\"Failed to serialize incidents\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n\n/// Output single incident detail\npub fn output_incident_detail(incident: \u0026Incident, format: OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            println!(\"{}\", \"-\".repeat(60));\n            println!(\n                \"#{} - {}\",\n                incident.incident_number,\n                truncate(\u0026incident.title, 50)\n            );\n            println!(\"{}\", \"-\".repeat(60));\n            println!(\n                \"Status:   {} {:?}\",\n                status_icon(incident.status),\n                incident.status\n            );\n            println!(\"Urgency:  {:?}\", incident.urgency);\n            println!(\"Service:  {}\", incident.service.name);\n            println!(\"Created:  {}\", time_ago(\u0026incident.created_at));\n\n            if !incident.assignments.is_empty() {\n                println!(\"\\nAssigned to:\");\n                for assignment in \u0026incident.assignments {\n                    println!(\n                        \"  - {} ({})\",\n                        assignment.assignee.display_name(),\n                        assignment.assignee.email\n                    );\n                }\n            }\n\n            if !incident.html_url.is_empty() {\n                println!(\"\\nLink: {}\", incident.html_url);\n            }\n        }\n        OutputFormat::Json =\u003e {\n            let json =\n                serde_json::to_string_pretty(incident).context(\"Failed to serialize incident\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n\n/// Output config status\npub fn output_config_status(config: \u0026PagerDutyConfig) {\n    println!(\"PagerDuty Configuration\");\n    println!(\"{}\", \"-\".repeat(40));\n    println!(\n        \"API token:  {}\",\n        if config.api_token.is_some() {\n            \"Configured\"\n        } else {\n            \"Not set\"\n        }\n    );\n\n    if !config.escalation_policy_ids.is_empty() {\n        println!(\n            \"Default escalation policies: {}\",\n            config.escalation_policy_ids.join(\", \")\n        );\n    }\n\n    if !config.schedule_ids.is_empty() {\n        println!(\"Default schedules: {}\", config.schedule_ids.join(\", \"));\n    }\n}\n\n/// Output current user info\npub fn output_user(user: \u0026super::types::User, format: OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            println!(\"{}\", user.display_name());\n            if !user.email.is_empty() {\n                println!(\"{}\", user.email);\n            }\n            if !user.html_url.is_empty() {\n                println!(\"{}\", user.html_url);\n            }\n        }\n        OutputFormat::Json =\u003e {\n            let json = serde_json::to_string_pretty(user).context(\"Failed to serialize user\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":4}},{"line":14,"address":[],"length":0,"stats":{"Line":4}},{"line":15,"address":[],"length":0,"stats":{"Line":2}},{"line":16,"address":[],"length":0,"stats":{"Line":1}},{"line":17,"address":[],"length":0,"stats":{"Line":1}},{"line":22,"address":[],"length":0,"stats":{"Line":6}},{"line":23,"address":[],"length":0,"stats":{"Line":6}},{"line":24,"address":[],"length":0,"stats":{"Line":2}},{"line":25,"address":[],"length":0,"stats":{"Line":2}},{"line":26,"address":[],"length":0,"stats":{"Line":2}},{"line":31,"address":[],"length":0,"stats":{"Line":11}},{"line":32,"address":[],"length":0,"stats":{"Line":21}},{"line":33,"address":[],"length":0,"stats":{"Line":2}},{"line":36,"address":[],"length":0,"stats":{"Line":20}},{"line":37,"address":[],"length":0,"stats":{"Line":40}},{"line":39,"address":[],"length":0,"stats":{"Line":10}},{"line":40,"address":[],"length":0,"stats":{"Line":8}},{"line":41,"address":[],"length":0,"stats":{"Line":8}},{"line":42,"address":[],"length":0,"stats":{"Line":8}},{"line":43,"address":[],"length":0,"stats":{"Line":6}},{"line":44,"address":[],"length":0,"stats":{"Line":8}},{"line":46,"address":[],"length":0,"stats":{"Line":8}},{"line":51,"address":[],"length":0,"stats":{"Line":13}},{"line":52,"address":[],"length":0,"stats":{"Line":26}},{"line":53,"address":[],"length":0,"stats":{"Line":20}},{"line":55,"address":[],"length":0,"stats":{"Line":12}},{"line":60,"address":[],"length":0,"stats":{"Line":5}},{"line":61,"address":[],"length":0,"stats":{"Line":5}},{"line":63,"address":[],"length":0,"stats":{"Line":6}},{"line":64,"address":[],"length":0,"stats":{"Line":2}},{"line":65,"address":[],"length":0,"stats":{"Line":1}},{"line":68,"address":[],"length":0,"stats":{"Line":4}},{"line":69,"address":[],"length":0,"stats":{"Line":6}},{"line":70,"address":[],"length":0,"stats":{"Line":6}},{"line":71,"address":[],"length":0,"stats":{"Line":14}},{"line":73,"address":[],"length":0,"stats":{"Line":6}},{"line":74,"address":[],"length":0,"stats":{"Line":4}},{"line":75,"address":[],"length":0,"stats":{"Line":2}},{"line":77,"address":[],"length":0,"stats":{"Line":4}},{"line":80,"address":[],"length":0,"stats":{"Line":6}},{"line":81,"address":[],"length":0,"stats":{"Line":10}},{"line":82,"address":[],"length":0,"stats":{"Line":4}},{"line":83,"address":[],"length":0,"stats":{"Line":6}},{"line":84,"address":[],"length":0,"stats":{"Line":6}},{"line":85,"address":[],"length":0,"stats":{"Line":6}},{"line":89,"address":[],"length":0,"stats":{"Line":4}},{"line":90,"address":[],"length":0,"stats":{"Line":8}},{"line":93,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":6}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":98,"address":[],"length":0,"stats":{"Line":4}},{"line":102,"address":[],"length":0,"stats":{"Line":4}},{"line":103,"address":[],"length":0,"stats":{"Line":4}},{"line":105,"address":[],"length":0,"stats":{"Line":4}},{"line":106,"address":[],"length":0,"stats":{"Line":2}},{"line":107,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":2}},{"line":111,"address":[],"length":0,"stats":{"Line":3}},{"line":112,"address":[],"length":0,"stats":{"Line":3}},{"line":113,"address":[],"length":0,"stats":{"Line":3}},{"line":114,"address":[],"length":0,"stats":{"Line":5}},{"line":117,"address":[],"length":0,"stats":{"Line":4}},{"line":118,"address":[],"length":0,"stats":{"Line":6}},{"line":120,"address":[],"length":0,"stats":{"Line":4}},{"line":121,"address":[],"length":0,"stats":{"Line":6}},{"line":122,"address":[],"length":0,"stats":{"Line":6}},{"line":123,"address":[],"length":0,"stats":{"Line":4}},{"line":124,"address":[],"length":0,"stats":{"Line":4}},{"line":125,"address":[],"length":0,"stats":{"Line":4}},{"line":126,"address":[],"length":0,"stats":{"Line":2}},{"line":130,"address":[],"length":0,"stats":{"Line":2}},{"line":131,"address":[],"length":0,"stats":{"Line":4}},{"line":134,"address":[],"length":0,"stats":{"Line":2}},{"line":135,"address":[],"length":0,"stats":{"Line":6}},{"line":136,"address":[],"length":0,"stats":{"Line":4}},{"line":139,"address":[],"length":0,"stats":{"Line":3}},{"line":143,"address":[],"length":0,"stats":{"Line":3}},{"line":144,"address":[],"length":0,"stats":{"Line":3}},{"line":146,"address":[],"length":0,"stats":{"Line":8}},{"line":147,"address":[],"length":0,"stats":{"Line":2}},{"line":148,"address":[],"length":0,"stats":{"Line":2}},{"line":150,"address":[],"length":0,"stats":{"Line":4}},{"line":152,"address":[],"length":0,"stats":{"Line":8}},{"line":153,"address":[],"length":0,"stats":{"Line":2}},{"line":154,"address":[],"length":0,"stats":{"Line":2}},{"line":155,"address":[],"length":0,"stats":{"Line":4}},{"line":158,"address":[],"length":0,"stats":{"Line":4}},{"line":159,"address":[],"length":0,"stats":{"Line":4}},{"line":160,"address":[],"length":0,"stats":{"Line":8}},{"line":162,"address":[],"length":0,"stats":{"Line":2}},{"line":163,"address":[],"length":0,"stats":{"Line":2}},{"line":164,"address":[],"length":0,"stats":{"Line":4}},{"line":165,"address":[],"length":0,"stats":{"Line":2}},{"line":166,"address":[],"length":0,"stats":{"Line":2}},{"line":167,"address":[],"length":0,"stats":{"Line":1}},{"line":168,"address":[],"length":0,"stats":{"Line":1}},{"line":173,"address":[],"length":0,"stats":{"Line":3}},{"line":174,"address":[],"length":0,"stats":{"Line":1}},{"line":178,"address":[],"length":0,"stats":{"Line":1}},{"line":179,"address":[],"length":0,"stats":{"Line":3}},{"line":180,"address":[],"length":0,"stats":{"Line":2}},{"line":183,"address":[],"length":0,"stats":{"Line":3}},{"line":187,"address":[],"length":0,"stats":{"Line":5}},{"line":188,"address":[],"length":0,"stats":{"Line":10}},{"line":189,"address":[],"length":0,"stats":{"Line":20}},{"line":190,"address":[],"length":0,"stats":{"Line":5}},{"line":191,"address":[],"length":0,"stats":{"Line":5}},{"line":192,"address":[],"length":0,"stats":{"Line":10}},{"line":193,"address":[],"length":0,"stats":{"Line":4}},{"line":195,"address":[],"length":0,"stats":{"Line":1}},{"line":199,"address":[],"length":0,"stats":{"Line":6}},{"line":200,"address":[],"length":0,"stats":{"Line":2}},{"line":201,"address":[],"length":0,"stats":{"Line":2}},{"line":202,"address":[],"length":0,"stats":{"Line":2}},{"line":206,"address":[],"length":0,"stats":{"Line":6}},{"line":207,"address":[],"length":0,"stats":{"Line":4}},{"line":212,"address":[],"length":0,"stats":{"Line":3}},{"line":213,"address":[],"length":0,"stats":{"Line":3}},{"line":215,"address":[],"length":0,"stats":{"Line":8}},{"line":216,"address":[],"length":0,"stats":{"Line":3}},{"line":217,"address":[],"length":0,"stats":{"Line":1}},{"line":219,"address":[],"length":0,"stats":{"Line":3}},{"line":220,"address":[],"length":0,"stats":{"Line":1}},{"line":224,"address":[],"length":0,"stats":{"Line":4}},{"line":225,"address":[],"length":0,"stats":{"Line":2}},{"line":228,"address":[],"length":0,"stats":{"Line":3}}],"covered":126,"coverable":126},{"path":["/","Users","chi","Projects","hu","src","pagerduty","display","tests.rs"],"content":"use super::*;\n\n#[test]\nfn status_color_triggered_is_red() {\n    assert_eq!(status_color(IncidentStatus::Triggered), Color::Red);\n}\n\n#[test]\nfn status_color_acknowledged_is_yellow() {\n    assert_eq!(status_color(IncidentStatus::Acknowledged), Color::Yellow);\n}\n\n#[test]\nfn status_color_resolved_is_green() {\n    assert_eq!(status_color(IncidentStatus::Resolved), Color::Green);\n}\n\n#[test]\nfn status_icon_triggered() {\n    assert_eq!(status_icon(IncidentStatus::Triggered), \"!\");\n}\n\n#[test]\nfn status_icon_acknowledged() {\n    assert_eq!(status_icon(IncidentStatus::Acknowledged), \"~\");\n}\n\n#[test]\nfn status_icon_resolved() {\n    assert_eq!(status_icon(IncidentStatus::Resolved), \"\");\n}\n\n#[test]\nfn truncate_short_string() {\n    assert_eq!(truncate(\"hello\", 10), \"hello\");\n}\n\n#[test]\nfn truncate_exact_length() {\n    assert_eq!(truncate(\"hello\", 5), \"hello\");\n}\n\n#[test]\nfn truncate_long_string() {\n    assert_eq!(truncate(\"hello world\", 8), \"hello...\");\n}\n\n#[test]\nfn truncate_very_short_max() {\n    // Edge case: max_len less than 3\n    assert_eq!(truncate(\"hello\", 2), \"...\");\n}\n\n#[test]\nfn time_ago_invalid_timestamp() {\n    assert_eq!(time_ago(\"invalid\"), \"invalid\");\n}\n\n#[test]\nfn time_ago_days() {\n    // 5 days ago\n    let dt = chrono::Utc::now() - chrono::Duration::days(5);\n    let timestamp = dt.to_rfc3339();\n    assert_eq!(time_ago(\u0026timestamp), \"5d ago\");\n}\n\n#[test]\nfn time_ago_hours() {\n    // 3 hours ago\n    let dt = chrono::Utc::now() - chrono::Duration::hours(3);\n    let timestamp = dt.to_rfc3339();\n    assert_eq!(time_ago(\u0026timestamp), \"3h ago\");\n}\n\n#[test]\nfn time_ago_minutes() {\n    // 15 minutes ago\n    let dt = chrono::Utc::now() - chrono::Duration::minutes(15);\n    let timestamp = dt.to_rfc3339();\n    assert_eq!(time_ago(\u0026timestamp), \"15m ago\");\n}\n\n#[test]\nfn time_ago_just_now() {\n    // 30 seconds ago\n    let dt = chrono::Utc::now() - chrono::Duration::seconds(30);\n    let timestamp = dt.to_rfc3339();\n    assert_eq!(time_ago(\u0026timestamp), \"just now\");\n}\n\n#[test]\nfn output_config_status_not_configured() {\n    let config = PagerDutyConfig::default();\n    // Just verify it doesn't panic\n    output_config_status(\u0026config);\n}\n\n#[test]\nfn output_config_status_configured() {\n    let config = PagerDutyConfig {\n        api_token: Some(\"token\".to_string()),\n        escalation_policy_ids: vec![\"EP1\".to_string()],\n        schedule_ids: vec![\"S1\".to_string(), \"S2\".to_string()],\n    };\n    // Just verify it doesn't panic\n    output_config_status(\u0026config);\n}\n\n#[test]\nfn output_oncalls_empty() {\n    let result = output_oncalls(\u0026[], OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_incidents_empty() {\n    let result = output_incidents(\u0026[], OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_oncalls_json_empty() {\n    let result = output_oncalls(\u0026[], OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_incidents_json_empty() {\n    let result = output_incidents(\u0026[], OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_oncalls_with_data() {\n    use super::super::types::{EscalationPolicy, Schedule, User};\n\n    let oncalls = vec![Oncall {\n        user: User {\n            id: \"U1\".to_string(),\n            name: Some(\"Alice\".to_string()),\n            summary: None,\n            email: \"alice@example.com\".to_string(),\n            html_url: String::new(),\n        },\n        schedule: Some(Schedule {\n            id: \"S1\".to_string(),\n            name: \"Weekly\".to_string(),\n            html_url: String::new(),\n        }),\n        escalation_policy: EscalationPolicy {\n            id: \"EP1\".to_string(),\n            name: \"Primary\".to_string(),\n            html_url: String::new(),\n        },\n        escalation_level: 1,\n        start: None,\n        end: None,\n    }];\n\n    let result = output_oncalls(\u0026oncalls, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_incidents_with_data() {\n    use super::super::types::{Service, Urgency};\n\n    let incidents = vec![Incident {\n        id: \"INC1\".to_string(),\n        incident_number: 42,\n        title: \"Test incident\".to_string(),\n        status: IncidentStatus::Triggered,\n        urgency: Urgency::High,\n        created_at: chrono::Utc::now().to_rfc3339(),\n        html_url: String::new(),\n        service: Service {\n            id: \"S1\".to_string(),\n            name: \"Production\".to_string(),\n            status: \"active\".to_string(),\n            html_url: String::new(),\n        },\n        assignments: vec![],\n    }];\n\n    let result = output_incidents(\u0026incidents, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_incident_detail_table() {\n    use super::super::types::{Assignment, Service, Urgency, User};\n\n    let incident = Incident {\n        id: \"INC1\".to_string(),\n        incident_number: 42,\n        title: \"Server down\".to_string(),\n        status: IncidentStatus::Acknowledged,\n        urgency: Urgency::High,\n        created_at: chrono::Utc::now().to_rfc3339(),\n        html_url: \"https://pagerduty.com/incidents/INC1\".to_string(),\n        service: Service {\n            id: \"S1\".to_string(),\n            name: \"Production\".to_string(),\n            status: \"active\".to_string(),\n            html_url: String::new(),\n        },\n        assignments: vec![Assignment {\n            assignee: User {\n                id: \"U1\".to_string(),\n                name: Some(\"Alice\".to_string()),\n                summary: None,\n                email: \"alice@example.com\".to_string(),\n                html_url: String::new(),\n            },\n        }],\n    };\n\n    let result = output_incident_detail(\u0026incident, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_incident_detail_json() {\n    use super::super::types::{Service, Urgency};\n\n    let incident = Incident {\n        id: \"INC1\".to_string(),\n        incident_number: 42,\n        title: \"Server down\".to_string(),\n        status: IncidentStatus::Triggered,\n        urgency: Urgency::Low,\n        created_at: \"2026-01-01T12:00:00Z\".to_string(),\n        html_url: String::new(),\n        service: Service {\n            id: \"S1\".to_string(),\n            name: \"Production\".to_string(),\n            status: \"active\".to_string(),\n            html_url: String::new(),\n        },\n        assignments: vec![],\n    };\n\n    let result = output_incident_detail(\u0026incident, OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_user_table_format() {\n    use super::super::types::User;\n\n    let user = User {\n        id: \"U1\".to_string(),\n        name: Some(\"Alice Smith\".to_string()),\n        summary: None,\n        email: \"alice@example.com\".to_string(),\n        html_url: \"https://pagerduty.com/users/U1\".to_string(),\n    };\n\n    let result = output_user(\u0026user, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_user_json_format() {\n    use super::super::types::User;\n\n    let user = User {\n        id: \"U1\".to_string(),\n        name: Some(\"Alice Smith\".to_string()),\n        summary: None,\n        email: \"alice@example.com\".to_string(),\n        html_url: \"https://pagerduty.com/users/U1\".to_string(),\n    };\n\n    let result = output_user(\u0026user, OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_user_empty_email() {\n    use super::super::types::User;\n\n    let user = User {\n        id: \"U1\".to_string(),\n        name: Some(\"Alice\".to_string()),\n        summary: None,\n        email: String::new(),\n        html_url: String::new(),\n    };\n\n    let result = output_user(\u0026user, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_oncalls_without_schedule() {\n    use super::super::types::{EscalationPolicy, User};\n\n    let oncalls = vec![Oncall {\n        user: User {\n            id: \"U1\".to_string(),\n            name: Some(\"Alice\".to_string()),\n            summary: None,\n            email: \"alice@example.com\".to_string(),\n            html_url: String::new(),\n        },\n        schedule: None,\n        escalation_policy: EscalationPolicy {\n            id: \"EP1\".to_string(),\n            name: \"Primary\".to_string(),\n            html_url: String::new(),\n        },\n        escalation_level: 1,\n        start: None,\n        end: None,\n    }];\n\n    let result = output_oncalls(\u0026oncalls, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_oncalls_json_with_data() {\n    use super::super::types::{EscalationPolicy, Schedule, User};\n\n    let oncalls = vec![Oncall {\n        user: User {\n            id: \"U1\".to_string(),\n            name: Some(\"Alice\".to_string()),\n            summary: None,\n            email: \"alice@example.com\".to_string(),\n            html_url: String::new(),\n        },\n        schedule: Some(Schedule {\n            id: \"S1\".to_string(),\n            name: \"Weekly\".to_string(),\n            html_url: String::new(),\n        }),\n        escalation_policy: EscalationPolicy {\n            id: \"EP1\".to_string(),\n            name: \"Primary\".to_string(),\n            html_url: String::new(),\n        },\n        escalation_level: 1,\n        start: None,\n        end: None,\n    }];\n\n    let result = output_oncalls(\u0026oncalls, OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_incidents_json_with_data() {\n    use super::super::types::{Service, Urgency};\n\n    let incidents = vec![Incident {\n        id: \"INC1\".to_string(),\n        incident_number: 42,\n        title: \"Test incident\".to_string(),\n        status: IncidentStatus::Acknowledged,\n        urgency: Urgency::Low,\n        created_at: chrono::Utc::now().to_rfc3339(),\n        html_url: String::new(),\n        service: Service {\n            id: \"S1\".to_string(),\n            name: \"Production\".to_string(),\n            status: \"active\".to_string(),\n            html_url: String::new(),\n        },\n        assignments: vec![],\n    }];\n\n    let result = output_incidents(\u0026incidents, OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_incident_detail_no_url() {\n    use super::super::types::{Service, Urgency};\n\n    let incident = Incident {\n        id: \"INC1\".to_string(),\n        incident_number: 42,\n        title: \"Server down\".to_string(),\n        status: IncidentStatus::Resolved,\n        urgency: Urgency::High,\n        created_at: chrono::Utc::now().to_rfc3339(),\n        html_url: String::new(),\n        service: Service {\n            id: \"S1\".to_string(),\n            name: \"Production\".to_string(),\n            status: \"active\".to_string(),\n            html_url: String::new(),\n        },\n        assignments: vec![],\n    };\n\n    let result = output_incident_detail(\u0026incident, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn truncate_zero_max() {\n    // Edge case: max_len = 0\n    assert_eq!(truncate(\"hello\", 0), \"...\");\n}\n\n#[test]\nfn time_ago_boundary_cases() {\n    // Exactly 1 day ago\n    let dt = chrono::Utc::now() - chrono::Duration::days(1);\n    let timestamp = dt.to_rfc3339();\n    assert_eq!(time_ago(\u0026timestamp), \"1d ago\");\n\n    // Exactly 1 hour ago\n    let dt = chrono::Utc::now() - chrono::Duration::hours(1);\n    let timestamp = dt.to_rfc3339();\n    assert_eq!(time_ago(\u0026timestamp), \"1h ago\");\n\n    // Exactly 1 minute ago\n    let dt = chrono::Utc::now() - chrono::Duration::minutes(1);\n    let timestamp = dt.to_rfc3339();\n    assert_eq!(time_ago(\u0026timestamp), \"1m ago\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","pagerduty","mod.rs"],"content":"//! PagerDuty integration\n//!\n//! View on-call schedules and incidents.\n//!\n//! # CLI Usage\n//! Use [`run`] for CLI commands that format and print output.\n//!\n//! # Programmatic Usage (MCP/HTTP)\n//! Use the reusable functions that return typed data:\n//! - [`get_config`] - Get configuration status\n//! - [`list_oncalls`] - List on-call users\n//! - [`list_alerts`] - List active alerts (triggered + acknowledged)\n//! - [`list_incidents`] - List incidents with filters\n//! - [`get_incident`] - Get incident details\n//! - [`get_current_user`] - Get current user info\n\nmod cli;\nmod client;\nmod config;\nmod display;\nmod service;\npub mod types;\n\nuse anyhow::Result;\n\npub use cli::PagerDutyCommand;\nuse cli::StatusFilter;\nuse client::PagerDutyClient;\npub use config::PagerDutyConfig;\npub use service::{IncidentOptions, OncallOptions};\npub use types::{Incident, Oncall, User};\nuse types::{IncidentStatus, OutputFormat};\n\n/// Run a PagerDuty command (CLI entry point - formats and prints)\n#[cfg(not(tarpaulin_include))]\npub async fn run(cmd: PagerDutyCommand) -\u003e Result\u003c()\u003e {\n    match cmd {\n        PagerDutyCommand::Config =\u003e cmd_config(),\n        PagerDutyCommand::Auth { token } =\u003e cmd_auth(\u0026token),\n        PagerDutyCommand::Oncall {\n            policy,\n            schedule,\n            json,\n        } =\u003e cmd_oncall(policy.as_deref(), schedule.as_deref(), json).await,\n        PagerDutyCommand::Alerts { limit, json } =\u003e cmd_alerts(limit, json).await,\n        PagerDutyCommand::Incidents {\n            status,\n            limit,\n            json,\n        } =\u003e cmd_incidents(status, limit, json).await,\n        PagerDutyCommand::Show { id, json } =\u003e cmd_show(\u0026id, json).await,\n        PagerDutyCommand::Whoami { json } =\u003e cmd_whoami(json).await,\n    }\n}\n\n// ============================================================================\n// Reusable functions for MCP/HTTP - return typed data, never print\n// ============================================================================\n\n/// Get PagerDuty configuration status (for MCP/HTTP)\n#[allow(dead_code)]\npub fn get_config() -\u003e Result\u003cPagerDutyConfig\u003e {\n    service::get_config()\n}\n\n/// List on-call users (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn list_oncalls(opts: \u0026OncallOptions) -\u003e Result\u003cVec\u003cOncall\u003e\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n    let client = PagerDutyClient::new()?;\n    service::list_oncalls(\u0026client, opts).await\n}\n\n/// List active alerts - triggered + acknowledged only (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn list_alerts(limit: usize) -\u003e Result\u003cVec\u003cIncident\u003e\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n    let client = PagerDutyClient::new()?;\n    service::list_alerts(\u0026client, limit).await\n}\n\n/// List incidents with filters (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn list_incidents(opts: \u0026IncidentOptions) -\u003e Result\u003cVec\u003cIncident\u003e\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n    let client = PagerDutyClient::new()?;\n    service::list_incidents(\u0026client, opts).await\n}\n\n/// Get incident details by ID (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn get_incident(id: \u0026str) -\u003e Result\u003cIncident\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n    let client = PagerDutyClient::new()?;\n    service::get_incident(\u0026client, id).await\n}\n\n/// Get current user info (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn get_current_user() -\u003e Result\u003cUser\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n    let client = PagerDutyClient::new()?;\n    service::get_current_user(\u0026client).await\n}\n\n// ============================================================================\n// CLI command handlers - create client, call service, format and print\n// ============================================================================\n\n/// Show config status\nfn cmd_config() -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    display::output_config_status(\u0026config);\n    Ok(())\n}\n\n/// Save API token\nfn cmd_auth(token: \u0026str) -\u003e Result\u003c()\u003e {\n    service::save_auth(token)?;\n    println!(\"PagerDuty API token saved.\");\n    Ok(())\n}\n\n/// Show who's on call\nasync fn cmd_oncall(policy: Option\u003c\u0026str\u003e, schedule: Option\u003c\u0026str\u003e, json: bool) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n\n    let client = PagerDutyClient::new()?;\n    let opts = OncallOptions {\n        policy_id: policy.map(|p| p.to_string()),\n        schedule_id: schedule.map(|s| s.to_string()),\n    };\n\n    let oncalls = service::list_oncalls(\u0026client, \u0026opts).await?;\n\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n    display::output_oncalls(\u0026oncalls, format)?;\n    Ok(())\n}\n\n/// List active alerts (triggered + acknowledged)\nasync fn cmd_alerts(limit: usize, json: bool) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n\n    let client = PagerDutyClient::new()?;\n    let incidents = service::list_alerts(\u0026client, limit).await?;\n\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n    display::output_incidents(\u0026incidents, format)?;\n    Ok(())\n}\n\n/// List incidents with optional status filter\nasync fn cmd_incidents(status: Option\u003cStatusFilter\u003e, limit: usize, json: bool) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n\n    let client = PagerDutyClient::new()?;\n    let opts = IncidentOptions {\n        statuses: status_filter_to_statuses(status),\n        limit,\n    };\n    let incidents = service::list_incidents(\u0026client, \u0026opts).await?;\n\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n    display::output_incidents(\u0026incidents, format)?;\n    Ok(())\n}\n\n/// Show incident details\nasync fn cmd_show(id: \u0026str, json: bool) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n\n    let client = PagerDutyClient::new()?;\n    let incident = service::get_incident(\u0026client, id).await?;\n\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n    display::output_incident_detail(\u0026incident, format)?;\n    Ok(())\n}\n\n/// Show current user info\nasync fn cmd_whoami(json: bool) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n\n    let client = PagerDutyClient::new()?;\n    let user = service::get_current_user(\u0026client).await?;\n\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n    display::output_user(\u0026user, format)?;\n    Ok(())\n}\n\n/// Convert CLI status filter to API statuses\nfn status_filter_to_statuses(filter: Option\u003cStatusFilter\u003e) -\u003e Vec\u003cIncidentStatus\u003e {\n    match filter {\n        Some(StatusFilter::Triggered) =\u003e vec![IncidentStatus::Triggered],\n        Some(StatusFilter::Acknowledged) =\u003e vec![IncidentStatus::Acknowledged],\n        Some(StatusFilter::Resolved) =\u003e vec![IncidentStatus::Resolved],\n        Some(StatusFilter::Active) | None =\u003e {\n            vec![IncidentStatus::Triggered, IncidentStatus::Acknowledged]\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use config::PagerDutyConfig;\n\n    #[test]\n    fn status_filter_to_statuses_none() {\n        let statuses = status_filter_to_statuses(None);\n        assert_eq!(statuses.len(), 2);\n        assert!(statuses.contains(\u0026IncidentStatus::Triggered));\n        assert!(statuses.contains(\u0026IncidentStatus::Acknowledged));\n    }\n\n    #[test]\n    fn status_filter_to_statuses_triggered() {\n        let statuses = status_filter_to_statuses(Some(StatusFilter::Triggered));\n        assert_eq!(statuses, vec![IncidentStatus::Triggered]);\n    }\n\n    #[test]\n    fn status_filter_to_statuses_acknowledged() {\n        let statuses = status_filter_to_statuses(Some(StatusFilter::Acknowledged));\n        assert_eq!(statuses, vec![IncidentStatus::Acknowledged]);\n    }\n\n    #[test]\n    fn status_filter_to_statuses_resolved() {\n        let statuses = status_filter_to_statuses(Some(StatusFilter::Resolved));\n        assert_eq!(statuses, vec![IncidentStatus::Resolved]);\n    }\n\n    #[test]\n    fn status_filter_to_statuses_active() {\n        let statuses = status_filter_to_statuses(Some(StatusFilter::Active));\n        assert_eq!(statuses.len(), 2);\n        assert!(statuses.contains(\u0026IncidentStatus::Triggered));\n        assert!(statuses.contains(\u0026IncidentStatus::Acknowledged));\n    }\n\n    #[test]\n    fn cmd_config_runs() {\n        // Just verify it doesn't panic\n        let result = cmd_config();\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn ensure_configured_with_token_succeeds() {\n        let config = PagerDutyConfig {\n            api_token: Some(\"test-token\".to_string()),\n            ..Default::default()\n        };\n        let result = service::ensure_configured(\u0026config);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn ensure_configured_without_token_fails() {\n        let config = PagerDutyConfig::default();\n        let result = service::ensure_configured(\u0026config);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn cmd_auth_saves_token() {\n        // This test writes to config, which is I/O - just verify it runs\n        // Note: This may modify the actual config file, but we're testing the logic\n        // In a real scenario, we'd mock the file system\n        let result = cmd_auth(\"test-token-12345\");\n        // Either succeeds or fails due to file system permissions\n        let _ = result;\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":4}},{"line":20,"address":[],"length":0,"stats":{"Line":2}},{"line":21,"address":[],"length":0,"stats":{"Line":2}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":1}},{"line":41,"address":[],"length":0,"stats":{"Line":1}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":1}},{"line":51,"address":[],"length":0,"stats":{"Line":3}},{"line":52,"address":[],"length":0,"stats":{"Line":6}},{"line":53,"address":[],"length":0,"stats":{"Line":6}},{"line":54,"address":[],"length":0,"stats":{"Line":3}},{"line":58,"address":[],"length":0,"stats":{"Line":1}},{"line":59,"address":[],"length":0,"stats":{"Line":2}},{"line":60,"address":[],"length":0,"stats":{"Line":2}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":5}},{"line":153,"address":[],"length":0,"stats":{"Line":4}},{"line":154,"address":[],"length":0,"stats":{"Line":2}},{"line":155,"address":[],"length":0,"stats":{"Line":2}},{"line":156,"address":[],"length":0,"stats":{"Line":2}},{"line":158,"address":[],"length":0,"stats":{"Line":6}}],"covered":20,"coverable":86},{"path":["/","Users","chi","Projects","hu","src","pagerduty","types","mod.rs"],"content":"//! PagerDuty data types\n\nuse serde::{Deserialize, Serialize};\n\n#[cfg(test)]\nmod tests;\n\n/// PagerDuty user\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct User {\n    /// User ID\n    pub id: String,\n    /// User name (full response)\n    #[serde(default)]\n    pub name: Option\u003cString\u003e,\n    /// Summary (reference response)\n    #[serde(default)]\n    pub summary: Option\u003cString\u003e,\n    /// Email address\n    #[serde(default)]\n    pub email: String,\n    /// URL to user in PagerDuty\n    #[serde(default)]\n    pub html_url: String,\n}\n\nimpl User {\n    /// Get display name (prefers name over summary)\n    pub fn display_name(\u0026self) -\u003e \u0026str {\n        self.name\n            .as_deref()\n            .or(self.summary.as_deref())\n            .unwrap_or(\u0026self.id)\n    }\n}\n\n/// Escalation policy\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct EscalationPolicy {\n    /// Policy ID\n    pub id: String,\n    /// Policy name (API returns \"summary\" for references)\n    #[serde(alias = \"summary\")]\n    pub name: String,\n    /// URL to policy in PagerDuty\n    #[serde(default)]\n    pub html_url: String,\n}\n\n/// On-call schedule\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Schedule {\n    /// Schedule ID\n    pub id: String,\n    /// Schedule name (API returns \"summary\" for references)\n    #[serde(alias = \"summary\")]\n    pub name: String,\n    /// URL to schedule in PagerDuty\n    #[serde(default)]\n    pub html_url: String,\n}\n\n/// On-call entry\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Oncall {\n    /// User on call\n    pub user: User,\n    /// Schedule (if any)\n    pub schedule: Option\u003cSchedule\u003e,\n    /// Escalation policy\n    pub escalation_policy: EscalationPolicy,\n    /// Escalation level (1 = primary, 2 = secondary, etc.)\n    pub escalation_level: u32,\n    /// Start time of on-call shift\n    pub start: Option\u003cString\u003e,\n    /// End time of on-call shift\n    pub end: Option\u003cString\u003e,\n}\n\n/// Service\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Service {\n    /// Service ID\n    pub id: String,\n    /// Service name (API returns \"summary\" for references)\n    #[serde(alias = \"summary\")]\n    pub name: String,\n    /// Service status\n    #[serde(default)]\n    pub status: String,\n    /// URL to service in PagerDuty\n    #[serde(default)]\n    pub html_url: String,\n}\n\n/// Incident urgency\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum Urgency {\n    /// High urgency\n    High,\n    /// Low urgency\n    Low,\n}\n\n/// Incident status\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum IncidentStatus {\n    /// Triggered - not yet acknowledged\n    Triggered,\n    /// Acknowledged - someone is working on it\n    Acknowledged,\n    /// Resolved - incident is closed\n    Resolved,\n}\n\nimpl IncidentStatus {\n    /// Convert to API query string value\n    #[must_use]\n    pub fn as_str(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Self::Triggered =\u003e \"triggered\",\n            Self::Acknowledged =\u003e \"acknowledged\",\n            Self::Resolved =\u003e \"resolved\",\n        }\n    }\n}\n\n/// Assignment (user assigned to incident)\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Assignment {\n    /// Assigned user\n    pub assignee: User,\n}\n\n/// Incident\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Incident {\n    /// Incident ID\n    pub id: String,\n    /// Incident number\n    pub incident_number: u64,\n    /// Title/summary\n    pub title: String,\n    /// Current status\n    pub status: IncidentStatus,\n    /// Urgency level\n    pub urgency: Urgency,\n    /// Creation timestamp\n    pub created_at: String,\n    /// URL to incident in PagerDuty\n    #[serde(default)]\n    pub html_url: String,\n    /// Service this incident belongs to\n    pub service: Service,\n    /// Users assigned to this incident\n    #[serde(default)]\n    pub assignments: Vec\u003cAssignment\u003e,\n}\n\n/// Output format\n#[derive(Debug, Clone, Copy, Default, PartialEq, Eq)]\npub enum OutputFormat {\n    /// Table format\n    #[default]\n    Table,\n    /// JSON format\n    Json,\n}\n\n/// API response wrapper for oncalls\n#[derive(Debug, Deserialize)]\npub struct OncallsResponse {\n    /// List of oncalls\n    pub oncalls: Vec\u003cOncall\u003e,\n}\n\n/// API response wrapper for incidents\n#[derive(Debug, Deserialize)]\npub struct IncidentsResponse {\n    /// List of incidents\n    pub incidents: Vec\u003cIncident\u003e,\n}\n\n/// API response wrapper for single incident\n#[derive(Debug, Deserialize)]\npub struct IncidentResponse {\n    /// The incident\n    pub incident: Incident,\n}\n\n/// API response wrapper for services\n#[allow(dead_code)]\n#[derive(Debug, Deserialize)]\npub struct ServicesResponse {\n    /// List of services\n    pub services: Vec\u003cService\u003e,\n}\n\n/// Current user response\n#[allow(dead_code)]\n#[derive(Debug, Deserialize)]\npub struct CurrentUserResponse {\n    /// The user\n    pub user: User,\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":14}},{"line":30,"address":[],"length":0,"stats":{"Line":28}},{"line":32,"address":[],"length":0,"stats":{"Line":56}},{"line":33,"address":[],"length":0,"stats":{"Line":14}},{"line":121,"address":[],"length":0,"stats":{"Line":6}},{"line":122,"address":[],"length":0,"stats":{"Line":6}},{"line":123,"address":[],"length":0,"stats":{"Line":3}},{"line":124,"address":[],"length":0,"stats":{"Line":2}},{"line":125,"address":[],"length":0,"stats":{"Line":1}}],"covered":9,"coverable":9},{"path":["/","Users","chi","Projects","hu","src","pagerduty","types","tests.rs"],"content":"use super::*;\n\n#[test]\nfn incident_status_deserialize() {\n    let json = r#\"\"triggered\"\"#;\n    let status: IncidentStatus = serde_json::from_str(json).unwrap();\n    assert_eq!(status, IncidentStatus::Triggered);\n\n    let json = r#\"\"acknowledged\"\"#;\n    let status: IncidentStatus = serde_json::from_str(json).unwrap();\n    assert_eq!(status, IncidentStatus::Acknowledged);\n\n    let json = r#\"\"resolved\"\"#;\n    let status: IncidentStatus = serde_json::from_str(json).unwrap();\n    assert_eq!(status, IncidentStatus::Resolved);\n}\n\n#[test]\nfn incident_status_serialize() {\n    let json = serde_json::to_string(\u0026IncidentStatus::Triggered).unwrap();\n    assert_eq!(json, r#\"\"triggered\"\"#);\n\n    let json = serde_json::to_string(\u0026IncidentStatus::Acknowledged).unwrap();\n    assert_eq!(json, r#\"\"acknowledged\"\"#);\n\n    let json = serde_json::to_string(\u0026IncidentStatus::Resolved).unwrap();\n    assert_eq!(json, r#\"\"resolved\"\"#);\n}\n\n#[test]\nfn incident_status_as_str() {\n    assert_eq!(IncidentStatus::Triggered.as_str(), \"triggered\");\n    assert_eq!(IncidentStatus::Acknowledged.as_str(), \"acknowledged\");\n    assert_eq!(IncidentStatus::Resolved.as_str(), \"resolved\");\n}\n\n#[test]\nfn urgency_deserialize() {\n    let json = r#\"\"high\"\"#;\n    let urgency: Urgency = serde_json::from_str(json).unwrap();\n    assert_eq!(urgency, Urgency::High);\n\n    let json = r#\"\"low\"\"#;\n    let urgency: Urgency = serde_json::from_str(json).unwrap();\n    assert_eq!(urgency, Urgency::Low);\n}\n\n#[test]\nfn urgency_serialize() {\n    let json = serde_json::to_string(\u0026Urgency::High).unwrap();\n    assert_eq!(json, r#\"\"high\"\"#);\n\n    let json = serde_json::to_string(\u0026Urgency::Low).unwrap();\n    assert_eq!(json, r#\"\"low\"\"#);\n}\n\n#[test]\nfn user_deserialize() {\n    let json = r#\"{\n            \"id\": \"U123\",\n            \"name\": \"Alice Smith\",\n            \"email\": \"alice@example.com\",\n            \"html_url\": \"https://pagerduty.com/users/U123\"\n        }\"#;\n    let user: User = serde_json::from_str(json).unwrap();\n    assert_eq!(user.id, \"U123\");\n    assert_eq!(user.display_name(), \"Alice Smith\");\n    assert_eq!(user.email, \"alice@example.com\");\n    assert_eq!(user.html_url, \"https://pagerduty.com/users/U123\");\n}\n\n#[test]\nfn user_deserialize_without_html_url() {\n    let json = r#\"{\n            \"id\": \"U123\",\n            \"name\": \"Alice Smith\",\n            \"email\": \"alice@example.com\"\n        }\"#;\n    let user: User = serde_json::from_str(json).unwrap();\n    assert_eq!(user.html_url, \"\");\n}\n\n#[test]\nfn oncall_deserialize() {\n    let json = r#\"{\n            \"user\": {\"id\": \"U1\", \"name\": \"Alice\", \"email\": \"alice@example.com\"},\n            \"escalation_policy\": {\"id\": \"EP1\", \"name\": \"Primary\"},\n            \"escalation_level\": 1,\n            \"schedule\": null,\n            \"start\": \"2026-01-01T00:00:00Z\",\n            \"end\": \"2026-01-08T00:00:00Z\"\n        }\"#;\n    let oncall: Oncall = serde_json::from_str(json).unwrap();\n    assert_eq!(oncall.user.display_name(), \"Alice\");\n    assert_eq!(oncall.escalation_level, 1);\n    assert!(oncall.schedule.is_none());\n    assert_eq!(oncall.start, Some(\"2026-01-01T00:00:00Z\".to_string()));\n}\n\n#[test]\nfn oncall_deserialize_with_schedule() {\n    let json = r#\"{\n            \"user\": {\"id\": \"U1\", \"name\": \"Alice\", \"email\": \"alice@example.com\"},\n            \"escalation_policy\": {\"id\": \"EP1\", \"name\": \"Primary\"},\n            \"escalation_level\": 2,\n            \"schedule\": {\"id\": \"S1\", \"name\": \"Weekly Rotation\"},\n            \"start\": null,\n            \"end\": null\n        }\"#;\n    let oncall: Oncall = serde_json::from_str(json).unwrap();\n    assert!(oncall.schedule.is_some());\n    assert_eq!(oncall.schedule.unwrap().name, \"Weekly Rotation\");\n    assert_eq!(oncall.escalation_level, 2);\n}\n\n#[test]\nfn incident_deserialize() {\n    let json = r#\"{\n            \"id\": \"INC123\",\n            \"incident_number\": 42,\n            \"title\": \"Server down\",\n            \"status\": \"triggered\",\n            \"urgency\": \"high\",\n            \"created_at\": \"2026-01-01T12:00:00Z\",\n            \"html_url\": \"https://pagerduty.com/incidents/INC123\",\n            \"service\": {\"id\": \"S1\", \"name\": \"Production\", \"status\": \"active\"},\n            \"assignments\": []\n        }\"#;\n    let incident: Incident = serde_json::from_str(json).unwrap();\n    assert_eq!(incident.id, \"INC123\");\n    assert_eq!(incident.incident_number, 42);\n    assert_eq!(incident.status, IncidentStatus::Triggered);\n    assert_eq!(incident.urgency, Urgency::High);\n    assert_eq!(incident.service.name, \"Production\");\n}\n\n#[test]\nfn incident_deserialize_with_assignments() {\n    let json = r#\"{\n            \"id\": \"INC123\",\n            \"incident_number\": 42,\n            \"title\": \"Server down\",\n            \"status\": \"acknowledged\",\n            \"urgency\": \"low\",\n            \"created_at\": \"2026-01-01T12:00:00Z\",\n            \"service\": {\"id\": \"S1\", \"name\": \"Production\", \"status\": \"active\"},\n            \"assignments\": [\n                {\"assignee\": {\"id\": \"U1\", \"name\": \"Alice\", \"email\": \"alice@example.com\"}}\n            ]\n        }\"#;\n    let incident: Incident = serde_json::from_str(json).unwrap();\n    assert_eq!(incident.assignments.len(), 1);\n    assert_eq!(incident.assignments[0].assignee.display_name(), \"Alice\");\n}\n\n#[test]\nfn oncalls_response_deserialize() {\n    let json = r#\"{\"oncalls\": []}\"#;\n    let resp: OncallsResponse = serde_json::from_str(json).unwrap();\n    assert!(resp.oncalls.is_empty());\n}\n\n#[test]\nfn incidents_response_deserialize() {\n    let json = r#\"{\"incidents\": []}\"#;\n    let resp: IncidentsResponse = serde_json::from_str(json).unwrap();\n    assert!(resp.incidents.is_empty());\n}\n\n#[test]\nfn services_response_deserialize() {\n    let json = r#\"{\"services\": []}\"#;\n    let resp: ServicesResponse = serde_json::from_str(json).unwrap();\n    assert!(resp.services.is_empty());\n}\n\n#[test]\nfn current_user_response_deserialize() {\n    let json = r#\"{\"user\": {\"id\": \"U1\", \"name\": \"Alice\", \"email\": \"alice@example.com\"}}\"#;\n    let resp: CurrentUserResponse = serde_json::from_str(json).unwrap();\n    assert_eq!(resp.user.display_name(), \"Alice\");\n}\n\n#[test]\nfn output_format_default() {\n    let format = OutputFormat::default();\n    assert_eq!(format, OutputFormat::Table);\n}\n\n#[test]\nfn output_format_eq() {\n    assert_eq!(OutputFormat::Table, OutputFormat::Table);\n    assert_eq!(OutputFormat::Json, OutputFormat::Json);\n    assert_ne!(OutputFormat::Table, OutputFormat::Json);\n}\n\n#[test]\nfn types_are_debug() {\n    // Ensure all types implement Debug\n    let user = User {\n        id: \"U1\".to_string(),\n        name: Some(\"Alice\".to_string()),\n        summary: None,\n        email: \"alice@example.com\".to_string(),\n        html_url: String::new(),\n    };\n    let _ = format!(\"{:?}\", user);\n    let _ = format!(\"{:?}\", IncidentStatus::Triggered);\n    let _ = format!(\"{:?}\", Urgency::High);\n    let _ = format!(\"{:?}\", OutputFormat::Table);\n}\n\n#[test]\nfn types_are_clone() {\n    let user = User {\n        id: \"U1\".to_string(),\n        name: Some(\"Alice\".to_string()),\n        summary: None,\n        email: \"alice@example.com\".to_string(),\n        html_url: String::new(),\n    };\n    let cloned = user.clone();\n    assert_eq!(cloned.id, user.id);\n\n    let status = IncidentStatus::Triggered;\n    let cloned = status;\n    assert_eq!(cloned, status);\n}\n\n#[test]\nfn user_display_name_prefers_name() {\n    let user = User {\n        id: \"U1\".to_string(),\n        name: Some(\"Alice\".to_string()),\n        summary: Some(\"Alice Summary\".to_string()),\n        email: String::new(),\n        html_url: String::new(),\n    };\n    assert_eq!(user.display_name(), \"Alice\");\n}\n\n#[test]\nfn user_display_name_falls_back_to_summary() {\n    let user = User {\n        id: \"U1\".to_string(),\n        name: None,\n        summary: Some(\"Alice Summary\".to_string()),\n        email: String::new(),\n        html_url: String::new(),\n    };\n    assert_eq!(user.display_name(), \"Alice Summary\");\n}\n\n#[test]\nfn user_display_name_falls_back_to_id() {\n    let user = User {\n        id: \"U1\".to_string(),\n        name: None,\n        summary: None,\n        email: String::new(),\n        html_url: String::new(),\n    };\n    assert_eq!(user.display_name(), \"U1\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","pipeline","aws.rs"],"content":"//! AWS CLI wrapper functions\n\nuse anyhow::{Context, Result};\nuse std::process::Command;\n\nuse super::types::{\n    AwsConfig, ListExecutionsResponse, ListPipelinesResponse, Pipeline, PipelineExecution,\n    PipelineState,\n};\n\n/// Build AWS CLI base command with region\nfn build_aws_cmd(config: \u0026AwsConfig) -\u003e Command {\n    let mut cmd = Command::new(\"aws\");\n    cmd.arg(\"codepipeline\");\n\n    if let Some(region) = \u0026config.region {\n        cmd.arg(\"--region\").arg(region);\n    }\n\n    cmd\n}\n\n/// List all pipelines\npub fn list_pipelines(config: \u0026AwsConfig) -\u003e Result\u003cVec\u003cPipeline\u003e\u003e {\n    let mut cmd = build_aws_cmd(config);\n    cmd.arg(\"list-pipelines\");\n\n    let output = cmd\n        .output()\n        .context(\"Failed to execute aws cli. Is AWS CLI installed and configured?\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"aws cli failed: {}\", stderr.trim());\n    }\n\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    parse_list_pipelines(\u0026stdout)\n}\n\n/// Parse list-pipelines output\npub fn parse_list_pipelines(json: \u0026str) -\u003e Result\u003cVec\u003cPipeline\u003e\u003e {\n    let resp: ListPipelinesResponse =\n        serde_json::from_str(json).context(\"Failed to parse aws cli output\")?;\n\n    Ok(resp.pipelines.iter().map(|s| s.to_pipeline()).collect())\n}\n\n/// Get pipeline state\npub fn get_pipeline_state(config: \u0026AwsConfig, name: \u0026str) -\u003e Result\u003cPipelineState\u003e {\n    let mut cmd = build_aws_cmd(config);\n    cmd.arg(\"get-pipeline-state\").arg(\"--name\").arg(name);\n\n    let output = cmd.output().context(\"Failed to execute aws cli\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"aws cli failed: {}\", stderr.trim());\n    }\n\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    parse_pipeline_state(\u0026stdout)\n}\n\n/// Parse get-pipeline-state output\npub fn parse_pipeline_state(json: \u0026str) -\u003e Result\u003cPipelineState\u003e {\n    serde_json::from_str(json).context(\"Failed to parse pipeline state\")\n}\n\n/// List pipeline executions\npub fn list_executions(\n    config: \u0026AwsConfig,\n    name: \u0026str,\n    limit: usize,\n) -\u003e Result\u003cVec\u003cPipelineExecution\u003e\u003e {\n    let mut cmd = build_aws_cmd(config);\n    cmd.arg(\"list-pipeline-executions\")\n        .arg(\"--pipeline-name\")\n        .arg(name)\n        .arg(\"--max-results\")\n        .arg(limit.to_string());\n\n    let output = cmd.output().context(\"Failed to execute aws cli\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"aws cli failed: {}\", stderr.trim());\n    }\n\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    parse_list_executions(\u0026stdout)\n}\n\n/// Parse list-pipeline-executions output\npub fn parse_list_executions(json: \u0026str) -\u003e Result\u003cVec\u003cPipelineExecution\u003e\u003e {\n    let resp: ListExecutionsResponse =\n        serde_json::from_str(json).context(\"Failed to parse executions\")?;\n\n    Ok(resp.executions)\n}\n\n/// Build list-pipelines args (for testing)\n#[cfg(test)]\npub fn build_list_args(config: \u0026AwsConfig) -\u003e Vec\u003cString\u003e {\n    let mut args = vec![\"codepipeline\".to_string()];\n\n    if let Some(region) = \u0026config.region {\n        args.push(\"--region\".to_string());\n        args.push(region.clone());\n    }\n\n    args.push(\"list-pipelines\".to_string());\n    args\n}\n\n/// Build get-pipeline-state args (for testing)\n#[cfg(test)]\npub fn build_state_args(config: \u0026AwsConfig, name: \u0026str) -\u003e Vec\u003cString\u003e {\n    let mut args = vec![\"codepipeline\".to_string()];\n\n    if let Some(region) = \u0026config.region {\n        args.push(\"--region\".to_string());\n        args.push(region.clone());\n    }\n\n    args.push(\"get-pipeline-state\".to_string());\n    args.push(\"--name\".to_string());\n    args.push(name.to_string());\n    args\n}\n\n/// Build list-pipeline-executions args (for testing)\n#[cfg(test)]\npub fn build_executions_args(config: \u0026AwsConfig, name: \u0026str, limit: usize) -\u003e Vec\u003cString\u003e {\n    let mut args = vec![\"codepipeline\".to_string()];\n\n    if let Some(region) = \u0026config.region {\n        args.push(\"--region\".to_string());\n        args.push(region.clone());\n    }\n\n    args.push(\"list-pipeline-executions\".to_string());\n    args.push(\"--pipeline-name\".to_string());\n    args.push(name.to_string());\n    args.push(\"--max-results\".to_string());\n    args.push(limit.to_string());\n    args\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn build_list_args_basic() {\n        let config = AwsConfig::default();\n        let args = build_list_args(\u0026config);\n        assert_eq!(args, vec![\"codepipeline\", \"list-pipelines\"]);\n    }\n\n    #[test]\n    fn build_list_args_with_region() {\n        let config = AwsConfig {\n            region: Some(\"us-west-2\".to_string()),\n        };\n        let args = build_list_args(\u0026config);\n        assert_eq!(\n            args,\n            vec![\"codepipeline\", \"--region\", \"us-west-2\", \"list-pipelines\"]\n        );\n    }\n\n    #[test]\n    fn build_state_args_basic() {\n        let config = AwsConfig::default();\n        let args = build_state_args(\u0026config, \"my-pipeline\");\n        assert_eq!(\n            args,\n            vec![\n                \"codepipeline\",\n                \"get-pipeline-state\",\n                \"--name\",\n                \"my-pipeline\"\n            ]\n        );\n    }\n\n    #[test]\n    fn build_state_args_with_region() {\n        let config = AwsConfig {\n            region: Some(\"eu-west-1\".to_string()),\n        };\n        let args = build_state_args(\u0026config, \"my-pipeline\");\n        assert_eq!(\n            args,\n            vec![\n                \"codepipeline\",\n                \"--region\",\n                \"eu-west-1\",\n                \"get-pipeline-state\",\n                \"--name\",\n                \"my-pipeline\"\n            ]\n        );\n    }\n\n    #[test]\n    fn build_executions_args_basic() {\n        let config = AwsConfig::default();\n        let args = build_executions_args(\u0026config, \"my-pipeline\", 10);\n        assert_eq!(\n            args,\n            vec![\n                \"codepipeline\",\n                \"list-pipeline-executions\",\n                \"--pipeline-name\",\n                \"my-pipeline\",\n                \"--max-results\",\n                \"10\"\n            ]\n        );\n    }\n\n    #[test]\n    fn parse_list_pipelines_empty() {\n        let json = r#\"{\"pipelines\": []}\"#;\n        let pipelines = parse_list_pipelines(json).unwrap();\n        assert!(pipelines.is_empty());\n    }\n\n    #[test]\n    fn parse_list_pipelines_single() {\n        let json = r#\"{\"pipelines\": [{\"name\": \"test\"}]}\"#;\n        let pipelines = parse_list_pipelines(json).unwrap();\n        assert_eq!(pipelines.len(), 1);\n        assert_eq!(pipelines[0].name, \"test\");\n    }\n\n    #[test]\n    fn parse_list_pipelines_invalid() {\n        let result = parse_list_pipelines(\"not json\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn parse_pipeline_state_basic() {\n        let json = r#\"{\n            \"pipelineName\": \"test\",\n            \"stageStates\": []\n        }\"#;\n        let state = parse_pipeline_state(json).unwrap();\n        assert_eq!(state.name, \"test\");\n    }\n\n    #[test]\n    fn parse_list_executions_empty() {\n        let json = r#\"{\"pipelineExecutionSummaries\": []}\"#;\n        let executions = parse_list_executions(json).unwrap();\n        assert!(executions.is_empty());\n    }\n\n    #[test]\n    fn parse_list_executions_single() {\n        let json = r#\"{\n            \"pipelineExecutionSummaries\": [\n                {\"pipelineExecutionId\": \"exec-1\", \"status\": \"Succeeded\"}\n            ]\n        }\"#;\n        let executions = parse_list_executions(json).unwrap();\n        assert_eq!(executions.len(), 1);\n        assert_eq!(executions[0].id, \"exec-1\");\n    }\n\n    #[test]\n    fn build_executions_args_with_region() {\n        let config = AwsConfig {\n            region: Some(\"ap-northeast-1\".to_string()),\n        };\n        let args = build_executions_args(\u0026config, \"prod-pipeline\", 5);\n        assert_eq!(\n            args,\n            vec![\n                \"codepipeline\",\n                \"--region\",\n                \"ap-northeast-1\",\n                \"list-pipeline-executions\",\n                \"--pipeline-name\",\n                \"prod-pipeline\",\n                \"--max-results\",\n                \"5\"\n            ]\n        );\n    }\n\n    #[test]\n    fn parse_list_pipelines_multiple() {\n        let json = r#\"{\n            \"pipelines\": [\n                {\"name\": \"pipeline-1\", \"created\": \"2026-01-01\", \"updated\": \"2026-01-02\"},\n                {\"name\": \"pipeline-2\"},\n                {\"name\": \"pipeline-3\", \"created\": \"2026-01-03\"}\n            ]\n        }\"#;\n        let pipelines = parse_list_pipelines(json).unwrap();\n        assert_eq!(pipelines.len(), 3);\n        assert_eq!(pipelines[0].name, \"pipeline-1\");\n        assert_eq!(pipelines[0].created, Some(\"2026-01-01\".to_string()));\n        assert_eq!(pipelines[0].updated, Some(\"2026-01-02\".to_string()));\n        assert_eq!(pipelines[1].name, \"pipeline-2\");\n        assert!(pipelines[1].created.is_none());\n        assert_eq!(pipelines[2].name, \"pipeline-3\");\n    }\n\n    #[test]\n    fn parse_pipeline_state_with_stages() {\n        let json = r#\"{\n            \"pipelineName\": \"complex-pipeline\",\n            \"stageStates\": [\n                {\n                    \"stageName\": \"Source\",\n                    \"latestExecution\": {\"status\": \"Succeeded\"},\n                    \"actionStates\": [\n                        {\"actionName\": \"GitCheckout\", \"latestExecution\": {\"status\": \"Succeeded\"}}\n                    ]\n                },\n                {\n                    \"stageName\": \"Build\",\n                    \"latestExecution\": {\"status\": \"InProgress\"},\n                    \"actionStates\": []\n                }\n            ]\n        }\"#;\n        let state = parse_pipeline_state(json).unwrap();\n        assert_eq!(state.name, \"complex-pipeline\");\n        assert_eq!(state.stages.len(), 2);\n        assert_eq!(state.stages[0].name, \"Source\");\n        assert_eq!(\n            state.stages[0].latest_execution.as_ref().unwrap().status,\n            \"Succeeded\"\n        );\n        assert_eq!(state.stages[0].actions.len(), 1);\n        assert_eq!(state.stages[0].actions[0].name, \"GitCheckout\");\n        assert_eq!(state.stages[1].name, \"Build\");\n    }\n\n    #[test]\n    fn parse_pipeline_state_invalid_json() {\n        let result = parse_pipeline_state(\"invalid json\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn parse_list_executions_invalid() {\n        let result = parse_list_executions(\"not valid json\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn parse_list_executions_multiple() {\n        let json = r#\"{\n            \"pipelineExecutionSummaries\": [\n                {\n                    \"pipelineExecutionId\": \"exec-1\",\n                    \"status\": \"Succeeded\",\n                    \"startTime\": \"2026-01-01T10:00:00Z\",\n                    \"lastUpdateTime\": \"2026-01-01T10:30:00Z\",\n                    \"trigger\": {\"triggerType\": \"Webhook\"}\n                },\n                {\n                    \"pipelineExecutionId\": \"exec-2\",\n                    \"status\": \"Failed\",\n                    \"startTime\": \"2026-01-01T08:00:00Z\"\n                },\n                {\n                    \"pipelineExecutionId\": \"exec-3\",\n                    \"status\": \"InProgress\"\n                }\n            ]\n        }\"#;\n        let executions = parse_list_executions(json).unwrap();\n        assert_eq!(executions.len(), 3);\n        assert_eq!(executions[0].id, \"exec-1\");\n        assert_eq!(executions[0].status, \"Succeeded\");\n        assert!(executions[0].trigger.is_some());\n        assert_eq!(\n            executions[0].trigger.as_ref().unwrap().trigger_type,\n            \"Webhook\"\n        );\n        assert_eq!(executions[1].id, \"exec-2\");\n        assert_eq!(executions[1].status, \"Failed\");\n        assert!(executions[1].trigger.is_none());\n        assert_eq!(executions[2].id, \"exec-3\");\n        assert_eq!(executions[2].status, \"InProgress\");\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":1}},{"line":13,"address":[],"length":0,"stats":{"Line":2}},{"line":14,"address":[],"length":0,"stats":{"Line":2}},{"line":16,"address":[],"length":0,"stats":{"Line":1}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":1}},{"line":24,"address":[],"length":0,"stats":{"Line":1}},{"line":25,"address":[],"length":0,"stats":{"Line":3}},{"line":26,"address":[],"length":0,"stats":{"Line":2}},{"line":28,"address":[],"length":0,"stats":{"Line":2}},{"line":32,"address":[],"length":0,"stats":{"Line":1}},{"line":33,"address":[],"length":0,"stats":{"Line":3}},{"line":34,"address":[],"length":0,"stats":{"Line":3}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":4}},{"line":43,"address":[],"length":0,"stats":{"Line":6}},{"line":44,"address":[],"length":0,"stats":{"Line":13}},{"line":46,"address":[],"length":0,"stats":{"Line":17}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":3}},{"line":67,"address":[],"length":0,"stats":{"Line":9}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":96,"address":[],"length":0,"stats":{"Line":6}},{"line":97,"address":[],"length":0,"stats":{"Line":13}},{"line":99,"address":[],"length":0,"stats":{"Line":3}},{"line":104,"address":[],"length":0,"stats":{"Line":2}},{"line":105,"address":[],"length":0,"stats":{"Line":8}},{"line":107,"address":[],"length":0,"stats":{"Line":4}},{"line":108,"address":[],"length":0,"stats":{"Line":5}},{"line":109,"address":[],"length":0,"stats":{"Line":3}},{"line":112,"address":[],"length":0,"stats":{"Line":8}},{"line":113,"address":[],"length":0,"stats":{"Line":2}},{"line":118,"address":[],"length":0,"stats":{"Line":2}},{"line":119,"address":[],"length":0,"stats":{"Line":8}},{"line":121,"address":[],"length":0,"stats":{"Line":4}},{"line":122,"address":[],"length":0,"stats":{"Line":5}},{"line":123,"address":[],"length":0,"stats":{"Line":3}},{"line":126,"address":[],"length":0,"stats":{"Line":8}},{"line":127,"address":[],"length":0,"stats":{"Line":8}},{"line":128,"address":[],"length":0,"stats":{"Line":8}},{"line":129,"address":[],"length":0,"stats":{"Line":2}},{"line":134,"address":[],"length":0,"stats":{"Line":2}},{"line":135,"address":[],"length":0,"stats":{"Line":8}},{"line":137,"address":[],"length":0,"stats":{"Line":4}},{"line":138,"address":[],"length":0,"stats":{"Line":5}},{"line":139,"address":[],"length":0,"stats":{"Line":3}},{"line":142,"address":[],"length":0,"stats":{"Line":8}},{"line":143,"address":[],"length":0,"stats":{"Line":8}},{"line":144,"address":[],"length":0,"stats":{"Line":8}},{"line":145,"address":[],"length":0,"stats":{"Line":8}},{"line":146,"address":[],"length":0,"stats":{"Line":8}},{"line":147,"address":[],"length":0,"stats":{"Line":2}}],"covered":49,"coverable":72},{"path":["/","Users","chi","Projects","hu","src","pipeline","cli.rs"],"content":"//! Pipeline CLI commands\n\nuse clap::Subcommand;\n\n#[derive(Debug, Subcommand)]\npub enum PipelineCommand {\n    /// List all pipelines\n    List {\n        /// AWS region\n        #[arg(short, long)]\n        region: Option\u003cString\u003e,\n\n        /// Output as JSON\n        #[arg(long)]\n        json: bool,\n    },\n\n    /// Show pipeline status (stages and actions)\n    Status {\n        /// Pipeline name\n        name: String,\n\n        /// AWS region\n        #[arg(short, long)]\n        region: Option\u003cString\u003e,\n\n        /// Output as JSON\n        #[arg(long)]\n        json: bool,\n    },\n\n    /// Show pipeline execution history\n    History {\n        /// Pipeline name\n        name: String,\n\n        /// AWS region\n        #[arg(short, long)]\n        region: Option\u003cString\u003e,\n\n        /// Maximum number of results\n        #[arg(short, long, default_value = \"10\")]\n        limit: usize,\n\n        /// Output as JSON\n        #[arg(long)]\n        json: bool,\n    },\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use clap::{CommandFactory, Parser};\n\n    #[derive(Parser)]\n    struct TestCli {\n        #[command(subcommand)]\n        cmd: PipelineCommand,\n    }\n\n    #[test]\n    fn parses_list_basic() {\n        let cli = TestCli::try_parse_from([\"test\", \"list\"]).unwrap();\n        match cli.cmd {\n            PipelineCommand::List { region, json } =\u003e {\n                assert!(region.is_none());\n                assert!(!json);\n            }\n            _ =\u003e panic!(\"Expected List command\"),\n        }\n    }\n\n    #[test]\n    fn parses_list_with_region() {\n        let cli = TestCli::try_parse_from([\"test\", \"list\", \"-r\", \"us-west-2\"]).unwrap();\n        match cli.cmd {\n            PipelineCommand::List { region, .. } =\u003e {\n                assert_eq!(region, Some(\"us-west-2\".to_string()));\n            }\n            _ =\u003e panic!(\"Expected List command\"),\n        }\n    }\n\n    #[test]\n    fn parses_list_json() {\n        let cli = TestCli::try_parse_from([\"test\", \"list\", \"--json\"]).unwrap();\n        match cli.cmd {\n            PipelineCommand::List { json, .. } =\u003e {\n                assert!(json);\n            }\n            _ =\u003e panic!(\"Expected List command\"),\n        }\n    }\n\n    #[test]\n    fn parses_status_basic() {\n        let cli = TestCli::try_parse_from([\"test\", \"status\", \"my-pipeline\"]).unwrap();\n        match cli.cmd {\n            PipelineCommand::Status { name, region, json } =\u003e {\n                assert_eq!(name, \"my-pipeline\");\n                assert!(region.is_none());\n                assert!(!json);\n            }\n            _ =\u003e panic!(\"Expected Status command\"),\n        }\n    }\n\n    #[test]\n    fn parses_status_with_region() {\n        let cli =\n            TestCli::try_parse_from([\"test\", \"status\", \"my-pipeline\", \"-r\", \"eu-west-1\"]).unwrap();\n        match cli.cmd {\n            PipelineCommand::Status { region, .. } =\u003e {\n                assert_eq!(region, Some(\"eu-west-1\".to_string()));\n            }\n            _ =\u003e panic!(\"Expected Status command\"),\n        }\n    }\n\n    #[test]\n    fn parses_status_json() {\n        let cli = TestCli::try_parse_from([\"test\", \"status\", \"my-pipeline\", \"--json\"]).unwrap();\n        match cli.cmd {\n            PipelineCommand::Status { json, .. } =\u003e {\n                assert!(json);\n            }\n            _ =\u003e panic!(\"Expected Status command\"),\n        }\n    }\n\n    #[test]\n    fn parses_history_basic() {\n        let cli = TestCli::try_parse_from([\"test\", \"history\", \"my-pipeline\"]).unwrap();\n        match cli.cmd {\n            PipelineCommand::History {\n                name, limit, json, ..\n            } =\u003e {\n                assert_eq!(name, \"my-pipeline\");\n                assert_eq!(limit, 10); // default\n                assert!(!json);\n            }\n            _ =\u003e panic!(\"Expected History command\"),\n        }\n    }\n\n    #[test]\n    fn parses_history_with_limit() {\n        let cli = TestCli::try_parse_from([\"test\", \"history\", \"my-pipeline\", \"-l\", \"25\"]).unwrap();\n        match cli.cmd {\n            PipelineCommand::History { limit, .. } =\u003e {\n                assert_eq!(limit, 25);\n            }\n            _ =\u003e panic!(\"Expected History command\"),\n        }\n    }\n\n    #[test]\n    fn parses_history_with_region() {\n        let cli = TestCli::try_parse_from([\"test\", \"history\", \"my-pipeline\", \"-r\", \"ap-south-1\"])\n            .unwrap();\n        match cli.cmd {\n            PipelineCommand::History { region, .. } =\u003e {\n                assert_eq!(region, Some(\"ap-south-1\".to_string()));\n            }\n            _ =\u003e panic!(\"Expected History command\"),\n        }\n    }\n\n    #[test]\n    fn parses_history_json() {\n        let cli = TestCli::try_parse_from([\"test\", \"history\", \"my-pipeline\", \"--json\"]).unwrap();\n        match cli.cmd {\n            PipelineCommand::History { json, .. } =\u003e {\n                assert!(json);\n            }\n            _ =\u003e panic!(\"Expected History command\"),\n        }\n    }\n\n    #[test]\n    fn command_debug() {\n        let cmd = PipelineCommand::List {\n            region: None,\n            json: false,\n        };\n        let debug = format!(\"{:?}\", cmd);\n        assert!(debug.contains(\"List\"));\n    }\n\n    #[test]\n    fn command_has_help() {\n        let mut cmd = TestCli::command();\n        let help = cmd.render_help();\n        assert!(!help.to_string().is_empty());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","pipeline","display","mod.rs"],"content":"//! Pipeline output formatting\n\nuse anyhow::{Context, Result};\nuse comfy_table::{presets::UTF8_FULL_CONDENSED, Cell, Color, ContentArrangement, Table};\n\nuse super::types::{OutputFormat, Pipeline, PipelineExecution, PipelineState, StageStatus};\n\n#[cfg(test)]\nmod tests;\n\n/// Get color for stage/execution status\nfn status_color(status: \u0026str) -\u003e Color {\n    match status {\n        \"Succeeded\" =\u003e Color::Green,\n        \"InProgress\" =\u003e Color::Yellow,\n        \"Failed\" =\u003e Color::Red,\n        \"Stopped\" | \"Cancelled\" | \"Superseded\" =\u003e Color::DarkGrey,\n        _ =\u003e Color::White,\n    }\n}\n\n/// Get icon for status\nfn status_icon(status: \u0026str) -\u003e \u0026'static str {\n    match status {\n        \"Succeeded\" =\u003e \"\",\n        \"InProgress\" =\u003e \"\",\n        \"Failed\" =\u003e \"\",\n        \"Stopped\" | \"Cancelled\" =\u003e \"\",\n        _ =\u003e \" \",\n    }\n}\n\n/// Output pipelines list\npub fn output_pipelines(pipelines: \u0026[Pipeline], format: OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            if pipelines.is_empty() {\n                println!(\"No pipelines found.\");\n                return Ok(());\n            }\n\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_content_arrangement(ContentArrangement::Dynamic);\n            table.set_header(vec![\"NAME\", \"CREATED\", \"UPDATED\"]);\n\n            for pipeline in pipelines {\n                table.add_row(vec![\n                    Cell::new(\u0026pipeline.name).fg(Color::Cyan),\n                    Cell::new(pipeline.created.as_deref().unwrap_or(\"-\")),\n                    Cell::new(pipeline.updated.as_deref().unwrap_or(\"-\")),\n                ]);\n            }\n\n            println!(\"{table}\");\n            println!(\"\\n{} pipelines\", pipelines.len());\n        }\n        OutputFormat::Json =\u003e {\n            let json =\n                serde_json::to_string_pretty(pipelines).context(\"Failed to serialize pipelines\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n\n/// Output pipeline state (stages with status)\npub fn output_pipeline_state(state: \u0026PipelineState, format: OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            println!(\"Pipeline: {}\", state.name);\n            println!();\n\n            if state.stages.is_empty() {\n                println!(\"No stages found.\");\n                return Ok(());\n            }\n\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_content_arrangement(ContentArrangement::Dynamic);\n            table.set_header(vec![\"STAGE\", \"STATUS\", \"ACTIONS\"]);\n\n            for stage in \u0026state.stages {\n                let status = stage\n                    .latest_execution\n                    .as_ref()\n                    .map(|e| e.status.as_str())\n                    .unwrap_or(\"-\");\n\n                let status_enum = StageStatus::from_str(status);\n                let icon = status_icon(status);\n                let display_status = format!(\"{} {}\", icon, status);\n\n                // Show action count\n                let action_count = stage.actions.len();\n                let action_summary = if action_count \u003e 0 {\n                    let succeeded = stage\n                        .actions\n                        .iter()\n                        .filter(|a| {\n                            a.latest_execution\n                                .as_ref()\n                                .map(|e| e.status == \"Succeeded\")\n                                .unwrap_or(false)\n                        })\n                        .count();\n                    format!(\"{}/{} succeeded\", succeeded, action_count)\n                } else {\n                    \"-\".to_string()\n                };\n\n                table.add_row(vec![\n                    Cell::new(\u0026stage.name).fg(Color::Cyan),\n                    Cell::new(\u0026display_status).fg(match status_enum {\n                        StageStatus::Succeeded =\u003e Color::Green,\n                        StageStatus::InProgress =\u003e Color::Yellow,\n                        StageStatus::Failed =\u003e Color::Red,\n                        _ =\u003e Color::White,\n                    }),\n                    Cell::new(\u0026action_summary),\n                ]);\n            }\n\n            println!(\"{table}\");\n        }\n        OutputFormat::Json =\u003e {\n            let json = serde_json::to_string_pretty(state)\n                .context(\"Failed to serialize pipeline state\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n\n/// Output pipeline execution history\npub fn output_executions(executions: \u0026[PipelineExecution], format: OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            if executions.is_empty() {\n                println!(\"No executions found.\");\n                return Ok(());\n            }\n\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_content_arrangement(ContentArrangement::Dynamic);\n            table.set_header(vec![\"ID\", \"STATUS\", \"STARTED\", \"TRIGGER\"]);\n\n            for exec in executions {\n                let icon = status_icon(\u0026exec.status);\n                let display_status = format!(\"{} {}\", icon, exec.status);\n\n                let trigger = exec\n                    .trigger\n                    .as_ref()\n                    .map(|t| t.trigger_type.as_str())\n                    .unwrap_or(\"-\");\n\n                table.add_row(vec![\n                    Cell::new(\u0026exec.id).fg(Color::Cyan),\n                    Cell::new(\u0026display_status).fg(status_color(\u0026exec.status)),\n                    Cell::new(exec.started.as_deref().unwrap_or(\"-\")),\n                    Cell::new(trigger),\n                ]);\n            }\n\n            println!(\"{table}\");\n            println!(\"\\n{} executions\", executions.len());\n        }\n        OutputFormat::Json =\u003e {\n            let json = serde_json::to_string_pretty(executions)\n                .context(\"Failed to serialize executions\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":8}},{"line":13,"address":[],"length":0,"stats":{"Line":8}},{"line":14,"address":[],"length":0,"stats":{"Line":10}},{"line":15,"address":[],"length":0,"stats":{"Line":7}},{"line":16,"address":[],"length":0,"stats":{"Line":6}},{"line":17,"address":[],"length":0,"stats":{"Line":12}},{"line":18,"address":[],"length":0,"stats":{"Line":1}},{"line":23,"address":[],"length":0,"stats":{"Line":12}},{"line":24,"address":[],"length":0,"stats":{"Line":12}},{"line":25,"address":[],"length":0,"stats":{"Line":15}},{"line":26,"address":[],"length":0,"stats":{"Line":11}},{"line":27,"address":[],"length":0,"stats":{"Line":9}},{"line":28,"address":[],"length":0,"stats":{"Line":11}},{"line":29,"address":[],"length":0,"stats":{"Line":2}},{"line":34,"address":[],"length":0,"stats":{"Line":3}},{"line":35,"address":[],"length":0,"stats":{"Line":3}},{"line":37,"address":[],"length":0,"stats":{"Line":4}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":39,"address":[],"length":0,"stats":{"Line":1}},{"line":42,"address":[],"length":0,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":3}},{"line":44,"address":[],"length":0,"stats":{"Line":3}},{"line":45,"address":[],"length":0,"stats":{"Line":5}},{"line":47,"address":[],"length":0,"stats":{"Line":4}},{"line":48,"address":[],"length":0,"stats":{"Line":4}},{"line":49,"address":[],"length":0,"stats":{"Line":5}},{"line":50,"address":[],"length":0,"stats":{"Line":6}},{"line":51,"address":[],"length":0,"stats":{"Line":4}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":56,"address":[],"length":0,"stats":{"Line":4}},{"line":59,"address":[],"length":0,"stats":{"Line":1}},{"line":60,"address":[],"length":0,"stats":{"Line":3}},{"line":61,"address":[],"length":0,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":2}},{"line":68,"address":[],"length":0,"stats":{"Line":7}},{"line":69,"address":[],"length":0,"stats":{"Line":7}},{"line":71,"address":[],"length":0,"stats":{"Line":12}},{"line":72,"address":[],"length":0,"stats":{"Line":6}},{"line":74,"address":[],"length":0,"stats":{"Line":12}},{"line":75,"address":[],"length":0,"stats":{"Line":2}},{"line":76,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":10}},{"line":80,"address":[],"length":0,"stats":{"Line":15}},{"line":81,"address":[],"length":0,"stats":{"Line":15}},{"line":82,"address":[],"length":0,"stats":{"Line":25}},{"line":84,"address":[],"length":0,"stats":{"Line":15}},{"line":85,"address":[],"length":0,"stats":{"Line":10}},{"line":86,"address":[],"length":0,"stats":{"Line":5}},{"line":88,"address":[],"length":0,"stats":{"Line":13}},{"line":91,"address":[],"length":0,"stats":{"Line":15}},{"line":92,"address":[],"length":0,"stats":{"Line":15}},{"line":93,"address":[],"length":0,"stats":{"Line":15}},{"line":96,"address":[],"length":0,"stats":{"Line":15}},{"line":97,"address":[],"length":0,"stats":{"Line":10}},{"line":98,"address":[],"length":0,"stats":{"Line":4}},{"line":99,"address":[],"length":0,"stats":{"Line":2}},{"line":101,"address":[],"length":0,"stats":{"Line":4}},{"line":102,"address":[],"length":0,"stats":{"Line":2}},{"line":103,"address":[],"length":0,"stats":{"Line":2}},{"line":104,"address":[],"length":0,"stats":{"Line":6}},{"line":105,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":4}},{"line":110,"address":[],"length":0,"stats":{"Line":6}},{"line":113,"address":[],"length":0,"stats":{"Line":15}},{"line":114,"address":[],"length":0,"stats":{"Line":20}},{"line":115,"address":[],"length":0,"stats":{"Line":20}},{"line":116,"address":[],"length":0,"stats":{"Line":1}},{"line":117,"address":[],"length":0,"stats":{"Line":1}},{"line":118,"address":[],"length":0,"stats":{"Line":1}},{"line":119,"address":[],"length":0,"stats":{"Line":2}},{"line":121,"address":[],"length":0,"stats":{"Line":10}},{"line":125,"address":[],"length":0,"stats":{"Line":10}},{"line":128,"address":[],"length":0,"stats":{"Line":3}},{"line":130,"address":[],"length":0,"stats":{"Line":2}},{"line":133,"address":[],"length":0,"stats":{"Line":6}},{"line":137,"address":[],"length":0,"stats":{"Line":3}},{"line":138,"address":[],"length":0,"stats":{"Line":3}},{"line":140,"address":[],"length":0,"stats":{"Line":4}},{"line":141,"address":[],"length":0,"stats":{"Line":2}},{"line":142,"address":[],"length":0,"stats":{"Line":1}},{"line":145,"address":[],"length":0,"stats":{"Line":2}},{"line":146,"address":[],"length":0,"stats":{"Line":3}},{"line":147,"address":[],"length":0,"stats":{"Line":3}},{"line":148,"address":[],"length":0,"stats":{"Line":6}},{"line":150,"address":[],"length":0,"stats":{"Line":3}},{"line":151,"address":[],"length":0,"stats":{"Line":3}},{"line":152,"address":[],"length":0,"stats":{"Line":3}},{"line":154,"address":[],"length":0,"stats":{"Line":2}},{"line":155,"address":[],"length":0,"stats":{"Line":1}},{"line":157,"address":[],"length":0,"stats":{"Line":3}},{"line":160,"address":[],"length":0,"stats":{"Line":3}},{"line":161,"address":[],"length":0,"stats":{"Line":4}},{"line":162,"address":[],"length":0,"stats":{"Line":5}},{"line":163,"address":[],"length":0,"stats":{"Line":5}},{"line":164,"address":[],"length":0,"stats":{"Line":2}},{"line":168,"address":[],"length":0,"stats":{"Line":2}},{"line":169,"address":[],"length":0,"stats":{"Line":4}},{"line":172,"address":[],"length":0,"stats":{"Line":3}},{"line":174,"address":[],"length":0,"stats":{"Line":2}},{"line":177,"address":[],"length":0,"stats":{"Line":2}}],"covered":100,"coverable":100},{"path":["/","Users","chi","Projects","hu","src","pipeline","display","tests.rs"],"content":"use super::*;\n\n#[test]\nfn status_color_succeeded() {\n    assert_eq!(status_color(\"Succeeded\"), Color::Green);\n}\n\n#[test]\nfn status_color_in_progress() {\n    assert_eq!(status_color(\"InProgress\"), Color::Yellow);\n}\n\n#[test]\nfn status_color_failed() {\n    assert_eq!(status_color(\"Failed\"), Color::Red);\n}\n\n#[test]\nfn status_color_stopped() {\n    assert_eq!(status_color(\"Stopped\"), Color::DarkGrey);\n}\n\n#[test]\nfn status_color_cancelled() {\n    assert_eq!(status_color(\"Cancelled\"), Color::DarkGrey);\n}\n\n#[test]\nfn status_color_unknown() {\n    assert_eq!(status_color(\"Unknown\"), Color::White);\n}\n\n#[test]\nfn status_icon_succeeded() {\n    assert_eq!(status_icon(\"Succeeded\"), \"\");\n}\n\n#[test]\nfn status_icon_in_progress() {\n    assert_eq!(status_icon(\"InProgress\"), \"\");\n}\n\n#[test]\nfn status_icon_failed() {\n    assert_eq!(status_icon(\"Failed\"), \"\");\n}\n\n#[test]\nfn status_icon_stopped() {\n    assert_eq!(status_icon(\"Stopped\"), \"\");\n}\n\n#[test]\nfn status_icon_unknown() {\n    assert_eq!(status_icon(\"Other\"), \" \");\n}\n\n#[test]\nfn status_icon_cancelled() {\n    assert_eq!(status_icon(\"Cancelled\"), \"\");\n}\n\n#[test]\nfn status_color_superseded() {\n    assert_eq!(status_color(\"Superseded\"), Color::DarkGrey);\n}\n\n#[test]\nfn output_pipelines_empty() {\n    let result = output_pipelines(\u0026[], OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_pipelines_table() {\n    let pipelines = vec![Pipeline {\n        name: \"test-pipeline\".to_string(),\n        created: Some(\"2026-01-01\".to_string()),\n        updated: None,\n    }];\n    let result = output_pipelines(\u0026pipelines, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_pipelines_json() {\n    let pipelines = vec![Pipeline {\n        name: \"test-pipeline\".to_string(),\n        created: None,\n        updated: None,\n    }];\n    let result = output_pipelines(\u0026pipelines, OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_pipeline_state_empty() {\n    let state = PipelineState {\n        name: \"test\".to_string(),\n        stages: vec![],\n    };\n    let result = output_pipeline_state(\u0026state, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_pipeline_state_table() {\n    use super::super::types::{ActionExecution, ActionState, StageExecution, StageState};\n\n    let state = PipelineState {\n        name: \"test-pipeline\".to_string(),\n        stages: vec![StageState {\n            name: \"Source\".to_string(),\n            latest_execution: Some(StageExecution {\n                status: \"Succeeded\".to_string(),\n            }),\n            actions: vec![ActionState {\n                name: \"SourceAction\".to_string(),\n                latest_execution: Some(ActionExecution {\n                    status: \"Succeeded\".to_string(),\n                    last_status_change: None,\n                }),\n            }],\n        }],\n    };\n    let result = output_pipeline_state(\u0026state, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_pipeline_state_with_all_statuses() {\n    use super::super::types::{ActionExecution, ActionState, StageExecution, StageState};\n\n    // Test with InProgress status\n    let state = PipelineState {\n        name: \"in-progress-pipeline\".to_string(),\n        stages: vec![StageState {\n            name: \"Build\".to_string(),\n            latest_execution: Some(StageExecution {\n                status: \"InProgress\".to_string(),\n            }),\n            actions: vec![ActionState {\n                name: \"BuildAction\".to_string(),\n                latest_execution: Some(ActionExecution {\n                    status: \"InProgress\".to_string(),\n                    last_status_change: Some(\"2026-01-01T00:00:00Z\".to_string()),\n                }),\n            }],\n        }],\n    };\n    assert!(output_pipeline_state(\u0026state, OutputFormat::Table).is_ok());\n\n    // Test with Failed status\n    let state = PipelineState {\n        name: \"failed-pipeline\".to_string(),\n        stages: vec![StageState {\n            name: \"Deploy\".to_string(),\n            latest_execution: Some(StageExecution {\n                status: \"Failed\".to_string(),\n            }),\n            actions: vec![],\n        }],\n    };\n    assert!(output_pipeline_state(\u0026state, OutputFormat::Table).is_ok());\n\n    // Test with Stopped status (triggers Unknown branch)\n    let state = PipelineState {\n        name: \"stopped-pipeline\".to_string(),\n        stages: vec![StageState {\n            name: \"Test\".to_string(),\n            latest_execution: Some(StageExecution {\n                status: \"Stopped\".to_string(),\n            }),\n            actions: vec![],\n        }],\n    };\n    assert!(output_pipeline_state(\u0026state, OutputFormat::Table).is_ok());\n\n    // Test stage with no execution\n    let state = PipelineState {\n        name: \"no-execution-pipeline\".to_string(),\n        stages: vec![StageState {\n            name: \"Pending\".to_string(),\n            latest_execution: None,\n            actions: vec![],\n        }],\n    };\n    assert!(output_pipeline_state(\u0026state, OutputFormat::Table).is_ok());\n}\n\n#[test]\nfn output_pipeline_state_json() {\n    let state = PipelineState {\n        name: \"test\".to_string(),\n        stages: vec![],\n    };\n    let result = output_pipeline_state(\u0026state, OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_executions_empty() {\n    let result = output_executions(\u0026[], OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_executions_table() {\n    use super::super::types::ExecutionTrigger;\n\n    let executions = vec![PipelineExecution {\n        id: \"exec-1\".to_string(),\n        status: \"Succeeded\".to_string(),\n        started: Some(\"2026-01-01T00:00:00Z\".to_string()),\n        updated: None,\n        trigger: Some(ExecutionTrigger {\n            trigger_type: \"Webhook\".to_string(),\n        }),\n    }];\n    let result = output_executions(\u0026executions, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn output_executions_json() {\n    let executions = vec![PipelineExecution {\n        id: \"exec-1\".to_string(),\n        status: \"Failed\".to_string(),\n        started: None,\n        updated: None,\n        trigger: None,\n    }];\n    let result = output_executions(\u0026executions, OutputFormat::Json);\n    assert!(result.is_ok());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","pipeline","mod.rs"],"content":"//! AWS CodePipeline status (read-only)\n//!\n//! List pipelines, view status, and check execution history.\n\nmod aws;\nmod cli;\nmod display;\nmod types;\n\nuse anyhow::Result;\n\npub use cli::PipelineCommand;\nuse types::{AwsConfig, OutputFormat};\n\n/// Run a pipeline command\npub async fn run(cmd: PipelineCommand) -\u003e Result\u003c()\u003e {\n    match cmd {\n        PipelineCommand::List { region, json } =\u003e cmd_list(region, json),\n        PipelineCommand::Status { name, region, json } =\u003e cmd_status(\u0026name, region, json),\n        PipelineCommand::History {\n            name,\n            region,\n            limit,\n            json,\n        } =\u003e cmd_history(\u0026name, region, limit, json),\n    }\n}\n\n/// List pipelines\nfn cmd_list(region: Option\u003cString\u003e, json: bool) -\u003e Result\u003c()\u003e {\n    let config = AwsConfig { region };\n    let pipelines = aws::list_pipelines(\u0026config)?;\n\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n\n    display::output_pipelines(\u0026pipelines, format)?;\n    Ok(())\n}\n\n/// Show pipeline status\nfn cmd_status(name: \u0026str, region: Option\u003cString\u003e, json: bool) -\u003e Result\u003c()\u003e {\n    let config = AwsConfig { region };\n    let state = aws::get_pipeline_state(\u0026config, name)?;\n\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n\n    display::output_pipeline_state(\u0026state, format)?;\n    Ok(())\n}\n\n/// Show pipeline execution history\nfn cmd_history(name: \u0026str, region: Option\u003cString\u003e, limit: usize, json: bool) -\u003e Result\u003c()\u003e {\n    let config = AwsConfig { region };\n    let executions = aws::list_executions(\u0026config, name, limit)?;\n\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n\n    display::output_executions(\u0026executions, format)?;\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn aws_config_from_region() {\n        let config = AwsConfig {\n            region: Some(\"us-east-1\".to_string()),\n        };\n        assert_eq!(config.region, Some(\"us-east-1\".to_string()));\n    }\n\n    #[test]\n    fn aws_config_default() {\n        let config = AwsConfig { region: None };\n        assert!(config.region.is_none());\n    }\n\n    #[test]\n    fn output_format_from_json_flag_true() {\n        let json = true;\n        let format = if json {\n            OutputFormat::Json\n        } else {\n            OutputFormat::Table\n        };\n        assert_eq!(format, OutputFormat::Json);\n    }\n\n    #[test]\n    fn output_format_from_json_flag_false() {\n        let json = false;\n        let format = if json {\n            OutputFormat::Json\n        } else {\n            OutputFormat::Table\n        };\n        assert_eq!(format, OutputFormat::Table);\n    }\n\n    #[test]\n    fn pipeline_command_list_matches() {\n        let cmd = PipelineCommand::List {\n            region: Some(\"us-west-2\".to_string()),\n            json: true,\n        };\n        match cmd {\n            PipelineCommand::List { region, json } =\u003e {\n                assert_eq!(region, Some(\"us-west-2\".to_string()));\n                assert!(json);\n            }\n            _ =\u003e panic!(\"Expected List command\"),\n        }\n    }\n\n    #[test]\n    fn pipeline_command_status_matches() {\n        let cmd = PipelineCommand::Status {\n            name: \"my-pipeline\".to_string(),\n            region: None,\n            json: false,\n        };\n        match cmd {\n            PipelineCommand::Status { name, region, json } =\u003e {\n                assert_eq!(name, \"my-pipeline\");\n                assert!(region.is_none());\n                assert!(!json);\n            }\n            _ =\u003e panic!(\"Expected Status command\"),\n        }\n    }\n\n    #[test]\n    fn pipeline_command_history_matches() {\n        let cmd = PipelineCommand::History {\n            name: \"prod-pipeline\".to_string(),\n            region: Some(\"eu-central-1\".to_string()),\n            limit: 25,\n            json: true,\n        };\n        match cmd {\n            PipelineCommand::History {\n                name,\n                region,\n                limit,\n                json,\n            } =\u003e {\n                assert_eq!(name, \"prod-pipeline\");\n                assert_eq!(region, Some(\"eu-central-1\".to_string()));\n                assert_eq!(limit, 25);\n                assert!(json);\n            }\n            _ =\u003e panic!(\"Expected History command\"),\n        }\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":2}},{"line":17,"address":[],"length":0,"stats":{"Line":1}},{"line":18,"address":[],"length":0,"stats":{"Line":5}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":1}},{"line":31,"address":[],"length":0,"stats":{"Line":2}},{"line":32,"address":[],"length":0,"stats":{"Line":3}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}}],"covered":6,"coverable":33},{"path":["/","Users","chi","Projects","hu","src","pipeline","types.rs"],"content":"//! CodePipeline data types\n\nuse serde::{Deserialize, Serialize};\n\n/// Pipeline summary\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Pipeline {\n    /// Pipeline name\n    pub name: String,\n    /// Creation time\n    #[serde(default)]\n    pub created: Option\u003cString\u003e,\n    /// Last update time\n    #[serde(default)]\n    pub updated: Option\u003cString\u003e,\n}\n\n/// Pipeline state (current status)\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PipelineState {\n    /// Pipeline name\n    #[serde(rename = \"pipelineName\")]\n    pub name: String,\n    /// Stage states\n    #[serde(rename = \"stageStates\", default)]\n    pub stages: Vec\u003cStageState\u003e,\n}\n\n/// Stage state\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct StageState {\n    /// Stage name\n    #[serde(rename = \"stageName\")]\n    pub name: String,\n    /// Latest execution\n    #[serde(rename = \"latestExecution\", default)]\n    pub latest_execution: Option\u003cStageExecution\u003e,\n    /// Action states\n    #[serde(rename = \"actionStates\", default)]\n    pub actions: Vec\u003cActionState\u003e,\n}\n\n/// Stage execution info\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct StageExecution {\n    /// Status\n    pub status: String,\n}\n\n/// Action state\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ActionState {\n    /// Action name\n    #[serde(rename = \"actionName\")]\n    pub name: String,\n    /// Latest execution\n    #[serde(rename = \"latestExecution\", default)]\n    pub latest_execution: Option\u003cActionExecution\u003e,\n}\n\n/// Action execution info\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ActionExecution {\n    /// Status\n    pub status: String,\n    /// Last status change\n    #[serde(rename = \"lastStatusChange\", default)]\n    pub last_status_change: Option\u003cString\u003e,\n}\n\n/// Pipeline execution summary\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PipelineExecution {\n    /// Execution ID\n    #[serde(rename = \"pipelineExecutionId\")]\n    pub id: String,\n    /// Status\n    pub status: String,\n    /// Start time\n    #[serde(rename = \"startTime\", default)]\n    pub started: Option\u003cString\u003e,\n    /// Last update time\n    #[serde(rename = \"lastUpdateTime\", default)]\n    pub updated: Option\u003cString\u003e,\n    /// Trigger info\n    #[serde(default)]\n    pub trigger: Option\u003cExecutionTrigger\u003e,\n}\n\n/// Execution trigger\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ExecutionTrigger {\n    /// Trigger type\n    #[serde(rename = \"triggerType\")]\n    pub trigger_type: String,\n}\n\n/// Stage status enum\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum StageStatus {\n    /// In progress\n    InProgress,\n    /// Succeeded\n    Succeeded,\n    /// Failed\n    Failed,\n    /// Stopped\n    Stopped,\n    /// Unknown\n    Unknown,\n}\n\nimpl StageStatus {\n    /// Parse from string\n    pub fn from_str(s: \u0026str) -\u003e Self {\n        match s {\n            \"InProgress\" =\u003e Self::InProgress,\n            \"Succeeded\" =\u003e Self::Succeeded,\n            \"Failed\" =\u003e Self::Failed,\n            \"Stopped\" =\u003e Self::Stopped,\n            _ =\u003e Self::Unknown,\n        }\n    }\n}\n\n/// Output format\n#[derive(Debug, Clone, Copy, Default, PartialEq, Eq)]\npub enum OutputFormat {\n    /// Table format\n    #[default]\n    Table,\n    /// JSON format\n    Json,\n}\n\n/// AWS CLI configuration\n#[derive(Debug, Clone, Default)]\npub struct AwsConfig {\n    /// AWS region\n    pub region: Option\u003cString\u003e,\n}\n\n/// List pipelines response\n#[derive(Debug, Deserialize)]\npub struct ListPipelinesResponse {\n    /// Pipelines\n    pub pipelines: Vec\u003cPipelineSummary\u003e,\n}\n\n/// Pipeline summary from list\n#[derive(Debug, Deserialize)]\npub struct PipelineSummary {\n    /// Name\n    pub name: String,\n    /// Created\n    pub created: Option\u003cString\u003e,\n    /// Updated\n    pub updated: Option\u003cString\u003e,\n}\n\nimpl PipelineSummary {\n    /// Convert to Pipeline\n    pub fn to_pipeline(\u0026self) -\u003e Pipeline {\n        Pipeline {\n            name: self.name.clone(),\n            created: self.created.clone(),\n            updated: self.updated.clone(),\n        }\n    }\n}\n\n/// List executions response\n#[derive(Debug, Deserialize)]\npub struct ListExecutionsResponse {\n    /// Executions\n    #[serde(rename = \"pipelineExecutionSummaries\")]\n    pub executions: Vec\u003cPipelineExecution\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn pipeline_debug() {\n        let p = Pipeline {\n            name: \"test\".to_string(),\n            created: None,\n            updated: None,\n        };\n        let debug = format!(\"{:?}\", p);\n        assert!(debug.contains(\"test\"));\n    }\n\n    #[test]\n    fn pipeline_clone() {\n        let p = Pipeline {\n            name: \"test\".to_string(),\n            created: Some(\"2026-01-01\".to_string()),\n            updated: None,\n        };\n        let cloned = p.clone();\n        assert_eq!(cloned.name, p.name);\n    }\n\n    #[test]\n    fn stage_status_from_str() {\n        assert_eq!(StageStatus::from_str(\"InProgress\"), StageStatus::InProgress);\n        assert_eq!(StageStatus::from_str(\"Succeeded\"), StageStatus::Succeeded);\n        assert_eq!(StageStatus::from_str(\"Failed\"), StageStatus::Failed);\n        assert_eq!(StageStatus::from_str(\"Stopped\"), StageStatus::Stopped);\n        assert_eq!(StageStatus::from_str(\"Other\"), StageStatus::Unknown);\n    }\n\n    #[test]\n    fn output_format_default() {\n        let format = OutputFormat::default();\n        assert_eq!(format, OutputFormat::Table);\n    }\n\n    #[test]\n    fn aws_config_default() {\n        let config = AwsConfig::default();\n        assert!(config.region.is_none());\n    }\n\n    #[test]\n    fn parse_list_pipelines_response() {\n        let json = r#\"{\n            \"pipelines\": [\n                {\"name\": \"pipeline-1\", \"created\": \"2026-01-01\", \"updated\": \"2026-01-02\"},\n                {\"name\": \"pipeline-2\"}\n            ]\n        }\"#;\n        let resp: ListPipelinesResponse = serde_json::from_str(json).unwrap();\n        assert_eq!(resp.pipelines.len(), 2);\n        assert_eq!(resp.pipelines[0].name, \"pipeline-1\");\n    }\n\n    #[test]\n    fn parse_pipeline_state() {\n        let json = r#\"{\n            \"pipelineName\": \"my-pipeline\",\n            \"stageStates\": [\n                {\n                    \"stageName\": \"Source\",\n                    \"latestExecution\": {\"status\": \"Succeeded\"},\n                    \"actionStates\": []\n                }\n            ]\n        }\"#;\n        let state: PipelineState = serde_json::from_str(json).unwrap();\n        assert_eq!(state.name, \"my-pipeline\");\n        assert_eq!(state.stages.len(), 1);\n        assert_eq!(state.stages[0].name, \"Source\");\n    }\n\n    #[test]\n    fn parse_list_executions_response() {\n        let json = r#\"{\n            \"pipelineExecutionSummaries\": [\n                {\n                    \"pipelineExecutionId\": \"exec-1\",\n                    \"status\": \"Succeeded\",\n                    \"startTime\": \"2026-01-01T00:00:00Z\",\n                    \"trigger\": {\"triggerType\": \"Webhook\"}\n                }\n            ]\n        }\"#;\n        let resp: ListExecutionsResponse = serde_json::from_str(json).unwrap();\n        assert_eq!(resp.executions.len(), 1);\n        assert_eq!(resp.executions[0].id, \"exec-1\");\n        assert_eq!(resp.executions[0].status, \"Succeeded\");\n    }\n\n    #[test]\n    fn pipeline_summary_to_pipeline() {\n        let summary = PipelineSummary {\n            name: \"test\".to_string(),\n            created: Some(\"2026-01-01\".to_string()),\n            updated: None,\n        };\n        let pipeline = summary.to_pipeline();\n        assert_eq!(pipeline.name, \"test\");\n        assert_eq!(pipeline.created, Some(\"2026-01-01\".to_string()));\n    }\n}\n","traces":[{"line":115,"address":[],"length":0,"stats":{"Line":10}},{"line":116,"address":[],"length":0,"stats":{"Line":10}},{"line":117,"address":[],"length":0,"stats":{"Line":12}},{"line":118,"address":[],"length":0,"stats":{"Line":10}},{"line":119,"address":[],"length":0,"stats":{"Line":8}},{"line":120,"address":[],"length":0,"stats":{"Line":6}},{"line":121,"address":[],"length":0,"stats":{"Line":2}},{"line":163,"address":[],"length":0,"stats":{"Line":5}},{"line":165,"address":[],"length":0,"stats":{"Line":15}},{"line":166,"address":[],"length":0,"stats":{"Line":15}},{"line":167,"address":[],"length":0,"stats":{"Line":5}}],"covered":11,"coverable":11},{"path":["/","Users","chi","Projects","hu","src","read","around.rs"],"content":"/// Extract lines around a center line with context\npub fn extract_lines_around(\n    content: \u0026str,\n    center: usize,\n    context: usize,\n) -\u003e (Vec\u003c(usize, String)\u003e, usize) {\n    let lines: Vec\u003c\u0026str\u003e = content.lines().collect();\n    let total_lines = lines.len();\n\n    if total_lines == 0 || center == 0 {\n        return (vec![], total_lines);\n    }\n\n    // Convert to 0-indexed\n    let center_idx = center.saturating_sub(1);\n\n    // Calculate range with clamping\n    let start = center_idx.saturating_sub(context);\n    let end = (center_idx + context + 1).min(total_lines);\n\n    let result: Vec\u003c(usize, String)\u003e = lines[start..end]\n        .iter()\n        .enumerate()\n        .map(|(i, line)| (start + i + 1, (*line).to_string()))\n        .collect();\n\n    (result, total_lines)\n}\n\n/// Format lines with line numbers and highlight center\npub fn format_lines_around(lines: \u0026[(usize, String)], center: usize, total_lines: usize) -\u003e String {\n    if lines.is_empty() {\n        return \"No content\".to_string();\n    }\n\n    let width = total_lines.to_string().len();\n    let mut output = Vec::new();\n\n    for (num, line) in lines {\n        let marker = if *num == center { \"\u003e\" } else { \" \" };\n        output.push(format!(\n            \"{}{:\u003ewidth$}: {}\",\n            marker,\n            num,\n            line,\n            width = width\n        ));\n    }\n\n    output.join(\"\\n\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn extract_basic() {\n        let content = \"line1\\nline2\\nline3\\nline4\\nline5\";\n        let (lines, total) = extract_lines_around(content, 3, 1);\n        assert_eq!(total, 5);\n        assert_eq!(lines.len(), 3);\n        assert_eq!(lines[0], (2, \"line2\".to_string()));\n        assert_eq!(lines[1], (3, \"line3\".to_string()));\n        assert_eq!(lines[2], (4, \"line4\".to_string()));\n    }\n\n    #[test]\n    fn extract_at_start() {\n        let content = \"line1\\nline2\\nline3\\nline4\\nline5\";\n        let (lines, _) = extract_lines_around(content, 1, 2);\n        assert_eq!(lines.len(), 3);\n        assert_eq!(lines[0], (1, \"line1\".to_string()));\n    }\n\n    #[test]\n    fn extract_at_end() {\n        let content = \"line1\\nline2\\nline3\\nline4\\nline5\";\n        let (lines, _) = extract_lines_around(content, 5, 2);\n        assert_eq!(lines.len(), 3);\n        assert_eq!(lines[2], (5, \"line5\".to_string()));\n    }\n\n    #[test]\n    fn extract_beyond_bounds() {\n        let content = \"line1\\nline2\\nline3\";\n        let (lines, _) = extract_lines_around(content, 2, 10);\n        assert_eq!(lines.len(), 3);\n    }\n\n    #[test]\n    fn extract_empty_content() {\n        let (lines, total) = extract_lines_around(\"\", 1, 5);\n        assert!(lines.is_empty());\n        assert_eq!(total, 0);\n    }\n\n    #[test]\n    fn extract_zero_center() {\n        let content = \"line1\\nline2\";\n        let (lines, _) = extract_lines_around(content, 0, 5);\n        assert!(lines.is_empty());\n    }\n\n    #[test]\n    fn extract_zero_context() {\n        let content = \"line1\\nline2\\nline3\";\n        let (lines, _) = extract_lines_around(content, 2, 0);\n        assert_eq!(lines.len(), 1);\n        assert_eq!(lines[0], (2, \"line2\".to_string()));\n    }\n\n    #[test]\n    fn extract_single_line() {\n        let content = \"only line\";\n        let (lines, total) = extract_lines_around(content, 1, 5);\n        assert_eq!(lines.len(), 1);\n        assert_eq!(total, 1);\n    }\n\n    #[test]\n    fn format_basic() {\n        let lines = vec![\n            (9, \"line9\".to_string()),\n            (10, \"line10\".to_string()),\n            (11, \"line11\".to_string()),\n        ];\n        let output = format_lines_around(\u0026lines, 10, 11);\n        assert!(output.contains(\"\u003e10: line10\"));\n        assert!(output.contains(\" 9: line9\"));\n        assert!(output.contains(\"11: line11\"));\n    }\n\n    #[test]\n    fn format_empty() {\n        let lines: Vec\u003c(usize, String)\u003e = vec![];\n        let output = format_lines_around(\u0026lines, 1, 0);\n        assert_eq!(output, \"No content\");\n    }\n\n    #[test]\n    fn format_line_numbers_aligned() {\n        let lines = vec![\n            (1, \"first\".to_string()),\n            (10, \"tenth\".to_string()),\n            (100, \"hundredth\".to_string()),\n        ];\n        let output = format_lines_around(\u0026lines, 10, 100);\n        // All line numbers should be right-aligned with same width\n        let output_lines: Vec\u003c\u0026str\u003e = output.lines().collect();\n        assert!(output_lines[0].starts_with(\"   1:\"));\n        assert!(output_lines[1].starts_with(\"\u003e 10:\"));\n        assert!(output_lines[2].starts_with(\" 100:\"));\n    }\n\n    #[test]\n    fn format_preserves_content() {\n        let lines = vec![\n            (1, \"  indented content\".to_string()),\n            (2, \"normal\".to_string()),\n        ];\n        let output = format_lines_around(\u0026lines, 1, 10);\n        assert!(output.contains(\"  indented content\"));\n    }\n}\n","traces":[{"line":2,"address":[],"length":0,"stats":{"Line":9}},{"line":7,"address":[],"length":0,"stats":{"Line":45}},{"line":8,"address":[],"length":0,"stats":{"Line":27}},{"line":10,"address":[],"length":0,"stats":{"Line":17}},{"line":11,"address":[],"length":0,"stats":{"Line":2}},{"line":15,"address":[],"length":0,"stats":{"Line":21}},{"line":18,"address":[],"length":0,"stats":{"Line":28}},{"line":19,"address":[],"length":0,"stats":{"Line":28}},{"line":21,"address":[],"length":0,"stats":{"Line":28}},{"line":24,"address":[],"length":0,"stats":{"Line":70}},{"line":27,"address":[],"length":0,"stats":{"Line":7}},{"line":31,"address":[],"length":0,"stats":{"Line":5}},{"line":32,"address":[],"length":0,"stats":{"Line":10}},{"line":33,"address":[],"length":0,"stats":{"Line":2}},{"line":36,"address":[],"length":0,"stats":{"Line":12}},{"line":37,"address":[],"length":0,"stats":{"Line":8}},{"line":39,"address":[],"length":0,"stats":{"Line":49}},{"line":40,"address":[],"length":0,"stats":{"Line":45}},{"line":41,"address":[],"length":0,"stats":{"Line":45}},{"line":42,"address":[],"length":0,"stats":{"Line":15}},{"line":50,"address":[],"length":0,"stats":{"Line":8}}],"covered":21,"coverable":21},{"path":["/","Users","chi","Projects","hu","src","read","cli.rs"],"content":"use clap::Args;\n\n#[derive(Debug, Args)]\npub struct ReadArgs {\n    /// File path to read\n    pub path: String,\n\n    /// Show file outline (functions, structs, classes)\n    #[arg(long, short = 'o')]\n    pub outline: bool,\n\n    /// Show public interface only (pub items in Rust, exports in JS)\n    #[arg(long, short = 'i')]\n    pub interface: bool,\n\n    /// Show lines around a specific line number\n    #[arg(long, short = 'a', value_name = \"LINE\")]\n    pub around: Option\u003cusize\u003e,\n\n    /// Number of context lines for --around (default: 10)\n    #[arg(long, short = 'n', default_value = \"10\")]\n    pub context: usize,\n\n    /// Show git diff\n    #[arg(long, short = 'd')]\n    pub diff: bool,\n\n    /// Commit to diff against (default: HEAD)\n    #[arg(long, default_value = \"HEAD\")]\n    pub commit: String,\n}\n\nimpl ReadArgs {\n    /// Check if any mode is active (outline, interface, around, diff)\n    #[cfg(test)]\n    pub fn has_mode(\u0026self) -\u003e bool {\n        self.outline || self.interface || self.around.is_some() || self.diff\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use clap::Parser;\n\n    #[derive(Parser)]\n    struct TestCli {\n        #[command(flatten)]\n        read: ReadArgs,\n    }\n\n    #[test]\n    fn parse_path_only() {\n        let cli = TestCli::try_parse_from([\"test\", \"file.rs\"]).unwrap();\n        assert_eq!(cli.read.path, \"file.rs\");\n        assert!(!cli.read.outline);\n        assert!(!cli.read.interface);\n        assert!(cli.read.around.is_none());\n        assert!(!cli.read.diff);\n    }\n\n    #[test]\n    fn parse_outline_long() {\n        let cli = TestCli::try_parse_from([\"test\", \"--outline\", \"file.rs\"]).unwrap();\n        assert!(cli.read.outline);\n    }\n\n    #[test]\n    fn parse_outline_short() {\n        let cli = TestCli::try_parse_from([\"test\", \"-o\", \"file.rs\"]).unwrap();\n        assert!(cli.read.outline);\n    }\n\n    #[test]\n    fn parse_interface_long() {\n        let cli = TestCli::try_parse_from([\"test\", \"--interface\", \"file.rs\"]).unwrap();\n        assert!(cli.read.interface);\n    }\n\n    #[test]\n    fn parse_interface_short() {\n        let cli = TestCli::try_parse_from([\"test\", \"-i\", \"file.rs\"]).unwrap();\n        assert!(cli.read.interface);\n    }\n\n    #[test]\n    fn parse_around_long() {\n        let cli = TestCli::try_parse_from([\"test\", \"--around\", \"50\", \"file.rs\"]).unwrap();\n        assert_eq!(cli.read.around, Some(50));\n    }\n\n    #[test]\n    fn parse_around_short() {\n        let cli = TestCli::try_parse_from([\"test\", \"-a\", \"100\", \"file.rs\"]).unwrap();\n        assert_eq!(cli.read.around, Some(100));\n    }\n\n    #[test]\n    fn parse_context_long() {\n        let cli = TestCli::try_parse_from([\"test\", \"-a\", \"50\", \"-n\", \"20\", \"file.rs\"]).unwrap();\n        assert_eq!(cli.read.context, 20);\n    }\n\n    #[test]\n    fn parse_context_default() {\n        let cli = TestCli::try_parse_from([\"test\", \"file.rs\"]).unwrap();\n        assert_eq!(cli.read.context, 10);\n    }\n\n    #[test]\n    fn parse_diff_flag() {\n        let cli = TestCli::try_parse_from([\"test\", \"--diff\", \"file.rs\"]).unwrap();\n        assert!(cli.read.diff);\n        assert_eq!(cli.read.commit, \"HEAD\");\n    }\n\n    #[test]\n    fn parse_diff_with_commit() {\n        let cli =\n            TestCli::try_parse_from([\"test\", \"--diff\", \"--commit\", \"HEAD~1\", \"file.rs\"]).unwrap();\n        assert!(cli.read.diff);\n        assert_eq!(cli.read.commit, \"HEAD~1\");\n    }\n\n    #[test]\n    fn has_mode_none() {\n        let cli = TestCli::try_parse_from([\"test\", \"file.rs\"]).unwrap();\n        assert!(!cli.read.has_mode());\n    }\n\n    #[test]\n    fn has_mode_outline() {\n        let cli = TestCli::try_parse_from([\"test\", \"-o\", \"file.rs\"]).unwrap();\n        assert!(cli.read.has_mode());\n    }\n\n    #[test]\n    fn has_mode_interface() {\n        let cli = TestCli::try_parse_from([\"test\", \"-i\", \"file.rs\"]).unwrap();\n        assert!(cli.read.has_mode());\n    }\n\n    #[test]\n    fn has_mode_around() {\n        let cli = TestCli::try_parse_from([\"test\", \"-a\", \"50\", \"file.rs\"]).unwrap();\n        assert!(cli.read.has_mode());\n    }\n\n    #[test]\n    fn has_mode_diff() {\n        let cli = TestCli::try_parse_from([\"test\", \"-d\", \"file.rs\"]).unwrap();\n        assert!(cli.read.has_mode());\n    }\n\n    #[test]\n    fn read_args_debug() {\n        let cli = TestCli::try_parse_from([\"test\", \"file.rs\"]).unwrap();\n        let debug = format!(\"{:?}\", cli.read);\n        assert!(debug.contains(\"ReadArgs\"));\n    }\n\n    #[test]\n    fn path_required() {\n        let result = TestCli::try_parse_from([\"test\"]);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn combined_flags() {\n        let cli = TestCli::try_parse_from([\"test\", \"-o\", \"-i\", \"-a\", \"50\", \"-n\", \"5\", \"file.rs\"])\n            .unwrap();\n        assert!(cli.read.outline);\n        assert!(cli.read.interface);\n        assert_eq!(cli.read.around, Some(50));\n        assert_eq!(cli.read.context, 5);\n    }\n}\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":5}},{"line":37,"address":[],"length":0,"stats":{"Line":17}}],"covered":2,"coverable":2},{"path":["/","Users","chi","Projects","hu","src","read","diff.rs"],"content":"use anyhow::{Context, Result};\nuse std::path::Path;\nuse std::process::Command;\n\n/// Get git diff for a file against a commit\npub fn git_diff(path: \u0026str, commit: Option\u003c\u0026str\u003e) -\u003e Result\u003cString\u003e {\n    let commit_ref = commit.unwrap_or(\"HEAD\");\n\n    // Verify file exists\n    let path = Path::new(path);\n    if !path.exists() {\n        anyhow::bail!(\"File not found: {}\", path.display());\n    }\n\n    // Run git diff\n    let output = Command::new(\"git\")\n        .args([\"diff\", commit_ref, \"--\", path.to_str().unwrap_or(\"\")])\n        .output()\n        .context(\"Failed to run git diff\")?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        anyhow::bail!(\"git diff failed: {}\", stderr);\n    }\n\n    let diff = String::from_utf8_lossy(\u0026output.stdout).to_string();\n\n    if diff.is_empty() {\n        return Ok(\"No changes\".to_string());\n    }\n\n    Ok(diff)\n}\n\n/// Format diff output with colors\npub fn format_diff(diff: \u0026str) -\u003e String {\n    if diff == \"No changes\" {\n        return diff.to_string();\n    }\n\n    let mut output = Vec::new();\n\n    for line in diff.lines() {\n        if line.starts_with('+') \u0026\u0026 !line.starts_with(\"+++\") {\n            // Added line - green\n            output.push(format!(\"\\x1b[32m{}\\x1b[0m\", line));\n        } else if line.starts_with('-') \u0026\u0026 !line.starts_with(\"---\") {\n            // Removed line - red\n            output.push(format!(\"\\x1b[31m{}\\x1b[0m\", line));\n        } else if line.starts_with(\"@@\") {\n            // Hunk header - cyan\n            output.push(format!(\"\\x1b[36m{}\\x1b[0m\", line));\n        } else if line.starts_with(\"diff\") || line.starts_with(\"index\") {\n            // Header - dim\n            output.push(format!(\"\\x1b[2m{}\\x1b[0m\", line));\n        } else {\n            output.push(line.to_string());\n        }\n    }\n\n    output.join(\"\\n\")\n}\n\n/// Parse diff to extract changed line ranges\n#[cfg(test)]\npub fn parse_diff_hunks(diff: \u0026str) -\u003e Vec\u003cDiffHunk\u003e {\n    let mut hunks = Vec::new();\n    let hunk_re = regex::Regex::new(r\"@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@\").unwrap();\n\n    for caps in hunk_re.captures_iter(diff) {\n        let old_start: usize = caps.get(1).unwrap().as_str().parse().unwrap_or(0);\n        let old_count: usize = caps\n            .get(2)\n            .map(|m| m.as_str().parse().unwrap_or(1))\n            .unwrap_or(1);\n        let new_start: usize = caps.get(3).unwrap().as_str().parse().unwrap_or(0);\n        let new_count: usize = caps\n            .get(4)\n            .map(|m| m.as_str().parse().unwrap_or(1))\n            .unwrap_or(1);\n\n        hunks.push(DiffHunk {\n            old_start,\n            old_count,\n            new_start,\n            new_count,\n        });\n    }\n\n    hunks\n}\n\n/// A diff hunk (changed section)\n#[cfg(test)]\n#[derive(Debug, Clone, PartialEq)]\npub struct DiffHunk {\n    pub old_start: usize,\n    pub old_count: usize,\n    pub new_start: usize,\n    pub new_count: usize,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn format_diff_additions() {\n        let diff = \"+added line\";\n        let formatted = format_diff(diff);\n        assert!(formatted.contains(\"\\x1b[32m\"));\n        assert!(formatted.contains(\"+added line\"));\n    }\n\n    #[test]\n    fn format_diff_deletions() {\n        let diff = \"-removed line\";\n        let formatted = format_diff(diff);\n        assert!(formatted.contains(\"\\x1b[31m\"));\n        assert!(formatted.contains(\"-removed line\"));\n    }\n\n    #[test]\n    fn format_diff_hunk_header() {\n        let diff = \"@@ -1,3 +1,4 @@\";\n        let formatted = format_diff(diff);\n        assert!(formatted.contains(\"\\x1b[36m\"));\n    }\n\n    #[test]\n    fn format_diff_file_header() {\n        let diff = \"diff --git a/file.rs b/file.rs\";\n        let formatted = format_diff(diff);\n        assert!(formatted.contains(\"\\x1b[2m\"));\n    }\n\n    #[test]\n    fn format_diff_no_changes() {\n        let formatted = format_diff(\"No changes\");\n        assert_eq!(formatted, \"No changes\");\n    }\n\n    #[test]\n    fn format_diff_preserves_context() {\n        let diff = \" unchanged line\";\n        let formatted = format_diff(diff);\n        assert_eq!(formatted, \" unchanged line\");\n    }\n\n    #[test]\n    fn format_diff_plus_header_not_green() {\n        let diff = \"+++ b/file.rs\";\n        let formatted = format_diff(diff);\n        // Should not have green color code\n        assert!(!formatted.contains(\"\\x1b[32m\"));\n    }\n\n    #[test]\n    fn format_diff_minus_header_not_red() {\n        let diff = \"--- a/file.rs\";\n        let formatted = format_diff(diff);\n        // Should not have red color code\n        assert!(!formatted.contains(\"\\x1b[31m\"));\n    }\n\n    #[test]\n    fn parse_diff_hunks_single() {\n        let diff = \"@@ -1,3 +1,4 @@\";\n        let hunks = parse_diff_hunks(diff);\n        assert_eq!(hunks.len(), 1);\n        assert_eq!(hunks[0].old_start, 1);\n        assert_eq!(hunks[0].old_count, 3);\n        assert_eq!(hunks[0].new_start, 1);\n        assert_eq!(hunks[0].new_count, 4);\n    }\n\n    #[test]\n    fn parse_diff_hunks_multiple() {\n        let diff = \"@@ -1,3 +1,4 @@\\nsome content\\n@@ -10,5 +11,6 @@\";\n        let hunks = parse_diff_hunks(diff);\n        assert_eq!(hunks.len(), 2);\n        assert_eq!(hunks[1].old_start, 10);\n        assert_eq!(hunks[1].new_start, 11);\n    }\n\n    #[test]\n    fn parse_diff_hunks_no_count() {\n        let diff = \"@@ -5 +5 @@\";\n        let hunks = parse_diff_hunks(diff);\n        assert_eq!(hunks.len(), 1);\n        assert_eq!(hunks[0].old_count, 1);\n        assert_eq!(hunks[0].new_count, 1);\n    }\n\n    #[test]\n    fn parse_diff_hunks_empty() {\n        let diff = \"no hunks here\";\n        let hunks = parse_diff_hunks(diff);\n        assert!(hunks.is_empty());\n    }\n\n    #[test]\n    fn diff_hunk_clone() {\n        let hunk = DiffHunk {\n            old_start: 1,\n            old_count: 2,\n            new_start: 3,\n            new_count: 4,\n        };\n        let cloned = hunk.clone();\n        assert_eq!(hunk, cloned);\n    }\n\n    #[test]\n    fn diff_hunk_debug() {\n        let hunk = DiffHunk {\n            old_start: 1,\n            old_count: 2,\n            new_start: 3,\n            new_count: 4,\n        };\n        let debug = format!(\"{:?}\", hunk);\n        assert!(debug.contains(\"DiffHunk\"));\n    }\n\n    // Integration test - requires git repo\n    #[test]\n    fn git_diff_cargo_toml() {\n        // This test uses Cargo.toml which should exist in a git repo\n        let result = git_diff(\n            concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/Cargo.toml\"),\n            Some(\"HEAD\"),\n        );\n        // Either succeeds with diff or \"No changes\"\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn git_diff_nonexistent_file() {\n        let result = git_diff(\"/nonexistent/file.txt\", None);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn git_diff_invalid_commit() {\n        // Using an invalid commit reference should cause git diff to fail\n        let result = git_diff(\n            concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/Cargo.toml\"),\n            Some(\"invalid_commit_ref_that_does_not_exist_xyz123\"),\n        );\n        assert!(result.is_err());\n        let err = result.unwrap_err().to_string();\n        assert!(err.contains(\"git diff failed\"));\n    }\n\n    #[test]\n    fn format_diff_index_header() {\n        let diff = \"index abc123..def456 100644\";\n        let formatted = format_diff(diff);\n        // Should have dim color\n        assert!(formatted.contains(\"\\x1b[2m\"));\n    }\n\n    #[test]\n    fn git_diff_with_actual_changes() {\n        // Compare src/main.rs against an older commit to ensure we get actual diff output\n        // This tests the Ok(diff) return path (line 32) when diff is non-empty\n        let result = git_diff(\n            concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/src/main.rs\"),\n            Some(\"HEAD~20\"), // src/main.rs changes frequently\n        );\n\n        // This test is designed to exercise the non-empty diff return path\n        match result {\n            Ok(diff) =\u003e {\n                // Either \"No changes\" or actual diff content\n                if diff != \"No changes\" {\n                    assert!(\n                        diff.contains(\"diff\") || diff.contains(\"@@\"),\n                        \"Expected diff content but got: {}\",\n                        diff\n                    );\n                }\n            }\n            Err(_) =\u003e {\n                // If not enough history, skip silently - this is CI-friendly\n            }\n        }\n    }\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":6}},{"line":7,"address":[],"length":0,"stats":{"Line":24}},{"line":10,"address":[],"length":0,"stats":{"Line":18}},{"line":11,"address":[],"length":0,"stats":{"Line":6}},{"line":12,"address":[],"length":0,"stats":{"Line":4}},{"line":16,"address":[],"length":0,"stats":{"Line":15}},{"line":17,"address":[],"length":0,"stats":{"Line":30}},{"line":21,"address":[],"length":0,"stats":{"Line":5}},{"line":22,"address":[],"length":0,"stats":{"Line":3}},{"line":23,"address":[],"length":0,"stats":{"Line":2}},{"line":26,"address":[],"length":0,"stats":{"Line":12}},{"line":28,"address":[],"length":0,"stats":{"Line":8}},{"line":29,"address":[],"length":0,"stats":{"Line":3}},{"line":32,"address":[],"length":0,"stats":{"Line":1}},{"line":36,"address":[],"length":0,"stats":{"Line":11}},{"line":37,"address":[],"length":0,"stats":{"Line":11}},{"line":38,"address":[],"length":0,"stats":{"Line":6}},{"line":41,"address":[],"length":0,"stats":{"Line":16}},{"line":43,"address":[],"length":0,"stats":{"Line":24}},{"line":44,"address":[],"length":0,"stats":{"Line":19}},{"line":46,"address":[],"length":0,"stats":{"Line":3}},{"line":47,"address":[],"length":0,"stats":{"Line":18}},{"line":49,"address":[],"length":0,"stats":{"Line":3}},{"line":50,"address":[],"length":0,"stats":{"Line":14}},{"line":52,"address":[],"length":0,"stats":{"Line":3}},{"line":53,"address":[],"length":0,"stats":{"Line":21}},{"line":55,"address":[],"length":0,"stats":{"Line":6}},{"line":57,"address":[],"length":0,"stats":{"Line":9}},{"line":61,"address":[],"length":0,"stats":{"Line":16}},{"line":66,"address":[],"length":0,"stats":{"Line":4}},{"line":67,"address":[],"length":0,"stats":{"Line":8}},{"line":68,"address":[],"length":0,"stats":{"Line":16}},{"line":70,"address":[],"length":0,"stats":{"Line":16}},{"line":71,"address":[],"length":0,"stats":{"Line":24}},{"line":72,"address":[],"length":0,"stats":{"Line":12}},{"line":74,"address":[],"length":0,"stats":{"Line":13}},{"line":76,"address":[],"length":0,"stats":{"Line":24}},{"line":77,"address":[],"length":0,"stats":{"Line":12}},{"line":79,"address":[],"length":0,"stats":{"Line":13}},{"line":82,"address":[],"length":0,"stats":{"Line":12}},{"line":83,"address":[],"length":0,"stats":{"Line":8}},{"line":84,"address":[],"length":0,"stats":{"Line":8}},{"line":85,"address":[],"length":0,"stats":{"Line":4}},{"line":86,"address":[],"length":0,"stats":{"Line":4}},{"line":90,"address":[],"length":0,"stats":{"Line":4}}],"covered":45,"coverable":45},{"path":["/","Users","chi","Projects","hu","src","read","interface","mod.rs"],"content":"use regex::Regex;\nuse std::path::Path;\n\nuse super::types::{ItemKind, OutlineItem};\n\n#[cfg(test)]\nmod tests;\n\n/// Extract public interface from file content\npub fn extract_interface(content: \u0026str, path: \u0026str) -\u003e Vec\u003cOutlineItem\u003e {\n    let ext = Path::new(path)\n        .extension()\n        .and_then(|e| e.to_str())\n        .unwrap_or(\"\");\n\n    match ext {\n        \"rs\" =\u003e extract_rust_interface(content),\n        \"py\" =\u003e extract_python_interface(content),\n        \"js\" | \"ts\" | \"jsx\" | \"tsx\" | \"mjs\" =\u003e extract_js_interface(content),\n        \"rb\" =\u003e extract_ruby_interface(content),\n        \"go\" =\u003e extract_go_interface(content),\n        _ =\u003e vec![],\n    }\n}\n\n/// Extract Rust public interface (pub items only)\nfn extract_rust_interface(content: \u0026str) -\u003e Vec\u003cOutlineItem\u003e {\n    let mut items = Vec::new();\n\n    let pub_fn_re =\n        Regex::new(r\"^(\\s*)pub\\s+(async\\s+)?fn\\s+(\\w+)\\s*(\u003c[^\u003e]+\u003e)?\\s*\\([^)]*\\)(\\s*-\u003e\\s*[^{]+)?\")\n            .unwrap();\n    let pub_struct_re = Regex::new(r\"^(\\s*)pub\\s+struct\\s+(\\w+)(\u003c[^\u003e]+\u003e)?\").unwrap();\n    let pub_enum_re = Regex::new(r\"^(\\s*)pub\\s+enum\\s+(\\w+)(\u003c[^\u003e]+\u003e)?\").unwrap();\n    let pub_trait_re = Regex::new(r\"^(\\s*)pub\\s+trait\\s+(\\w+)(\u003c[^\u003e]+\u003e)?\").unwrap();\n    let pub_const_re = Regex::new(r\"^(\\s*)pub\\s+const\\s+(\\w+)\").unwrap();\n    let pub_type_re = Regex::new(r\"^(\\s*)pub\\s+type\\s+(\\w+)\").unwrap();\n    let pub_mod_re = Regex::new(r\"^(\\s*)pub\\s+mod\\s+(\\w+)\").unwrap();\n\n    for (line_num, line) in content.lines().enumerate() {\n        let line_num = line_num + 1;\n\n        if let Some(caps) = pub_fn_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim_end_matches('{').trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 4,\n                ItemKind::Function,\n            ));\n        } else if let Some(caps) = pub_struct_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 4,\n                ItemKind::Struct,\n            ));\n        } else if let Some(caps) = pub_enum_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 4,\n                ItemKind::Enum,\n            ));\n        } else if let Some(caps) = pub_trait_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 4,\n                ItemKind::Trait,\n            ));\n        } else if let Some(caps) = pub_const_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 4,\n                ItemKind::Const,\n            ));\n        } else if let Some(caps) = pub_type_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 4,\n                ItemKind::Type,\n            ));\n        } else if let Some(caps) = pub_mod_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 4,\n                ItemKind::Module,\n            ));\n        }\n    }\n\n    items\n}\n\n/// Extract Python public interface (exclude _private items)\nfn extract_python_interface(content: \u0026str) -\u003e Vec\u003cOutlineItem\u003e {\n    let mut items = Vec::new();\n\n    let def_re = Regex::new(r\"^(\\s*)(async\\s+)?def\\s+(\\w+)\\s*\\([^)]*\\)(\\s*-\u003e\\s*[^:]+)?\").unwrap();\n    let class_re = Regex::new(r\"^(\\s*)class\\s+(\\w+)(\\([^)]*\\))?\").unwrap();\n\n    for (line_num, line) in content.lines().enumerate() {\n        let line_num = line_num + 1;\n\n        if let Some(caps) = def_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let name = caps.get(3).map_or(\"\", |m| m.as_str());\n\n            // Skip private functions (leading underscore) at top level\n            if indent == 0 \u0026\u0026 name.starts_with('_') \u0026\u0026 !name.starts_with(\"__\") {\n                continue;\n            }\n\n            // Skip methods (indented)\n            if indent \u003e 0 {\n                continue;\n            }\n\n            let sig = caps.get(0).unwrap().as_str().trim_end_matches(':').trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                0,\n                ItemKind::Function,\n            ));\n        } else if let Some(caps) = class_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let name = caps.get(2).map_or(\"\", |m| m.as_str());\n\n            // Skip private classes\n            if name.starts_with('_') \u0026\u0026 !name.starts_with(\"__\") {\n                continue;\n            }\n\n            // Skip nested classes\n            if indent \u003e 0 {\n                continue;\n            }\n\n            let sig = caps.get(0).unwrap().as_str().trim_end_matches(':').trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                0,\n                ItemKind::Class,\n            ));\n        }\n    }\n\n    items\n}\n\n/// Extract JavaScript/TypeScript public interface (exports only)\nfn extract_js_interface(content: \u0026str) -\u003e Vec\u003cOutlineItem\u003e {\n    let mut items = Vec::new();\n\n    let export_fn_re =\n        Regex::new(r\"^(\\s*)export\\s+(async\\s+)?function\\s+(\\w+)\\s*(\u003c[^\u003e]+\u003e)?\\s*\\([^)]*\\)\").unwrap();\n    let export_const_re =\n        Regex::new(r\"^(\\s*)export\\s+(const|let|var)\\s+(\\w+)\\s*=\\s*(async\\s+)?\\([^)]*\\)\\s*=\u003e\")\n            .unwrap();\n    let export_class_re = Regex::new(r\"^(\\s*)export\\s+class\\s+(\\w+)(\\s+extends\\s+\\w+)?\").unwrap();\n    let export_default_re =\n        Regex::new(r\"^(\\s*)export\\s+default\\s+(class|function)?\\s*(\\w+)?\").unwrap();\n\n    for (line_num, line) in content.lines().enumerate() {\n        let line_num = line_num + 1;\n\n        if let Some(caps) = export_fn_re.captures(line) {\n            let sig = caps.get(0).unwrap().as_str().trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                0,\n                ItemKind::Function,\n            ));\n        } else if let Some(caps) = export_const_re.captures(line) {\n            let sig = caps.get(0).unwrap().as_str().trim_end_matches(\"=\u003e\").trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                0,\n                ItemKind::Function,\n            ));\n        } else if let Some(caps) = export_class_re.captures(line) {\n            let sig = caps.get(0).unwrap().as_str().trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                0,\n                ItemKind::Class,\n            ));\n        } else if let Some(caps) = export_default_re.captures(line) {\n            let sig = caps.get(0).unwrap().as_str().trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                0,\n                ItemKind::Other,\n            ));\n        }\n    }\n\n    items\n}\n\n/// Extract Ruby public interface (exclude private methods)\nfn extract_ruby_interface(content: \u0026str) -\u003e Vec\u003cOutlineItem\u003e {\n    let mut items = Vec::new();\n    let mut in_private = false;\n\n    let def_re = Regex::new(r\"^(\\s*)def\\s+(\\w+[?!=]?)(\\([^)]*\\))?\").unwrap();\n    let class_re = Regex::new(r\"^(\\s*)class\\s+(\\w+)(\\s*\u003c\\s*\\w+)?\").unwrap();\n    let module_re = Regex::new(r\"^(\\s*)module\\s+(\\w+)\").unwrap();\n    let private_re = Regex::new(r\"^\\s*private\\s*$\").unwrap();\n    let public_re = Regex::new(r\"^\\s*public\\s*$\").unwrap();\n\n    for (line_num, line) in content.lines().enumerate() {\n        let line_num = line_num + 1;\n\n        // Track private/public sections\n        if private_re.is_match(line) {\n            in_private = true;\n            continue;\n        }\n        if public_re.is_match(line) {\n            in_private = false;\n            continue;\n        }\n\n        // Reset private flag on new class/module\n        if class_re.is_match(line) || module_re.is_match(line) {\n            in_private = false;\n        }\n\n        if let Some(caps) = def_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n\n            // Skip private methods\n            if in_private {\n                continue;\n            }\n\n            // Skip nested methods\n            if indent \u003e 2 {\n                continue;\n            }\n\n            let sig = caps.get(0).unwrap().as_str().trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 2,\n                ItemKind::Function,\n            ));\n        } else if let Some(caps) = class_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n\n            // Skip nested classes\n            if indent \u003e 0 {\n                continue;\n            }\n\n            let sig = caps.get(0).unwrap().as_str().trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                0,\n                ItemKind::Class,\n            ));\n        } else if let Some(caps) = module_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n\n            // Skip nested modules\n            if indent \u003e 0 {\n                continue;\n            }\n\n            let sig = caps.get(0).unwrap().as_str().trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                0,\n                ItemKind::Module,\n            ));\n        }\n    }\n\n    items\n}\n\n/// Extract Go public interface (exported items - capitalized)\nfn extract_go_interface(content: \u0026str) -\u003e Vec\u003cOutlineItem\u003e {\n    let mut items = Vec::new();\n\n    let func_re =\n        Regex::new(r\"^func\\s+(\\([^)]+\\)\\s+)?([A-Z]\\w*)\\s*\\([^)]*\\)(\\s*\\([^)]*\\)|\\s*\\w+)?\").unwrap();\n    let type_struct_re = Regex::new(r\"^type\\s+([A-Z]\\w*)\\s+struct\").unwrap();\n    let type_interface_re = Regex::new(r\"^type\\s+([A-Z]\\w*)\\s+interface\").unwrap();\n\n    for (line_num, line) in content.lines().enumerate() {\n        let line_num = line_num + 1;\n\n        if let Some(caps) = func_re.captures(line) {\n            let sig = caps.get(0).unwrap().as_str().trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                0,\n                ItemKind::Function,\n            ));\n        } else if let Some(caps) = type_struct_re.captures(line) {\n            let sig = caps.get(0).unwrap().as_str().trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                0,\n                ItemKind::Struct,\n            ));\n        } else if let Some(caps) = type_interface_re.captures(line) {\n            let sig = caps.get(0).unwrap().as_str().trim();\n            items.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                0,\n                ItemKind::Trait,\n            ));\n        }\n    }\n\n    items\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":36}},{"line":11,"address":[],"length":0,"stats":{"Line":72}},{"line":13,"address":[],"length":0,"stats":{"Line":108}},{"line":16,"address":[],"length":0,"stats":{"Line":36}},{"line":17,"address":[],"length":0,"stats":{"Line":56}},{"line":18,"address":[],"length":0,"stats":{"Line":40}},{"line":19,"address":[],"length":0,"stats":{"Line":85}},{"line":20,"address":[],"length":0,"stats":{"Line":30}},{"line":21,"address":[],"length":0,"stats":{"Line":16}},{"line":22,"address":[],"length":0,"stats":{"Line":1}},{"line":27,"address":[],"length":0,"stats":{"Line":10}},{"line":28,"address":[],"length":0,"stats":{"Line":20}},{"line":30,"address":[],"length":0,"stats":{"Line":10}},{"line":31,"address":[],"length":0,"stats":{"Line":20}},{"line":33,"address":[],"length":0,"stats":{"Line":40}},{"line":34,"address":[],"length":0,"stats":{"Line":40}},{"line":35,"address":[],"length":0,"stats":{"Line":40}},{"line":36,"address":[],"length":0,"stats":{"Line":40}},{"line":37,"address":[],"length":0,"stats":{"Line":40}},{"line":38,"address":[],"length":0,"stats":{"Line":40}},{"line":40,"address":[],"length":0,"stats":{"Line":370}},{"line":41,"address":[],"length":0,"stats":{"Line":340}},{"line":43,"address":[],"length":0,"stats":{"Line":341}},{"line":44,"address":[],"length":0,"stats":{"Line":6}},{"line":45,"address":[],"length":0,"stats":{"Line":4}},{"line":46,"address":[],"length":0,"stats":{"Line":3}},{"line":47,"address":[],"length":0,"stats":{"Line":1}},{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":1}},{"line":50,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":339}},{"line":53,"address":[],"length":0,"stats":{"Line":6}},{"line":54,"address":[],"length":0,"stats":{"Line":4}},{"line":55,"address":[],"length":0,"stats":{"Line":3}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":1}},{"line":59,"address":[],"length":0,"stats":{"Line":1}},{"line":61,"address":[],"length":0,"stats":{"Line":337}},{"line":62,"address":[],"length":0,"stats":{"Line":6}},{"line":63,"address":[],"length":0,"stats":{"Line":4}},{"line":64,"address":[],"length":0,"stats":{"Line":3}},{"line":65,"address":[],"length":0,"stats":{"Line":1}},{"line":66,"address":[],"length":0,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":1}},{"line":68,"address":[],"length":0,"stats":{"Line":1}},{"line":70,"address":[],"length":0,"stats":{"Line":335}},{"line":71,"address":[],"length":0,"stats":{"Line":6}},{"line":72,"address":[],"length":0,"stats":{"Line":4}},{"line":73,"address":[],"length":0,"stats":{"Line":3}},{"line":74,"address":[],"length":0,"stats":{"Line":1}},{"line":75,"address":[],"length":0,"stats":{"Line":2}},{"line":76,"address":[],"length":0,"stats":{"Line":1}},{"line":77,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":333}},{"line":80,"address":[],"length":0,"stats":{"Line":6}},{"line":81,"address":[],"length":0,"stats":{"Line":4}},{"line":82,"address":[],"length":0,"stats":{"Line":3}},{"line":83,"address":[],"length":0,"stats":{"Line":1}},{"line":84,"address":[],"length":0,"stats":{"Line":2}},{"line":85,"address":[],"length":0,"stats":{"Line":1}},{"line":86,"address":[],"length":0,"stats":{"Line":1}},{"line":88,"address":[],"length":0,"stats":{"Line":331}},{"line":89,"address":[],"length":0,"stats":{"Line":6}},{"line":90,"address":[],"length":0,"stats":{"Line":4}},{"line":91,"address":[],"length":0,"stats":{"Line":3}},{"line":92,"address":[],"length":0,"stats":{"Line":1}},{"line":93,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":1}},{"line":95,"address":[],"length":0,"stats":{"Line":1}},{"line":97,"address":[],"length":0,"stats":{"Line":329}},{"line":98,"address":[],"length":0,"stats":{"Line":6}},{"line":99,"address":[],"length":0,"stats":{"Line":4}},{"line":100,"address":[],"length":0,"stats":{"Line":3}},{"line":101,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":2}},{"line":103,"address":[],"length":0,"stats":{"Line":1}},{"line":104,"address":[],"length":0,"stats":{"Line":1}},{"line":109,"address":[],"length":0,"stats":{"Line":10}},{"line":113,"address":[],"length":0,"stats":{"Line":7}},{"line":114,"address":[],"length":0,"stats":{"Line":14}},{"line":116,"address":[],"length":0,"stats":{"Line":28}},{"line":117,"address":[],"length":0,"stats":{"Line":28}},{"line":119,"address":[],"length":0,"stats":{"Line":43}},{"line":120,"address":[],"length":0,"stats":{"Line":22}},{"line":122,"address":[],"length":0,"stats":{"Line":26}},{"line":123,"address":[],"length":0,"stats":{"Line":24}},{"line":124,"address":[],"length":0,"stats":{"Line":24}},{"line":127,"address":[],"length":0,"stats":{"Line":12}},{"line":128,"address":[],"length":0,"stats":{"Line":1}},{"line":132,"address":[],"length":0,"stats":{"Line":3}},{"line":133,"address":[],"length":0,"stats":{"Line":1}},{"line":136,"address":[],"length":0,"stats":{"Line":8}},{"line":137,"address":[],"length":0,"stats":{"Line":6}},{"line":138,"address":[],"length":0,"stats":{"Line":2}},{"line":139,"address":[],"length":0,"stats":{"Line":4}},{"line":141,"address":[],"length":0,"stats":{"Line":2}},{"line":143,"address":[],"length":0,"stats":{"Line":19}},{"line":144,"address":[],"length":0,"stats":{"Line":30}},{"line":145,"address":[],"length":0,"stats":{"Line":30}},{"line":148,"address":[],"length":0,"stats":{"Line":11}},{"line":149,"address":[],"length":0,"stats":{"Line":1}},{"line":153,"address":[],"length":0,"stats":{"Line":4}},{"line":154,"address":[],"length":0,"stats":{"Line":1}},{"line":157,"address":[],"length":0,"stats":{"Line":12}},{"line":158,"address":[],"length":0,"stats":{"Line":9}},{"line":159,"address":[],"length":0,"stats":{"Line":3}},{"line":160,"address":[],"length":0,"stats":{"Line":6}},{"line":162,"address":[],"length":0,"stats":{"Line":3}},{"line":167,"address":[],"length":0,"stats":{"Line":7}},{"line":171,"address":[],"length":0,"stats":{"Line":5}},{"line":172,"address":[],"length":0,"stats":{"Line":10}},{"line":174,"address":[],"length":0,"stats":{"Line":5}},{"line":175,"address":[],"length":0,"stats":{"Line":15}},{"line":176,"address":[],"length":0,"stats":{"Line":5}},{"line":177,"address":[],"length":0,"stats":{"Line":10}},{"line":179,"address":[],"length":0,"stats":{"Line":20}},{"line":180,"address":[],"length":0,"stats":{"Line":5}},{"line":181,"address":[],"length":0,"stats":{"Line":15}},{"line":183,"address":[],"length":0,"stats":{"Line":25}},{"line":184,"address":[],"length":0,"stats":{"Line":10}},{"line":186,"address":[],"length":0,"stats":{"Line":12}},{"line":187,"address":[],"length":0,"stats":{"Line":5}},{"line":188,"address":[],"length":0,"stats":{"Line":4}},{"line":189,"address":[],"length":0,"stats":{"Line":2}},{"line":190,"address":[],"length":0,"stats":{"Line":2}},{"line":191,"address":[],"length":0,"stats":{"Line":1}},{"line":192,"address":[],"length":0,"stats":{"Line":1}},{"line":194,"address":[],"length":0,"stats":{"Line":11}},{"line":195,"address":[],"length":0,"stats":{"Line":5}},{"line":196,"address":[],"length":0,"stats":{"Line":4}},{"line":197,"address":[],"length":0,"stats":{"Line":2}},{"line":198,"address":[],"length":0,"stats":{"Line":2}},{"line":199,"address":[],"length":0,"stats":{"Line":1}},{"line":200,"address":[],"length":0,"stats":{"Line":1}},{"line":202,"address":[],"length":0,"stats":{"Line":9}},{"line":203,"address":[],"length":0,"stats":{"Line":5}},{"line":204,"address":[],"length":0,"stats":{"Line":4}},{"line":205,"address":[],"length":0,"stats":{"Line":2}},{"line":206,"address":[],"length":0,"stats":{"Line":2}},{"line":207,"address":[],"length":0,"stats":{"Line":1}},{"line":208,"address":[],"length":0,"stats":{"Line":1}},{"line":210,"address":[],"length":0,"stats":{"Line":7}},{"line":211,"address":[],"length":0,"stats":{"Line":5}},{"line":212,"address":[],"length":0,"stats":{"Line":4}},{"line":213,"address":[],"length":0,"stats":{"Line":2}},{"line":214,"address":[],"length":0,"stats":{"Line":2}},{"line":215,"address":[],"length":0,"stats":{"Line":1}},{"line":216,"address":[],"length":0,"stats":{"Line":1}},{"line":221,"address":[],"length":0,"stats":{"Line":5}},{"line":225,"address":[],"length":0,"stats":{"Line":8}},{"line":226,"address":[],"length":0,"stats":{"Line":16}},{"line":227,"address":[],"length":0,"stats":{"Line":16}},{"line":229,"address":[],"length":0,"stats":{"Line":32}},{"line":230,"address":[],"length":0,"stats":{"Line":32}},{"line":231,"address":[],"length":0,"stats":{"Line":32}},{"line":232,"address":[],"length":0,"stats":{"Line":32}},{"line":233,"address":[],"length":0,"stats":{"Line":32}},{"line":235,"address":[],"length":0,"stats":{"Line":102}},{"line":236,"address":[],"length":0,"stats":{"Line":78}},{"line":239,"address":[],"length":0,"stats":{"Line":117}},{"line":240,"address":[],"length":0,"stats":{"Line":2}},{"line":241,"address":[],"length":0,"stats":{"Line":2}},{"line":243,"address":[],"length":0,"stats":{"Line":111}},{"line":244,"address":[],"length":0,"stats":{"Line":1}},{"line":245,"address":[],"length":0,"stats":{"Line":1}},{"line":249,"address":[],"length":0,"stats":{"Line":207}},{"line":250,"address":[],"length":0,"stats":{"Line":9}},{"line":253,"address":[],"length":0,"stats":{"Line":79}},{"line":254,"address":[],"length":0,"stats":{"Line":42}},{"line":257,"address":[],"length":0,"stats":{"Line":7}},{"line":258,"address":[],"length":0,"stats":{"Line":2}},{"line":262,"address":[],"length":0,"stats":{"Line":5}},{"line":263,"address":[],"length":0,"stats":{"Line":1}},{"line":266,"address":[],"length":0,"stats":{"Line":16}},{"line":267,"address":[],"length":0,"stats":{"Line":12}},{"line":268,"address":[],"length":0,"stats":{"Line":4}},{"line":269,"address":[],"length":0,"stats":{"Line":8}},{"line":270,"address":[],"length":0,"stats":{"Line":4}},{"line":271,"address":[],"length":0,"stats":{"Line":4}},{"line":273,"address":[],"length":0,"stats":{"Line":64}},{"line":274,"address":[],"length":0,"stats":{"Line":36}},{"line":277,"address":[],"length":0,"stats":{"Line":6}},{"line":278,"address":[],"length":0,"stats":{"Line":1}},{"line":281,"address":[],"length":0,"stats":{"Line":20}},{"line":282,"address":[],"length":0,"stats":{"Line":15}},{"line":283,"address":[],"length":0,"stats":{"Line":5}},{"line":284,"address":[],"length":0,"stats":{"Line":10}},{"line":286,"address":[],"length":0,"stats":{"Line":5}},{"line":288,"address":[],"length":0,"stats":{"Line":49}},{"line":289,"address":[],"length":0,"stats":{"Line":18}},{"line":292,"address":[],"length":0,"stats":{"Line":3}},{"line":293,"address":[],"length":0,"stats":{"Line":1}},{"line":296,"address":[],"length":0,"stats":{"Line":8}},{"line":297,"address":[],"length":0,"stats":{"Line":6}},{"line":298,"address":[],"length":0,"stats":{"Line":2}},{"line":299,"address":[],"length":0,"stats":{"Line":4}},{"line":301,"address":[],"length":0,"stats":{"Line":2}},{"line":306,"address":[],"length":0,"stats":{"Line":8}},{"line":310,"address":[],"length":0,"stats":{"Line":5}},{"line":311,"address":[],"length":0,"stats":{"Line":10}},{"line":313,"address":[],"length":0,"stats":{"Line":5}},{"line":314,"address":[],"length":0,"stats":{"Line":15}},{"line":315,"address":[],"length":0,"stats":{"Line":20}},{"line":316,"address":[],"length":0,"stats":{"Line":20}},{"line":318,"address":[],"length":0,"stats":{"Line":25}},{"line":319,"address":[],"length":0,"stats":{"Line":10}},{"line":321,"address":[],"length":0,"stats":{"Line":12}},{"line":322,"address":[],"length":0,"stats":{"Line":5}},{"line":323,"address":[],"length":0,"stats":{"Line":4}},{"line":324,"address":[],"length":0,"stats":{"Line":2}},{"line":325,"address":[],"length":0,"stats":{"Line":2}},{"line":326,"address":[],"length":0,"stats":{"Line":1}},{"line":327,"address":[],"length":0,"stats":{"Line":1}},{"line":329,"address":[],"length":0,"stats":{"Line":11}},{"line":330,"address":[],"length":0,"stats":{"Line":5}},{"line":331,"address":[],"length":0,"stats":{"Line":4}},{"line":332,"address":[],"length":0,"stats":{"Line":2}},{"line":333,"address":[],"length":0,"stats":{"Line":2}},{"line":334,"address":[],"length":0,"stats":{"Line":1}},{"line":335,"address":[],"length":0,"stats":{"Line":1}},{"line":337,"address":[],"length":0,"stats":{"Line":9}},{"line":338,"address":[],"length":0,"stats":{"Line":5}},{"line":339,"address":[],"length":0,"stats":{"Line":4}},{"line":340,"address":[],"length":0,"stats":{"Line":2}},{"line":341,"address":[],"length":0,"stats":{"Line":2}},{"line":342,"address":[],"length":0,"stats":{"Line":1}},{"line":343,"address":[],"length":0,"stats":{"Line":1}},{"line":348,"address":[],"length":0,"stats":{"Line":5}}],"covered":229,"coverable":229},{"path":["/","Users","chi","Projects","hu","src","read","interface","tests.rs"],"content":"use super::*;\n\n#[test]\nfn rust_pub_fn() {\n    let content = \"pub fn test() {}\";\n    let items = extract_interface(content, \"test.rs\");\n    assert_eq!(items.len(), 1);\n    assert!(items[0].text.contains(\"pub fn test\"));\n}\n\n#[test]\nfn rust_private_fn_excluded() {\n    let content = \"fn private_test() {}\";\n    let items = extract_interface(content, \"test.rs\");\n    assert!(items.is_empty());\n}\n\n#[test]\nfn rust_pub_struct() {\n    let content = \"pub struct Config {}\";\n    let items = extract_interface(content, \"test.rs\");\n    assert_eq!(items.len(), 1);\n    assert!(items[0].text.contains(\"pub struct Config\"));\n}\n\n#[test]\nfn rust_pub_enum() {\n    let content = \"pub enum Status { Ok, Err }\";\n    let items = extract_interface(content, \"test.rs\");\n    assert_eq!(items.len(), 1);\n    assert!(items[0].text.contains(\"pub enum Status\"));\n}\n\n#[test]\nfn rust_pub_trait() {\n    let content = \"pub trait Handler {}\";\n    let items = extract_interface(content, \"test.rs\");\n    assert_eq!(items.len(), 1);\n    assert!(items[0].text.contains(\"pub trait Handler\"));\n}\n\n#[test]\nfn rust_pub_const() {\n    let content = \"pub const MAX: u32 = 100;\";\n    let items = extract_interface(content, \"test.rs\");\n    assert_eq!(items.len(), 1);\n    assert!(items[0].text.contains(\"pub const MAX\"));\n}\n\n#[test]\nfn rust_pub_type() {\n    let content = \"pub type Result\u003cT\u003e = std::result::Result\u003cT, Error\u003e;\";\n    let items = extract_interface(content, \"test.rs\");\n    assert_eq!(items.len(), 1);\n    assert!(items[0].text.contains(\"pub type Result\"));\n}\n\n#[test]\nfn rust_pub_mod() {\n    let content = \"pub mod utils;\";\n    let items = extract_interface(content, \"test.rs\");\n    assert_eq!(items.len(), 1);\n    assert!(items[0].text.contains(\"pub mod utils\"));\n}\n\n#[test]\nfn python_public_function() {\n    let content = \"def public_fn():\";\n    let items = extract_interface(content, \"test.py\");\n    assert_eq!(items.len(), 1);\n}\n\n#[test]\nfn python_private_function_excluded() {\n    let content = \"def _private_fn():\";\n    let items = extract_interface(content, \"test.py\");\n    assert!(items.is_empty());\n}\n\n#[test]\nfn python_dunder_included() {\n    let content = \"def __init__(self):\";\n    let items = extract_interface(content, \"test.py\");\n    assert_eq!(items.len(), 1);\n}\n\n#[test]\nfn python_public_class() {\n    let content = \"class Handler:\";\n    let items = extract_interface(content, \"test.py\");\n    assert_eq!(items.len(), 1);\n}\n\n#[test]\nfn python_private_class_excluded() {\n    let content = \"class _Private:\";\n    let items = extract_interface(content, \"test.py\");\n    assert!(items.is_empty());\n}\n\n#[test]\nfn python_method_excluded() {\n    let content = r#\"class Test:\n    def method(self):\n        pass\n\"#;\n    let items = extract_interface(content, \"test.py\");\n    // Only class, not method\n    assert_eq!(items.len(), 1);\n    assert!(items[0].text.contains(\"class Test\"));\n}\n\n#[test]\nfn js_export_function() {\n    let content = \"export function test() {}\";\n    let items = extract_interface(content, \"test.js\");\n    assert_eq!(items.len(), 1);\n    assert!(items[0].text.contains(\"export function test\"));\n}\n\n#[test]\nfn js_non_export_excluded() {\n    let content = \"function internal() {}\";\n    let items = extract_interface(content, \"test.js\");\n    assert!(items.is_empty());\n}\n\n#[test]\nfn js_export_arrow() {\n    let content = \"export const handler = (req) =\u003e\";\n    let items = extract_interface(content, \"test.js\");\n    assert_eq!(items.len(), 1);\n}\n\n#[test]\nfn js_export_class() {\n    let content = \"export class Service {}\";\n    let items = extract_interface(content, \"test.js\");\n    assert_eq!(items.len(), 1);\n    assert!(items[0].text.contains(\"export class Service\"));\n}\n\n#[test]\nfn js_export_default() {\n    let content = \"export default function\";\n    let items = extract_interface(content, \"test.js\");\n    assert_eq!(items.len(), 1);\n}\n\n#[test]\nfn ruby_public_method() {\n    let content = \"def public_method\\nend\";\n    let items = extract_interface(content, \"test.rb\");\n    assert_eq!(items.len(), 1);\n}\n\n#[test]\nfn ruby_private_method_excluded() {\n    let content = r#\"\nclass Test\n  def public\n  end\n\n  private\n\n  def private_method\n  end\nend\n\"#;\n    let items = extract_interface(content, \"test.rb\");\n    // Only class and public method\n    assert_eq!(items.len(), 2);\n}\n\n#[test]\nfn ruby_class() {\n    let content = \"class Handler\";\n    let items = extract_interface(content, \"test.rb\");\n    assert_eq!(items.len(), 1);\n    assert!(items[0].text.contains(\"class Handler\"));\n}\n\n#[test]\nfn ruby_module() {\n    let content = \"module Utils\";\n    let items = extract_interface(content, \"test.rb\");\n    assert_eq!(items.len(), 1);\n    assert!(items[0].text.contains(\"module Utils\"));\n}\n\n#[test]\nfn go_exported_func() {\n    let content = \"func Handler(w http.ResponseWriter) {}\";\n    let items = extract_interface(content, \"test.go\");\n    assert_eq!(items.len(), 1);\n}\n\n#[test]\nfn go_unexported_func_excluded() {\n    let content = \"func internal() {}\";\n    let items = extract_interface(content, \"test.go\");\n    assert!(items.is_empty());\n}\n\n#[test]\nfn go_exported_struct() {\n    let content = \"type Config struct {}\";\n    let items = extract_interface(content, \"test.go\");\n    assert_eq!(items.len(), 1);\n}\n\n#[test]\nfn go_unexported_struct_excluded() {\n    let content = \"type config struct {}\";\n    let items = extract_interface(content, \"test.go\");\n    assert!(items.is_empty());\n}\n\n#[test]\nfn go_exported_interface() {\n    let content = \"type Handler interface {}\";\n    let items = extract_interface(content, \"test.go\");\n    assert_eq!(items.len(), 1);\n}\n\n#[test]\nfn unknown_extension() {\n    let content = \"some content\";\n    let items = extract_interface(content, \"test.xyz\");\n    assert!(items.is_empty());\n}\n\n#[test]\nfn empty_content() {\n    let items = extract_interface(\"\", \"test.rs\");\n    assert!(items.is_empty());\n}\n\n#[test]\nfn python_nested_class_excluded() {\n    // Nested classes (indented) should be excluded\n    let content = r#\"class Outer:\n    class Inner:\n        pass\n\"#;\n    let items = extract_interface(content, \"test.py\");\n    // Only top-level class\n    assert_eq!(items.len(), 1);\n    assert!(items[0].text.contains(\"class Outer\"));\n}\n\n#[test]\nfn ruby_public_after_private() {\n    // public keyword should reset private state\n    let content = r#\"class Test\n  private\n\n  def private_method\n  end\n\n  public\n\n  def public_again\n  end\nend\n\"#;\n    let items = extract_interface(content, \"test.rb\");\n    // class + public_again (private_method is excluded)\n    assert_eq!(items.len(), 2);\n    assert!(items.iter().any(|i| i.text.contains(\"class Test\")));\n    assert!(items.iter().any(|i| i.text.contains(\"def public_again\")));\n    assert!(!items.iter().any(|i| i.text.contains(\"private_method\")));\n}\n\n#[test]\nfn ruby_nested_method_excluded() {\n    // Deeply nested methods (indent \u003e 2) should be excluded\n    let content = r#\"class Test\n  def outer\n      def inner_method\n      end\n  end\nend\n\"#;\n    let items = extract_interface(content, \"test.rb\");\n    // class + outer method, but not inner_method\n    assert_eq!(items.len(), 2);\n    assert!(items.iter().any(|i| i.text.contains(\"class Test\")));\n    assert!(items.iter().any(|i| i.text.contains(\"def outer\")));\n    assert!(!items.iter().any(|i| i.text.contains(\"inner_method\")));\n}\n\n#[test]\nfn ruby_nested_class_excluded() {\n    // Nested classes should be excluded\n    let content = r#\"class Outer\n  class Inner\n  end\nend\n\"#;\n    let items = extract_interface(content, \"test.rb\");\n    // Only top-level class\n    assert_eq!(items.len(), 1);\n    assert!(items[0].text.contains(\"class Outer\"));\n}\n\n#[test]\nfn ruby_nested_module_excluded() {\n    // Nested modules should be excluded\n    let content = r#\"module Outer\n  module Inner\n  end\nend\n\"#;\n    let items = extract_interface(content, \"test.rb\");\n    // Only top-level module\n    assert_eq!(items.len(), 1);\n    assert!(items[0].text.contains(\"module Outer\"));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","read","mod.rs"],"content":"mod around;\nmod cli;\nmod diff;\nmod display;\nmod interface;\nmod outline;\nmod service;\nmod types;\n\npub use cli::ReadArgs;\npub use types::ReadOutput;\n\nuse anyhow::Result;\n\n/// Run the read command (CLI entry point - formats and prints)\n#[cfg(not(tarpaulin_include))]\npub fn run(args: ReadArgs) -\u003e Result\u003c()\u003e {\n    let output = service::run(args)?;\n    let formatted = display::format(\u0026output);\n    print!(\"{}\", formatted);\n    Ok(())\n}\n\n/// Run the read command and return data (for MCP/HTTP)\n#[allow(dead_code)]\npub fn read(args: ReadArgs) -\u003e Result\u003cReadOutput\u003e {\n    service::run(args)\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","Users","chi","Projects","hu","src","read","outline","mod.rs"],"content":"use regex::Regex;\nuse std::path::Path;\n\nuse super::types::{FileOutline, ItemKind, OutlineItem};\n\n#[cfg(test)]\nmod tests;\n\n/// Extract outline from file content based on extension\npub fn extract_outline(content: \u0026str, path: \u0026str) -\u003e FileOutline {\n    let ext = Path::new(path)\n        .extension()\n        .and_then(|e| e.to_str())\n        .unwrap_or(\"\");\n\n    let mut outline = FileOutline::new();\n\n    match ext {\n        \"rs\" =\u003e extract_rust_outline(content, \u0026mut outline),\n        \"py\" =\u003e extract_python_outline(content, \u0026mut outline),\n        \"js\" | \"ts\" | \"jsx\" | \"tsx\" | \"mjs\" =\u003e extract_js_outline(content, \u0026mut outline),\n        \"rb\" =\u003e extract_ruby_outline(content, \u0026mut outline),\n        \"go\" =\u003e extract_go_outline(content, \u0026mut outline),\n        \"md\" | \"markdown\" =\u003e extract_markdown_outline(content, \u0026mut outline),\n        _ =\u003e {}\n    }\n\n    outline\n}\n\n/// Extract Rust outline (functions, structs, enums, traits, impls)\nfn extract_rust_outline(content: \u0026str, outline: \u0026mut FileOutline) {\n    let fn_re = Regex::new(\n        r\"^(\\s*)(pub\\s+)?(async\\s+)?fn\\s+(\\w+)\\s*(\u003c[^\u003e]+\u003e)?\\s*\\([^)]*\\)(\\s*-\u003e\\s*[^{]+)?\",\n    )\n    .unwrap();\n    let struct_re = Regex::new(r\"^(\\s*)(pub\\s+)?struct\\s+(\\w+)(\u003c[^\u003e]+\u003e)?\").unwrap();\n    let enum_re = Regex::new(r\"^(\\s*)(pub\\s+)?enum\\s+(\\w+)(\u003c[^\u003e]+\u003e)?\").unwrap();\n    let trait_re = Regex::new(r\"^(\\s*)(pub\\s+)?trait\\s+(\\w+)(\u003c[^\u003e]+\u003e)?\").unwrap();\n    let impl_re = Regex::new(r\"^(\\s*)impl\\s*(\u003c[^\u003e]+\u003e)?\\s*(\\w+)(\u003c[^\u003e]+\u003e)?(\\s+for\\s+\\w+)?\").unwrap();\n    let mod_re = Regex::new(r\"^(\\s*)(pub\\s+)?mod\\s+(\\w+)\").unwrap();\n    let const_re = Regex::new(r\"^(\\s*)(pub\\s+)?const\\s+(\\w+)\").unwrap();\n    let type_re = Regex::new(r\"^(\\s*)(pub\\s+)?type\\s+(\\w+)\").unwrap();\n\n    for (line_num, line) in content.lines().enumerate() {\n        let line_num = line_num + 1;\n\n        if let Some(caps) = fn_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim_end_matches('{').trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 4,\n                ItemKind::Function,\n            ));\n        } else if let Some(caps) = struct_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 4,\n                ItemKind::Struct,\n            ));\n        } else if let Some(caps) = enum_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 4,\n                ItemKind::Enum,\n            ));\n        } else if let Some(caps) = trait_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 4,\n                ItemKind::Trait,\n            ));\n        } else if let Some(caps) = impl_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 4,\n                ItemKind::Impl,\n            ));\n        } else if let Some(caps) = mod_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 4,\n                ItemKind::Module,\n            ));\n        } else if let Some(caps) = const_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 4,\n                ItemKind::Const,\n            ));\n        } else if let Some(caps) = type_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 4,\n                ItemKind::Type,\n            ));\n        }\n    }\n}\n\n/// Extract Python outline (functions, classes)\nfn extract_python_outline(content: \u0026str, outline: \u0026mut FileOutline) {\n    let def_re = Regex::new(r\"^(\\s*)(async\\s+)?def\\s+(\\w+)\\s*\\([^)]*\\)(\\s*-\u003e\\s*[^:]+)?\").unwrap();\n    let class_re = Regex::new(r\"^(\\s*)class\\s+(\\w+)(\\([^)]*\\))?\").unwrap();\n\n    for (line_num, line) in content.lines().enumerate() {\n        let line_num = line_num + 1;\n\n        if let Some(caps) = def_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim_end_matches(':').trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 4,\n                ItemKind::Function,\n            ));\n        } else if let Some(caps) = class_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim_end_matches(':').trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 4,\n                ItemKind::Class,\n            ));\n        }\n    }\n}\n\n/// Extract JavaScript/TypeScript outline\nfn extract_js_outline(content: \u0026str, outline: \u0026mut FileOutline) {\n    let fn_re =\n        Regex::new(r\"^(\\s*)(export\\s+)?(async\\s+)?function\\s+(\\w+)\\s*(\u003c[^\u003e]+\u003e)?\\s*\\([^)]*\\)\")\n            .unwrap();\n    let arrow_re =\n        Regex::new(r\"^(\\s*)(export\\s+)?(const|let|var)\\s+(\\w+)\\s*=\\s*(async\\s+)?\\([^)]*\\)\\s*=\u003e\")\n            .unwrap();\n    let class_re = Regex::new(r\"^(\\s*)(export\\s+)?class\\s+(\\w+)(\\s+extends\\s+\\w+)?\").unwrap();\n    let method_re = Regex::new(r\"^(\\s*)(async\\s+)?(\\w+)\\s*\\([^)]*\\)\\s*\\{\").unwrap();\n\n    for (line_num, line) in content.lines().enumerate() {\n        let line_num = line_num + 1;\n\n        if let Some(caps) = fn_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 2,\n                ItemKind::Function,\n            ));\n        } else if let Some(caps) = arrow_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim_end_matches(\"=\u003e\").trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 2,\n                ItemKind::Function,\n            ));\n        } else if let Some(caps) = class_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 2,\n                ItemKind::Class,\n            ));\n        } else if let Some(caps) = method_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            // Only include methods with some indent (inside class)\n            if indent \u003e 0 {\n                let sig = caps.get(0).unwrap().as_str().trim_end_matches('{').trim();\n                outline.push(OutlineItem::new(\n                    line_num,\n                    sig.to_string(),\n                    indent / 2,\n                    ItemKind::Function,\n                ));\n            }\n        }\n    }\n}\n\n/// Extract Ruby outline\nfn extract_ruby_outline(content: \u0026str, outline: \u0026mut FileOutline) {\n    let def_re = Regex::new(r\"^(\\s*)def\\s+(\\w+[?!=]?)(\\([^)]*\\))?\").unwrap();\n    let class_re = Regex::new(r\"^(\\s*)class\\s+(\\w+)(\\s*\u003c\\s*\\w+)?\").unwrap();\n    let module_re = Regex::new(r\"^(\\s*)module\\s+(\\w+)\").unwrap();\n\n    for (line_num, line) in content.lines().enumerate() {\n        let line_num = line_num + 1;\n\n        if let Some(caps) = def_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 2,\n                ItemKind::Function,\n            ));\n        } else if let Some(caps) = class_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 2,\n                ItemKind::Class,\n            ));\n        } else if let Some(caps) = module_re.captures(line) {\n            let indent = caps.get(1).map_or(0, |m| m.as_str().len());\n            let sig = caps.get(0).unwrap().as_str().trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                indent / 2,\n                ItemKind::Module,\n            ));\n        }\n    }\n}\n\n/// Extract Go outline\nfn extract_go_outline(content: \u0026str, outline: \u0026mut FileOutline) {\n    let func_re =\n        Regex::new(r\"^func\\s+(\\([^)]+\\)\\s+)?(\\w+)\\s*\\([^)]*\\)(\\s*\\([^)]*\\)|\\s*\\w+)?\").unwrap();\n    let type_struct_re = Regex::new(r\"^type\\s+(\\w+)\\s+struct\").unwrap();\n    let type_interface_re = Regex::new(r\"^type\\s+(\\w+)\\s+interface\").unwrap();\n\n    for (line_num, line) in content.lines().enumerate() {\n        let line_num = line_num + 1;\n\n        if let Some(caps) = func_re.captures(line) {\n            let sig = caps.get(0).unwrap().as_str().trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                0,\n                ItemKind::Function,\n            ));\n        } else if let Some(caps) = type_struct_re.captures(line) {\n            let sig = caps.get(0).unwrap().as_str().trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                0,\n                ItemKind::Struct,\n            ));\n        } else if let Some(caps) = type_interface_re.captures(line) {\n            let sig = caps.get(0).unwrap().as_str().trim();\n            outline.push(OutlineItem::new(\n                line_num,\n                sig.to_string(),\n                0,\n                ItemKind::Trait,\n            ));\n        }\n    }\n}\n\n/// Extract Markdown outline (headings)\nfn extract_markdown_outline(content: \u0026str, outline: \u0026mut FileOutline) {\n    let heading_re = Regex::new(r\"^(#{1,6})\\s+(.+)$\").unwrap();\n\n    for (line_num, line) in content.lines().enumerate() {\n        let line_num = line_num + 1;\n\n        if let Some(caps) = heading_re.captures(line) {\n            let level = caps.get(1).unwrap().as_str().len() as u8;\n            let text = caps.get(2).unwrap().as_str().to_string();\n            outline.push(OutlineItem::new(\n                line_num,\n                text,\n                (level - 1) as usize,\n                ItemKind::Heading(level),\n            ));\n        }\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":33}},{"line":11,"address":[],"length":0,"stats":{"Line":66}},{"line":13,"address":[],"length":0,"stats":{"Line":99}},{"line":16,"address":[],"length":0,"stats":{"Line":66}},{"line":18,"address":[],"length":0,"stats":{"Line":33}},{"line":19,"address":[],"length":0,"stats":{"Line":72}},{"line":20,"address":[],"length":0,"stats":{"Line":32}},{"line":21,"address":[],"length":0,"stats":{"Line":75}},{"line":22,"address":[],"length":0,"stats":{"Line":22}},{"line":23,"address":[],"length":0,"stats":{"Line":15}},{"line":24,"address":[],"length":0,"stats":{"Line":8}},{"line":25,"address":[],"length":0,"stats":{"Line":2}},{"line":28,"address":[],"length":0,"stats":{"Line":33}},{"line":32,"address":[],"length":0,"stats":{"Line":13}},{"line":37,"address":[],"length":0,"stats":{"Line":52}},{"line":38,"address":[],"length":0,"stats":{"Line":52}},{"line":39,"address":[],"length":0,"stats":{"Line":52}},{"line":40,"address":[],"length":0,"stats":{"Line":52}},{"line":41,"address":[],"length":0,"stats":{"Line":52}},{"line":42,"address":[],"length":0,"stats":{"Line":52}},{"line":43,"address":[],"length":0,"stats":{"Line":52}},{"line":45,"address":[],"length":0,"stats":{"Line":75}},{"line":46,"address":[],"length":0,"stats":{"Line":36}},{"line":48,"address":[],"length":0,"stats":{"Line":41}},{"line":49,"address":[],"length":0,"stats":{"Line":30}},{"line":50,"address":[],"length":0,"stats":{"Line":20}},{"line":51,"address":[],"length":0,"stats":{"Line":15}},{"line":52,"address":[],"length":0,"stats":{"Line":5}},{"line":53,"address":[],"length":0,"stats":{"Line":10}},{"line":54,"address":[],"length":0,"stats":{"Line":5}},{"line":55,"address":[],"length":0,"stats":{"Line":5}},{"line":57,"address":[],"length":0,"stats":{"Line":27}},{"line":58,"address":[],"length":0,"stats":{"Line":6}},{"line":59,"address":[],"length":0,"stats":{"Line":4}},{"line":60,"address":[],"length":0,"stats":{"Line":3}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":62,"address":[],"length":0,"stats":{"Line":2}},{"line":63,"address":[],"length":0,"stats":{"Line":1}},{"line":64,"address":[],"length":0,"stats":{"Line":1}},{"line":66,"address":[],"length":0,"stats":{"Line":25}},{"line":67,"address":[],"length":0,"stats":{"Line":6}},{"line":68,"address":[],"length":0,"stats":{"Line":4}},{"line":69,"address":[],"length":0,"stats":{"Line":3}},{"line":70,"address":[],"length":0,"stats":{"Line":1}},{"line":71,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":1}},{"line":75,"address":[],"length":0,"stats":{"Line":23}},{"line":76,"address":[],"length":0,"stats":{"Line":6}},{"line":77,"address":[],"length":0,"stats":{"Line":4}},{"line":78,"address":[],"length":0,"stats":{"Line":3}},{"line":79,"address":[],"length":0,"stats":{"Line":1}},{"line":80,"address":[],"length":0,"stats":{"Line":2}},{"line":81,"address":[],"length":0,"stats":{"Line":1}},{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":84,"address":[],"length":0,"stats":{"Line":23}},{"line":85,"address":[],"length":0,"stats":{"Line":18}},{"line":86,"address":[],"length":0,"stats":{"Line":12}},{"line":87,"address":[],"length":0,"stats":{"Line":9}},{"line":88,"address":[],"length":0,"stats":{"Line":3}},{"line":89,"address":[],"length":0,"stats":{"Line":6}},{"line":90,"address":[],"length":0,"stats":{"Line":3}},{"line":91,"address":[],"length":0,"stats":{"Line":3}},{"line":93,"address":[],"length":0,"stats":{"Line":15}},{"line":94,"address":[],"length":0,"stats":{"Line":6}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":96,"address":[],"length":0,"stats":{"Line":3}},{"line":97,"address":[],"length":0,"stats":{"Line":1}},{"line":98,"address":[],"length":0,"stats":{"Line":2}},{"line":99,"address":[],"length":0,"stats":{"Line":1}},{"line":100,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":13}},{"line":103,"address":[],"length":0,"stats":{"Line":6}},{"line":104,"address":[],"length":0,"stats":{"Line":4}},{"line":105,"address":[],"length":0,"stats":{"Line":3}},{"line":106,"address":[],"length":0,"stats":{"Line":1}},{"line":107,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":1}},{"line":109,"address":[],"length":0,"stats":{"Line":1}},{"line":111,"address":[],"length":0,"stats":{"Line":11}},{"line":112,"address":[],"length":0,"stats":{"Line":6}},{"line":113,"address":[],"length":0,"stats":{"Line":4}},{"line":114,"address":[],"length":0,"stats":{"Line":3}},{"line":115,"address":[],"length":0,"stats":{"Line":1}},{"line":116,"address":[],"length":0,"stats":{"Line":2}},{"line":117,"address":[],"length":0,"stats":{"Line":1}},{"line":118,"address":[],"length":0,"stats":{"Line":1}},{"line":125,"address":[],"length":0,"stats":{"Line":4}},{"line":126,"address":[],"length":0,"stats":{"Line":16}},{"line":127,"address":[],"length":0,"stats":{"Line":16}},{"line":129,"address":[],"length":0,"stats":{"Line":26}},{"line":130,"address":[],"length":0,"stats":{"Line":14}},{"line":132,"address":[],"length":0,"stats":{"Line":17}},{"line":133,"address":[],"length":0,"stats":{"Line":18}},{"line":134,"address":[],"length":0,"stats":{"Line":12}},{"line":135,"address":[],"length":0,"stats":{"Line":9}},{"line":136,"address":[],"length":0,"stats":{"Line":3}},{"line":137,"address":[],"length":0,"stats":{"Line":6}},{"line":138,"address":[],"length":0,"stats":{"Line":3}},{"line":139,"address":[],"length":0,"stats":{"Line":3}},{"line":141,"address":[],"length":0,"stats":{"Line":10}},{"line":142,"address":[],"length":0,"stats":{"Line":12}},{"line":143,"address":[],"length":0,"stats":{"Line":8}},{"line":144,"address":[],"length":0,"stats":{"Line":6}},{"line":145,"address":[],"length":0,"stats":{"Line":2}},{"line":146,"address":[],"length":0,"stats":{"Line":4}},{"line":147,"address":[],"length":0,"stats":{"Line":2}},{"line":148,"address":[],"length":0,"stats":{"Line":2}},{"line":155,"address":[],"length":0,"stats":{"Line":6}},{"line":156,"address":[],"length":0,"stats":{"Line":6}},{"line":157,"address":[],"length":0,"stats":{"Line":12}},{"line":159,"address":[],"length":0,"stats":{"Line":6}},{"line":160,"address":[],"length":0,"stats":{"Line":12}},{"line":162,"address":[],"length":0,"stats":{"Line":24}},{"line":163,"address":[],"length":0,"stats":{"Line":24}},{"line":165,"address":[],"length":0,"stats":{"Line":58}},{"line":166,"address":[],"length":0,"stats":{"Line":40}},{"line":168,"address":[],"length":0,"stats":{"Line":42}},{"line":169,"address":[],"length":0,"stats":{"Line":12}},{"line":170,"address":[],"length":0,"stats":{"Line":8}},{"line":171,"address":[],"length":0,"stats":{"Line":6}},{"line":172,"address":[],"length":0,"stats":{"Line":2}},{"line":173,"address":[],"length":0,"stats":{"Line":4}},{"line":174,"address":[],"length":0,"stats":{"Line":2}},{"line":175,"address":[],"length":0,"stats":{"Line":2}},{"line":177,"address":[],"length":0,"stats":{"Line":37}},{"line":178,"address":[],"length":0,"stats":{"Line":6}},{"line":179,"address":[],"length":0,"stats":{"Line":4}},{"line":180,"address":[],"length":0,"stats":{"Line":3}},{"line":181,"address":[],"length":0,"stats":{"Line":1}},{"line":182,"address":[],"length":0,"stats":{"Line":2}},{"line":183,"address":[],"length":0,"stats":{"Line":1}},{"line":184,"address":[],"length":0,"stats":{"Line":1}},{"line":186,"address":[],"length":0,"stats":{"Line":37}},{"line":187,"address":[],"length":0,"stats":{"Line":18}},{"line":188,"address":[],"length":0,"stats":{"Line":12}},{"line":189,"address":[],"length":0,"stats":{"Line":9}},{"line":190,"address":[],"length":0,"stats":{"Line":3}},{"line":191,"address":[],"length":0,"stats":{"Line":6}},{"line":192,"address":[],"length":0,"stats":{"Line":3}},{"line":193,"address":[],"length":0,"stats":{"Line":3}},{"line":195,"address":[],"length":0,"stats":{"Line":32}},{"line":196,"address":[],"length":0,"stats":{"Line":24}},{"line":198,"address":[],"length":0,"stats":{"Line":8}},{"line":199,"address":[],"length":0,"stats":{"Line":20}},{"line":200,"address":[],"length":0,"stats":{"Line":16}},{"line":201,"address":[],"length":0,"stats":{"Line":8}},{"line":202,"address":[],"length":0,"stats":{"Line":12}},{"line":203,"address":[],"length":0,"stats":{"Line":4}},{"line":204,"address":[],"length":0,"stats":{"Line":4}},{"line":212,"address":[],"length":0,"stats":{"Line":4}},{"line":213,"address":[],"length":0,"stats":{"Line":16}},{"line":214,"address":[],"length":0,"stats":{"Line":16}},{"line":215,"address":[],"length":0,"stats":{"Line":16}},{"line":217,"address":[],"length":0,"stats":{"Line":20}},{"line":218,"address":[],"length":0,"stats":{"Line":8}},{"line":220,"address":[],"length":0,"stats":{"Line":10}},{"line":221,"address":[],"length":0,"stats":{"Line":12}},{"line":222,"address":[],"length":0,"stats":{"Line":8}},{"line":223,"address":[],"length":0,"stats":{"Line":6}},{"line":224,"address":[],"length":0,"stats":{"Line":2}},{"line":225,"address":[],"length":0,"stats":{"Line":4}},{"line":226,"address":[],"length":0,"stats":{"Line":2}},{"line":227,"address":[],"length":0,"stats":{"Line":2}},{"line":229,"address":[],"length":0,"stats":{"Line":5}},{"line":230,"address":[],"length":0,"stats":{"Line":6}},{"line":231,"address":[],"length":0,"stats":{"Line":4}},{"line":232,"address":[],"length":0,"stats":{"Line":3}},{"line":233,"address":[],"length":0,"stats":{"Line":1}},{"line":234,"address":[],"length":0,"stats":{"Line":2}},{"line":235,"address":[],"length":0,"stats":{"Line":1}},{"line":236,"address":[],"length":0,"stats":{"Line":1}},{"line":238,"address":[],"length":0,"stats":{"Line":3}},{"line":239,"address":[],"length":0,"stats":{"Line":6}},{"line":240,"address":[],"length":0,"stats":{"Line":4}},{"line":241,"address":[],"length":0,"stats":{"Line":3}},{"line":242,"address":[],"length":0,"stats":{"Line":1}},{"line":243,"address":[],"length":0,"stats":{"Line":2}},{"line":244,"address":[],"length":0,"stats":{"Line":1}},{"line":245,"address":[],"length":0,"stats":{"Line":1}},{"line":252,"address":[],"length":0,"stats":{"Line":3}},{"line":253,"address":[],"length":0,"stats":{"Line":3}},{"line":254,"address":[],"length":0,"stats":{"Line":9}},{"line":255,"address":[],"length":0,"stats":{"Line":12}},{"line":256,"address":[],"length":0,"stats":{"Line":12}},{"line":258,"address":[],"length":0,"stats":{"Line":15}},{"line":259,"address":[],"length":0,"stats":{"Line":6}},{"line":261,"address":[],"length":0,"stats":{"Line":8}},{"line":262,"address":[],"length":0,"stats":{"Line":5}},{"line":263,"address":[],"length":0,"stats":{"Line":4}},{"line":264,"address":[],"length":0,"stats":{"Line":2}},{"line":265,"address":[],"length":0,"stats":{"Line":2}},{"line":266,"address":[],"length":0,"stats":{"Line":1}},{"line":267,"address":[],"length":0,"stats":{"Line":1}},{"line":269,"address":[],"length":0,"stats":{"Line":7}},{"line":270,"address":[],"length":0,"stats":{"Line":5}},{"line":271,"address":[],"length":0,"stats":{"Line":4}},{"line":272,"address":[],"length":0,"stats":{"Line":2}},{"line":273,"address":[],"length":0,"stats":{"Line":2}},{"line":274,"address":[],"length":0,"stats":{"Line":1}},{"line":275,"address":[],"length":0,"stats":{"Line":1}},{"line":277,"address":[],"length":0,"stats":{"Line":5}},{"line":278,"address":[],"length":0,"stats":{"Line":5}},{"line":279,"address":[],"length":0,"stats":{"Line":4}},{"line":280,"address":[],"length":0,"stats":{"Line":2}},{"line":281,"address":[],"length":0,"stats":{"Line":2}},{"line":282,"address":[],"length":0,"stats":{"Line":1}},{"line":283,"address":[],"length":0,"stats":{"Line":1}},{"line":290,"address":[],"length":0,"stats":{"Line":1}},{"line":291,"address":[],"length":0,"stats":{"Line":4}},{"line":293,"address":[],"length":0,"stats":{"Line":13}},{"line":294,"address":[],"length":0,"stats":{"Line":10}},{"line":296,"address":[],"length":0,"stats":{"Line":18}},{"line":297,"address":[],"length":0,"stats":{"Line":16}},{"line":298,"address":[],"length":0,"stats":{"Line":20}},{"line":299,"address":[],"length":0,"stats":{"Line":16}},{"line":300,"address":[],"length":0,"stats":{"Line":8}},{"line":301,"address":[],"length":0,"stats":{"Line":8}},{"line":302,"address":[],"length":0,"stats":{"Line":4}},{"line":303,"address":[],"length":0,"stats":{"Line":4}}],"covered":220,"coverable":220},{"path":["/","Users","chi","Projects","hu","src","read","outline","tests.rs"],"content":"use super::*;\n\n#[test]\nfn rust_function() {\n    let content = \"pub fn test(x: i32) -\u003e String {\";\n    let outline = extract_outline(content, \"test.rs\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"pub fn test\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Function);\n}\n\n#[test]\nfn rust_async_function() {\n    let content = \"pub async fn fetch() -\u003e Result\u003c()\u003e {\";\n    let outline = extract_outline(content, \"test.rs\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"async fn fetch\"));\n}\n\n#[test]\nfn rust_struct() {\n    let content = \"pub struct Config\u003cT\u003e {\";\n    let outline = extract_outline(content, \"test.rs\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"struct Config\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Struct);\n}\n\n#[test]\nfn rust_enum() {\n    let content = \"pub enum Status {\";\n    let outline = extract_outline(content, \"test.rs\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"enum Status\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Enum);\n}\n\n#[test]\nfn rust_trait() {\n    let content = \"pub trait Handler {\";\n    let outline = extract_outline(content, \"test.rs\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"trait Handler\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Trait);\n}\n\n#[test]\nfn rust_impl() {\n    let content = \"impl Config {\";\n    let outline = extract_outline(content, \"test.rs\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"impl Config\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Impl);\n}\n\n#[test]\nfn rust_impl_for() {\n    let content = \"impl Handler for Config {\";\n    let outline = extract_outline(content, \"test.rs\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"impl Handler for Config\"));\n}\n\n#[test]\nfn rust_mod() {\n    let content = \"pub mod utils;\";\n    let outline = extract_outline(content, \"test.rs\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"mod utils\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Module);\n}\n\n#[test]\nfn rust_const() {\n    let content = \"pub const MAX_SIZE: usize = 1024;\";\n    let outline = extract_outline(content, \"test.rs\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"const MAX_SIZE\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Const);\n}\n\n#[test]\nfn rust_type() {\n    let content = \"pub type Result\u003cT\u003e = std::result::Result\u003cT, Error\u003e;\";\n    let outline = extract_outline(content, \"test.rs\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"type Result\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Type);\n}\n\n#[test]\nfn rust_nested() {\n    let content = r#\"\nimpl Config {\n    pub fn new() -\u003e Self {\n    }\n}\n\"#;\n    let outline = extract_outline(content, \"test.rs\");\n    assert_eq!(outline.len(), 2);\n    assert_eq!(outline.items[0].level, 0);\n    assert_eq!(outline.items[1].level, 1);\n}\n\n#[test]\nfn python_function() {\n    let content = \"def process(data: list) -\u003e dict:\";\n    let outline = extract_outline(content, \"test.py\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"def process\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Function);\n}\n\n#[test]\nfn python_async_function() {\n    let content = \"async def fetch(url):\";\n    let outline = extract_outline(content, \"test.py\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"async def fetch\"));\n}\n\n#[test]\nfn python_class() {\n    let content = \"class Handler(BaseHandler):\";\n    let outline = extract_outline(content, \"test.py\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"class Handler\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Class);\n}\n\n#[test]\nfn python_nested() {\n    let content = r#\"\nclass Handler:\n    def process(self):\n        pass\n\"#;\n    let outline = extract_outline(content, \"test.py\");\n    assert_eq!(outline.len(), 2);\n    assert_eq!(outline.items[0].level, 0);\n    assert_eq!(outline.items[1].level, 1);\n}\n\n#[test]\nfn js_function() {\n    let content = \"export async function fetchData(url) {\";\n    let outline = extract_outline(content, \"test.js\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"function fetchData\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Function);\n}\n\n#[test]\nfn js_arrow_function() {\n    let content = \"const handler = async (req, res) =\u003e\";\n    let outline = extract_outline(content, \"test.js\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"const handler\"));\n}\n\n#[test]\nfn js_class() {\n    let content = \"export class UserService extends Service {\";\n    let outline = extract_outline(content, \"test.js\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"class UserService\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Class);\n}\n\n#[test]\nfn ts_function() {\n    let content = \"export function process\u003cT\u003e(data: T[]): T[] {\";\n    let outline = extract_outline(content, \"test.ts\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"function process\"));\n}\n\n#[test]\nfn ruby_def() {\n    let content = \"def process(data)\";\n    let outline = extract_outline(content, \"test.rb\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"def process\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Function);\n}\n\n#[test]\nfn ruby_predicate() {\n    let content = \"def valid?\";\n    let outline = extract_outline(content, \"test.rb\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"def valid?\"));\n}\n\n#[test]\nfn ruby_class() {\n    let content = \"class Handler \u003c BaseHandler\";\n    let outline = extract_outline(content, \"test.rb\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"class Handler\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Class);\n}\n\n#[test]\nfn ruby_module() {\n    let content = \"module Utils\";\n    let outline = extract_outline(content, \"test.rb\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"module Utils\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Module);\n}\n\n#[test]\nfn go_func() {\n    let content = \"func (s *Server) Handle(w http.ResponseWriter, r *http.Request) {\";\n    let outline = extract_outline(content, \"test.go\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"func\"));\n    assert!(outline.items[0].text.contains(\"Handle\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Function);\n}\n\n#[test]\nfn go_struct() {\n    let content = \"type Config struct {\";\n    let outline = extract_outline(content, \"test.go\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"type Config struct\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Struct);\n}\n\n#[test]\nfn go_interface() {\n    let content = \"type Handler interface {\";\n    let outline = extract_outline(content, \"test.go\");\n    assert_eq!(outline.len(), 1);\n    assert!(outline.items[0].text.contains(\"type Handler interface\"));\n    assert_eq!(outline.items[0].kind, ItemKind::Trait);\n}\n\n#[test]\nfn markdown_headings() {\n    let content = r#\"\n# Title\n## Section 1\n### Subsection\n## Section 2\n\"#;\n    let outline = extract_outline(content, \"test.md\");\n    assert_eq!(outline.len(), 4);\n    assert_eq!(outline.items[0].text, \"Title\");\n    assert_eq!(outline.items[0].kind, ItemKind::Heading(1));\n    assert_eq!(outline.items[0].level, 0);\n    assert_eq!(outline.items[1].text, \"Section 1\");\n    assert_eq!(outline.items[1].kind, ItemKind::Heading(2));\n    assert_eq!(outline.items[1].level, 1);\n    assert_eq!(outline.items[2].text, \"Subsection\");\n    assert_eq!(outline.items[2].kind, ItemKind::Heading(3));\n    assert_eq!(outline.items[2].level, 2);\n}\n\n#[test]\nfn unknown_extension() {\n    let content = \"some content\";\n    let outline = extract_outline(content, \"test.xyz\");\n    assert!(outline.is_empty());\n}\n\n#[test]\nfn empty_content() {\n    let outline = extract_outline(\"\", \"test.rs\");\n    assert!(outline.is_empty());\n}\n\n#[test]\nfn line_numbers_correct() {\n    let content = r#\"\npub fn first() {}\npub fn second() {}\n\"#;\n    let outline = extract_outline(content, \"test.rs\");\n    assert_eq!(outline.len(), 2);\n    assert_eq!(outline.items[0].line, 2);\n    assert_eq!(outline.items[1].line, 3);\n}\n\n#[test]\nfn js_class_methods() {\n    // Test that methods inside JavaScript classes are detected\n    let content = r#\"class UserService {\n  constructor(db) {\n    this.db = db;\n  }\n\n  async findById(id) {\n    return this.db.find(id);\n  }\n\n  delete(id) {\n  }\n}\n\"#;\n    let outline = extract_outline(content, \"test.js\");\n    // class + 3 methods (constructor, findById, delete)\n    assert_eq!(outline.len(), 4);\n    assert!(outline.items[0].text.contains(\"class UserService\"));\n    assert!(outline.items[1].text.contains(\"constructor\"));\n    assert!(outline.items[2].text.contains(\"findById\"));\n    assert!(outline.items[3].text.contains(\"delete\"));\n}\n\n#[test]\nfn js_method_async() {\n    // Test async methods inside class\n    let content = r#\"class Api {\n  async fetch(url) {\n  }\n}\n\"#;\n    let outline = extract_outline(content, \"test.js\");\n    assert_eq!(outline.len(), 2);\n    assert!(outline.items[1].text.contains(\"async fetch\"));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","read","service.rs"],"content":"use anyhow::{Context, Result};\nuse std::fs;\nuse std::path::Path;\n\nuse super::around::extract_lines_around;\nuse super::cli::ReadArgs;\nuse super::diff::git_diff;\nuse super::interface::extract_interface;\nuse super::outline::extract_outline;\nuse super::types::ReadOutput;\n\n/// Run the read command - returns data, never prints\npub fn run(args: ReadArgs) -\u003e Result\u003cReadOutput\u003e {\n    let path = resolve_path(\u0026args.path)?;\n    let content = fs::read_to_string(\u0026path)\n        .with_context(|| format!(\"Failed to read file: {}\", path.display()))?;\n\n    if let Some(center) = args.around {\n        // Lines around a specific line\n        let (lines, total_lines) = extract_lines_around(\u0026content, center, args.context);\n        Ok(ReadOutput::Around {\n            lines,\n            center,\n            total_lines,\n        })\n    } else if args.diff {\n        // Git diff\n        let commit = if args.commit == \"HEAD\" {\n            None\n        } else {\n            Some(args.commit.as_str())\n        };\n        let diff = git_diff(path.to_str().unwrap_or(\"\"), commit)?;\n        Ok(ReadOutput::Diff(diff))\n    } else if args.interface {\n        // Public interface\n        let items = extract_interface(\u0026content, path.to_str().unwrap_or(\"\"));\n        Ok(ReadOutput::Interface(items))\n    } else if args.outline {\n        // File outline\n        let outline = extract_outline(\u0026content, path.to_str().unwrap_or(\"\"));\n        Ok(ReadOutput::Outline(outline))\n    } else {\n        // Full file content\n        Ok(ReadOutput::Full(content))\n    }\n}\n\n/// Resolve a path to absolute\nfn resolve_path(path_str: \u0026str) -\u003e Result\u003cstd::path::PathBuf\u003e {\n    let path = Path::new(path_str);\n    if path.is_absolute() {\n        Ok(path.to_path_buf())\n    } else {\n        let cwd = std::env::current_dir().context(\"Failed to get current directory\")?;\n        let resolved = cwd.join(path);\n        if !resolved.exists() {\n            anyhow::bail!(\"File not found: {}\", path_str);\n        }\n        Ok(resolved)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn resolve_path_absolute() {\n        let result = resolve_path(\"/tmp\");\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn resolve_path_relative() {\n        // Cargo.toml exists in project root\n        let result = resolve_path(\"Cargo.toml\");\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn resolve_path_not_found() {\n        let result = resolve_path(\"nonexistent_file_xyz.abc\");\n        assert!(result.is_err());\n    }\n\n    // Integration tests - verify correct ReadOutput variant is returned\n    #[test]\n    fn run_returns_outline() {\n        let args = ReadArgs {\n            path: concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/Cargo.toml\").to_string(),\n            outline: true,\n            interface: false,\n            around: None,\n            context: 10,\n            diff: false,\n            commit: \"HEAD\".to_string(),\n        };\n        let result = run(args).unwrap();\n        assert!(matches!(result, ReadOutput::Outline(_)));\n    }\n\n    #[test]\n    fn run_returns_around() {\n        let args = ReadArgs {\n            path: concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/Cargo.toml\").to_string(),\n            outline: false,\n            interface: false,\n            around: Some(5),\n            context: 3,\n            diff: false,\n            commit: \"HEAD\".to_string(),\n        };\n        let result = run(args).unwrap();\n        assert!(matches!(result, ReadOutput::Around { .. }));\n    }\n\n    #[test]\n    fn run_returns_full() {\n        let args = ReadArgs {\n            path: concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/Cargo.toml\").to_string(),\n            outline: false,\n            interface: false,\n            around: None,\n            context: 10,\n            diff: false,\n            commit: \"HEAD\".to_string(),\n        };\n        let result = run(args).unwrap();\n        assert!(matches!(result, ReadOutput::Full(_)));\n    }\n\n    #[test]\n    fn run_returns_interface() {\n        let args = ReadArgs {\n            path: concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/src/main.rs\").to_string(),\n            outline: false,\n            interface: true,\n            around: None,\n            context: 10,\n            diff: false,\n            commit: \"HEAD\".to_string(),\n        };\n        let result = run(args).unwrap();\n        assert!(matches!(result, ReadOutput::Interface(_)));\n    }\n\n    #[test]\n    fn run_returns_diff() {\n        let args = ReadArgs {\n            path: concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/Cargo.toml\").to_string(),\n            outline: false,\n            interface: false,\n            around: None,\n            context: 10,\n            diff: true,\n            commit: \"HEAD\".to_string(),\n        };\n        let result = run(args).unwrap();\n        assert!(matches!(result, ReadOutput::Diff(_)));\n    }\n\n    #[test]\n    fn run_diff_specific_commit() {\n        let args = ReadArgs {\n            path: concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/Cargo.toml\").to_string(),\n            outline: false,\n            interface: false,\n            around: None,\n            context: 10,\n            diff: true,\n            commit: \"HEAD~1\".to_string(),\n        };\n        // This may fail if HEAD~1 doesn't exist, but shouldn't panic\n        let _ = run(args);\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":6}},{"line":14,"address":[],"length":0,"stats":{"Line":18}},{"line":15,"address":[],"length":0,"stats":{"Line":18}},{"line":16,"address":[],"length":0,"stats":{"Line":6}},{"line":18,"address":[],"length":0,"stats":{"Line":8}},{"line":20,"address":[],"length":0,"stats":{"Line":6}},{"line":21,"address":[],"length":0,"stats":{"Line":6}},{"line":22,"address":[],"length":0,"stats":{"Line":1}},{"line":23,"address":[],"length":0,"stats":{"Line":6}},{"line":25,"address":[],"length":0,"stats":{"Line":4}},{"line":26,"address":[],"length":0,"stats":{"Line":1}},{"line":28,"address":[],"length":0,"stats":{"Line":1}},{"line":30,"address":[],"length":0,"stats":{"Line":10}},{"line":31,"address":[],"length":0,"stats":{"Line":6}},{"line":32,"address":[],"length":0,"stats":{"Line":4}},{"line":33,"address":[],"length":0,"stats":{"Line":4}},{"line":35,"address":[],"length":0,"stats":{"Line":6}},{"line":36,"address":[],"length":0,"stats":{"Line":4}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":38,"address":[],"length":0,"stats":{"Line":4}},{"line":40,"address":[],"length":0,"stats":{"Line":6}},{"line":41,"address":[],"length":0,"stats":{"Line":4}},{"line":42,"address":[],"length":0,"stats":{"Line":1}},{"line":45,"address":[],"length":0,"stats":{"Line":1}},{"line":48,"address":[],"length":0,"stats":{"Line":6}},{"line":52,"address":[],"length":0,"stats":{"Line":9}},{"line":53,"address":[],"length":0,"stats":{"Line":27}},{"line":54,"address":[],"length":0,"stats":{"Line":18}},{"line":55,"address":[],"length":0,"stats":{"Line":7}},{"line":57,"address":[],"length":0,"stats":{"Line":6}},{"line":58,"address":[],"length":0,"stats":{"Line":6}},{"line":59,"address":[],"length":0,"stats":{"Line":2}},{"line":60,"address":[],"length":0,"stats":{"Line":2}},{"line":62,"address":[],"length":0,"stats":{"Line":1}},{"line":67,"address":[],"length":0,"stats":{"Line":5}},{"line":68,"address":[],"length":0,"stats":{"Line":10}},{"line":69,"address":[],"length":0,"stats":{"Line":4}},{"line":72,"address":[],"length":0,"stats":{"Line":6}},{"line":74,"address":[],"length":0,"stats":{"Line":18}},{"line":75,"address":[],"length":0,"stats":{"Line":25}},{"line":76,"address":[],"length":0,"stats":{"Line":20}},{"line":77,"address":[],"length":0,"stats":{"Line":20}},{"line":78,"address":[],"length":0,"stats":{"Line":15}},{"line":81,"address":[],"length":0,"stats":{"Line":6}},{"line":85,"address":[],"length":0,"stats":{"Line":4}},{"line":86,"address":[],"length":0,"stats":{"Line":8}},{"line":87,"address":[],"length":0,"stats":{"Line":4}},{"line":90,"address":[],"length":0,"stats":{"Line":4}},{"line":92,"address":[],"length":0,"stats":{"Line":11}},{"line":93,"address":[],"length":0,"stats":{"Line":15}},{"line":94,"address":[],"length":0,"stats":{"Line":12}},{"line":95,"address":[],"length":0,"stats":{"Line":9}},{"line":98,"address":[],"length":0,"stats":{"Line":4}}],"covered":53,"coverable":53},{"path":["/","Users","chi","Projects","hu","src","read","types.rs"],"content":"/// An item in a file outline (function, struct, class, heading, etc.)\n#[derive(Debug, Clone, PartialEq)]\npub struct OutlineItem {\n    /// Line number where this item starts (1-indexed)\n    pub line: usize,\n    /// The signature or heading text\n    pub text: String,\n    /// Indent level (0 for top-level)\n    pub level: usize,\n    /// Kind of item (function, struct, class, heading, etc.)\n    pub kind: ItemKind,\n}\n\nimpl OutlineItem {\n    pub fn new(line: usize, text: String, level: usize, kind: ItemKind) -\u003e Self {\n        Self {\n            line,\n            text,\n            level,\n            kind,\n        }\n    }\n}\n\n/// Kind of outline item\n#[derive(Debug, Clone, PartialEq)]\npub enum ItemKind {\n    Function,\n    Struct,\n    Enum,\n    Trait,\n    Impl,\n    Class,\n    Module,\n    Const,\n    Type,\n    Heading(u8), // Heading level (1-6)\n    Other,\n}\n\nimpl ItemKind {\n    pub fn icon(\u0026self) -\u003e \u0026'static str {\n        match self {\n            ItemKind::Function =\u003e \"fn\",\n            ItemKind::Struct =\u003e \"struct\",\n            ItemKind::Enum =\u003e \"enum\",\n            ItemKind::Trait =\u003e \"trait\",\n            ItemKind::Impl =\u003e \"impl\",\n            ItemKind::Class =\u003e \"class\",\n            ItemKind::Module =\u003e \"mod\",\n            ItemKind::Const =\u003e \"const\",\n            ItemKind::Type =\u003e \"type\",\n            ItemKind::Heading(n) =\u003e match n {\n                1 =\u003e \"#\",\n                2 =\u003e \"##\",\n                3 =\u003e \"###\",\n                _ =\u003e \"####\",\n            },\n            ItemKind::Other =\u003e \"\",\n        }\n    }\n}\n\n/// File outline (collection of items)\n#[derive(Debug, Clone, Default)]\npub struct FileOutline {\n    pub items: Vec\u003cOutlineItem\u003e,\n}\n\nimpl FileOutline {\n    pub fn new() -\u003e Self {\n        Self { items: Vec::new() }\n    }\n\n    pub fn push(\u0026mut self, item: OutlineItem) {\n        self.items.push(item);\n    }\n\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.items.is_empty()\n    }\n\n    #[cfg(test)]\n    pub fn len(\u0026self) -\u003e usize {\n        self.items.len()\n    }\n}\n\n/// Result of reading a file with options\n#[derive(Debug, Clone)]\npub enum ReadOutput {\n    /// Full file content\n    Full(String),\n    /// File outline (signatures)\n    Outline(FileOutline),\n    /// Public interface only\n    Interface(Vec\u003cOutlineItem\u003e),\n    /// Lines around a specific line\n    Around {\n        lines: Vec\u003c(usize, String)\u003e,\n        center: usize,\n        total_lines: usize,\n    },\n    /// Git diff output\n    Diff(String),\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn outline_item_new() {\n        let item = OutlineItem::new(10, \"fn test()\".to_string(), 0, ItemKind::Function);\n        assert_eq!(item.line, 10);\n        assert_eq!(item.text, \"fn test()\");\n        assert_eq!(item.level, 0);\n        assert_eq!(item.kind, ItemKind::Function);\n    }\n\n    #[test]\n    fn outline_item_clone() {\n        let item = OutlineItem::new(1, \"test\".to_string(), 0, ItemKind::Function);\n        let cloned = item.clone();\n        assert_eq!(item, cloned);\n    }\n\n    #[test]\n    fn outline_item_debug() {\n        let item = OutlineItem::new(1, \"test\".to_string(), 0, ItemKind::Function);\n        let debug = format!(\"{:?}\", item);\n        assert!(debug.contains(\"OutlineItem\"));\n    }\n\n    #[test]\n    fn item_kind_icon_function() {\n        assert_eq!(ItemKind::Function.icon(), \"fn\");\n    }\n\n    #[test]\n    fn item_kind_icon_struct() {\n        assert_eq!(ItemKind::Struct.icon(), \"struct\");\n    }\n\n    #[test]\n    fn item_kind_icon_enum() {\n        assert_eq!(ItemKind::Enum.icon(), \"enum\");\n    }\n\n    #[test]\n    fn item_kind_icon_trait() {\n        assert_eq!(ItemKind::Trait.icon(), \"trait\");\n    }\n\n    #[test]\n    fn item_kind_icon_impl() {\n        assert_eq!(ItemKind::Impl.icon(), \"impl\");\n    }\n\n    #[test]\n    fn item_kind_icon_class() {\n        assert_eq!(ItemKind::Class.icon(), \"class\");\n    }\n\n    #[test]\n    fn item_kind_icon_module() {\n        assert_eq!(ItemKind::Module.icon(), \"mod\");\n    }\n\n    #[test]\n    fn item_kind_icon_const() {\n        assert_eq!(ItemKind::Const.icon(), \"const\");\n    }\n\n    #[test]\n    fn item_kind_icon_type() {\n        assert_eq!(ItemKind::Type.icon(), \"type\");\n    }\n\n    #[test]\n    fn item_kind_icon_other() {\n        assert_eq!(ItemKind::Other.icon(), \"\");\n    }\n\n    #[test]\n    fn item_kind_icon_heading() {\n        assert_eq!(ItemKind::Heading(1).icon(), \"#\");\n        assert_eq!(ItemKind::Heading(2).icon(), \"##\");\n        assert_eq!(ItemKind::Heading(3).icon(), \"###\");\n        assert_eq!(ItemKind::Heading(4).icon(), \"####\");\n        assert_eq!(ItemKind::Heading(5).icon(), \"####\");\n        assert_eq!(ItemKind::Heading(6).icon(), \"####\");\n    }\n\n    #[test]\n    fn item_kind_clone() {\n        let kind = ItemKind::Function;\n        let cloned = kind.clone();\n        assert_eq!(kind, cloned);\n    }\n\n    #[test]\n    fn item_kind_debug() {\n        let kind = ItemKind::Struct;\n        let debug = format!(\"{:?}\", kind);\n        assert!(debug.contains(\"Struct\"));\n    }\n\n    #[test]\n    fn file_outline_new() {\n        let outline = FileOutline::new();\n        assert!(outline.is_empty());\n        assert_eq!(outline.len(), 0);\n    }\n\n    #[test]\n    fn file_outline_default() {\n        let outline = FileOutline::default();\n        assert!(outline.is_empty());\n    }\n\n    #[test]\n    fn file_outline_push() {\n        let mut outline = FileOutline::new();\n        outline.push(OutlineItem::new(\n            1,\n            \"test\".to_string(),\n            0,\n            ItemKind::Function,\n        ));\n        assert_eq!(outline.len(), 1);\n        assert!(!outline.is_empty());\n    }\n\n    #[test]\n    fn file_outline_clone() {\n        let mut outline = FileOutline::new();\n        outline.push(OutlineItem::new(\n            1,\n            \"test\".to_string(),\n            0,\n            ItemKind::Function,\n        ));\n        let cloned = outline.clone();\n        assert_eq!(outline.len(), cloned.len());\n    }\n\n    #[test]\n    fn file_outline_debug() {\n        let outline = FileOutline::new();\n        let debug = format!(\"{:?}\", outline);\n        assert!(debug.contains(\"FileOutline\"));\n    }\n\n    #[test]\n    fn read_output_full() {\n        let output = ReadOutput::Full(\"content\".to_string());\n        assert!(matches!(output, ReadOutput::Full(_)));\n    }\n\n    #[test]\n    fn read_output_outline() {\n        let output = ReadOutput::Outline(FileOutline::new());\n        assert!(matches!(output, ReadOutput::Outline(_)));\n    }\n\n    #[test]\n    fn read_output_interface() {\n        let output = ReadOutput::Interface(vec![]);\n        assert!(matches!(output, ReadOutput::Interface(_)));\n    }\n\n    #[test]\n    fn read_output_around() {\n        let output = ReadOutput::Around {\n            lines: vec![(1, \"line\".to_string())],\n            center: 1,\n            total_lines: 10,\n        };\n        assert!(matches!(output, ReadOutput::Around { .. }));\n    }\n\n    #[test]\n    fn read_output_diff() {\n        let output = ReadOutput::Diff(\"diff output\".to_string());\n        assert!(matches!(output, ReadOutput::Diff(_)));\n    }\n\n    #[test]\n    fn read_output_clone() {\n        let output = ReadOutput::Full(\"test\".to_string());\n        let cloned = output.clone();\n        if let (ReadOutput::Full(a), ReadOutput::Full(b)) = (output, cloned) {\n            assert_eq!(a, b);\n        } else {\n            panic!(\"Expected Full\");\n        }\n    }\n\n    #[test]\n    fn read_output_debug() {\n        let output = ReadOutput::Diff(\"test\".to_string());\n        let debug = format!(\"{:?}\", output);\n        assert!(debug.contains(\"Diff\"));\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":83}},{"line":42,"address":[],"length":0,"stats":{"Line":24}},{"line":43,"address":[],"length":0,"stats":{"Line":24}},{"line":44,"address":[],"length":0,"stats":{"Line":5}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":1}},{"line":47,"address":[],"length":0,"stats":{"Line":1}},{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":1}},{"line":50,"address":[],"length":0,"stats":{"Line":1}},{"line":51,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":1}},{"line":53,"address":[],"length":0,"stats":{"Line":16}},{"line":54,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":3}},{"line":59,"address":[],"length":0,"stats":{"Line":1}},{"line":71,"address":[],"length":0,"stats":{"Line":42}},{"line":72,"address":[],"length":0,"stats":{"Line":42}},{"line":75,"address":[],"length":0,"stats":{"Line":47}},{"line":76,"address":[],"length":0,"stats":{"Line":141}},{"line":79,"address":[],"length":0,"stats":{"Line":10}},{"line":80,"address":[],"length":0,"stats":{"Line":20}},{"line":84,"address":[],"length":0,"stats":{"Line":34}},{"line":85,"address":[],"length":0,"stats":{"Line":68}}],"covered":26,"coverable":26},{"path":["/","Users","chi","Projects","hu","src","sentry","client.rs"],"content":"//! Sentry HTTP client\n\nuse anyhow::Result;\nuse reqwest::Client;\nuse serde::de::DeserializeOwned;\nuse std::future::Future;\nuse std::time::Duration;\nuse tokio::time::sleep;\n\nuse super::config::{load_config, SentryConfig};\nuse super::types::{Event, Issue};\n\nconst SENTRY_API_URL: \u0026str = \"https://sentry.io/api/0\";\nconst MAX_RETRIES: u32 = 3;\nconst DEFAULT_RETRY_SECS: u64 = 5;\n\n/// Trait for Sentry API operations (enables testing with mocks)\npub trait SentryApi {\n    /// List issues for organization\n    fn list_issues(\n        \u0026self,\n        query: Option\u003c\u0026str\u003e,\n        limit: usize,\n    ) -\u003e impl Future\u003cOutput = Result\u003cVec\u003cIssue\u003e\u003e\u003e + Send;\n\n    /// List issues for a specific project\n    fn list_project_issues(\n        \u0026self,\n        project: \u0026str,\n        query: Option\u003c\u0026str\u003e,\n        limit: usize,\n    ) -\u003e impl Future\u003cOutput = Result\u003cVec\u003cIssue\u003e\u003e\u003e + Send;\n\n    /// Get a single issue by ID\n    fn get_issue(\u0026self, issue_id: \u0026str) -\u003e impl Future\u003cOutput = Result\u003cIssue\u003e\u003e + Send;\n\n    /// List events for an issue\n    fn list_issue_events(\n        \u0026self,\n        issue_id: \u0026str,\n        limit: usize,\n    ) -\u003e impl Future\u003cOutput = Result\u003cVec\u003cEvent\u003e\u003e\u003e + Send;\n}\n\n/// Sentry API client\npub struct SentryClient {\n    config: SentryConfig,\n    http: Client,\n}\n\nimpl SentryClient {\n    /// Create a new Sentry client\n    pub fn new() -\u003e Result\u003cSelf\u003e {\n        let config = load_config()?;\n        let http = Client::builder().user_agent(\"hu-cli/0.1.0\").build()?;\n        Ok(Self { config, http })\n    }\n\n    /// Get auth token\n    fn auth_token(\u0026self) -\u003e Result\u003c\u0026str\u003e {\n        self.config\n            .auth_token\n            .as_deref()\n            .ok_or_else(|| anyhow::anyhow!(\"Sentry auth_token not configured\"))\n    }\n\n    /// Get organization slug\n    fn organization(\u0026self) -\u003e Result\u003c\u0026str\u003e {\n        self.config\n            .organization\n            .as_deref()\n            .ok_or_else(|| anyhow::anyhow!(\"Sentry organization not configured\"))\n    }\n\n    /// List issues for organization\n    pub async fn list_issues(\u0026self, query: Option\u003c\u0026str\u003e, limit: usize) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n        let org = self.organization()?;\n        let url = format!(\"{}/organizations/{}/issues/\", SENTRY_API_URL, org);\n\n        let mut params = vec![(\"limit\", limit.to_string())];\n        if let Some(q) = query {\n            params.push((\"query\", q.to_string()));\n        }\n\n        self.get_with_params(\u0026url, \u0026params).await\n    }\n\n    /// List issues for a specific project\n    pub async fn list_project_issues(\n        \u0026self,\n        project: \u0026str,\n        query: Option\u003c\u0026str\u003e,\n        limit: usize,\n    ) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n        let org = self.organization()?;\n        let url = format!(\"{}/projects/{}/{}/issues/\", SENTRY_API_URL, org, project);\n\n        let mut params = vec![(\"limit\", limit.to_string())];\n        if let Some(q) = query {\n            params.push((\"query\", q.to_string()));\n        }\n\n        self.get_with_params(\u0026url, \u0026params).await\n    }\n\n    /// Get a single issue by ID\n    pub async fn get_issue(\u0026self, issue_id: \u0026str) -\u003e Result\u003cIssue\u003e {\n        let org = self.organization()?;\n        let url = format!(\n            \"{}/organizations/{}/issues/{}/\",\n            SENTRY_API_URL, org, issue_id\n        );\n\n        self.get(\u0026url).await\n    }\n\n    /// List events for an issue\n    pub async fn list_issue_events(\u0026self, issue_id: \u0026str, limit: usize) -\u003e Result\u003cVec\u003cEvent\u003e\u003e {\n        let org = self.organization()?;\n        let url = format!(\n            \"{}/organizations/{}/issues/{}/events/\",\n            SENTRY_API_URL, org, issue_id\n        );\n\n        self.get_with_params(\u0026url, \u0026[(\"limit\", limit.to_string())])\n            .await\n    }\n\n    /// Make a GET request\n    async fn get\u003cT: DeserializeOwned\u003e(\u0026self, url: \u0026str) -\u003e Result\u003cT\u003e {\n        let token = self.auth_token()?.to_string();\n\n        self.execute_with_retry(|| {\n            self.http\n                .get(url)\n                .header(\"Authorization\", format!(\"Bearer {}\", token))\n                .send()\n        })\n        .await\n    }\n\n    /// Make a GET request with parameters\n    async fn get_with_params\u003cT: DeserializeOwned\u003e(\n        \u0026self,\n        url: \u0026str,\n        params: \u0026[(\u0026str, String)],\n    ) -\u003e Result\u003cT\u003e {\n        let token = self.auth_token()?.to_string();\n        let params: Vec\u003c(String, String)\u003e = params\n            .iter()\n            .map(|(k, v)| (k.to_string(), v.clone()))\n            .collect();\n\n        self.execute_with_retry(|| {\n            self.http\n                .get(url)\n                .header(\"Authorization\", format!(\"Bearer {}\", token))\n                .query(\u0026params)\n                .send()\n        })\n        .await\n    }\n\n    /// Execute request with retry on rate limit\n    async fn execute_with_retry\u003cF, Fut, T\u003e(\u0026self, request_fn: F) -\u003e Result\u003cT\u003e\n    where\n        F: Fn() -\u003e Fut,\n        Fut: std::future::Future\u003cOutput = Result\u003creqwest::Response, reqwest::Error\u003e\u003e,\n        T: DeserializeOwned,\n    {\n        let mut retries = 0;\n\n        loop {\n            let response = request_fn().await?;\n            let status = response.status();\n\n            if status == reqwest::StatusCode::TOO_MANY_REQUESTS {\n                if retries \u003e= MAX_RETRIES {\n                    return Err(anyhow::anyhow!(\n                        \"Rate limited after {} retries\",\n                        MAX_RETRIES\n                    ));\n                }\n\n                let retry_after = response\n                    .headers()\n                    .get(\"retry-after\")\n                    .and_then(|v| v.to_str().ok())\n                    .and_then(|s| s.parse::\u003cu64\u003e().ok())\n                    .unwrap_or(DEFAULT_RETRY_SECS);\n\n                eprintln!(\n                    \"Rate limited, waiting {} seconds... (retry {}/{})\",\n                    retry_after,\n                    retries + 1,\n                    MAX_RETRIES\n                );\n                sleep(Duration::from_secs(retry_after)).await;\n                retries += 1;\n                continue;\n            }\n\n            if !status.is_success() {\n                let body = response.text().await.unwrap_or_default();\n                return Err(anyhow::anyhow!(\"HTTP {}: {}\", status.as_u16(), body));\n            }\n\n            let text = response.text().await?;\n            return serde_json::from_str(\u0026text).map_err(|e| {\n                anyhow::anyhow!(\"Parse error: {}: {}\", e, \u0026text[..text.len().min(200)])\n            });\n        }\n    }\n}\n\nimpl SentryApi for SentryClient {\n    async fn list_issues(\u0026self, query: Option\u003c\u0026str\u003e, limit: usize) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n        SentryClient::list_issues(self, query, limit).await\n    }\n\n    async fn list_project_issues(\n        \u0026self,\n        project: \u0026str,\n        query: Option\u003c\u0026str\u003e,\n        limit: usize,\n    ) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n        SentryClient::list_project_issues(self, project, query, limit).await\n    }\n\n    async fn get_issue(\u0026self, issue_id: \u0026str) -\u003e Result\u003cIssue\u003e {\n        SentryClient::get_issue(self, issue_id).await\n    }\n\n    async fn list_issue_events(\u0026self, issue_id: \u0026str, limit: usize) -\u003e Result\u003cVec\u003cEvent\u003e\u003e {\n        SentryClient::list_issue_events(self, issue_id, limit).await\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":1}},{"line":25,"address":[],"length":0,"stats":{"Line":2}},{"line":26,"address":[],"length":0,"stats":{"Line":4}},{"line":27,"address":[],"length":0,"stats":{"Line":1}},{"line":31,"address":[],"length":0,"stats":{"Line":1}},{"line":32,"address":[],"length":0,"stats":{"Line":1}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}}],"covered":6,"coverable":84},{"path":["/","Users","chi","Projects","hu","src","sentry","config.rs"],"content":"//! Sentry configuration\n//!\n//! Loads configuration from `~/.config/hu/settings.toml`\n\nuse anyhow::Result;\nuse serde::{Deserialize, Serialize};\nuse std::fs;\nuse std::path::PathBuf;\n\n/// Sentry configuration\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct SentryConfig {\n    /// Auth token\n    pub auth_token: Option\u003cString\u003e,\n    /// Organization slug\n    pub organization: Option\u003cString\u003e,\n    /// Default project slug\n    pub project: Option\u003cString\u003e,\n}\n\nimpl SentryConfig {\n    /// Check if configured with auth token\n    #[must_use]\n    pub fn is_configured(\u0026self) -\u003e bool {\n        self.auth_token.is_some() \u0026\u0026 self.organization.is_some()\n    }\n}\n\n/// Settings file structure\n#[derive(Debug, Default, Deserialize)]\nstruct SettingsFile {\n    sentry: Option\u003cSentryConfig\u003e,\n}\n\n/// Get path to config file\npub fn config_path() -\u003e Option\u003cPathBuf\u003e {\n    dirs::home_dir().map(|p| p.join(\".config\").join(\"hu\").join(\"settings.toml\"))\n}\n\n/// Load Sentry config from settings file and environment\npub fn load_config() -\u003e Result\u003cSentryConfig\u003e {\n    let mut config = SentryConfig::default();\n\n    // Load from settings file\n    if let Some(path) = config_path() {\n        if path.exists() {\n            let contents = fs::read_to_string(\u0026path)?;\n            let settings: SettingsFile = toml::from_str(\u0026contents)?;\n            if let Some(sentry) = settings.sentry {\n                config = sentry;\n            }\n        }\n    }\n\n    // Override with environment variables\n    if let Ok(token) = std::env::var(\"SENTRY_AUTH_TOKEN\") {\n        config.auth_token = Some(token);\n    }\n    if let Ok(org) = std::env::var(\"SENTRY_ORG\") {\n        config.organization = Some(org);\n    }\n    if let Ok(project) = std::env::var(\"SENTRY_PROJECT\") {\n        config.project = Some(project);\n    }\n\n    Ok(config)\n}\n\n/// Save auth token to config file\npub fn save_auth_token(token: \u0026str, org: \u0026str) -\u003e Result\u003c()\u003e {\n    let path = config_path().ok_or_else(|| anyhow::anyhow!(\"Cannot determine config directory\"))?;\n\n    // Read existing or create new\n    let contents = if path.exists() {\n        fs::read_to_string(\u0026path)?\n    } else {\n        String::new()\n    };\n\n    // Parse as TOML value\n    let mut doc: toml::Value =\n        toml::from_str(\u0026contents).unwrap_or_else(|_| toml::Value::Table(toml::map::Map::new()));\n\n    // Ensure sentry section exists\n    let table = doc\n        .as_table_mut()\n        .ok_or_else(|| anyhow::anyhow!(\"Config is not a table\"))?;\n\n    if !table.contains_key(\"sentry\") {\n        table.insert(\n            \"sentry\".to_string(),\n            toml::Value::Table(toml::map::Map::new()),\n        );\n    }\n\n    let sentry = table\n        .get_mut(\"sentry\")\n        .and_then(|v| v.as_table_mut())\n        .ok_or_else(|| anyhow::anyhow!(\"sentry section is not a table\"))?;\n\n    sentry.insert(\n        \"auth_token\".to_string(),\n        toml::Value::String(token.to_string()),\n    );\n    sentry.insert(\n        \"organization\".to_string(),\n        toml::Value::String(org.to_string()),\n    );\n\n    // Write back\n    let output = toml::to_string_pretty(\u0026doc)?;\n\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent)?;\n    }\n\n    fs::write(\u0026path, output)?;\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_sentry_config_is_configured_both_set() {\n        let config = SentryConfig {\n            auth_token: Some(\"token\".to_string()),\n            organization: Some(\"my-org\".to_string()),\n            project: None,\n        };\n        assert!(config.is_configured());\n    }\n\n    #[test]\n    fn test_sentry_config_is_configured_only_token() {\n        let config = SentryConfig {\n            auth_token: Some(\"token\".to_string()),\n            organization: None,\n            project: None,\n        };\n        assert!(!config.is_configured());\n    }\n\n    #[test]\n    fn test_sentry_config_is_configured_only_org() {\n        let config = SentryConfig {\n            auth_token: None,\n            organization: Some(\"my-org\".to_string()),\n            project: None,\n        };\n        assert!(!config.is_configured());\n    }\n\n    #[test]\n    fn test_sentry_config_is_configured_neither() {\n        let config = SentryConfig {\n            auth_token: None,\n            organization: None,\n            project: None,\n        };\n        assert!(!config.is_configured());\n    }\n\n    #[test]\n    fn test_sentry_config_default() {\n        let config = SentryConfig::default();\n        assert!(config.auth_token.is_none());\n        assert!(config.organization.is_none());\n        assert!(config.project.is_none());\n        assert!(!config.is_configured());\n    }\n\n    #[test]\n    fn test_config_path_returns_some() {\n        let path = config_path();\n        if let Some(p) = path {\n            assert!(p.to_string_lossy().contains(\"settings.toml\"));\n        }\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":6}},{"line":25,"address":[],"length":0,"stats":{"Line":16}},{"line":36,"address":[],"length":0,"stats":{"Line":2}},{"line":37,"address":[],"length":0,"stats":{"Line":8}},{"line":41,"address":[],"length":0,"stats":{"Line":1}},{"line":42,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":1}},{"line":47,"address":[],"length":0,"stats":{"Line":3}},{"line":48,"address":[],"length":0,"stats":{"Line":4}},{"line":49,"address":[],"length":0,"stats":{"Line":1}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":1}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":1}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":1}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}}],"covered":15,"coverable":46},{"path":["/","Users","chi","Projects","hu","src","sentry","display","mod.rs"],"content":"//! Sentry output formatting\n\nuse anyhow::{Context, Result};\nuse comfy_table::{presets::UTF8_FULL_CONDENSED, Cell, Color, ContentArrangement, Table};\n\nuse super::types::{Event, Issue, OutputFormat};\n\n#[cfg(test)]\nmod tests;\n\n/// Format relative time\nfn time_ago(timestamp: \u0026str) -\u003e String {\n    let Ok(dt) = chrono::DateTime::parse_from_rfc3339(timestamp) else {\n        return timestamp.to_string();\n    };\n\n    let now = chrono::Utc::now();\n    let duration = now.signed_duration_since(dt);\n\n    if duration.num_days() \u003e 0 {\n        format!(\"{}d ago\", duration.num_days())\n    } else if duration.num_hours() \u003e 0 {\n        format!(\"{}h ago\", duration.num_hours())\n    } else if duration.num_minutes() \u003e 0 {\n        format!(\"{}m ago\", duration.num_minutes())\n    } else {\n        \"just now\".to_string()\n    }\n}\n\n/// Truncate string\nfn truncate(s: \u0026str, max_len: usize) -\u003e String {\n    if s.len() \u003c= max_len {\n        s.to_string()\n    } else {\n        format!(\"{}...\", \u0026s[..max_len.saturating_sub(3)])\n    }\n}\n\n/// Color for issue level\nfn level_color(level: \u0026str) -\u003e Color {\n    match level {\n        \"error\" =\u003e Color::Red,\n        \"warning\" =\u003e Color::Yellow,\n        \"info\" =\u003e Color::Blue,\n        _ =\u003e Color::White,\n    }\n}\n\n/// Color for issue status\n#[allow(dead_code)]\nfn status_color(status: \u0026str) -\u003e Color {\n    match status {\n        \"resolved\" =\u003e Color::Green,\n        \"ignored\" =\u003e Color::DarkGrey,\n        _ =\u003e Color::White,\n    }\n}\n\n/// Output issues list\npub fn output_issues(issues: \u0026[Issue], format: OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            if issues.is_empty() {\n                println!(\"No issues found.\");\n                return Ok(());\n            }\n\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_content_arrangement(ContentArrangement::Dynamic);\n            table.set_header(vec![\"ID\", \"Level\", \"Title\", \"Events\", \"Users\", \"Last Seen\"]);\n\n            for issue in issues {\n                table.add_row(vec![\n                    Cell::new(\u0026issue.short_id).fg(Color::Cyan),\n                    Cell::new(\u0026issue.level).fg(level_color(\u0026issue.level)),\n                    Cell::new(truncate(\u0026issue.title, 50)),\n                    Cell::new(\u0026issue.count),\n                    Cell::new(issue.user_count.to_string()),\n                    Cell::new(time_ago(\u0026issue.last_seen)),\n                ]);\n            }\n\n            println!(\"{table}\");\n            println!(\"\\n{} issues\", issues.len());\n        }\n        OutputFormat::Json =\u003e {\n            let json =\n                serde_json::to_string_pretty(issues).context(\"Failed to serialize issues\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n\n/// Output single issue detail\npub fn output_issue_detail(issue: \u0026Issue, format: OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            println!(\"{}\", \"-\".repeat(60));\n            println!(\"{} - {}\", issue.short_id, issue.title);\n            println!(\"{}\", \"-\".repeat(60));\n            println!(\n                \"Project:    {} ({})\",\n                issue.project.name, issue.project.slug\n            );\n            println!(\"Level:      {}\", issue.level);\n            println!(\"Status:     {}\", issue.status);\n            println!(\"Platform:   {}\", issue.platform);\n            println!(\"Events:     {}\", issue.count);\n            println!(\"Users:      {}\", issue.user_count);\n            println!(\"First seen: {}\", time_ago(\u0026issue.first_seen));\n            println!(\"Last seen:  {}\", time_ago(\u0026issue.last_seen));\n\n            if !issue.culprit.is_empty() {\n                println!(\"\\nCulprit: {}\", issue.culprit);\n            }\n\n            if !issue.metadata.error_type.is_empty() || !issue.metadata.value.is_empty() {\n                println!(\"\\nError:\");\n                if !issue.metadata.error_type.is_empty() {\n                    println!(\"  Type: {}\", issue.metadata.error_type);\n                }\n                if !issue.metadata.value.is_empty() {\n                    println!(\"  Message: {}\", issue.metadata.value);\n                }\n                if !issue.metadata.filename.is_empty() {\n                    println!(\"  File: {}\", issue.metadata.filename);\n                }\n                if !issue.metadata.function.is_empty() {\n                    println!(\"  Function: {}\", issue.metadata.function);\n                }\n            }\n\n            println!(\"\\nLink: {}\", issue.permalink);\n        }\n        OutputFormat::Json =\u003e {\n            let json = serde_json::to_string_pretty(issue).context(\"Failed to serialize issue\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n\n/// Output events list\npub fn output_events(events: \u0026[Event], format: OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            if events.is_empty() {\n                println!(\"No events found.\");\n                return Ok(());\n            }\n\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_content_arrangement(ContentArrangement::Dynamic);\n            table.set_header(vec![\"Event ID\", \"Time\", \"User\", \"Message\"]);\n\n            for event in events {\n                let user = event\n                    .user\n                    .as_ref()\n                    .and_then(|u| u.email.as_ref().or(u.username.as_ref()).or(u.id.as_ref()))\n                    .map(|s| s.as_str())\n                    .unwrap_or(\"-\");\n\n                let message = if event.message.is_empty() {\n                    \u0026event.title\n                } else {\n                    \u0026event.message\n                };\n\n                let event_id_short = if event.id.len() \u003e 12 {\n                    \u0026event.id[..12]\n                } else {\n                    \u0026event.id\n                };\n                let date = event.date_created.as_deref().unwrap_or(\"-\");\n\n                table.add_row(vec![\n                    Cell::new(event_id_short).fg(Color::Cyan),\n                    Cell::new(time_ago(date)),\n                    Cell::new(truncate(user, 20)),\n                    Cell::new(truncate(message, 40)),\n                ]);\n            }\n\n            println!(\"{table}\");\n            println!(\"\\n{} events\", events.len());\n        }\n        OutputFormat::Json =\u003e {\n            let json =\n                serde_json::to_string_pretty(events).context(\"Failed to serialize events\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n\n/// Output config status\npub fn output_config_status(config: \u0026super::config::SentryConfig) {\n    println!(\"Sentry Configuration\");\n    println!(\"{}\", \"-\".repeat(40));\n    println!(\n        \"Auth token:   {}\",\n        if config.auth_token.is_some() {\n            \"Yes\"\n        } else {\n            \"No\"\n        }\n    );\n    println!(\n        \"Organization: {}\",\n        config.organization.as_deref().unwrap_or(\"Not set\")\n    );\n    println!(\n        \"Project:      {}\",\n        config.project.as_deref().unwrap_or(\"Not set\")\n    );\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":15}},{"line":13,"address":[],"length":0,"stats":{"Line":29}},{"line":14,"address":[],"length":0,"stats":{"Line":2}},{"line":17,"address":[],"length":0,"stats":{"Line":28}},{"line":18,"address":[],"length":0,"stats":{"Line":56}},{"line":20,"address":[],"length":0,"stats":{"Line":14}},{"line":21,"address":[],"length":0,"stats":{"Line":4}},{"line":22,"address":[],"length":0,"stats":{"Line":13}},{"line":23,"address":[],"length":0,"stats":{"Line":4}},{"line":24,"address":[],"length":0,"stats":{"Line":12}},{"line":25,"address":[],"length":0,"stats":{"Line":4}},{"line":27,"address":[],"length":0,"stats":{"Line":22}},{"line":32,"address":[],"length":0,"stats":{"Line":10}},{"line":33,"address":[],"length":0,"stats":{"Line":20}},{"line":34,"address":[],"length":0,"stats":{"Line":18}},{"line":36,"address":[],"length":0,"stats":{"Line":4}},{"line":41,"address":[],"length":0,"stats":{"Line":5}},{"line":42,"address":[],"length":0,"stats":{"Line":5}},{"line":43,"address":[],"length":0,"stats":{"Line":7}},{"line":44,"address":[],"length":0,"stats":{"Line":4}},{"line":45,"address":[],"length":0,"stats":{"Line":3}},{"line":46,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":3}},{"line":53,"address":[],"length":0,"stats":{"Line":3}},{"line":54,"address":[],"length":0,"stats":{"Line":4}},{"line":55,"address":[],"length":0,"stats":{"Line":3}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":61,"address":[],"length":0,"stats":{"Line":3}},{"line":62,"address":[],"length":0,"stats":{"Line":3}},{"line":64,"address":[],"length":0,"stats":{"Line":4}},{"line":65,"address":[],"length":0,"stats":{"Line":2}},{"line":66,"address":[],"length":0,"stats":{"Line":1}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":3}},{"line":71,"address":[],"length":0,"stats":{"Line":3}},{"line":72,"address":[],"length":0,"stats":{"Line":8}},{"line":74,"address":[],"length":0,"stats":{"Line":4}},{"line":75,"address":[],"length":0,"stats":{"Line":4}},{"line":76,"address":[],"length":0,"stats":{"Line":5}},{"line":77,"address":[],"length":0,"stats":{"Line":6}},{"line":78,"address":[],"length":0,"stats":{"Line":4}},{"line":79,"address":[],"length":0,"stats":{"Line":3}},{"line":80,"address":[],"length":0,"stats":{"Line":4}},{"line":81,"address":[],"length":0,"stats":{"Line":2}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":4}},{"line":89,"address":[],"length":0,"stats":{"Line":1}},{"line":90,"address":[],"length":0,"stats":{"Line":3}},{"line":91,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":2}},{"line":98,"address":[],"length":0,"stats":{"Line":4}},{"line":99,"address":[],"length":0,"stats":{"Line":4}},{"line":101,"address":[],"length":0,"stats":{"Line":12}},{"line":102,"address":[],"length":0,"stats":{"Line":6}},{"line":103,"address":[],"length":0,"stats":{"Line":12}},{"line":104,"address":[],"length":0,"stats":{"Line":3}},{"line":105,"address":[],"length":0,"stats":{"Line":3}},{"line":108,"address":[],"length":0,"stats":{"Line":6}},{"line":109,"address":[],"length":0,"stats":{"Line":6}},{"line":110,"address":[],"length":0,"stats":{"Line":6}},{"line":111,"address":[],"length":0,"stats":{"Line":6}},{"line":112,"address":[],"length":0,"stats":{"Line":6}},{"line":113,"address":[],"length":0,"stats":{"Line":12}},{"line":114,"address":[],"length":0,"stats":{"Line":12}},{"line":116,"address":[],"length":0,"stats":{"Line":5}},{"line":117,"address":[],"length":0,"stats":{"Line":2}},{"line":120,"address":[],"length":0,"stats":{"Line":4}},{"line":121,"address":[],"length":0,"stats":{"Line":4}},{"line":122,"address":[],"length":0,"stats":{"Line":4}},{"line":123,"address":[],"length":0,"stats":{"Line":2}},{"line":125,"address":[],"length":0,"stats":{"Line":3}},{"line":126,"address":[],"length":0,"stats":{"Line":1}},{"line":128,"address":[],"length":0,"stats":{"Line":3}},{"line":129,"address":[],"length":0,"stats":{"Line":1}},{"line":131,"address":[],"length":0,"stats":{"Line":4}},{"line":132,"address":[],"length":0,"stats":{"Line":2}},{"line":136,"address":[],"length":0,"stats":{"Line":6}},{"line":139,"address":[],"length":0,"stats":{"Line":4}},{"line":140,"address":[],"length":0,"stats":{"Line":2}},{"line":143,"address":[],"length":0,"stats":{"Line":4}},{"line":147,"address":[],"length":0,"stats":{"Line":4}},{"line":148,"address":[],"length":0,"stats":{"Line":4}},{"line":150,"address":[],"length":0,"stats":{"Line":6}},{"line":151,"address":[],"length":0,"stats":{"Line":2}},{"line":152,"address":[],"length":0,"stats":{"Line":1}},{"line":155,"address":[],"length":0,"stats":{"Line":4}},{"line":156,"address":[],"length":0,"stats":{"Line":6}},{"line":157,"address":[],"length":0,"stats":{"Line":6}},{"line":158,"address":[],"length":0,"stats":{"Line":12}},{"line":160,"address":[],"length":0,"stats":{"Line":8}},{"line":161,"address":[],"length":0,"stats":{"Line":6}},{"line":162,"address":[],"length":0,"stats":{"Line":3}},{"line":164,"address":[],"length":0,"stats":{"Line":27}},{"line":165,"address":[],"length":0,"stats":{"Line":9}},{"line":168,"address":[],"length":0,"stats":{"Line":9}},{"line":169,"address":[],"length":0,"stats":{"Line":1}},{"line":171,"address":[],"length":0,"stats":{"Line":2}},{"line":174,"address":[],"length":0,"stats":{"Line":6}},{"line":175,"address":[],"length":0,"stats":{"Line":1}},{"line":177,"address":[],"length":0,"stats":{"Line":2}},{"line":179,"address":[],"length":0,"stats":{"Line":15}},{"line":181,"address":[],"length":0,"stats":{"Line":9}},{"line":182,"address":[],"length":0,"stats":{"Line":12}},{"line":183,"address":[],"length":0,"stats":{"Line":9}},{"line":184,"address":[],"length":0,"stats":{"Line":9}},{"line":185,"address":[],"length":0,"stats":{"Line":9}},{"line":189,"address":[],"length":0,"stats":{"Line":4}},{"line":190,"address":[],"length":0,"stats":{"Line":8}},{"line":193,"address":[],"length":0,"stats":{"Line":1}},{"line":194,"address":[],"length":0,"stats":{"Line":3}},{"line":195,"address":[],"length":0,"stats":{"Line":2}},{"line":198,"address":[],"length":0,"stats":{"Line":3}},{"line":202,"address":[],"length":0,"stats":{"Line":2}},{"line":203,"address":[],"length":0,"stats":{"Line":4}},{"line":204,"address":[],"length":0,"stats":{"Line":8}},{"line":205,"address":[],"length":0,"stats":{"Line":2}},{"line":206,"address":[],"length":0,"stats":{"Line":2}},{"line":207,"address":[],"length":0,"stats":{"Line":4}},{"line":208,"address":[],"length":0,"stats":{"Line":1}},{"line":210,"address":[],"length":0,"stats":{"Line":1}},{"line":213,"address":[],"length":0,"stats":{"Line":2}},{"line":214,"address":[],"length":0,"stats":{"Line":2}},{"line":215,"address":[],"length":0,"stats":{"Line":8}},{"line":217,"address":[],"length":0,"stats":{"Line":2}},{"line":218,"address":[],"length":0,"stats":{"Line":2}},{"line":219,"address":[],"length":0,"stats":{"Line":8}}],"covered":126,"coverable":126},{"path":["/","Users","chi","Projects","hu","src","sentry","display","tests.rs"],"content":"use super::*;\nuse crate::sentry::types::{EventUser, IssueMetadata, ProjectInfo};\n\n#[test]\nfn test_time_ago_days() {\n    let now = chrono::Utc::now();\n    let two_days_ago = now - chrono::Duration::days(2);\n    let ts = two_days_ago.to_rfc3339();\n    assert_eq!(time_ago(\u0026ts), \"2d ago\");\n}\n\n#[test]\nfn test_time_ago_hours() {\n    let now = chrono::Utc::now();\n    let two_hours_ago = now - chrono::Duration::hours(2);\n    let ts = two_hours_ago.to_rfc3339();\n    assert_eq!(time_ago(\u0026ts), \"2h ago\");\n}\n\n#[test]\nfn test_time_ago_minutes() {\n    let now = chrono::Utc::now();\n    let five_mins_ago = now - chrono::Duration::minutes(5);\n    let ts = five_mins_ago.to_rfc3339();\n    assert_eq!(time_ago(\u0026ts), \"5m ago\");\n}\n\n#[test]\nfn test_time_ago_just_now() {\n    let now = chrono::Utc::now();\n    let ts = now.to_rfc3339();\n    assert_eq!(time_ago(\u0026ts), \"just now\");\n}\n\n#[test]\nfn test_time_ago_invalid() {\n    assert_eq!(time_ago(\"invalid\"), \"invalid\");\n}\n\n#[test]\nfn test_truncate_short() {\n    assert_eq!(truncate(\"hello\", 10), \"hello\");\n}\n\n#[test]\nfn test_truncate_exact() {\n    assert_eq!(truncate(\"hello\", 5), \"hello\");\n}\n\n#[test]\nfn test_truncate_long() {\n    assert_eq!(truncate(\"hello world\", 8), \"hello...\");\n}\n\n#[test]\nfn test_level_color() {\n    assert_eq!(level_color(\"error\"), Color::Red);\n    assert_eq!(level_color(\"warning\"), Color::Yellow);\n    assert_eq!(level_color(\"info\"), Color::Blue);\n    assert_eq!(level_color(\"debug\"), Color::White);\n}\n\n#[test]\nfn test_status_color() {\n    assert_eq!(status_color(\"resolved\"), Color::Green);\n    assert_eq!(status_color(\"ignored\"), Color::DarkGrey);\n    assert_eq!(status_color(\"unresolved\"), Color::White);\n}\n\nfn make_test_issue() -\u003e Issue {\n    Issue {\n        id: \"12345\".to_string(),\n        short_id: \"PROJ-123\".to_string(),\n        title: \"Test error\".to_string(),\n        culprit: \"src/main.rs\".to_string(),\n        level: \"error\".to_string(),\n        status: \"unresolved\".to_string(),\n        platform: \"rust\".to_string(),\n        count: \"42\".to_string(),\n        user_count: 10,\n        first_seen: chrono::Utc::now().to_rfc3339(),\n        last_seen: chrono::Utc::now().to_rfc3339(),\n        permalink: \"https://sentry.io/issue/123\".to_string(),\n        is_subscribed: false,\n        is_bookmarked: false,\n        project: ProjectInfo {\n            id: \"1\".to_string(),\n            name: \"Test Project\".to_string(),\n            slug: \"test-project\".to_string(),\n        },\n        metadata: IssueMetadata {\n            error_type: \"RuntimeError\".to_string(),\n            value: \"Something went wrong\".to_string(),\n            filename: \"main.rs\".to_string(),\n            function: \"main\".to_string(),\n        },\n    }\n}\n\n#[test]\nfn test_output_issues_empty() {\n    let issues: Vec\u003cIssue\u003e = vec![];\n    let result = output_issues(\u0026issues, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_issues_table() {\n    let issues = vec![make_test_issue()];\n    let result = output_issues(\u0026issues, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_issues_json() {\n    let issues = vec![make_test_issue()];\n    let result = output_issues(\u0026issues, OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_issue_detail_table() {\n    let issue = make_test_issue();\n    let result = output_issue_detail(\u0026issue, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_issue_detail_json() {\n    let issue = make_test_issue();\n    let result = output_issue_detail(\u0026issue, OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_events_empty() {\n    let events: Vec\u003cEvent\u003e = vec![];\n    let result = output_events(\u0026events, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_events_table() {\n    let events = vec![Event {\n        id: \"abcdef123456\".to_string(),\n        title: \"Test event\".to_string(),\n        message: \"Error message\".to_string(),\n        platform: \"rust\".to_string(),\n        date_created: Some(chrono::Utc::now().to_rfc3339()),\n        user: Some(EventUser {\n            id: Some(\"user123\".to_string()),\n            email: Some(\"test@example.com\".to_string()),\n            username: None,\n            ip_address: None,\n        }),\n        tags: vec![],\n    }];\n    let result = output_events(\u0026events, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_events_json() {\n    let events = vec![Event {\n        id: \"abcdef123456\".to_string(),\n        title: \"Test event\".to_string(),\n        message: \"\".to_string(),\n        platform: \"\".to_string(),\n        date_created: None,\n        user: None,\n        tags: vec![],\n    }];\n    let result = output_events(\u0026events, OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_issue_detail_empty_metadata() {\n    // Test with empty culprit and empty metadata fields\n    let issue = Issue {\n        id: \"12345\".to_string(),\n        short_id: \"PROJ-456\".to_string(),\n        title: \"Test error\".to_string(),\n        culprit: \"\".to_string(), // empty culprit\n        level: \"warning\".to_string(),\n        status: \"resolved\".to_string(),\n        platform: \"python\".to_string(),\n        count: \"1\".to_string(),\n        user_count: 1,\n        first_seen: chrono::Utc::now().to_rfc3339(),\n        last_seen: chrono::Utc::now().to_rfc3339(),\n        permalink: \"https://sentry.io/issue/456\".to_string(),\n        is_subscribed: false,\n        is_bookmarked: false,\n        project: ProjectInfo {\n            id: \"2\".to_string(),\n            name: \"Other Project\".to_string(),\n            slug: \"other-project\".to_string(),\n        },\n        metadata: IssueMetadata {\n            error_type: \"\".to_string(), // empty\n            value: \"\".to_string(),      // empty\n            filename: \"\".to_string(),   // empty\n            function: \"\".to_string(),   // empty\n        },\n    };\n    let result = output_issue_detail(\u0026issue, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_issue_detail_partial_metadata() {\n    // Test with only some metadata fields populated\n    let issue = Issue {\n        id: \"12345\".to_string(),\n        short_id: \"PROJ-789\".to_string(),\n        title: \"Partial metadata\".to_string(),\n        culprit: \"some/path.py\".to_string(),\n        level: \"error\".to_string(),\n        status: \"unresolved\".to_string(),\n        platform: \"python\".to_string(),\n        count: \"5\".to_string(),\n        user_count: 3,\n        first_seen: chrono::Utc::now().to_rfc3339(),\n        last_seen: chrono::Utc::now().to_rfc3339(),\n        permalink: \"https://sentry.io/issue/789\".to_string(),\n        is_subscribed: false,\n        is_bookmarked: false,\n        project: ProjectInfo {\n            id: \"3\".to_string(),\n            name: \"Third Project\".to_string(),\n            slug: \"third-project\".to_string(),\n        },\n        metadata: IssueMetadata {\n            error_type: \"ValueError\".to_string(),\n            value: \"\".to_string(), // empty value\n            filename: \"\".to_string(),\n            function: \"process_data\".to_string(),\n        },\n    };\n    let result = output_issue_detail(\u0026issue, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_events_user_variants() {\n    // Test event with username instead of email\n    let events = vec![\n        Event {\n            id: \"event1234567890\".to_string(),\n            title: \"Event with username\".to_string(),\n            message: \"Has message\".to_string(),\n            platform: \"rust\".to_string(),\n            date_created: Some(chrono::Utc::now().to_rfc3339()),\n            user: Some(EventUser {\n                id: None,\n                email: None,\n                username: Some(\"testuser\".to_string()),\n                ip_address: None,\n            }),\n            tags: vec![],\n        },\n        Event {\n            id: \"event2\".to_string(), // short ID\n            title: \"Event with only id\".to_string(),\n            message: \"\".to_string(), // empty message - should use title\n            platform: \"rust\".to_string(),\n            date_created: Some(chrono::Utc::now().to_rfc3339()),\n            user: Some(EventUser {\n                id: Some(\"user-id-only\".to_string()),\n                email: None,\n                username: None,\n                ip_address: None,\n            }),\n            tags: vec![],\n        },\n    ];\n    let result = output_events(\u0026events, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_config_status() {\n    use crate::sentry::config::SentryConfig;\n\n    // Test with all fields set\n    let config = SentryConfig {\n        auth_token: Some(\"test-token\".to_string()),\n        organization: Some(\"my-org\".to_string()),\n        project: Some(\"my-project\".to_string()),\n    };\n    output_config_status(\u0026config);\n\n    // Test with no fields set\n    let empty_config = SentryConfig {\n        auth_token: None,\n        organization: None,\n        project: None,\n    };\n    output_config_status(\u0026empty_config);\n}\n","traces":[{"line":70,"address":[],"length":0,"stats":{"Line":4}},{"line":72,"address":[],"length":0,"stats":{"Line":12}},{"line":73,"address":[],"length":0,"stats":{"Line":12}},{"line":74,"address":[],"length":0,"stats":{"Line":12}},{"line":75,"address":[],"length":0,"stats":{"Line":12}},{"line":76,"address":[],"length":0,"stats":{"Line":12}},{"line":77,"address":[],"length":0,"stats":{"Line":12}},{"line":78,"address":[],"length":0,"stats":{"Line":12}},{"line":79,"address":[],"length":0,"stats":{"Line":12}},{"line":81,"address":[],"length":0,"stats":{"Line":12}},{"line":82,"address":[],"length":0,"stats":{"Line":12}},{"line":83,"address":[],"length":0,"stats":{"Line":12}},{"line":86,"address":[],"length":0,"stats":{"Line":8}},{"line":91,"address":[],"length":0,"stats":{"Line":4}}],"covered":14,"coverable":14},{"path":["/","Users","chi","Projects","hu","src","sentry","mod.rs"],"content":"//! Sentry integration\n//!\n//! List and view issues from Sentry.\n//!\n//! # CLI Usage\n//! Use [`run`] for CLI commands that format and print output.\n//!\n//! # Programmatic Usage (MCP/HTTP)\n//! Use the reusable functions that return typed data:\n//! - [`get_config`] - Get configuration status\n//! - [`list_issues`] - List issues with filters\n//! - [`get_issue`] - Get issue details\n//! - [`list_events`] - List events for an issue\n\nmod client;\nmod config;\nmod display;\nmod service;\npub mod types;\n\nuse anyhow::Result;\nuse clap::Subcommand;\n\nuse client::SentryClient;\npub use config::SentryConfig;\npub use service::{EventOptions, IssueOptions};\nuse types::OutputFormat;\npub use types::{Event, Issue};\n\n/// Sentry subcommands\n#[derive(Debug, Subcommand)]\npub enum SentryCommand {\n    /// Show configuration status\n    Config,\n\n    /// List issues\n    Issues {\n        /// Filter by project\n        #[arg(short, long)]\n        project: Option\u003cString\u003e,\n\n        /// Search query (Sentry search syntax)\n        #[arg(short, long)]\n        query: Option\u003cString\u003e,\n\n        /// Maximum number of issues to return\n        #[arg(short, long, default_value = \"25\")]\n        limit: usize,\n\n        /// Output as JSON\n        #[arg(long)]\n        json: bool,\n    },\n\n    /// Show issue details\n    Show {\n        /// Issue ID or short ID\n        issue: String,\n\n        /// Output as JSON\n        #[arg(long)]\n        json: bool,\n    },\n\n    /// List events for an issue\n    Events {\n        /// Issue ID or short ID\n        issue: String,\n\n        /// Maximum number of events to return\n        #[arg(short, long, default_value = \"25\")]\n        limit: usize,\n\n        /// Output as JSON\n        #[arg(long)]\n        json: bool,\n    },\n\n    /// Set auth token\n    Auth {\n        /// Auth token\n        token: String,\n\n        /// Organization slug\n        #[arg(short, long)]\n        org: String,\n    },\n}\n\n/// Run a Sentry command (CLI entry point - formats and prints)\n#[cfg(not(tarpaulin_include))]\npub async fn run(cmd: SentryCommand) -\u003e Result\u003c()\u003e {\n    match cmd {\n        SentryCommand::Config =\u003e cmd_config(),\n        SentryCommand::Issues {\n            project,\n            query,\n            limit,\n            json,\n        } =\u003e cmd_issues(project, query, limit, json).await,\n        SentryCommand::Show { issue, json } =\u003e cmd_show(\u0026issue, json).await,\n        SentryCommand::Events { issue, limit, json } =\u003e cmd_events(\u0026issue, limit, json).await,\n        SentryCommand::Auth { token, org } =\u003e cmd_auth(\u0026token, \u0026org),\n    }\n}\n\n// ============================================================================\n// Reusable functions for MCP/HTTP - return typed data, never print\n// ============================================================================\n\n/// Get Sentry configuration status (for MCP/HTTP)\n#[allow(dead_code)]\npub fn get_config() -\u003e Result\u003cSentryConfig\u003e {\n    service::get_config()\n}\n\n/// List issues with filters (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn list_issues(opts: \u0026IssueOptions) -\u003e Result\u003cVec\u003cIssue\u003e\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n    let client = SentryClient::new()?;\n    service::list_issues(\u0026client, opts).await\n}\n\n/// Get issue details by ID (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn get_issue(issue_id: \u0026str) -\u003e Result\u003cIssue\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n    let client = SentryClient::new()?;\n    service::get_issue(\u0026client, issue_id).await\n}\n\n/// List events for an issue (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn list_events(opts: \u0026EventOptions) -\u003e Result\u003cVec\u003cEvent\u003e\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n    let client = SentryClient::new()?;\n    service::list_events(\u0026client, opts).await\n}\n\n// ============================================================================\n// CLI command handlers - create client, call service, format and print\n// ============================================================================\n\n/// Show config status\nfn cmd_config() -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    display::output_config_status(\u0026config);\n    Ok(())\n}\n\n/// Set auth token\nfn cmd_auth(token: \u0026str, org: \u0026str) -\u003e Result\u003c()\u003e {\n    service::save_auth(token, org)?;\n    println!(\"Sentry auth token saved for organization: {}\", org);\n    Ok(())\n}\n\n/// List issues\nasync fn cmd_issues(\n    project: Option\u003cString\u003e,\n    query: Option\u003cString\u003e,\n    limit: usize,\n    json: bool,\n) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n\n    let client = SentryClient::new()?;\n    let opts = IssueOptions {\n        project,\n        query,\n        limit,\n    };\n    let issues = service::list_issues(\u0026client, \u0026opts).await?;\n\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n\n    display::output_issues(\u0026issues, format)?;\n    Ok(())\n}\n\n/// Show issue details\nasync fn cmd_show(issue_id: \u0026str, json: bool) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n\n    let client = SentryClient::new()?;\n    let issue = service::get_issue(\u0026client, issue_id).await?;\n\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n\n    display::output_issue_detail(\u0026issue, format)?;\n    Ok(())\n}\n\n/// List events for an issue\nasync fn cmd_events(issue_id: \u0026str, limit: usize, json: bool) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n\n    let client = SentryClient::new()?;\n    let opts = EventOptions {\n        issue_id: issue_id.to_string(),\n        limit,\n    };\n    let events = service::list_events(\u0026client, \u0026opts).await?;\n\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n\n    display::output_events(\u0026events, format)?;\n    Ok(())\n}\n","traces":[{"line":77,"address":[],"length":0,"stats":{"Line":2}},{"line":78,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":1}},{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":1}},{"line":84,"address":[],"length":0,"stats":{"Line":1}},{"line":85,"address":[],"length":0,"stats":{"Line":7}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":1}},{"line":94,"address":[],"length":0,"stats":{"Line":1}},{"line":95,"address":[],"length":0,"stats":{"Line":1}},{"line":96,"address":[],"length":0,"stats":{"Line":1}},{"line":97,"address":[],"length":0,"stats":{"Line":1}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":1}},{"line":124,"address":[],"length":0,"stats":{"Line":2}},{"line":125,"address":[],"length":0,"stats":{"Line":3}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}}],"covered":15,"coverable":54},{"path":["/","Users","chi","Projects","hu","src","sentry","types.rs"],"content":"//! Sentry data types\n\nuse serde::{Deserialize, Serialize};\n\n/// Sentry issue\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Issue {\n    /// Issue ID\n    pub id: String,\n    /// Short ID (e.g., \"PROJECT-123\")\n    pub short_id: String,\n    /// Issue title\n    pub title: String,\n    /// Culprit (location in code)\n    #[serde(default)]\n    pub culprit: String,\n    /// Issue level (error, warning, info)\n    pub level: String,\n    /// Issue status (unresolved, resolved, ignored)\n    pub status: String,\n    /// Platform (python, javascript, etc.)\n    #[serde(default)]\n    pub platform: String,\n    /// Project info\n    pub project: ProjectInfo,\n    /// Number of events\n    pub count: String,\n    /// Number of affected users\n    pub user_count: u32,\n    /// First seen timestamp\n    pub first_seen: String,\n    /// Last seen timestamp\n    pub last_seen: String,\n    /// Permalink to Sentry UI\n    pub permalink: String,\n    /// Is subscribed\n    #[serde(default)]\n    pub is_subscribed: bool,\n    /// Is bookmarked\n    #[serde(default)]\n    pub is_bookmarked: bool,\n    /// Metadata\n    #[serde(default)]\n    pub metadata: IssueMetadata,\n}\n\n/// Project info embedded in issue\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ProjectInfo {\n    /// Project ID\n    pub id: String,\n    /// Project name\n    pub name: String,\n    /// Project slug\n    pub slug: String,\n}\n\n/// Issue metadata\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct IssueMetadata {\n    /// Error type\n    #[serde(rename = \"type\", default)]\n    pub error_type: String,\n    /// Error value/message\n    #[serde(default)]\n    pub value: String,\n    /// Filename\n    #[serde(default)]\n    pub filename: String,\n    /// Function name\n    #[serde(default)]\n    pub function: String,\n}\n\n/// Sentry event\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Event {\n    /// Event ID\n    #[serde(rename = \"eventID\")]\n    pub id: String,\n    /// Event title\n    #[serde(default)]\n    pub title: String,\n    /// Event message\n    #[serde(default)]\n    pub message: String,\n    /// Platform\n    #[serde(default)]\n    pub platform: String,\n    /// Timestamp\n    #[serde(rename = \"dateCreated\")]\n    pub date_created: Option\u003cString\u003e,\n    /// User info\n    pub user: Option\u003cEventUser\u003e,\n    /// Tags\n    #[serde(default)]\n    pub tags: Vec\u003cEventTag\u003e,\n}\n\n/// User info in event\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct EventUser {\n    /// User ID\n    pub id: Option\u003cString\u003e,\n    /// Email\n    pub email: Option\u003cString\u003e,\n    /// Username\n    pub username: Option\u003cString\u003e,\n    /// IP address\n    pub ip_address: Option\u003cString\u003e,\n}\n\n/// Event tag\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct EventTag {\n    /// Tag key\n    pub key: String,\n    /// Tag value\n    pub value: String,\n}\n\n/// Output format\n#[derive(Debug, Clone, Copy, Default)]\npub enum OutputFormat {\n    #[default]\n    Table,\n    Json,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_issue_debug() {\n        let issue = Issue {\n            id: \"12345\".to_string(),\n            short_id: \"PROJ-123\".to_string(),\n            title: \"Test error\".to_string(),\n            culprit: \"src/main.rs\".to_string(),\n            level: \"error\".to_string(),\n            status: \"unresolved\".to_string(),\n            platform: \"rust\".to_string(),\n            count: \"42\".to_string(),\n            user_count: 10,\n            first_seen: \"2024-01-01T00:00:00Z\".to_string(),\n            last_seen: \"2024-01-02T00:00:00Z\".to_string(),\n            permalink: \"https://sentry.io/issue/123\".to_string(),\n            is_subscribed: false,\n            is_bookmarked: true,\n            project: ProjectInfo {\n                id: \"1\".to_string(),\n                name: \"Test Project\".to_string(),\n                slug: \"test-project\".to_string(),\n            },\n            metadata: IssueMetadata::default(),\n        };\n        let debug = format!(\"{:?}\", issue);\n        assert!(debug.contains(\"Issue\"));\n        assert!(debug.contains(\"PROJ-123\"));\n    }\n\n    #[test]\n    fn test_issue_clone() {\n        let issue = Issue {\n            id: \"12345\".to_string(),\n            short_id: \"PROJ-123\".to_string(),\n            title: \"Test\".to_string(),\n            culprit: \"\".to_string(),\n            level: \"error\".to_string(),\n            status: \"unresolved\".to_string(),\n            platform: \"\".to_string(),\n            count: \"1\".to_string(),\n            user_count: 1,\n            first_seen: \"\".to_string(),\n            last_seen: \"\".to_string(),\n            permalink: \"\".to_string(),\n            is_subscribed: false,\n            is_bookmarked: false,\n            project: ProjectInfo {\n                id: \"1\".to_string(),\n                name: \"Test\".to_string(),\n                slug: \"test\".to_string(),\n            },\n            metadata: IssueMetadata::default(),\n        };\n        let cloned = issue.clone();\n        assert_eq!(cloned.id, issue.id);\n        assert_eq!(cloned.short_id, issue.short_id);\n    }\n\n    #[test]\n    fn test_project_info_debug() {\n        let project = ProjectInfo {\n            id: \"1\".to_string(),\n            name: \"My Project\".to_string(),\n            slug: \"my-project\".to_string(),\n        };\n        let debug = format!(\"{:?}\", project);\n        assert!(debug.contains(\"ProjectInfo\"));\n    }\n\n    #[test]\n    fn test_issue_metadata_default() {\n        let metadata = IssueMetadata::default();\n        assert!(metadata.error_type.is_empty());\n        assert!(metadata.value.is_empty());\n        assert!(metadata.filename.is_empty());\n        assert!(metadata.function.is_empty());\n    }\n\n    #[test]\n    fn test_issue_metadata_debug() {\n        let metadata = IssueMetadata {\n            error_type: \"RuntimeError\".to_string(),\n            value: \"Error message\".to_string(),\n            filename: \"main.rs\".to_string(),\n            function: \"main\".to_string(),\n        };\n        let debug = format!(\"{:?}\", metadata);\n        assert!(debug.contains(\"IssueMetadata\"));\n    }\n\n    #[test]\n    fn test_event_debug() {\n        let event = Event {\n            id: \"event123\".to_string(),\n            title: \"Error event\".to_string(),\n            message: \"Something went wrong\".to_string(),\n            platform: \"rust\".to_string(),\n            date_created: Some(\"2024-01-01T00:00:00Z\".to_string()),\n            user: None,\n            tags: vec![],\n        };\n        let debug = format!(\"{:?}\", event);\n        assert!(debug.contains(\"Event\"));\n    }\n\n    #[test]\n    fn test_event_clone() {\n        let event = Event {\n            id: \"event123\".to_string(),\n            title: \"Test\".to_string(),\n            message: \"\".to_string(),\n            platform: \"\".to_string(),\n            date_created: None,\n            user: Some(EventUser {\n                id: Some(\"user1\".to_string()),\n                email: None,\n                username: None,\n                ip_address: None,\n            }),\n            tags: vec![EventTag {\n                key: \"env\".to_string(),\n                value: \"prod\".to_string(),\n            }],\n        };\n        let cloned = event.clone();\n        assert_eq!(cloned.id, event.id);\n        assert!(cloned.user.is_some());\n    }\n\n    #[test]\n    fn test_event_user_debug() {\n        let user = EventUser {\n            id: Some(\"user123\".to_string()),\n            email: Some(\"test@example.com\".to_string()),\n            username: Some(\"testuser\".to_string()),\n            ip_address: Some(\"192.168.1.1\".to_string()),\n        };\n        let debug = format!(\"{:?}\", user);\n        assert!(debug.contains(\"EventUser\"));\n    }\n\n    #[test]\n    fn test_event_tag_debug() {\n        let tag = EventTag {\n            key: \"environment\".to_string(),\n            value: \"production\".to_string(),\n        };\n        let debug = format!(\"{:?}\", tag);\n        assert!(debug.contains(\"EventTag\"));\n    }\n\n    #[test]\n    fn test_output_format_default() {\n        let format = OutputFormat::default();\n        assert!(matches!(format, OutputFormat::Table));\n    }\n\n    #[test]\n    fn test_output_format_clone() {\n        let format = OutputFormat::Json;\n        let cloned = format.clone();\n        assert!(matches!(cloned, OutputFormat::Json));\n    }\n\n    #[test]\n    fn test_output_format_debug() {\n        let format = OutputFormat::Table;\n        let debug = format!(\"{:?}\", format);\n        assert_eq!(debug, \"Table\");\n    }\n\n    #[test]\n    fn test_issue_serde_default_fields() {\n        // Test that serde default works for optional fields\n        let json = r#\"{\n            \"id\": \"1\",\n            \"shortId\": \"PROJ-1\",\n            \"title\": \"Test\",\n            \"level\": \"error\",\n            \"status\": \"unresolved\",\n            \"count\": \"1\",\n            \"userCount\": 1,\n            \"firstSeen\": \"2024-01-01T00:00:00Z\",\n            \"lastSeen\": \"2024-01-01T00:00:00Z\",\n            \"permalink\": \"http://example.com\",\n            \"project\": {\"id\": \"1\", \"name\": \"Test\", \"slug\": \"test\"}\n        }\"#;\n        let issue: Issue = serde_json::from_str(json).unwrap();\n        assert!(issue.culprit.is_empty());\n        assert!(issue.platform.is_empty());\n        assert!(!issue.is_subscribed);\n        assert!(!issue.is_bookmarked);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","slack","auth","mod.rs"],"content":"//! OAuth 2.0 authentication flow for Slack\n//!\n//! Implements the browser-based OAuth flow to obtain bot tokens.\n\nuse anyhow::Result;\nuse std::time::Duration;\nuse tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader};\nuse tokio::net::TcpListener;\n\nuse super::config::{load_config, update_oauth_tokens};\n\n#[cfg(test)]\nmod tests;\n\nconst SLACK_AUTH_URL: \u0026str = \"https://slack.com/oauth/v2/authorize\";\nconst SLACK_TOKEN_URL: \u0026str = \"https://slack.com/api/oauth.v2.access\";\n\n/// OAuth scopes needed for Slack bot access\nconst OAUTH_SCOPES: \u0026str =\n    \"channels:read,channels:history,chat:write,search:read,users:read,groups:read\";\n\n/// Result of the OAuth flow\npub struct OAuthResult {\n    /// Whether authentication succeeded\n    pub success: bool,\n    /// Error message if failed\n    pub error: Option\u003cString\u003e,\n    /// Slack workspace name if successful\n    pub team_name: Option\u003cString\u003e,\n}\n\nimpl OAuthResult {\n    const fn success(team_name: String) -\u003e Self {\n        Self {\n            success: true,\n            error: None,\n            team_name: Some(team_name),\n        }\n    }\n\n    const fn failure(error: String) -\u003e Self {\n        Self {\n            success: false,\n            error: Some(error),\n            team_name: None,\n        }\n    }\n}\n\n/// Token response from Slack OAuth\n#[derive(serde::Deserialize)]\nstruct TokenResponse {\n    ok: bool,\n    access_token: Option\u003cString\u003e,\n    team: Option\u003cTeamInfo\u003e,\n    error: Option\u003cString\u003e,\n}\n\n/// Team info from OAuth response\n#[derive(serde::Deserialize)]\nstruct TeamInfo {\n    id: String,\n    name: String,\n}\n\n/// Generate a random state parameter for OAuth\nfn generate_state() -\u003e String {\n    use rand::Rng;\n\n    let mut rng = rand::thread_rng();\n    let bytes: [u8; 16] = rng.gen();\n    hex::encode(bytes)\n}\n\n/// Build the OAuth authorization URL\nfn build_authorization_url(client_id: \u0026str, redirect_uri: \u0026str, state: \u0026str) -\u003e String {\n    let params = [\n        (\"client_id\", client_id),\n        (\"scope\", OAUTH_SCOPES),\n        (\"redirect_uri\", redirect_uri),\n        (\"state\", state),\n    ];\n\n    let query = params\n        .iter()\n        .map(|(k, v)| format!(\"{}={}\", k, urlencoding::encode(v)))\n        .collect::\u003cVec\u003c_\u003e\u003e()\n        .join(\"\u0026\");\n\n    format!(\"{}?{}\", SLACK_AUTH_URL, query)\n}\n\n/// Exchange authorization code for tokens\nasync fn exchange_code_for_tokens(\n    client: \u0026reqwest::Client,\n    code: \u0026str,\n    redirect_uri: \u0026str,\n    client_id: \u0026str,\n    client_secret: \u0026str,\n) -\u003e Result\u003cTokenResponse\u003e {\n    let response = client\n        .post(SLACK_TOKEN_URL)\n        .form(\u0026[\n            (\"client_id\", client_id),\n            (\"client_secret\", client_secret),\n            (\"code\", code),\n            (\"redirect_uri\", redirect_uri),\n        ])\n        .send()\n        .await?;\n\n    if !response.status().is_success() {\n        let status = response.status().as_u16();\n        let body = response.text().await.unwrap_or_default();\n        return Err(anyhow::anyhow!(\"Token exchange failed ({status}): {body}\"));\n    }\n\n    let token_resp: TokenResponse = response.json().await?;\n\n    if !token_resp.ok {\n        let error = token_resp\n            .error\n            .unwrap_or_else(|| \"Unknown error\".to_string());\n        return Err(anyhow::anyhow!(format!(\"Token exchange failed: {}\", error)));\n    }\n\n    Ok(token_resp)\n}\n\n/// Parse the OAuth callback request to extract code and state\nfn parse_callback_request(request: \u0026str) -\u003e Option\u003c(String, String)\u003e {\n    let path = request.split_whitespace().nth(1)?;\n    let query = path.split('?').nth(1)?;\n\n    let mut code = None;\n    let mut state = None;\n\n    for param in query.split('\u0026') {\n        let mut parts = param.splitn(2, '=');\n        let key = parts.next()?;\n        let value = parts.next().unwrap_or(\"\");\n\n        match key {\n            \"code\" =\u003e code = Some(urlencoding::decode(value).ok()?.into_owned()),\n            \"state\" =\u003e state = Some(urlencoding::decode(value).ok()?.into_owned()),\n            _ =\u003e {}\n        }\n    }\n\n    Some((code?, state?))\n}\n\n/// Send HTTP response to browser\nasync fn send_response(\n    stream: \u0026mut tokio::net::TcpStream,\n    status: \u0026str,\n    title: \u0026str,\n    message: \u0026str,\n) -\u003e std::io::Result\u003c()\u003e {\n    let body = format!(\n        r#\"\u003c!DOCTYPE html\u003e\n\u003chtml\u003e\n\u003chead\u003e\u003ctitle\u003e{}\u003c/title\u003e\u003c/head\u003e\n\u003cbody style=\"font-family: sans-serif; padding: 40px; text-align: center;\"\u003e\n\u003ch1\u003e{}\u003c/h1\u003e\n\u003cp\u003e{}\u003c/p\u003e\n\u003cp\u003eYou can close this window.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\"#,\n        title, title, message\n    );\n\n    let response = format!(\n        \"HTTP/1.1 {}\\r\\nContent-Type: text/html\\r\\nContent-Length: {}\\r\\nConnection: close\\r\\n\\r\\n{}\",\n        status,\n        body.len(),\n        body\n    );\n\n    stream.write_all(response.as_bytes()).await\n}\n\n/// Run the OAuth authorization flow\n///\n/// Starts a local server, opens the browser, and waits for the callback.\npub async fn run_oauth_flow(port: u16) -\u003e Result\u003cOAuthResult\u003e {\n    let config = load_config()?;\n\n    let client_id = config.oauth.client_id.as_ref().ok_or_else(|| {\n        anyhow::anyhow!(\n            \"client_id not configured. Set slack.oauth.client_id in ~/.config/hu/settings.toml\"\n        )\n    })?;\n\n    let client_secret = config.oauth.client_secret.as_ref().ok_or_else(|| {\n        anyhow::anyhow!(\n            \"client_secret not configured. Set slack.oauth.client_secret in ~/.config/hu/settings.toml\"\n        )\n    })?;\n\n    let redirect_uri = format!(\"http://localhost:{}/callback\", port);\n    let state = generate_state();\n    let auth_url = build_authorization_url(client_id, \u0026redirect_uri, \u0026state);\n\n    // Start local server\n    let listener = TcpListener::bind(format!(\"127.0.0.1:{}\", port))\n        .await\n        .map_err(|e| {\n            anyhow::anyhow!(format!(\n                \"Failed to start local server on port {}: {}\",\n                port, e\n            ))\n        })?;\n\n    println!(\"\\nOpen this URL in your browser to authorize:\\n\");\n    println!(\"{}\\n\", auth_url);\n    println!(\"Waiting for authorization...\");\n\n    // Try to open browser\n    if let Err(_e) = open::that(\u0026auth_url) {\n        // debug!(\"Failed to open browser: {}\", _e);\n    }\n\n    // Wait for callback with timeout\n    let ctx = CallbackContext {\n        listener: \u0026listener,\n        expected_state: \u0026state,\n        redirect_uri: \u0026redirect_uri,\n        client_id,\n        client_secret,\n    };\n\n    tokio::time::timeout(Duration::from_secs(300), handle_callback(ctx))\n        .await\n        .unwrap_or_else(|_| {\n            Ok(OAuthResult::failure(\n                \"Authorization timed out after 5 minutes\".to_string(),\n            ))\n        })\n}\n\n/// Context for handling the OAuth callback\nstruct CallbackContext\u003c'a\u003e {\n    listener: \u0026'a TcpListener,\n    expected_state: \u0026'a str,\n    redirect_uri: \u0026'a str,\n    client_id: \u0026'a str,\n    client_secret: \u0026'a str,\n}\n\n/// Handle the OAuth callback - accepts connections and processes the callback\nasync fn handle_callback(ctx: CallbackContext\u003c'_\u003e) -\u003e Result\u003cOAuthResult\u003e {\n    loop {\n        let (mut stream, _) = ctx\n            .listener\n            .accept()\n            .await\n            .map_err(|e| anyhow::anyhow!(format!(\"Failed to accept connection: {}\", e)))?;\n\n        let mut reader = BufReader::new(\u0026mut stream);\n        let mut request_line = String::new();\n        reader\n            .read_line(\u0026mut request_line)\n            .await\n            .map_err(|e| anyhow::anyhow!(format!(\"Failed to read request: {}\", e)))?;\n\n        // Skip non-callback requests (favicon, etc.)\n        if !request_line.contains(\"/callback\") {\n            send_response(\u0026mut stream, \"404 Not Found\", \"Not Found\", \"\")\n                .await\n                .ok();\n            continue;\n        }\n\n        return process_callback(\u0026mut stream, \u0026request_line, \u0026ctx).await;\n    }\n}\n\n/// Process the OAuth callback request\nasync fn process_callback(\n    stream: \u0026mut tokio::net::TcpStream,\n    request_line: \u0026str,\n    ctx: \u0026CallbackContext\u003c'_\u003e,\n) -\u003e Result\u003cOAuthResult\u003e {\n    // Parse callback parameters\n    let Some((code, returned_state)) = parse_callback_request(request_line) else {\n        send_response(\n            stream,\n            \"400 Bad Request\",\n            \"Invalid Request\",\n            \"Missing code or state\",\n        )\n        .await\n        .ok();\n        return Ok(OAuthResult::failure(\n            \"Missing code or state parameter\".to_string(),\n        ));\n    };\n\n    // Verify state\n    if returned_state != ctx.expected_state {\n        send_response(stream, \"400 Bad Request\", \"Invalid State\", \"State mismatch\")\n            .await\n            .ok();\n        return Ok(OAuthResult::failure(\n            \"State mismatch - possible CSRF attack\".to_string(),\n        ));\n    }\n\n    // Exchange code for tokens\n    let http = reqwest::Client::new();\n    let tokens = match exchange_code_for_tokens(\n        \u0026http,\n        \u0026code,\n        ctx.redirect_uri,\n        ctx.client_id,\n        ctx.client_secret,\n    )\n    .await\n    {\n        Ok(t) =\u003e t,\n        Err(e) =\u003e {\n            send_response(\n                stream,\n                \"500 Internal Server Error\",\n                \"Token Exchange Failed\",\n                \u0026e.to_string(),\n            )\n            .await\n            .ok();\n            return Ok(OAuthResult::failure(e.to_string()));\n        }\n    };\n\n    // Save tokens and complete\n    complete_auth(stream, \u0026tokens).await\n}\n\n/// Complete authentication by saving tokens\nasync fn complete_auth(\n    stream: \u0026mut tokio::net::TcpStream,\n    tokens: \u0026TokenResponse,\n) -\u003e Result\u003cOAuthResult\u003e {\n    let access_token = tokens\n        .access_token\n        .as_ref()\n        .ok_or_else(|| anyhow::anyhow!(\"No access token in response\".to_string()))?;\n\n    let team = tokens\n        .team\n        .as_ref()\n        .ok_or_else(|| anyhow::anyhow!(\"No team info in response\".to_string()))?;\n\n    // Save tokens\n    if let Err(e) = update_oauth_tokens(access_token, \u0026team.id, \u0026team.name) {\n        send_response(\n            stream,\n            \"500 Internal Server Error\",\n            \"Failed to Save Tokens\",\n            \u0026e.to_string(),\n        )\n        .await\n        .ok();\n        return Ok(OAuthResult::failure(e.to_string()));\n    }\n\n    send_response(\n        stream,\n        \"200 OK\",\n        \"Authorization Successful!\",\n        \u0026format!(\"Connected to {}.\", team.name),\n    )\n    .await\n    .ok();\n    Ok(OAuthResult::success(team.name.clone()))\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":1}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":41,"address":[],"length":0,"stats":{"Line":1}},{"line":44,"address":[],"length":0,"stats":{"Line":1}},{"line":67,"address":[],"length":0,"stats":{"Line":4}},{"line":70,"address":[],"length":0,"stats":{"Line":8}},{"line":71,"address":[],"length":0,"stats":{"Line":16}},{"line":72,"address":[],"length":0,"stats":{"Line":8}},{"line":76,"address":[],"length":0,"stats":{"Line":2}},{"line":77,"address":[],"length":0,"stats":{"Line":4}},{"line":78,"address":[],"length":0,"stats":{"Line":4}},{"line":79,"address":[],"length":0,"stats":{"Line":4}},{"line":80,"address":[],"length":0,"stats":{"Line":4}},{"line":81,"address":[],"length":0,"stats":{"Line":2}},{"line":84,"address":[],"length":0,"stats":{"Line":4}},{"line":86,"address":[],"length":0,"stats":{"Line":34}},{"line":90,"address":[],"length":0,"stats":{"Line":4}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":7}},{"line":132,"address":[],"length":0,"stats":{"Line":21}},{"line":133,"address":[],"length":0,"stats":{"Line":18}},{"line":135,"address":[],"length":0,"stats":{"Line":10}},{"line":136,"address":[],"length":0,"stats":{"Line":10}},{"line":138,"address":[],"length":0,"stats":{"Line":19}},{"line":139,"address":[],"length":0,"stats":{"Line":27}},{"line":140,"address":[],"length":0,"stats":{"Line":27}},{"line":141,"address":[],"length":0,"stats":{"Line":45}},{"line":143,"address":[],"length":0,"stats":{"Line":9}},{"line":144,"address":[],"length":0,"stats":{"Line":29}},{"line":145,"address":[],"length":0,"stats":{"Line":25}},{"line":146,"address":[],"length":0,"stats":{"Line":1}},{"line":150,"address":[],"length":0,"stats":{"Line":11}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}}],"covered":31,"coverable":142},{"path":["/","Users","chi","Projects","hu","src","slack","auth","tests.rs"],"content":"use super::*;\n\n#[test]\nfn test_oauth_result_success() {\n    let result = OAuthResult::success(\"Test Team\".to_string());\n    assert!(result.success);\n    assert!(result.error.is_none());\n    assert_eq!(result.team_name, Some(\"Test Team\".to_string()));\n}\n\n#[test]\nfn test_oauth_result_failure() {\n    let result = OAuthResult::failure(\"auth error\".to_string());\n    assert!(!result.success);\n    assert_eq!(result.error, Some(\"auth error\".to_string()));\n    assert!(result.team_name.is_none());\n}\n\n#[test]\nfn test_generate_state_length() {\n    let state = generate_state();\n    // 16 bytes encoded as hex = 32 characters\n    assert_eq!(state.len(), 32);\n}\n\n#[test]\nfn test_generate_state_unique() {\n    let state1 = generate_state();\n    let state2 = generate_state();\n    assert_ne!(state1, state2);\n}\n\n#[test]\nfn test_generate_state_hex_chars() {\n    let state = generate_state();\n    assert!(state.chars().all(|c| c.is_ascii_hexdigit()));\n}\n\n#[test]\nfn test_build_authorization_url() {\n    let url = build_authorization_url(\"test-client-id\", \"http://localhost:9877/callback\", \"abc123\");\n    assert!(url.starts_with(\"https://slack.com/oauth/v2/authorize?\"));\n    assert!(url.contains(\"client_id=test-client-id\"));\n    assert!(url.contains(\"redirect_uri=http%3A%2F%2Flocalhost%3A9877%2Fcallback\"));\n    assert!(url.contains(\"state=abc123\"));\n    assert!(url.contains(\"scope=\"));\n}\n\n#[test]\nfn test_build_authorization_url_encodes_special_chars() {\n    let url = build_authorization_url(\"client\u0026id\", \"http://localhost/test?a=b\", \"state value\");\n    assert!(url.contains(\"client_id=client%26id\"));\n    assert!(url.contains(\"state=state%20value\"));\n}\n\n#[test]\nfn test_parse_callback_request_valid() {\n    let request = \"GET /callback?code=abc123\u0026state=xyz789 HTTP/1.1\";\n    let result = parse_callback_request(request);\n    assert!(result.is_some());\n    let (code, state) = result.unwrap();\n    assert_eq!(code, \"abc123\");\n    assert_eq!(state, \"xyz789\");\n}\n\n#[test]\nfn test_parse_callback_request_url_encoded() {\n    let request = \"GET /callback?code=abc%20123\u0026state=xyz%26789 HTTP/1.1\";\n    let result = parse_callback_request(request);\n    assert!(result.is_some());\n    let (code, state) = result.unwrap();\n    assert_eq!(code, \"abc 123\");\n    assert_eq!(state, \"xyz\u0026789\");\n}\n\n#[test]\nfn test_parse_callback_request_missing_code() {\n    let request = \"GET /callback?state=xyz789 HTTP/1.1\";\n    let result = parse_callback_request(request);\n    assert!(result.is_none());\n}\n\n#[test]\nfn test_parse_callback_request_missing_state() {\n    let request = \"GET /callback?code=abc123 HTTP/1.1\";\n    let result = parse_callback_request(request);\n    assert!(result.is_none());\n}\n\n#[test]\nfn test_parse_callback_request_no_query() {\n    let request = \"GET /callback HTTP/1.1\";\n    let result = parse_callback_request(request);\n    assert!(result.is_none());\n}\n\n#[test]\nfn test_parse_callback_request_empty() {\n    let request = \"\";\n    let result = parse_callback_request(request);\n    assert!(result.is_none());\n}\n\n#[test]\nfn test_parse_callback_request_extra_params() {\n    let request = \"GET /callback?code=abc\u0026state=xyz\u0026extra=foo HTTP/1.1\";\n    let result = parse_callback_request(request);\n    assert!(result.is_some());\n    let (code, state) = result.unwrap();\n    assert_eq!(code, \"abc\");\n    assert_eq!(state, \"xyz\");\n}\n\n#[test]\nfn test_token_response_deserialize_success() {\n    let json =\n        r#\"{\"ok\": true, \"access_token\": \"xoxb-test\", \"team\": {\"id\": \"T123\", \"name\": \"Test\"}}\"#;\n    let resp: TokenResponse = serde_json::from_str(json).unwrap();\n    assert!(resp.ok);\n    assert_eq!(resp.access_token, Some(\"xoxb-test\".to_string()));\n    assert!(resp.team.is_some());\n    let team = resp.team.unwrap();\n    assert_eq!(team.id, \"T123\");\n    assert_eq!(team.name, \"Test\");\n}\n\n#[test]\nfn test_token_response_deserialize_error() {\n    let json = r#\"{\"ok\": false, \"error\": \"invalid_code\"}\"#;\n    let resp: TokenResponse = serde_json::from_str(json).unwrap();\n    assert!(!resp.ok);\n    assert_eq!(resp.error, Some(\"invalid_code\".to_string()));\n    assert!(resp.access_token.is_none());\n}\n\n#[test]\nfn test_team_info_deserialize() {\n    let json = r#\"{\"id\": \"T12345\", \"name\": \"My Team\"}\"#;\n    let team: TeamInfo = serde_json::from_str(json).unwrap();\n    assert_eq!(team.id, \"T12345\");\n    assert_eq!(team.name, \"My Team\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","slack","channels","mod.rs"],"content":"//! Slack channel operations\n//!\n//! List channels, get channel info, and resolve channel names to IDs.\n\nuse anyhow::Result;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::PathBuf;\nuse std::time::{Duration, SystemTime};\nuse tokio::time::sleep;\n\nuse super::client::SlackClient;\nuse super::config::config_path;\nuse super::types::{SlackChannel, SlackUser};\n\n#[cfg(test)]\nmod tests;\n\n/// Cache expiry time (1 hour)\nconst CACHE_EXPIRY_SECS: u64 = 3600;\n\n/// Cached user lookup data\n#[derive(Serialize, Deserialize)]\nstruct UserCache {\n    /// Timestamp when cache was created\n    created: u64,\n    /// User ID to username mapping\n    users: HashMap\u003cString, String\u003e,\n}\n\n/// Get path to user cache file\nfn user_cache_path() -\u003e Option\u003cPathBuf\u003e {\n    config_path().map(|p| p.with_file_name(\"slack_users_cache.json\"))\n}\n\n/// Response from conversations.list API\n#[derive(Deserialize)]\nstruct ConversationsListResponse {\n    channels: Vec\u003cChannelResponse\u003e,\n    response_metadata: Option\u003cResponseMetadata\u003e,\n}\n\n/// Response from conversations.info API\n#[derive(Deserialize)]\nstruct ConversationsInfoResponse {\n    channel: ChannelResponse,\n}\n\n/// Response from users.list API\n#[derive(Deserialize)]\nstruct UsersListResponse {\n    members: Vec\u003cUserResponse\u003e,\n}\n\n/// Raw channel data from API\n#[derive(Deserialize)]\nstruct ChannelResponse {\n    id: String,\n    name: String,\n    is_private: Option\u003cbool\u003e,\n    is_member: Option\u003cbool\u003e,\n    topic: Option\u003cTopicResponse\u003e,\n    purpose: Option\u003cTopicResponse\u003e,\n    num_members: Option\u003cu32\u003e,\n    created: Option\u003ci64\u003e,\n}\n\n/// Raw user data from API\n#[derive(Deserialize)]\nstruct UserResponse {\n    id: String,\n    team_id: Option\u003cString\u003e,\n    name: String,\n    real_name: Option\u003cString\u003e,\n    is_bot: Option\u003cbool\u003e,\n    deleted: Option\u003cbool\u003e,\n    tz: Option\u003cString\u003e,\n}\n\n/// Topic or purpose field\n#[derive(Deserialize)]\nstruct TopicResponse {\n    value: String,\n}\n\n/// Pagination metadata\n#[derive(Deserialize)]\nstruct ResponseMetadata {\n    next_cursor: Option\u003cString\u003e,\n}\n\nimpl From\u003cChannelResponse\u003e for SlackChannel {\n    fn from(r: ChannelResponse) -\u003e Self {\n        Self {\n            id: r.id,\n            name: r.name,\n            is_private: r.is_private.unwrap_or(false),\n            is_member: r.is_member.unwrap_or(false),\n            topic: r.topic.map(|t| t.value).filter(|s| !s.is_empty()),\n            purpose: r.purpose.map(|p| p.value).filter(|s| !s.is_empty()),\n            num_members: r.num_members,\n            created: r.created.unwrap_or(0),\n        }\n    }\n}\n\nimpl From\u003cUserResponse\u003e for SlackUser {\n    fn from(r: UserResponse) -\u003e Self {\n        Self {\n            id: r.id,\n            team_id: r.team_id,\n            name: r.name,\n            real_name: r.real_name,\n            is_bot: r.is_bot.unwrap_or(false),\n            deleted: r.deleted.unwrap_or(false),\n            tz: r.tz,\n        }\n    }\n}\n\n/// List all accessible channels\npub async fn list_channels(client: \u0026SlackClient) -\u003e Result\u003cVec\u003cSlackChannel\u003e\u003e {\n    let mut all_channels = Vec::new();\n    let mut cursor: Option\u003cString\u003e = None;\n    let mut first_request = true;\n\n    loop {\n        // Rate limit: delay between paginated requests (Tier 2 = ~20 req/min)\n        if !first_request {\n            sleep(Duration::from_millis(500)).await;\n        }\n        first_request = false;\n\n        let mut params = vec![\n            (\"types\", \"public_channel\"),\n            (\"exclude_archived\", \"true\"),\n            (\"limit\", \"200\"),\n        ];\n\n        let cursor_str;\n        if let Some(ref c) = cursor {\n            cursor_str = c.clone();\n            params.push((\"cursor\", \u0026cursor_str));\n        }\n\n        let response: ConversationsListResponse = client\n            .get_with_params(\"conversations.list\", \u0026params)\n            .await?;\n\n        all_channels.extend(response.channels.into_iter().map(SlackChannel::from));\n\n        // Check for more pages\n        match response.response_metadata.and_then(|m| m.next_cursor) {\n            Some(c) if !c.is_empty() =\u003e cursor = Some(c),\n            _ =\u003e break,\n        }\n    }\n\n    // Sort by name\n    all_channels.sort_by(|a, b| a.name.cmp(\u0026b.name));\n\n    Ok(all_channels)\n}\n\n/// Get detailed info for a specific channel\npub async fn get_channel_info(client: \u0026SlackClient, channel_id: \u0026str) -\u003e Result\u003cSlackChannel\u003e {\n    let response: ConversationsInfoResponse = client\n        .get_with_params(\"conversations.info\", \u0026[(\"channel\", channel_id)])\n        .await?;\n\n    Ok(SlackChannel::from(response.channel))\n}\n\n/// Resolve a channel name (with or without #) to a channel ID\npub async fn resolve_channel(client: \u0026SlackClient, name_or_id: \u0026str) -\u003e Result\u003cString\u003e {\n    // If it already looks like an ID (channel, group, DM, or user), return it\n    // C = public channel, G = private channel, D = DM, U = user (for DM)\n    if name_or_id.starts_with('C')\n        || name_or_id.starts_with('G')\n        || name_or_id.starts_with('D')\n        || name_or_id.starts_with('U')\n    {\n        return Ok(name_or_id.to_string());\n    }\n\n    // Strip leading # if present\n    let name = name_or_id.trim_start_matches('#');\n\n    // List channels and find by name\n    let channels = list_channels(client).await?;\n    channels\n        .iter()\n        .find(|c| c.name == name)\n        .map(|c| c.id.clone())\n        .ok_or_else(|| anyhow::anyhow!(\"Channel not found: {}\", name))\n}\n\n/// List all users in the workspace\npub async fn list_users(client: \u0026SlackClient) -\u003e Result\u003cVec\u003cSlackUser\u003e\u003e {\n    let response: UsersListResponse = client.get(\"users.list\").await?;\n\n    let users: Vec\u003cSlackUser\u003e = response\n        .members\n        .into_iter()\n        .map(SlackUser::from)\n        .filter(|u| !u.deleted \u0026\u0026 !u.is_bot)\n        .collect();\n\n    Ok(users)\n}\n\n/// Build a lookup map from user ID to username (with caching)\npub async fn build_user_lookup(client: \u0026SlackClient) -\u003e Result\u003cHashMap\u003cString, String\u003e\u003e {\n    // Try to load from cache first\n    if let Some(cached) = load_user_cache() {\n        return Ok(cached);\n    }\n\n    // Fetch from API\n    let users = list_users(client).await?;\n    let lookup: HashMap\u003cString, String\u003e = users.into_iter().map(|u| (u.id, u.name)).collect();\n\n    // Save to cache\n    save_user_cache(\u0026lookup);\n\n    Ok(lookup)\n}\n\n/// Load user cache if valid\nfn load_user_cache() -\u003e Option\u003cHashMap\u003cString, String\u003e\u003e {\n    let path = user_cache_path()?;\n    let contents = fs::read_to_string(\u0026path).ok()?;\n    let cache: UserCache = serde_json::from_str(\u0026contents).ok()?;\n\n    // Check if cache is expired\n    let now = SystemTime::now()\n        .duration_since(SystemTime::UNIX_EPOCH)\n        .ok()?\n        .as_secs();\n\n    if now - cache.created \u003e CACHE_EXPIRY_SECS {\n        return None;\n    }\n\n    Some(cache.users)\n}\n\n/// Save user lookup to cache\nfn save_user_cache(users: \u0026HashMap\u003cString, String\u003e) {\n    let Some(path) = user_cache_path() else {\n        return;\n    };\n\n    let now = SystemTime::now()\n        .duration_since(SystemTime::UNIX_EPOCH)\n        .map(|d| d.as_secs())\n        .unwrap_or(0);\n\n    let cache = UserCache {\n        created: now,\n        users: users.clone(),\n    };\n\n    if let Ok(json) = serde_json::to_string(\u0026cache) {\n        let _ = fs::write(\u0026path, json);\n    }\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":1}},{"line":34,"address":[],"length":0,"stats":{"Line":4}},{"line":94,"address":[],"length":0,"stats":{"Line":3}},{"line":96,"address":[],"length":0,"stats":{"Line":3}},{"line":97,"address":[],"length":0,"stats":{"Line":3}},{"line":98,"address":[],"length":0,"stats":{"Line":6}},{"line":99,"address":[],"length":0,"stats":{"Line":6}},{"line":100,"address":[],"length":0,"stats":{"Line":13}},{"line":101,"address":[],"length":0,"stats":{"Line":13}},{"line":102,"address":[],"length":0,"stats":{"Line":3}},{"line":103,"address":[],"length":0,"stats":{"Line":6}},{"line":109,"address":[],"length":0,"stats":{"Line":3}},{"line":111,"address":[],"length":0,"stats":{"Line":6}},{"line":112,"address":[],"length":0,"stats":{"Line":6}},{"line":113,"address":[],"length":0,"stats":{"Line":6}},{"line":114,"address":[],"length":0,"stats":{"Line":6}},{"line":115,"address":[],"length":0,"stats":{"Line":9}},{"line":116,"address":[],"length":0,"stats":{"Line":6}},{"line":117,"address":[],"length":0,"stats":{"Line":3}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}}],"covered":19,"coverable":91},{"path":["/","Users","chi","Projects","hu","src","slack","channels","tests.rs"],"content":"use super::*;\n\n#[test]\nfn test_channel_response_to_slack_channel_full() {\n    let response = ChannelResponse {\n        id: \"C12345\".to_string(),\n        name: \"general\".to_string(),\n        is_private: Some(true),\n        is_member: Some(true),\n        topic: Some(TopicResponse {\n            value: \"Channel topic\".to_string(),\n        }),\n        purpose: Some(TopicResponse {\n            value: \"Channel purpose\".to_string(),\n        }),\n        num_members: Some(42),\n        created: Some(1704067200),\n    };\n\n    let channel = SlackChannel::from(response);\n    assert_eq!(channel.id, \"C12345\");\n    assert_eq!(channel.name, \"general\");\n    assert!(channel.is_private);\n    assert!(channel.is_member);\n    assert_eq!(channel.topic, Some(\"Channel topic\".to_string()));\n    assert_eq!(channel.purpose, Some(\"Channel purpose\".to_string()));\n    assert_eq!(channel.num_members, Some(42));\n    assert_eq!(channel.created, 1704067200);\n}\n\n#[test]\nfn test_channel_response_to_slack_channel_minimal() {\n    let response = ChannelResponse {\n        id: \"C12345\".to_string(),\n        name: \"general\".to_string(),\n        is_private: None,\n        is_member: None,\n        topic: None,\n        purpose: None,\n        num_members: None,\n        created: None,\n    };\n\n    let channel = SlackChannel::from(response);\n    assert_eq!(channel.id, \"C12345\");\n    assert_eq!(channel.name, \"general\");\n    assert!(!channel.is_private);\n    assert!(!channel.is_member);\n    assert!(channel.topic.is_none());\n    assert!(channel.purpose.is_none());\n    assert!(channel.num_members.is_none());\n    assert_eq!(channel.created, 0);\n}\n\n#[test]\nfn test_channel_response_empty_topic_filtered() {\n    let response = ChannelResponse {\n        id: \"C12345\".to_string(),\n        name: \"general\".to_string(),\n        is_private: None,\n        is_member: None,\n        topic: Some(TopicResponse {\n            value: \"\".to_string(),\n        }),\n        purpose: Some(TopicResponse {\n            value: \"\".to_string(),\n        }),\n        num_members: None,\n        created: None,\n    };\n\n    let channel = SlackChannel::from(response);\n    assert!(channel.topic.is_none());\n    assert!(channel.purpose.is_none());\n}\n\n#[test]\nfn test_user_response_to_slack_user_full() {\n    let response = UserResponse {\n        id: \"U12345\".to_string(),\n        team_id: Some(\"T12345\".to_string()),\n        name: \"alice\".to_string(),\n        real_name: Some(\"Alice Smith\".to_string()),\n        is_bot: Some(false),\n        deleted: Some(false),\n        tz: Some(\"America/New_York\".to_string()),\n    };\n\n    let user = SlackUser::from(response);\n    assert_eq!(user.id, \"U12345\");\n    assert_eq!(user.team_id, Some(\"T12345\".to_string()));\n    assert_eq!(user.name, \"alice\");\n    assert_eq!(user.real_name, Some(\"Alice Smith\".to_string()));\n    assert!(!user.is_bot);\n    assert!(!user.deleted);\n    assert_eq!(user.tz, Some(\"America/New_York\".to_string()));\n}\n\n#[test]\nfn test_user_response_to_slack_user_minimal() {\n    let response = UserResponse {\n        id: \"U12345\".to_string(),\n        team_id: None,\n        name: \"alice\".to_string(),\n        real_name: None,\n        is_bot: None,\n        deleted: None,\n        tz: None,\n    };\n\n    let user = SlackUser::from(response);\n    assert_eq!(user.id, \"U12345\");\n    assert!(user.team_id.is_none());\n    assert_eq!(user.name, \"alice\");\n    assert!(user.real_name.is_none());\n    assert!(!user.is_bot);\n    assert!(!user.deleted);\n    assert!(user.tz.is_none());\n}\n\n#[test]\nfn test_user_response_to_slack_user_bot() {\n    let response = UserResponse {\n        id: \"U12345\".to_string(),\n        team_id: None,\n        name: \"bot\".to_string(),\n        real_name: None,\n        is_bot: Some(true),\n        deleted: Some(true),\n        tz: None,\n    };\n\n    let user = SlackUser::from(response);\n    assert!(user.is_bot);\n    assert!(user.deleted);\n}\n\n#[test]\nfn test_user_cache_serialize_deserialize() {\n    let mut users = HashMap::new();\n    users.insert(\"U12345\".to_string(), \"alice\".to_string());\n    users.insert(\"U67890\".to_string(), \"bob\".to_string());\n\n    let cache = UserCache {\n        created: 1704067200,\n        users,\n    };\n\n    let json = serde_json::to_string(\u0026cache).unwrap();\n    let deserialized: UserCache = serde_json::from_str(\u0026json).unwrap();\n\n    assert_eq!(deserialized.created, 1704067200);\n    assert_eq!(deserialized.users.len(), 2);\n    assert_eq!(deserialized.users.get(\"U12345\"), Some(\u0026\"alice\".to_string()));\n}\n\n#[test]\nfn test_user_cache_path_is_some() {\n    // Should return Some on systems with a home directory\n    let path = user_cache_path();\n    if let Some(p) = path {\n        assert!(p.to_string_lossy().contains(\"slack_users_cache.json\"));\n    }\n}\n\n#[test]\nfn test_conversations_list_response_deserialize() {\n    let json = r#\"{\n            \"channels\": [\n                {\"id\": \"C12345\", \"name\": \"general\", \"is_private\": false, \"is_member\": true}\n            ],\n            \"response_metadata\": {\"next_cursor\": \"abc123\"}\n        }\"#;\n\n    let response: ConversationsListResponse = serde_json::from_str(json).unwrap();\n    assert_eq!(response.channels.len(), 1);\n    assert_eq!(response.channels[0].id, \"C12345\");\n    assert_eq!(\n        response.response_metadata.unwrap().next_cursor,\n        Some(\"abc123\".to_string())\n    );\n}\n\n#[test]\nfn test_conversations_list_response_no_cursor() {\n    let json = r#\"{\n            \"channels\": [\n                {\"id\": \"C12345\", \"name\": \"general\"}\n            ]\n        }\"#;\n\n    let response: ConversationsListResponse = serde_json::from_str(json).unwrap();\n    assert_eq!(response.channels.len(), 1);\n    assert!(response.response_metadata.is_none());\n}\n\n#[test]\nfn test_conversations_info_response_deserialize() {\n    let json = r#\"{\n            \"channel\": {\n                \"id\": \"C12345\",\n                \"name\": \"general\",\n                \"is_private\": true,\n                \"is_member\": true,\n                \"topic\": {\"value\": \"Discussion\"},\n                \"purpose\": {\"value\": \"General chat\"},\n                \"num_members\": 100,\n                \"created\": 1704067200\n            }\n        }\"#;\n\n    let response: ConversationsInfoResponse = serde_json::from_str(json).unwrap();\n    assert_eq!(response.channel.id, \"C12345\");\n    assert_eq!(response.channel.name, \"general\");\n}\n\n#[test]\nfn test_users_list_response_deserialize() {\n    let json = r#\"{\n            \"members\": [\n                {\"id\": \"U12345\", \"name\": \"alice\", \"real_name\": \"Alice\"},\n                {\"id\": \"U67890\", \"name\": \"bob\"}\n            ]\n        }\"#;\n\n    let response: UsersListResponse = serde_json::from_str(json).unwrap();\n    assert_eq!(response.members.len(), 2);\n    assert_eq!(response.members[0].id, \"U12345\");\n    assert_eq!(response.members[1].name, \"bob\");\n}\n\n#[test]\nfn test_topic_response_deserialize() {\n    let json = r#\"{\"value\": \"Test topic\"}\"#;\n    let topic: TopicResponse = serde_json::from_str(json).unwrap();\n    assert_eq!(topic.value, \"Test topic\");\n}\n\n#[test]\nfn test_response_metadata_deserialize() {\n    let json = r#\"{\"next_cursor\": \"cursor123\"}\"#;\n    let meta: ResponseMetadata = serde_json::from_str(json).unwrap();\n    assert_eq!(meta.next_cursor, Some(\"cursor123\".to_string()));\n}\n\n#[test]\nfn test_response_metadata_empty_cursor() {\n    let json = r#\"{}\"#;\n    let meta: ResponseMetadata = serde_json::from_str(json).unwrap();\n    assert!(meta.next_cursor.is_none());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","slack","client.rs"],"content":"//! Slack HTTP client\n//!\n//! Handles API requests with Bot token authentication.\n\nuse anyhow::Result;\nuse reqwest::Client;\nuse serde::de::DeserializeOwned;\nuse std::time::Duration;\nuse tokio::time::sleep;\n\nuse super::config::{load_config, SlackConfig};\n\nconst SLACK_API_URL: \u0026str = \"https://slack.com/api\";\nconst MAX_RETRIES: u32 = 3;\nconst DEFAULT_RETRY_SECS: u64 = 5;\n\n/// Slack API client\npub struct SlackClient {\n    config: SlackConfig,\n    http: Client,\n}\n\nimpl SlackClient {\n    /// Create a new Slack client\n    pub fn new() -\u003e Result\u003cSelf\u003e {\n        let config = load_config()?;\n        let http = Client::builder()\n            .user_agent(\"hu-cli/0.1.0\")\n            .no_proxy()\n            .build()\n            .map_err(|e| anyhow::anyhow!(format!(\"Failed to create HTTP client: {}\", e)))?;\n        Ok(Self { config, http })\n    }\n\n    /// Create a client for testing with explicit config and http client\n    #[cfg(test)]\n    pub fn with_config(config: SlackConfig, http: Client) -\u003e Self {\n        Self { config, http }\n    }\n\n    /// Get a reference to the current config (for testing)\n    #[cfg(test)]\n    #[must_use]\n    pub const fn config(\u0026self) -\u003e \u0026SlackConfig {\n        \u0026self.config\n    }\n\n    /// Get the bot token\n    fn bot_token(\u0026self) -\u003e Result\u003c\u0026str\u003e {\n        self.config\n            .oauth\n            .bot_token\n            .as_deref()\n            .ok_or_else(|| anyhow::anyhow!(\"bot_token not configured\".to_string()))\n    }\n\n    /// Get the user token (required for search API)\n    fn user_token(\u0026self) -\u003e Result\u003c\u0026str\u003e {\n        self.config.oauth.user_token.as_deref().ok_or_else(|| {\n            anyhow::anyhow!(\"user_token not configured (required for search)\".to_string())\n        })\n    }\n\n    /// Make a GET request to the Slack API\n    pub async fn get\u003cT: DeserializeOwned\u003e(\u0026self, method: \u0026str) -\u003e Result\u003cT\u003e {\n        let url = format!(\"{}/{}\", SLACK_API_URL, method);\n        let token = self.bot_token()?.to_string();\n\n        self.execute_with_retry(|| {\n            self.http\n                .get(\u0026url)\n                .header(\"Authorization\", format!(\"Bearer {}\", token))\n                .header(\"Accept\", \"application/json\")\n                .send()\n        })\n        .await\n    }\n\n    /// Make a GET request with query parameters\n    pub async fn get_with_params\u003cT: DeserializeOwned\u003e(\n        \u0026self,\n        method: \u0026str,\n        params: \u0026[(\u0026str, \u0026str)],\n    ) -\u003e Result\u003cT\u003e {\n        let url = format!(\"{}/{}\", SLACK_API_URL, method);\n        let token = self.bot_token()?.to_string();\n        let params: Vec\u003c(String, String)\u003e = params\n            .iter()\n            .map(|(k, v)| (k.to_string(), v.to_string()))\n            .collect();\n\n        self.execute_with_retry(|| {\n            self.http\n                .get(\u0026url)\n                .header(\"Authorization\", format!(\"Bearer {}\", token))\n                .header(\"Accept\", \"application/json\")\n                .query(\u0026params)\n                .send()\n        })\n        .await\n    }\n\n    /// Make a GET request using user token (required for search API)\n    pub async fn get_with_user_token\u003cT: DeserializeOwned\u003e(\n        \u0026self,\n        method: \u0026str,\n        params: \u0026[(\u0026str, \u0026str)],\n    ) -\u003e Result\u003cT\u003e {\n        let url = format!(\"{}/{}\", SLACK_API_URL, method);\n        let token = self.user_token()?.to_string();\n        let params: Vec\u003c(String, String)\u003e = params\n            .iter()\n            .map(|(k, v)| (k.to_string(), v.to_string()))\n            .collect();\n\n        self.execute_with_retry(|| {\n            self.http\n                .get(\u0026url)\n                .header(\"Authorization\", format!(\"Bearer {}\", token))\n                .header(\"Accept\", \"application/json\")\n                .query(\u0026params)\n                .send()\n        })\n        .await\n    }\n\n    /// Make a POST request to the Slack API\n    pub async fn post\u003cT, B\u003e(\u0026self, method: \u0026str, body: \u0026B) -\u003e Result\u003cT\u003e\n    where\n        T: DeserializeOwned,\n        B: serde::Serialize + Sync,\n    {\n        let url = format!(\"{}/{}\", SLACK_API_URL, method);\n        let token = self.bot_token()?.to_string();\n        let body_json = serde_json::to_string(body)?;\n\n        self.execute_with_retry(|| {\n            self.http\n                .post(\u0026url)\n                .header(\"Authorization\", format!(\"Bearer {}\", token))\n                .header(\"Accept\", \"application/json\")\n                .header(\"Content-Type\", \"application/json; charset=utf-8\")\n                .body(body_json.clone())\n                .send()\n        })\n        .await\n    }\n\n    /// Make a POST request using user token (required for conversations.mark)\n    pub async fn post_with_user_token\u003cT, B\u003e(\u0026self, method: \u0026str, body: \u0026B) -\u003e Result\u003cT\u003e\n    where\n        T: DeserializeOwned,\n        B: serde::Serialize + Sync,\n    {\n        let url = format!(\"{}/{}\", SLACK_API_URL, method);\n        let token = self.user_token()?.to_string();\n        let body_json = serde_json::to_string(body)?;\n\n        self.execute_with_retry(|| {\n            self.http\n                .post(\u0026url)\n                .header(\"Authorization\", format!(\"Bearer {}\", token))\n                .header(\"Accept\", \"application/json\")\n                .header(\"Content-Type\", \"application/json; charset=utf-8\")\n                .body(body_json.clone())\n                .send()\n        })\n        .await\n    }\n\n    /// Handle API response and check for Slack-specific errors\n    fn parse_response\u003cT: DeserializeOwned\u003e(\u0026self, text: \u0026str) -\u003e Result\u003cT\u003e {\n        // Slack returns { \"ok\": false, \"error\": \"...\" } for API errors\n        let value: serde_json::Value = serde_json::from_str(text)\n            .map_err(|e| anyhow::anyhow!(\"Parse error: {}: {}\", e, \u0026text[..text.len().min(200)]))?;\n\n        if let Some(ok) = value.get(\"ok\").and_then(serde_json::Value::as_bool) {\n            if !ok {\n                let error = value\n                    .get(\"error\")\n                    .and_then(|v| v.as_str())\n                    .unwrap_or(\"unknown error\");\n                return Err(anyhow::anyhow!(error.to_string()));\n            }\n        }\n\n        serde_json::from_str(text)\n            .map_err(|e| anyhow::anyhow!(\"Parse error: {}: {}\", e, \u0026text[..text.len().min(200)]))\n    }\n\n    /// Execute request with retry on rate limit\n    async fn execute_with_retry\u003cF, Fut, T\u003e(\u0026self, request_fn: F) -\u003e Result\u003cT\u003e\n    where\n        F: Fn() -\u003e Fut,\n        Fut: std::future::Future\u003cOutput = Result\u003creqwest::Response, reqwest::Error\u003e\u003e,\n        T: DeserializeOwned,\n    {\n        let mut retries = 0;\n\n        loop {\n            let response = request_fn().await?;\n            let status = response.status();\n\n            if status == reqwest::StatusCode::TOO_MANY_REQUESTS {\n                if retries \u003e= MAX_RETRIES {\n                    return Err(anyhow::anyhow!(\n                        \"Rate limited after {} retries\",\n                        MAX_RETRIES\n                    ));\n                }\n\n                // Get retry delay from header or use default\n                let retry_after = response\n                    .headers()\n                    .get(\"retry-after\")\n                    .and_then(|v| v.to_str().ok())\n                    .and_then(|s| s.parse::\u003cu64\u003e().ok())\n                    .unwrap_or(DEFAULT_RETRY_SECS);\n\n                eprintln!(\n                    \"Rate limited, waiting {} seconds... (retry {}/{})\",\n                    retry_after,\n                    retries + 1,\n                    MAX_RETRIES\n                );\n                sleep(Duration::from_secs(retry_after)).await;\n                retries += 1;\n                continue;\n            }\n\n            if !status.is_success() {\n                let body = response.text().await.unwrap_or_default();\n                return Err(anyhow::anyhow!(\"HTTP {}: {}\", status.as_u16(), body));\n            }\n\n            let text = response.text().await?;\n            return self.parse_response(\u0026text);\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::slack::config::{OAuthConfig, SlackConfig};\n\n    fn make_test_client() -\u003e SlackClient {\n        let config = SlackConfig {\n            oauth: OAuthConfig {\n                client_id: None,\n                client_secret: None,\n                bot_token: Some(\"xoxb-test\".to_string()),\n                user_token: Some(\"xoxp-test\".to_string()),\n                team_id: Some(\"T12345\".to_string()),\n                team_name: Some(\"Test Team\".to_string()),\n            },\n            default_channel: String::new(),\n            is_configured: true,\n        };\n        let http = Client::builder().build().unwrap();\n        SlackClient::with_config(config, http)\n    }\n\n    #[test]\n    fn test_parse_response_success() {\n        let client = make_test_client();\n        let json = r#\"{\"ok\": true, \"name\": \"test\"}\"#;\n\n        #[derive(Debug, serde::Deserialize, PartialEq)]\n        struct TestResponse {\n            ok: bool,\n            name: String,\n        }\n\n        let result: Result\u003cTestResponse\u003e = client.parse_response(json);\n        assert!(result.is_ok());\n        let resp = result.unwrap();\n        assert!(resp.ok);\n        assert_eq!(resp.name, \"test\");\n    }\n\n    #[test]\n    fn test_parse_response_slack_error() {\n        let client = make_test_client();\n        let json = r#\"{\"ok\": false, \"error\": \"channel_not_found\"}\"#;\n\n        #[derive(Debug, serde::Deserialize)]\n        struct TestResponse {\n            ok: bool,\n        }\n\n        let result: Result\u003cTestResponse\u003e = client.parse_response(json);\n        assert!(result.is_err());\n        let err = result.unwrap_err();\n        assert!(err.to_string().contains(\"channel_not_found\"));\n    }\n\n    #[test]\n    fn test_parse_response_slack_error_unknown() {\n        let client = make_test_client();\n        let json = r#\"{\"ok\": false}\"#;\n\n        #[derive(Debug, serde::Deserialize)]\n        struct TestResponse {\n            ok: bool,\n        }\n\n        let result: Result\u003cTestResponse\u003e = client.parse_response(json);\n        assert!(result.is_err());\n        let err = result.unwrap_err();\n        assert!(err.to_string().contains(\"unknown error\"));\n    }\n\n    #[test]\n    fn test_parse_response_invalid_json() {\n        let client = make_test_client();\n        let json = \"not json at all\";\n\n        #[derive(Debug, serde::Deserialize)]\n        struct TestResponse {\n            ok: bool,\n        }\n\n        let result: Result\u003cTestResponse\u003e = client.parse_response(json);\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"Parse error\"));\n    }\n\n    #[test]\n    fn test_bot_token() {\n        let client = make_test_client();\n        assert_eq!(client.bot_token().unwrap(), \"xoxb-test\");\n    }\n\n    #[test]\n    fn test_user_token() {\n        let client = make_test_client();\n        assert_eq!(client.user_token().unwrap(), \"xoxp-test\");\n    }\n\n    #[test]\n    fn test_bot_token_missing() {\n        let config = SlackConfig {\n            oauth: OAuthConfig {\n                client_id: None,\n                client_secret: None,\n                bot_token: None,\n                user_token: None,\n                team_id: None,\n                team_name: None,\n            },\n            default_channel: String::new(),\n            is_configured: false,\n        };\n        let http = Client::builder().build().unwrap();\n        let client = SlackClient::with_config(config, http);\n\n        assert!(client.bot_token().is_err());\n    }\n\n    #[test]\n    fn test_user_token_missing() {\n        let config = SlackConfig {\n            oauth: OAuthConfig {\n                client_id: None,\n                client_secret: None,\n                bot_token: Some(\"xoxb-test\".to_string()),\n                user_token: None,\n                team_id: None,\n                team_name: None,\n            },\n            default_channel: String::new(),\n            is_configured: true,\n        };\n        let http = Client::builder().build().unwrap();\n        let client = SlackClient::with_config(config, http);\n\n        assert!(client.user_token().is_err());\n    }\n\n    #[test]\n    fn test_config_accessor() {\n        let client = make_test_client();\n        assert!(client.config().is_configured);\n        assert_eq!(\n            client.config().oauth.team_name,\n            Some(\"Test Team\".to_string())\n        );\n    }\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":4}},{"line":38,"address":[],"length":0,"stats":{"Line":4}},{"line":43,"address":[],"length":0,"stats":{"Line":11}},{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":2}},{"line":50,"address":[],"length":0,"stats":{"Line":2}},{"line":51,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":4}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":7}},{"line":59,"address":[],"length":0,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":4}},{"line":173,"address":[],"length":0,"stats":{"Line":14}},{"line":174,"address":[],"length":0,"stats":{"Line":10}},{"line":176,"address":[],"length":0,"stats":{"Line":9}},{"line":177,"address":[],"length":0,"stats":{"Line":3}},{"line":178,"address":[],"length":0,"stats":{"Line":4}},{"line":180,"address":[],"length":0,"stats":{"Line":4}},{"line":182,"address":[],"length":0,"stats":{"Line":4}},{"line":186,"address":[],"length":0,"stats":{"Line":2}},{"line":187,"address":[],"length":0,"stats":{"Line":1}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}}],"covered":21,"coverable":115},{"path":["/","Users","chi","Projects","hu","src","slack","config","mod.rs"],"content":"//! Slack configuration management\n//!\n//! Loads configuration from `~/.config/hu/settings.toml` with environment variable overrides.\n\nuse anyhow::Result;\nuse serde::{Deserialize, Serialize};\nuse std::fs;\nuse std::path::PathBuf;\n\n#[cfg(test)]\nmod tests;\n\n/// Slack configuration\n#[derive(Debug, Clone, Default)]\npub struct SlackConfig {\n    /// Default channel (e.g., \"#general\")\n    pub default_channel: String,\n    /// OAuth configuration\n    pub oauth: OAuthConfig,\n    /// Whether configuration is complete\n    pub is_configured: bool,\n}\n\n/// OAuth 2.0 configuration for Slack\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct OAuthConfig {\n    /// OAuth client ID\n    pub client_id: Option\u003cString\u003e,\n    /// OAuth client secret\n    pub client_secret: Option\u003cString\u003e,\n    /// Bot token (xoxb-...)\n    pub bot_token: Option\u003cString\u003e,\n    /// User token (xoxp-...) - required for search API\n    pub user_token: Option\u003cString\u003e,\n    /// Team/workspace ID\n    pub team_id: Option\u003cString\u003e,\n    /// Team/workspace name\n    pub team_name: Option\u003cString\u003e,\n}\n\nimpl OAuthConfig {\n    /// Check if OAuth is fully configured (bot token present)\n    #[must_use]\n    pub fn is_configured(\u0026self) -\u003e bool {\n        self.bot_token\n            .as_ref()\n            .is_some_and(|t| t.starts_with(\"xoxb-\"))\n    }\n\n    /// Check if user token is available (required for search)\n    #[must_use]\n    pub fn has_user_token(\u0026self) -\u003e bool {\n        self.user_token\n            .as_ref()\n            .is_some_and(|t| t.starts_with(\"xoxp-\"))\n    }\n}\n\n/// Raw TOML structure for settings file\n#[derive(Debug, Deserialize)]\nstruct SettingsFile {\n    slack: Option\u003cSlackSection\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct SlackSection {\n    default_channel: Option\u003cString\u003e,\n    oauth: Option\u003cOAuthSection\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct OAuthSection {\n    client_id: Option\u003cString\u003e,\n    client_secret: Option\u003cString\u003e,\n    bot_token: Option\u003cString\u003e,\n    user_token: Option\u003cString\u003e,\n    team_id: Option\u003cString\u003e,\n    team_name: Option\u003cString\u003e,\n}\n\n/// Get the config file path\n///\n/// Uses `~/.config/hu/settings.toml` following XDG convention.\n#[must_use]\npub fn config_path() -\u003e Option\u003cPathBuf\u003e {\n    dirs::home_dir().map(|p| p.join(\".config\").join(\"hu\").join(\"settings.toml\"))\n}\n\n/// Load Slack configuration from settings file and environment variables\npub fn load_config() -\u003e Result\u003cSlackConfig\u003e {\n    let mut config = SlackConfig::default();\n\n    // Try to load from settings file\n    if let Some(path) = config_path() {\n        if path.exists() {\n            // debug!(\"Loading Slack config from {}\", path.display());\n            let contents = fs::read_to_string(\u0026path).map_err(|e| {\n                anyhow::anyhow!(format!(\"Failed to read {}: {}\", path.display(), e))\n            })?;\n\n            let settings: SettingsFile = toml::from_str(\u0026contents).map_err(|e| {\n                anyhow::anyhow!(format!(\"Failed to parse {}: {}\", path.display(), e))\n            })?;\n\n            if let Some(slack) = settings.slack {\n                config.default_channel = slack.default_channel.unwrap_or_default();\n\n                if let Some(oauth) = slack.oauth {\n                    config.oauth = OAuthConfig {\n                        client_id: oauth.client_id,\n                        client_secret: oauth.client_secret,\n                        bot_token: oauth.bot_token,\n                        user_token: oauth.user_token,\n                        team_id: oauth.team_id,\n                        team_name: oauth.team_name,\n                    };\n                }\n            }\n        }\n    }\n\n    // Environment variable overrides\n    if let Ok(token) = std::env::var(\"SLACK_BOT_TOKEN\") {\n        config.oauth.bot_token = Some(token);\n    }\n    if let Ok(token) = std::env::var(\"SLACK_USER_TOKEN\") {\n        config.oauth.user_token = Some(token);\n    }\n    if let Ok(channel) = std::env::var(\"SLACK_DEFAULT_CHANNEL\") {\n        config.default_channel = channel;\n    }\n\n    // Determine configuration status\n    config.is_configured = config.oauth.is_configured();\n\n    Ok(config)\n}\n\n/// Update OAuth tokens in the config file after successful authentication\npub fn update_oauth_tokens(bot_token: \u0026str, team_id: \u0026str, team_name: \u0026str) -\u003e Result\u003c()\u003e {\n    let path = config_path()\n        .ok_or_else(|| anyhow::anyhow!(\"Cannot determine config directory\".to_string()))?;\n\n    // Read existing file\n    let contents = if path.exists() {\n        fs::read_to_string(\u0026path)\n            .map_err(|e| anyhow::anyhow!(format!(\"Failed to read {}: {}\", path.display(), e)))?\n    } else {\n        String::new()\n    };\n\n    // Parse as TOML value for modification\n    let mut doc: toml::Value =\n        toml::from_str(\u0026contents).unwrap_or_else(|_| toml::Value::Table(toml::map::Map::new()));\n\n    // Ensure slack.oauth section exists\n    let table = doc\n        .as_table_mut()\n        .ok_or_else(|| anyhow::anyhow!(\"Config is not a table\".to_string()))?;\n\n    if !table.contains_key(\"slack\") {\n        table.insert(\n            \"slack\".to_string(),\n            toml::Value::Table(toml::map::Map::new()),\n        );\n    }\n\n    let slack = table\n        .get_mut(\"slack\")\n        .and_then(|v| v.as_table_mut())\n        .ok_or_else(|| anyhow::anyhow!(\"slack section is not a table\".to_string()))?;\n\n    if !slack.contains_key(\"oauth\") {\n        slack.insert(\n            \"oauth\".to_string(),\n            toml::Value::Table(toml::map::Map::new()),\n        );\n    }\n\n    let oauth = slack\n        .get_mut(\"oauth\")\n        .and_then(|v| v.as_table_mut())\n        .ok_or_else(|| anyhow::anyhow!(\"slack.oauth section is not a table\".to_string()))?;\n\n    // Update tokens\n    oauth.insert(\n        \"bot_token\".to_string(),\n        toml::Value::String(bot_token.to_string()),\n    );\n    oauth.insert(\n        \"team_id\".to_string(),\n        toml::Value::String(team_id.to_string()),\n    );\n    oauth.insert(\n        \"team_name\".to_string(),\n        toml::Value::String(team_name.to_string()),\n    );\n\n    // Write back\n    let output = toml::to_string_pretty(\u0026doc)\n        .map_err(|e| anyhow::anyhow!(format!(\"Failed to serialize config: {}\", e)))?;\n\n    // Ensure parent directory exists\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent)\n            .map_err(|e| anyhow::anyhow!(format!(\"Failed to create config directory: {}\", e)))?;\n    }\n\n    fs::write(\u0026path, output)\n        .map_err(|e| anyhow::anyhow!(format!(\"Failed to write {}: {}\", path.display(), e)))?;\n\n    // debug!(\"Updated Slack OAuth tokens in {}\", path.display());\n    Ok(())\n}\n\n/// Update user token in the config file\npub fn update_user_token(user_token: \u0026str) -\u003e Result\u003c()\u003e {\n    let path = config_path()\n        .ok_or_else(|| anyhow::anyhow!(\"Cannot determine config directory\".to_string()))?;\n\n    // Read existing file\n    let contents = if path.exists() {\n        fs::read_to_string(\u0026path)\n            .map_err(|e| anyhow::anyhow!(format!(\"Failed to read {}: {}\", path.display(), e)))?\n    } else {\n        String::new()\n    };\n\n    // Parse as TOML value for modification\n    let mut doc: toml::Value =\n        toml::from_str(\u0026contents).unwrap_or_else(|_| toml::Value::Table(toml::map::Map::new()));\n\n    // Ensure slack.oauth section exists\n    let table = doc\n        .as_table_mut()\n        .ok_or_else(|| anyhow::anyhow!(\"Config is not a table\".to_string()))?;\n\n    if !table.contains_key(\"slack\") {\n        table.insert(\n            \"slack\".to_string(),\n            toml::Value::Table(toml::map::Map::new()),\n        );\n    }\n\n    let slack = table\n        .get_mut(\"slack\")\n        .and_then(|v| v.as_table_mut())\n        .ok_or_else(|| anyhow::anyhow!(\"slack section is not a table\".to_string()))?;\n\n    if !slack.contains_key(\"oauth\") {\n        slack.insert(\n            \"oauth\".to_string(),\n            toml::Value::Table(toml::map::Map::new()),\n        );\n    }\n\n    let oauth = slack\n        .get_mut(\"oauth\")\n        .and_then(|v| v.as_table_mut())\n        .ok_or_else(|| anyhow::anyhow!(\"slack.oauth section is not a table\".to_string()))?;\n\n    // Update user token\n    oauth.insert(\n        \"user_token\".to_string(),\n        toml::Value::String(user_token.to_string()),\n    );\n\n    // Write back\n    let output = toml::to_string_pretty(\u0026doc)\n        .map_err(|e| anyhow::anyhow!(format!(\"Failed to serialize config: {}\", e)))?;\n\n    // Ensure parent directory exists\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent)\n            .map_err(|e| anyhow::anyhow!(format!(\"Failed to create config directory: {}\", e)))?;\n    }\n\n    fs::write(\u0026path, output)\n        .map_err(|e| anyhow::anyhow!(format!(\"Failed to write {}: {}\", path.display(), e)))?;\n\n    // debug!(\"Updated Slack user token in {}\", path.display());\n    Ok(())\n}\n","traces":[{"line":44,"address":[],"length":0,"stats":{"Line":4}},{"line":45,"address":[],"length":0,"stats":{"Line":4}},{"line":47,"address":[],"length":0,"stats":{"Line":8}},{"line":52,"address":[],"length":0,"stats":{"Line":3}},{"line":53,"address":[],"length":0,"stats":{"Line":3}},{"line":55,"address":[],"length":0,"stats":{"Line":7}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":8}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}}],"covered":8,"coverable":112},{"path":["/","Users","chi","Projects","hu","src","slack","config","tests.rs"],"content":"use super::*;\n\n#[test]\nfn test_oauth_config_is_configured_with_valid_bot_token() {\n    let config = OAuthConfig {\n        client_id: None,\n        client_secret: None,\n        bot_token: Some(\"xoxb-12345-67890\".to_string()),\n        user_token: None,\n        team_id: None,\n        team_name: None,\n    };\n    assert!(config.is_configured());\n}\n\n#[test]\nfn test_oauth_config_is_configured_with_invalid_bot_token() {\n    let config = OAuthConfig {\n        client_id: None,\n        client_secret: None,\n        bot_token: Some(\"invalid-token\".to_string()),\n        user_token: None,\n        team_id: None,\n        team_name: None,\n    };\n    assert!(!config.is_configured());\n}\n\n#[test]\nfn test_oauth_config_is_configured_without_bot_token() {\n    let config = OAuthConfig {\n        client_id: None,\n        client_secret: None,\n        bot_token: None,\n        user_token: None,\n        team_id: None,\n        team_name: None,\n    };\n    assert!(!config.is_configured());\n}\n\n#[test]\nfn test_oauth_config_has_user_token_with_valid_token() {\n    let config = OAuthConfig {\n        client_id: None,\n        client_secret: None,\n        bot_token: None,\n        user_token: Some(\"xoxp-12345-67890\".to_string()),\n        team_id: None,\n        team_name: None,\n    };\n    assert!(config.has_user_token());\n}\n\n#[test]\nfn test_oauth_config_has_user_token_with_invalid_token() {\n    let config = OAuthConfig {\n        client_id: None,\n        client_secret: None,\n        bot_token: None,\n        user_token: Some(\"invalid-token\".to_string()),\n        team_id: None,\n        team_name: None,\n    };\n    assert!(!config.has_user_token());\n}\n\n#[test]\nfn test_oauth_config_has_user_token_without_token() {\n    let config = OAuthConfig {\n        client_id: None,\n        client_secret: None,\n        bot_token: None,\n        user_token: None,\n        team_id: None,\n        team_name: None,\n    };\n    assert!(!config.has_user_token());\n}\n\n#[test]\nfn test_config_path_returns_some() {\n    // This test just verifies config_path returns Some on systems with a home dir\n    let path = config_path();\n    // On most systems this should return Some\n    if let Some(p) = path {\n        assert!(p.to_string_lossy().contains(\"settings.toml\"));\n    }\n}\n\n#[test]\nfn test_slack_config_default() {\n    let config = SlackConfig::default();\n    assert!(!config.is_configured);\n    assert!(config.default_channel.is_empty());\n    assert!(!config.oauth.is_configured());\n}\n\n#[test]\nfn test_oauth_config_default() {\n    let config = OAuthConfig::default();\n    assert!(config.client_id.is_none());\n    assert!(config.client_secret.is_none());\n    assert!(config.bot_token.is_none());\n    assert!(config.user_token.is_none());\n    assert!(config.team_id.is_none());\n    assert!(config.team_name.is_none());\n}\n\n#[test]\nfn test_oauth_config_serialize_deserialize() {\n    let config = OAuthConfig {\n        client_id: Some(\"client123\".to_string()),\n        client_secret: Some(\"secret456\".to_string()),\n        bot_token: Some(\"xoxb-test\".to_string()),\n        user_token: Some(\"xoxp-test\".to_string()),\n        team_id: Some(\"T12345\".to_string()),\n        team_name: Some(\"Test Team\".to_string()),\n    };\n\n    let json = serde_json::to_string(\u0026config).unwrap();\n    let deserialized: OAuthConfig = serde_json::from_str(\u0026json).unwrap();\n\n    assert_eq!(deserialized.client_id, Some(\"client123\".to_string()));\n    assert_eq!(deserialized.client_secret, Some(\"secret456\".to_string()));\n    assert_eq!(deserialized.bot_token, Some(\"xoxb-test\".to_string()));\n    assert_eq!(deserialized.user_token, Some(\"xoxp-test\".to_string()));\n    assert_eq!(deserialized.team_id, Some(\"T12345\".to_string()));\n    assert_eq!(deserialized.team_name, Some(\"Test Team\".to_string()));\n}\n\n#[test]\nfn test_oauth_config_debug() {\n    let config = OAuthConfig {\n        client_id: Some(\"client123\".to_string()),\n        client_secret: None,\n        bot_token: None,\n        user_token: None,\n        team_id: None,\n        team_name: None,\n    };\n\n    let debug = format!(\"{:?}\", config);\n    assert!(debug.contains(\"OAuthConfig\"));\n    assert!(debug.contains(\"client123\"));\n}\n\n#[test]\nfn test_oauth_config_clone() {\n    let config = OAuthConfig {\n        client_id: Some(\"client123\".to_string()),\n        client_secret: None,\n        bot_token: Some(\"xoxb-test\".to_string()),\n        user_token: None,\n        team_id: None,\n        team_name: None,\n    };\n\n    let cloned = config.clone();\n    assert_eq!(cloned.client_id, config.client_id);\n    assert_eq!(cloned.bot_token, config.bot_token);\n}\n\n#[test]\nfn test_slack_config_clone() {\n    let config = SlackConfig {\n        default_channel: \"general\".to_string(),\n        oauth: OAuthConfig::default(),\n        is_configured: true,\n    };\n\n    let cloned = config.clone();\n    assert_eq!(cloned.default_channel, \"general\");\n    assert!(cloned.is_configured);\n}\n\n#[test]\nfn test_slack_config_debug() {\n    let config = SlackConfig {\n        default_channel: \"test\".to_string(),\n        oauth: OAuthConfig::default(),\n        is_configured: false,\n    };\n\n    let debug = format!(\"{:?}\", config);\n    assert!(debug.contains(\"SlackConfig\"));\n    assert!(debug.contains(\"test\"));\n}\n\n#[test]\nfn test_settings_file_parse() {\n    let toml_str = r##\"\n            [slack]\n            default_channel = \"general\"\n\n            [slack.oauth]\n            client_id = \"client123\"\n            client_secret = \"secret456\"\n            bot_token = \"xoxb-token\"\n            user_token = \"xoxp-token\"\n            team_id = \"T12345\"\n            team_name = \"Test Team\"\n        \"##;\n\n    let settings: SettingsFile = toml::from_str(toml_str).unwrap();\n    let slack = settings.slack.unwrap();\n    assert_eq!(slack.default_channel, Some(\"general\".to_string()));\n\n    let oauth = slack.oauth.unwrap();\n    assert_eq!(oauth.client_id, Some(\"client123\".to_string()));\n    assert_eq!(oauth.bot_token, Some(\"xoxb-token\".to_string()));\n    assert_eq!(oauth.team_name, Some(\"Test Team\".to_string()));\n}\n\n#[test]\nfn test_settings_file_parse_empty() {\n    let toml_str = \"\";\n    let settings: SettingsFile = toml::from_str(toml_str).unwrap();\n    assert!(settings.slack.is_none());\n}\n\n#[test]\nfn test_settings_file_parse_no_oauth() {\n    let toml_str = r##\"\n            [slack]\n            default_channel = \"test\"\n        \"##;\n\n    let settings: SettingsFile = toml::from_str(toml_str).unwrap();\n    let slack = settings.slack.unwrap();\n    assert_eq!(slack.default_channel, Some(\"test\".to_string()));\n    assert!(slack.oauth.is_none());\n}\n\n#[test]\nfn test_settings_file_parse_partial_oauth() {\n    let toml_str = r##\"\n            [slack.oauth]\n            bot_token = \"xoxb-test\"\n        \"##;\n\n    let settings: SettingsFile = toml::from_str(toml_str).unwrap();\n    let slack = settings.slack.unwrap();\n    let oauth = slack.oauth.unwrap();\n    assert_eq!(oauth.bot_token, Some(\"xoxb-test\".to_string()));\n    assert!(oauth.client_id.is_none());\n}\n\n#[test]\nfn test_slack_section_debug() {\n    let toml_str = r##\"\n            [slack]\n            default_channel = \"test\"\n        \"##;\n\n    let settings: SettingsFile = toml::from_str(toml_str).unwrap();\n    let debug = format!(\"{:?}\", settings);\n    assert!(debug.contains(\"SettingsFile\"));\n}\n\n#[test]\nfn test_oauth_section_debug() {\n    let toml_str = r##\"\n            [slack.oauth]\n            bot_token = \"xoxb-test\"\n        \"##;\n\n    let settings: SettingsFile = toml::from_str(toml_str).unwrap();\n    let debug = format!(\"{:?}\", settings.slack.unwrap().oauth.unwrap());\n    assert!(debug.contains(\"OAuthSection\"));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","slack","display","mod.rs"],"content":"//! Slack output formatting\n\nuse anyhow::{Context, Result};\nuse comfy_table::{presets::UTF8_FULL_CONDENSED, Cell, Color, ContentArrangement, Table};\nuse regex::Regex;\nuse std::collections::HashMap;\n\nuse super::types::{OutputFormat, SlackChannel, SlackMessage, SlackSearchResult, SlackUser};\n\n#[cfg(test)]\nmod tests;\n\n/// Truncate string to max length with ellipsis\nfn truncate(s: \u0026str, max_len: usize) -\u003e String {\n    if s.len() \u003c= max_len {\n        s.to_string()\n    } else {\n        format!(\"{}...\", \u0026s[..max_len.saturating_sub(3)])\n    }\n}\n\n/// Clean up Slack message text for display\n/// - Converts \u003c@U04H482TK6Z|Adam Ladachowski\u003e to @Adam Ladachowski\n/// - Converts \u003c@U04H482TK6Z\u003e to @username using lookup\n/// - Converts \u003c#C12345678|channel-name\u003e to #channel-name\n/// - Converts \u003cURL|text\u003e to text\nfn clean_message_text(text: \u0026str, user_lookup: \u0026HashMap\u003cString, String\u003e) -\u003e String {\n    // Match Slack's special formatting: \u003c...\u003e\n    let re = Regex::new(r\"\u003c([^\u003e]+)\u003e\").unwrap();\n\n    re.replace_all(text, |caps: \u0026regex::Captures| {\n        let content = \u0026caps[1];\n\n        if let Some(rest) = content.strip_prefix('@') {\n            // User mention: \u003c@U12345|Display Name\u003e or \u003c@U12345\u003e\n            if let Some((_, display_name)) = rest.split_once('|') {\n                format!(\"@{}\", display_name)\n            } else {\n                // No display name, look up user ID\n                user_lookup\n                    .get(rest)\n                    .map(|name| format!(\"@{}\", name))\n                    .unwrap_or_else(|| format!(\"@{}\", rest))\n            }\n        } else if let Some(rest) = content.strip_prefix('#') {\n            // Channel mention: \u003c#C12345|channel-name\u003e\n            if let Some((_, channel_name)) = rest.split_once('|') {\n                format!(\"#{}\", channel_name)\n            } else {\n                format!(\"#{}\", rest)\n            }\n        } else if let Some(rest) = content.strip_prefix('!') {\n            // Special mention: \u003c!here\u003e, \u003c!channel\u003e, \u003c!everyone\u003e\n            format!(\"@{}\", rest)\n        } else if content.contains('|') {\n            // URL with display text: \u003chttps://example.com|Example\u003e\n            let (_, display) = content.split_once('|').unwrap();\n            display.to_string()\n        } else {\n            // Plain URL or other\n            content.to_string()\n        }\n    })\n    .to_string()\n}\n\n/// Format channel name for display\n/// Converts mpdm-user1--user2--user3-1 to @user1, @user2, @user3\n/// Converts user IDs like U04H482TK6Z to @username using lookup\nfn format_channel_name(name: \u0026str, user_lookup: \u0026HashMap\u003cString, String\u003e) -\u003e String {\n    if name.starts_with(\"mpdm-\") {\n        // Multi-person DM: mpdm-user1--user2--user3-1\n        let without_prefix = name.strip_prefix(\"mpdm-\").unwrap_or(name);\n        // Remove trailing -1, -2, etc.\n        let without_suffix = without_prefix\n            .rsplit_once('-')\n            .map(|(rest, _)| rest)\n            .unwrap_or(without_prefix);\n        // Split on -- and format as @mentions\n        let users: Vec\u003cString\u003e = without_suffix\n            .split(\"--\")\n            .map(|u| format!(\"@{}\", u))\n            .collect();\n        users.join(\", \")\n    } else if name.starts_with('U')\n        \u0026\u0026 name.len() == 11\n        \u0026\u0026 name.chars().all(|c| c.is_ascii_alphanumeric())\n    {\n        // User ID (DM): resolve to @username\n        user_lookup\n            .get(name)\n            .map(|n| format!(\"@{}\", n))\n            .unwrap_or_else(|| \"DM\".to_string())\n    } else {\n        format!(\"#{}\", name)\n    }\n}\n\n/// Format Unix timestamp to readable date\nfn format_timestamp(ts: \u0026str) -\u003e String {\n    // Slack timestamps are like \"1234567890.123456\"\n    ts.split('.')\n        .next()\n        .and_then(|s| s.parse::\u003ci64\u003e().ok())\n        .and_then(|secs| chrono::DateTime::from_timestamp(secs, 0))\n        .map_or_else(\n            || ts.to_string(),\n            |dt| dt.format(\"%Y-%m-%d %H:%M\").to_string(),\n        )\n}\n\n/// Output channels list\npub fn output_channels(channels: \u0026[SlackChannel], format: OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            if channels.is_empty() {\n                println!(\"No channels found.\");\n                return Ok(());\n            }\n\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_content_arrangement(ContentArrangement::Dynamic);\n            table.set_header(vec![\"Name\", \"Type\", \"Members\", \"Topic\"]);\n\n            for channel in channels {\n                let channel_type = if channel.is_private {\n                    \"private\"\n                } else {\n                    \"public\"\n                };\n                let members = channel\n                    .num_members\n                    .map_or_else(|| \"-\".to_string(), |n| n.to_string());\n                let topic = channel.topic.as_deref().unwrap_or(\"-\");\n\n                table.add_row(vec![\n                    Cell::new(format!(\"#{}\", channel.name)).fg(Color::Cyan),\n                    Cell::new(channel_type),\n                    Cell::new(members),\n                    Cell::new(truncate(topic, 40)),\n                ]);\n            }\n\n            println!(\"{table}\");\n            println!(\"\\n{} channels\", channels.len());\n        }\n        OutputFormat::Json =\u003e {\n            let json = serde_json::to_string_pretty(channels)\n                .context(\"Failed to serialize channels to JSON\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n\n/// Output channel detail\npub fn output_channel_detail(channel: \u0026SlackChannel, format: OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            println!(\"{}\", \"-\".repeat(60));\n            println!(\"#{} ({})\", channel.name, channel.id);\n            println!(\"{}\", \"-\".repeat(60));\n            println!(\n                \"Type:    {}\",\n                if channel.is_private {\n                    \"private\"\n                } else {\n                    \"public\"\n                }\n            );\n            println!(\"Member:  {}\", if channel.is_member { \"yes\" } else { \"no\" });\n            if let Some(n) = channel.num_members {\n                println!(\"Members: {}\", n);\n            }\n            if let Some(ref topic) = channel.topic {\n                println!(\"\\nTopic: {}\", topic);\n            }\n            if let Some(ref purpose) = channel.purpose {\n                println!(\"\\nPurpose: {}\", purpose);\n            }\n        }\n        OutputFormat::Json =\u003e {\n            let json = serde_json::to_string_pretty(channel)\n                .context(\"Failed to serialize channel to JSON\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n\n/// Output message history\npub fn output_messages(\n    messages: \u0026[SlackMessage],\n    channel_name: \u0026str,\n    format: OutputFormat,\n) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            if messages.is_empty() {\n                println!(\"No messages found.\");\n                return Ok(());\n            }\n\n            println!(\"Messages in #{}\", channel_name);\n            println!(\"{}\", \"-\".repeat(60));\n\n            for msg in messages.iter().rev() {\n                let time = format_timestamp(\u0026msg.ts);\n                let user = msg\n                    .username\n                    .as_deref()\n                    .or(msg.user.as_deref())\n                    .unwrap_or(\"unknown\");\n                let thread = msg\n                    .reply_count\n                    .map_or(String::new(), |n| format!(\" [{} replies]\", n));\n\n                println!(\"[{}] {}: {}{}\", time, user, msg.text, thread);\n            }\n\n            println!(\"\\n{} messages\", messages.len());\n        }\n        OutputFormat::Json =\u003e {\n            let json = serde_json::to_string_pretty(messages)\n                .context(\"Failed to serialize messages to JSON\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n\n/// Output search results\npub fn output_search_results(\n    results: \u0026SlackSearchResult,\n    format: OutputFormat,\n    user_lookup: \u0026HashMap\u003cString, String\u003e,\n) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            if results.matches.is_empty() {\n                println!(\"No messages found.\");\n                return Ok(());\n            }\n\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_content_arrangement(ContentArrangement::Dynamic);\n            table.set_header(vec![\"Channel\", \"User\", \"Time\", \"Message\"]);\n\n            for m in \u0026results.matches {\n                let time = format_timestamp(\u0026m.ts);\n                let user = m.username.as_deref().unwrap_or(\"-\");\n                let channel = format_channel_name(\u0026m.channel.name, user_lookup);\n                let text = clean_message_text(\u0026m.text, user_lookup);\n\n                table.add_row(vec![\n                    Cell::new(\u0026channel).fg(Color::Cyan),\n                    Cell::new(user),\n                    Cell::new(time),\n                    Cell::new(truncate(\u0026text, 50)),\n                ]);\n            }\n\n            println!(\"{table}\");\n            println!(\n                \"\\nShowing {} of {} matches\",\n                results.matches.len(),\n                results.total\n            );\n        }\n        OutputFormat::Json =\u003e {\n            let json = serde_json::to_string_pretty(results)\n                .context(\"Failed to serialize search results to JSON\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n\n/// Output users list\npub fn output_users(users: \u0026[SlackUser], format: OutputFormat) -\u003e Result\u003c()\u003e {\n    match format {\n        OutputFormat::Table =\u003e {\n            if users.is_empty() {\n                println!(\"No users found.\");\n                return Ok(());\n            }\n\n            let mut table = Table::new();\n            table.load_preset(UTF8_FULL_CONDENSED);\n            table.set_content_arrangement(ContentArrangement::Dynamic);\n            table.set_header(vec![\"Username\", \"Name\", \"Timezone\"]);\n\n            for user in users {\n                let name = user.real_name.as_deref().unwrap_or(\"-\");\n                let tz = user.tz.as_deref().unwrap_or(\"-\");\n\n                table.add_row(vec![\n                    Cell::new(format!(\"@{}\", user.name)).fg(Color::Cyan),\n                    Cell::new(name),\n                    Cell::new(tz),\n                ]);\n            }\n\n            println!(\"{table}\");\n            println!(\"\\n{} users\", users.len());\n        }\n        OutputFormat::Json =\u003e {\n            let json =\n                serde_json::to_string_pretty(users).context(\"Failed to serialize users to JSON\")?;\n            println!(\"{json}\");\n        }\n    }\n    Ok(())\n}\n\n/// Output config status\npub fn output_config_status(\n    is_configured: bool,\n    has_user_token: bool,\n    team_name: Option\u003c\u0026str\u003e,\n    default_channel: \u0026str,\n) {\n    println!(\"Slack Configuration\");\n    println!(\"{}\", \"-\".repeat(40));\n    println!(\"Bot token:  {}\", if is_configured { \"Yes\" } else { \"No\" });\n    println!(\n        \"User token: {}\",\n        if has_user_token {\n            \"Yes (search enabled)\"\n        } else {\n            \"No (search disabled)\"\n        }\n    );\n    if let Some(name) = team_name {\n        println!(\"Workspace:  {}\", name);\n    }\n    if !default_channel.is_empty() {\n        println!(\"Default:    {}\", default_channel);\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":8}},{"line":15,"address":[],"length":0,"stats":{"Line":16}},{"line":16,"address":[],"length":0,"stats":{"Line":12}},{"line":18,"address":[],"length":0,"stats":{"Line":8}},{"line":27,"address":[],"length":0,"stats":{"Line":13}},{"line":29,"address":[],"length":0,"stats":{"Line":52}},{"line":31,"address":[],"length":0,"stats":{"Line":53}},{"line":32,"address":[],"length":0,"stats":{"Line":28}},{"line":34,"address":[],"length":0,"stats":{"Line":19}},{"line":36,"address":[],"length":0,"stats":{"Line":7}},{"line":37,"address":[],"length":0,"stats":{"Line":4}},{"line":40,"address":[],"length":0,"stats":{"Line":3}},{"line":41,"address":[],"length":0,"stats":{"Line":6}},{"line":42,"address":[],"length":0,"stats":{"Line":7}},{"line":43,"address":[],"length":0,"stats":{"Line":5}},{"line":45,"address":[],"length":0,"stats":{"Line":13}},{"line":47,"address":[],"length":0,"stats":{"Line":7}},{"line":48,"address":[],"length":0,"stats":{"Line":6}},{"line":50,"address":[],"length":0,"stats":{"Line":2}},{"line":52,"address":[],"length":0,"stats":{"Line":8}},{"line":54,"address":[],"length":0,"stats":{"Line":6}},{"line":55,"address":[],"length":0,"stats":{"Line":4}},{"line":57,"address":[],"length":0,"stats":{"Line":3}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":61,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":6}},{"line":71,"address":[],"length":0,"stats":{"Line":12}},{"line":73,"address":[],"length":0,"stats":{"Line":10}},{"line":75,"address":[],"length":0,"stats":{"Line":4}},{"line":77,"address":[],"length":0,"stats":{"Line":2}},{"line":78,"address":[],"length":0,"stats":{"Line":4}},{"line":80,"address":[],"length":0,"stats":{"Line":6}},{"line":82,"address":[],"length":0,"stats":{"Line":12}},{"line":84,"address":[],"length":0,"stats":{"Line":4}},{"line":85,"address":[],"length":0,"stats":{"Line":8}},{"line":86,"address":[],"length":0,"stats":{"Line":2}},{"line":87,"address":[],"length":0,"stats":{"Line":48}},{"line":90,"address":[],"length":0,"stats":{"Line":2}},{"line":91,"address":[],"length":0,"stats":{"Line":4}},{"line":92,"address":[],"length":0,"stats":{"Line":4}},{"line":93,"address":[],"length":0,"stats":{"Line":4}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":100,"address":[],"length":0,"stats":{"Line":7}},{"line":102,"address":[],"length":0,"stats":{"Line":7}},{"line":104,"address":[],"length":0,"stats":{"Line":28}},{"line":105,"address":[],"length":0,"stats":{"Line":19}},{"line":107,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":18}},{"line":113,"address":[],"length":0,"stats":{"Line":3}},{"line":114,"address":[],"length":0,"stats":{"Line":3}},{"line":116,"address":[],"length":0,"stats":{"Line":4}},{"line":117,"address":[],"length":0,"stats":{"Line":2}},{"line":118,"address":[],"length":0,"stats":{"Line":1}},{"line":121,"address":[],"length":0,"stats":{"Line":2}},{"line":122,"address":[],"length":0,"stats":{"Line":3}},{"line":123,"address":[],"length":0,"stats":{"Line":3}},{"line":124,"address":[],"length":0,"stats":{"Line":6}},{"line":126,"address":[],"length":0,"stats":{"Line":5}},{"line":127,"address":[],"length":0,"stats":{"Line":4}},{"line":128,"address":[],"length":0,"stats":{"Line":1}},{"line":130,"address":[],"length":0,"stats":{"Line":1}},{"line":132,"address":[],"length":0,"stats":{"Line":4}},{"line":133,"address":[],"length":0,"stats":{"Line":2}},{"line":134,"address":[],"length":0,"stats":{"Line":6}},{"line":135,"address":[],"length":0,"stats":{"Line":10}},{"line":137,"address":[],"length":0,"stats":{"Line":6}},{"line":138,"address":[],"length":0,"stats":{"Line":10}},{"line":139,"address":[],"length":0,"stats":{"Line":4}},{"line":140,"address":[],"length":0,"stats":{"Line":4}},{"line":141,"address":[],"length":0,"stats":{"Line":6}},{"line":145,"address":[],"length":0,"stats":{"Line":2}},{"line":146,"address":[],"length":0,"stats":{"Line":4}},{"line":149,"address":[],"length":0,"stats":{"Line":3}},{"line":151,"address":[],"length":0,"stats":{"Line":2}},{"line":154,"address":[],"length":0,"stats":{"Line":2}},{"line":158,"address":[],"length":0,"stats":{"Line":3}},{"line":159,"address":[],"length":0,"stats":{"Line":3}},{"line":161,"address":[],"length":0,"stats":{"Line":8}},{"line":162,"address":[],"length":0,"stats":{"Line":4}},{"line":163,"address":[],"length":0,"stats":{"Line":8}},{"line":164,"address":[],"length":0,"stats":{"Line":2}},{"line":165,"address":[],"length":0,"stats":{"Line":2}},{"line":166,"address":[],"length":0,"stats":{"Line":2}},{"line":167,"address":[],"length":0,"stats":{"Line":1}},{"line":169,"address":[],"length":0,"stats":{"Line":1}},{"line":172,"address":[],"length":0,"stats":{"Line":8}},{"line":173,"address":[],"length":0,"stats":{"Line":6}},{"line":174,"address":[],"length":0,"stats":{"Line":2}},{"line":176,"address":[],"length":0,"stats":{"Line":6}},{"line":177,"address":[],"length":0,"stats":{"Line":2}},{"line":179,"address":[],"length":0,"stats":{"Line":6}},{"line":180,"address":[],"length":0,"stats":{"Line":2}},{"line":184,"address":[],"length":0,"stats":{"Line":3}},{"line":186,"address":[],"length":0,"stats":{"Line":2}},{"line":189,"address":[],"length":0,"stats":{"Line":3}},{"line":193,"address":[],"length":0,"stats":{"Line":3}},{"line":198,"address":[],"length":0,"stats":{"Line":3}},{"line":200,"address":[],"length":0,"stats":{"Line":4}},{"line":201,"address":[],"length":0,"stats":{"Line":2}},{"line":202,"address":[],"length":0,"stats":{"Line":1}},{"line":205,"address":[],"length":0,"stats":{"Line":2}},{"line":206,"address":[],"length":0,"stats":{"Line":4}},{"line":208,"address":[],"length":0,"stats":{"Line":5}},{"line":209,"address":[],"length":0,"stats":{"Line":6}},{"line":210,"address":[],"length":0,"stats":{"Line":4}},{"line":211,"address":[],"length":0,"stats":{"Line":2}},{"line":213,"address":[],"length":0,"stats":{"Line":6}},{"line":215,"address":[],"length":0,"stats":{"Line":4}},{"line":216,"address":[],"length":0,"stats":{"Line":2}},{"line":217,"address":[],"length":0,"stats":{"Line":6}},{"line":219,"address":[],"length":0,"stats":{"Line":4}},{"line":222,"address":[],"length":0,"stats":{"Line":4}},{"line":225,"address":[],"length":0,"stats":{"Line":3}},{"line":227,"address":[],"length":0,"stats":{"Line":2}},{"line":230,"address":[],"length":0,"stats":{"Line":2}},{"line":234,"address":[],"length":0,"stats":{"Line":3}},{"line":239,"address":[],"length":0,"stats":{"Line":3}},{"line":241,"address":[],"length":0,"stats":{"Line":4}},{"line":242,"address":[],"length":0,"stats":{"Line":2}},{"line":243,"address":[],"length":0,"stats":{"Line":1}},{"line":246,"address":[],"length":0,"stats":{"Line":2}},{"line":247,"address":[],"length":0,"stats":{"Line":3}},{"line":248,"address":[],"length":0,"stats":{"Line":3}},{"line":249,"address":[],"length":0,"stats":{"Line":6}},{"line":251,"address":[],"length":0,"stats":{"Line":7}},{"line":252,"address":[],"length":0,"stats":{"Line":8}},{"line":253,"address":[],"length":0,"stats":{"Line":12}},{"line":254,"address":[],"length":0,"stats":{"Line":10}},{"line":255,"address":[],"length":0,"stats":{"Line":10}},{"line":257,"address":[],"length":0,"stats":{"Line":8}},{"line":258,"address":[],"length":0,"stats":{"Line":10}},{"line":259,"address":[],"length":0,"stats":{"Line":6}},{"line":260,"address":[],"length":0,"stats":{"Line":6}},{"line":261,"address":[],"length":0,"stats":{"Line":4}},{"line":265,"address":[],"length":0,"stats":{"Line":2}},{"line":266,"address":[],"length":0,"stats":{"Line":1}},{"line":267,"address":[],"length":0,"stats":{"Line":1}},{"line":268,"address":[],"length":0,"stats":{"Line":2}},{"line":273,"address":[],"length":0,"stats":{"Line":3}},{"line":275,"address":[],"length":0,"stats":{"Line":2}},{"line":278,"address":[],"length":0,"stats":{"Line":2}},{"line":282,"address":[],"length":0,"stats":{"Line":3}},{"line":283,"address":[],"length":0,"stats":{"Line":3}},{"line":285,"address":[],"length":0,"stats":{"Line":4}},{"line":286,"address":[],"length":0,"stats":{"Line":2}},{"line":287,"address":[],"length":0,"stats":{"Line":1}},{"line":290,"address":[],"length":0,"stats":{"Line":2}},{"line":291,"address":[],"length":0,"stats":{"Line":3}},{"line":292,"address":[],"length":0,"stats":{"Line":3}},{"line":293,"address":[],"length":0,"stats":{"Line":5}},{"line":295,"address":[],"length":0,"stats":{"Line":7}},{"line":296,"address":[],"length":0,"stats":{"Line":12}},{"line":297,"address":[],"length":0,"stats":{"Line":12}},{"line":299,"address":[],"length":0,"stats":{"Line":8}},{"line":300,"address":[],"length":0,"stats":{"Line":12}},{"line":301,"address":[],"length":0,"stats":{"Line":6}},{"line":302,"address":[],"length":0,"stats":{"Line":2}},{"line":306,"address":[],"length":0,"stats":{"Line":2}},{"line":307,"address":[],"length":0,"stats":{"Line":4}},{"line":310,"address":[],"length":0,"stats":{"Line":1}},{"line":311,"address":[],"length":0,"stats":{"Line":3}},{"line":312,"address":[],"length":0,"stats":{"Line":2}},{"line":315,"address":[],"length":0,"stats":{"Line":2}},{"line":319,"address":[],"length":0,"stats":{"Line":3}},{"line":325,"address":[],"length":0,"stats":{"Line":6}},{"line":326,"address":[],"length":0,"stats":{"Line":12}},{"line":327,"address":[],"length":0,"stats":{"Line":12}},{"line":328,"address":[],"length":0,"stats":{"Line":3}},{"line":329,"address":[],"length":0,"stats":{"Line":3}},{"line":330,"address":[],"length":0,"stats":{"Line":3}},{"line":331,"address":[],"length":0,"stats":{"Line":1}},{"line":333,"address":[],"length":0,"stats":{"Line":2}},{"line":336,"address":[],"length":0,"stats":{"Line":7}},{"line":337,"address":[],"length":0,"stats":{"Line":2}},{"line":339,"address":[],"length":0,"stats":{"Line":4}},{"line":340,"address":[],"length":0,"stats":{"Line":1}}],"covered":176,"coverable":176},{"path":["/","Users","chi","Projects","hu","src","slack","display","tests.rs"],"content":"use super::*;\n\n#[test]\nfn test_truncate_short_string() {\n    assert_eq!(truncate(\"hello\", 10), \"hello\");\n}\n\n#[test]\nfn test_truncate_exact_length() {\n    assert_eq!(truncate(\"hello\", 5), \"hello\");\n}\n\n#[test]\nfn test_truncate_long_string() {\n    assert_eq!(truncate(\"hello world\", 8), \"hello...\");\n}\n\n#[test]\nfn test_truncate_very_short_max() {\n    assert_eq!(truncate(\"hello\", 3), \"...\");\n}\n\n#[test]\nfn test_clean_message_text_user_mention_with_display() {\n    let lookup = HashMap::new();\n    assert_eq!(\n        clean_message_text(\"\u003c@U12345|John Doe\u003e\", \u0026lookup),\n        \"@John Doe\"\n    );\n}\n\n#[test]\nfn test_clean_message_text_user_mention_with_lookup() {\n    let mut lookup = HashMap::new();\n    lookup.insert(\"U12345\".to_string(), \"johndoe\".to_string());\n    assert_eq!(clean_message_text(\"\u003c@U12345\u003e\", \u0026lookup), \"@johndoe\");\n}\n\n#[test]\nfn test_clean_message_text_user_mention_without_lookup() {\n    let lookup = HashMap::new();\n    assert_eq!(clean_message_text(\"\u003c@U12345\u003e\", \u0026lookup), \"@U12345\");\n}\n\n#[test]\nfn test_clean_message_text_channel_mention() {\n    let lookup = HashMap::new();\n    assert_eq!(clean_message_text(\"\u003c#C12345|general\u003e\", \u0026lookup), \"#general\");\n}\n\n#[test]\nfn test_clean_message_text_channel_mention_no_name() {\n    let lookup = HashMap::new();\n    assert_eq!(clean_message_text(\"\u003c#C12345\u003e\", \u0026lookup), \"#C12345\");\n}\n\n#[test]\nfn test_clean_message_text_special_mention() {\n    let lookup = HashMap::new();\n    assert_eq!(clean_message_text(\"\u003c!here\u003e\", \u0026lookup), \"@here\");\n    assert_eq!(clean_message_text(\"\u003c!channel\u003e\", \u0026lookup), \"@channel\");\n    assert_eq!(clean_message_text(\"\u003c!everyone\u003e\", \u0026lookup), \"@everyone\");\n}\n\n#[test]\nfn test_clean_message_text_url_with_display() {\n    let lookup = HashMap::new();\n    assert_eq!(\n        clean_message_text(\"\u003chttps://example.com|Example Site\u003e\", \u0026lookup),\n        \"Example Site\"\n    );\n}\n\n#[test]\nfn test_clean_message_text_plain_url() {\n    let lookup = HashMap::new();\n    assert_eq!(\n        clean_message_text(\"\u003chttps://example.com\u003e\", \u0026lookup),\n        \"https://example.com\"\n    );\n}\n\n#[test]\nfn test_clean_message_text_mixed() {\n    let mut lookup = HashMap::new();\n    lookup.insert(\"U12345\".to_string(), \"bob\".to_string());\n    assert_eq!(\n        clean_message_text(\"Hey \u003c@U12345\u003e, check \u003c#C99999|dev\u003e!\", \u0026lookup),\n        \"Hey @bob, check #dev!\"\n    );\n}\n\n#[test]\nfn test_format_channel_name_regular() {\n    let lookup = HashMap::new();\n    assert_eq!(format_channel_name(\"general\", \u0026lookup), \"#general\");\n}\n\n#[test]\nfn test_format_channel_name_mpdm() {\n    let lookup = HashMap::new();\n    assert_eq!(\n        format_channel_name(\"mpdm-alice--bob--charlie-1\", \u0026lookup),\n        \"@alice, @bob, @charlie\"\n    );\n}\n\n#[test]\nfn test_format_channel_name_user_id_with_lookup() {\n    let mut lookup = HashMap::new();\n    lookup.insert(\"U04H482TK6Z\".to_string(), \"alice\".to_string());\n    assert_eq!(format_channel_name(\"U04H482TK6Z\", \u0026lookup), \"@alice\");\n}\n\n#[test]\nfn test_format_channel_name_user_id_without_lookup() {\n    let lookup = HashMap::new();\n    assert_eq!(format_channel_name(\"U04H482TK6Z\", \u0026lookup), \"DM\");\n}\n\n#[test]\nfn test_format_timestamp_valid() {\n    // 2024-01-01 00:00:00 UTC\n    let result = format_timestamp(\"1704067200.123456\");\n    assert_eq!(result, \"2024-01-01 00:00\");\n}\n\n#[test]\nfn test_format_timestamp_no_decimal() {\n    let result = format_timestamp(\"1704067200\");\n    assert_eq!(result, \"2024-01-01 00:00\");\n}\n\n#[test]\nfn test_format_timestamp_invalid() {\n    let result = format_timestamp(\"invalid\");\n    assert_eq!(result, \"invalid\");\n}\n\n#[test]\nfn test_output_channels_empty() {\n    // Just verify it doesn't panic\n    let channels: Vec\u003cSlackChannel\u003e = vec![];\n    let result = output_channels(\u0026channels, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_channels_json() {\n    let channels = vec![SlackChannel {\n        id: \"C12345\".to_string(),\n        name: \"general\".to_string(),\n        is_private: false,\n        is_member: true,\n        topic: Some(\"General discussion\".to_string()),\n        purpose: None,\n        num_members: Some(100),\n        created: 1704067200,\n    }];\n    let result = output_channels(\u0026channels, OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_channel_detail_table() {\n    let channel = SlackChannel {\n        id: \"C12345\".to_string(),\n        name: \"general\".to_string(),\n        is_private: true,\n        is_member: false,\n        topic: Some(\"Topic\".to_string()),\n        purpose: Some(\"Purpose\".to_string()),\n        num_members: Some(50),\n        created: 1704067200,\n    };\n    let result = output_channel_detail(\u0026channel, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_messages_empty() {\n    let messages: Vec\u003cSlackMessage\u003e = vec![];\n    let result = output_messages(\u0026messages, \"general\", OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_messages_json() {\n    let messages = vec![SlackMessage {\n        msg_type: \"message\".to_string(),\n        user: Some(\"U12345\".to_string()),\n        text: \"Hello world\".to_string(),\n        ts: \"1704067200.123456\".to_string(),\n        thread_ts: None,\n        reply_count: Some(5),\n        username: Some(\"alice\".to_string()),\n    }];\n    let result = output_messages(\u0026messages, \"general\", OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_users_empty() {\n    let users: Vec\u003cSlackUser\u003e = vec![];\n    let result = output_users(\u0026users, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_users_json() {\n    let users = vec![SlackUser {\n        id: \"U12345\".to_string(),\n        team_id: Some(\"T12345\".to_string()),\n        name: \"alice\".to_string(),\n        real_name: Some(\"Alice Smith\".to_string()),\n        is_bot: false,\n        deleted: false,\n        tz: Some(\"America/New_York\".to_string()),\n    }];\n    let result = output_users(\u0026users, OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_search_results_empty() {\n    let results = SlackSearchResult {\n        total: 0,\n        matches: vec![],\n    };\n    let lookup = HashMap::new();\n    let result = output_search_results(\u0026results, OutputFormat::Table, \u0026lookup);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_search_results_json() {\n    use crate::slack::types::{SlackSearchChannel, SlackSearchMatch};\n    let results = SlackSearchResult {\n        total: 1,\n        matches: vec![SlackSearchMatch {\n            channel: SlackSearchChannel {\n                id: \"C12345\".to_string(),\n                name: \"general\".to_string(),\n            },\n            user: Some(\"U12345\".to_string()),\n            username: Some(\"alice\".to_string()),\n            text: \"Hello world\".to_string(),\n            ts: \"1704067200.123456\".to_string(),\n            permalink: Some(\"https://slack.com/...\".to_string()),\n        }],\n    };\n    let lookup = HashMap::new();\n    let result = output_search_results(\u0026results, OutputFormat::Json, \u0026lookup);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_channels_table_with_data() {\n    let channels = vec![\n        SlackChannel {\n            id: \"C12345\".to_string(),\n            name: \"general\".to_string(),\n            is_private: false,\n            is_member: true,\n            topic: Some(\"General discussion\".to_string()),\n            purpose: None,\n            num_members: Some(100),\n            created: 1704067200,\n        },\n        SlackChannel {\n            id: \"C67890\".to_string(),\n            name: \"private-team\".to_string(),\n            is_private: true,\n            is_member: false,\n            topic: None,\n            purpose: None,\n            num_members: None,\n            created: 1704067200,\n        },\n    ];\n    let result = output_channels(\u0026channels, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_channel_detail_json() {\n    let channel = SlackChannel {\n        id: \"C12345\".to_string(),\n        name: \"general\".to_string(),\n        is_private: false,\n        is_member: true,\n        topic: None,\n        purpose: None,\n        num_members: None,\n        created: 1704067200,\n    };\n    let result = output_channel_detail(\u0026channel, OutputFormat::Json);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_channel_detail_table_public() {\n    // Tests the \"public\" branch (line 166) in table output\n    let channel = SlackChannel {\n        id: \"C12345\".to_string(),\n        name: \"general\".to_string(),\n        is_private: false, // public channel\n        is_member: true,\n        topic: Some(\"General chat\".to_string()),\n        purpose: Some(\"For general discussion\".to_string()),\n        num_members: Some(50),\n        created: 1704067200,\n    };\n    let result = output_channel_detail(\u0026channel, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_messages_table_with_data() {\n    let messages = vec![\n        SlackMessage {\n            msg_type: \"message\".to_string(),\n            user: Some(\"U12345\".to_string()),\n            text: \"Hello world\".to_string(),\n            ts: \"1704067200.123456\".to_string(),\n            thread_ts: None,\n            reply_count: Some(5),\n            username: Some(\"alice\".to_string()),\n        },\n        SlackMessage {\n            msg_type: \"message\".to_string(),\n            user: None,\n            text: \"Another message\".to_string(),\n            ts: \"1704067201.123456\".to_string(),\n            thread_ts: None,\n            reply_count: None,\n            username: None,\n        },\n    ];\n    let result = output_messages(\u0026messages, \"general\", OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_users_table_with_data() {\n    let users = vec![\n        SlackUser {\n            id: \"U12345\".to_string(),\n            team_id: Some(\"T12345\".to_string()),\n            name: \"alice\".to_string(),\n            real_name: Some(\"Alice Smith\".to_string()),\n            is_bot: false,\n            deleted: false,\n            tz: Some(\"America/New_York\".to_string()),\n        },\n        SlackUser {\n            id: \"U67890\".to_string(),\n            team_id: None,\n            name: \"bob\".to_string(),\n            real_name: None,\n            is_bot: true,\n            deleted: false,\n            tz: None,\n        },\n    ];\n    let result = output_users(\u0026users, OutputFormat::Table);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_search_results_table_with_data() {\n    use crate::slack::types::{SlackSearchChannel, SlackSearchMatch};\n    let results = SlackSearchResult {\n        total: 100,\n        matches: vec![\n            SlackSearchMatch {\n                channel: SlackSearchChannel {\n                    id: \"C12345\".to_string(),\n                    name: \"general\".to_string(),\n                },\n                user: Some(\"U12345\".to_string()),\n                username: Some(\"alice\".to_string()),\n                text: \"Hello world\".to_string(),\n                ts: \"1704067200.123456\".to_string(),\n                permalink: Some(\"https://slack.com/...\".to_string()),\n            },\n            SlackSearchMatch {\n                channel: SlackSearchChannel {\n                    id: \"C67890\".to_string(),\n                    name: \"mpdm-alice--bob-1\".to_string(),\n                },\n                user: None,\n                username: None,\n                text: \"\u003c@U12345|Alice\u003e mentioned \u003c#C99999|dev\u003e\".to_string(),\n                ts: \"1704067201.123456\".to_string(),\n                permalink: None,\n            },\n        ],\n    };\n    let mut lookup = HashMap::new();\n    lookup.insert(\"U12345\".to_string(), \"alice\".to_string());\n    let result = output_search_results(\u0026results, OutputFormat::Table, \u0026lookup);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_output_config_status_all_configured() {\n    output_config_status(true, true, Some(\"Acme Corp\"), \"#general\");\n}\n\n#[test]\nfn test_output_config_status_not_configured() {\n    output_config_status(false, false, None, \"\");\n}\n\n#[test]\nfn test_output_config_status_partial() {\n    output_config_status(true, false, Some(\"My Team\"), \"\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","slack","handlers.rs"],"content":"use anyhow::Result;\n\nuse super::auth;\nuse super::client::SlackClient;\nuse super::config::{self, load_config};\nuse super::display;\nuse super::service;\nuse super::tidy;\nuse super::types::OutputFormat;\nuse super::SlackCommands;\n\n/// Run a Slack command (CLI entry point - formats and prints)\n#[cfg(not(tarpaulin_include))]\npub async fn run(command: SlackCommands) -\u003e Result\u003c()\u003e {\n    match command {\n        SlackCommands::Auth {\n            token,\n            user_token,\n            port,\n        } =\u003e cmd_auth(token.as_deref(), user_token.as_deref(), port).await,\n        SlackCommands::Channels { json } =\u003e cmd_channels(json).await,\n        SlackCommands::Info { channel, json } =\u003e cmd_info(\u0026channel, json).await,\n        SlackCommands::Send { channel, message } =\u003e cmd_send(\u0026channel, \u0026message).await,\n        SlackCommands::History {\n            channel,\n            limit,\n            json,\n        } =\u003e cmd_history(\u0026channel, limit, json).await,\n        SlackCommands::Search { query, count, json } =\u003e cmd_search(\u0026query, count, json).await,\n        SlackCommands::Users { json } =\u003e cmd_users(json).await,\n        SlackCommands::Config =\u003e cmd_config(),\n        SlackCommands::Whoami =\u003e cmd_whoami().await,\n        SlackCommands::Tidy { dry_run } =\u003e cmd_tidy(dry_run).await,\n    }\n}\n\n/// Verify a Slack token by calling auth.test and return the response\nasync fn verify_token(token: \u0026str) -\u003e Result\u003cserde_json::Value\u003e {\n    let client = reqwest::Client::new();\n    let response = client\n        .get(\"https://slack.com/api/auth.test\")\n        .header(\"Authorization\", format!(\"Bearer {}\", token))\n        .send()\n        .await?;\n\n    let result: serde_json::Value = response.json().await?;\n\n    if result.get(\"ok\").and_then(serde_json::Value::as_bool) != Some(true) {\n        let error = result\n            .get(\"error\")\n            .and_then(serde_json::Value::as_str)\n            .unwrap_or(\"unknown\");\n        anyhow::bail!(\"Token validation failed: {}\", error);\n    }\n\n    Ok(result)\n}\n\n/// Authenticate with Slack via OAuth or direct token\nasync fn cmd_auth(token: Option\u003c\u0026str\u003e, user_token: Option\u003c\u0026str\u003e, port: u16) -\u003e Result\u003c()\u003e {\n    // If user token provided, save it\n    if let Some(user_tok) = user_token {\n        if !user_tok.starts_with(\"xoxp-\") {\n            anyhow::bail!(\"Invalid user token format. Token should start with 'xoxp-'\");\n        }\n        verify_token(user_tok).await?;\n        config::update_user_token(user_tok)?;\n        println!(\"User token saved successfully!\");\n        println!(\"\\nYou can now use `hu slack search` command.\");\n        return Ok(());\n    }\n\n    // If bot token provided directly, save it and verify\n    if let Some(bot_token) = token {\n        if !bot_token.starts_with(\"xoxb-\") {\n            anyhow::bail!(\"Invalid bot token format. Token should start with 'xoxb-'\");\n        }\n        let result = verify_token(bot_token).await?;\n        let team_id = result\n            .get(\"team_id\")\n            .and_then(serde_json::Value::as_str)\n            .unwrap_or(\"\");\n        let team_name = result\n            .get(\"team\")\n            .and_then(serde_json::Value::as_str)\n            .unwrap_or(\"Unknown\");\n        config::update_oauth_tokens(bot_token, team_id, team_name)?;\n        println!(\"Token saved successfully!\");\n        println!(\"Connected to: {}\", team_name);\n        println!(\"\\nYou can now use `hu slack channels` and other commands.\");\n        return Ok(());\n    }\n\n    // Otherwise, run OAuth flow\n    let result = auth::run_oauth_flow(port).await?;\n\n    if result.success {\n        println!(\"\\nAuthentication successful!\");\n        if let Some(team) = result.team_name {\n            println!(\"Connected to: {}\", team);\n        }\n        println!(\"\\nYou can now use `hu slack channels` and other commands.\");\n    } else {\n        let error = result.error.unwrap_or_else(|| \"Unknown error\".to_string());\n        anyhow::bail!(\"Authentication failed: {}\", error);\n    }\n\n    Ok(())\n}\n\n/// List channels\nasync fn cmd_channels(json: bool) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n\n    let client = SlackClient::new()?;\n    let channels = service::list_channels(\u0026client).await?;\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n\n    display::output_channels(\u0026channels, format)?;\n    Ok(())\n}\n\n/// Get channel info\nasync fn cmd_info(channel: \u0026str, json: bool) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n\n    let client = SlackClient::new()?;\n    let info = service::get_channel_info(\u0026client, channel).await?;\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n\n    display::output_channel_detail(\u0026info, format)?;\n    Ok(())\n}\n\n/// Send a message\nasync fn cmd_send(channel: \u0026str, text: \u0026str) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n\n    let client = SlackClient::new()?;\n    let (sent_channel, ts) = service::send_message(\u0026client, channel, text).await?;\n\n    println!(\"Message sent to {} (ts: {})\", sent_channel, ts);\n    Ok(())\n}\n\n/// Get message history\nasync fn cmd_history(channel: \u0026str, limit: usize, json: bool) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n\n    let client = SlackClient::new()?;\n    let messages = service::get_history(\u0026client, channel, limit).await?;\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n\n    // Get channel name for display\n    let channel_name = channel.trim_start_matches('#');\n    display::output_messages(\u0026messages, channel_name, format)?;\n    Ok(())\n}\n\n/// Search messages\nasync fn cmd_search(query: \u0026str, count: usize, json: bool) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n\n    let client = SlackClient::new()?;\n    let results = service::search_messages(\u0026client, query, count).await?;\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n\n    // Build user lookup for resolving DM user IDs to names\n    let user_lookup = service::build_user_lookup(\u0026client).await?;\n\n    display::output_search_results(\u0026results, format, \u0026user_lookup)?;\n    Ok(())\n}\n\n/// List users\nasync fn cmd_users(json: bool) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n\n    let client = SlackClient::new()?;\n    let users = service::list_users(\u0026client).await?;\n    let format = if json {\n        OutputFormat::Json\n    } else {\n        OutputFormat::Table\n    };\n\n    display::output_users(\u0026users, format)?;\n    Ok(())\n}\n\n/// Show configuration status\nfn cmd_config() -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n\n    display::output_config_status(\n        config.is_configured,\n        config.oauth.has_user_token(),\n        config.oauth.team_name.as_deref(),\n        \u0026config.default_channel,\n    );\n\n    if let Some(path) = config::config_path() {\n        println!(\"Config:     {}\", path.display());\n    }\n\n    Ok(())\n}\n\n/// Show current user info from token\nasync fn cmd_whoami() -\u003e Result\u003c()\u003e {\n    let config = load_config()?;\n    let token = config\n        .oauth\n        .user_token\n        .or(config.oauth.bot_token)\n        .ok_or_else(|| anyhow::anyhow!(\"No token configured\"))?;\n\n    let result = verify_token(\u0026token).await?;\n\n    println!(\n        \"User ID:   {}\",\n        result\n            .get(\"user_id\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"unknown\")\n    );\n    println!(\n        \"User:      {}\",\n        result\n            .get(\"user\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"unknown\")\n    );\n    println!(\n        \"Team ID:   {}\",\n        result\n            .get(\"team_id\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"unknown\")\n    );\n    println!(\n        \"Team:      {}\",\n        result\n            .get(\"team\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"unknown\")\n    );\n\n    Ok(())\n}\n\n/// Tidy channels - mark as read if no mentions\nasync fn cmd_tidy(dry_run: bool) -\u003e Result\u003c()\u003e {\n    let config = service::get_config()?;\n    service::ensure_user_token(\u0026config)?;\n\n    let client = SlackClient::new()?;\n    let token = config.oauth.user_token.as_deref().unwrap();\n    let result = verify_token(token).await?;\n\n    let user_info = tidy::UserInfo {\n        user_id: result\n            .get(\"user_id\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"\")\n            .to_string(),\n        name: \"Adam\".to_string(),\n        full_name: \"Adam Ladachowski\".to_string(),\n    };\n\n    if dry_run {\n        println!(\"DRY RUN - no channels will be marked as read\\n\");\n    }\n\n    let results = tidy::tidy_channels(\u0026client, \u0026user_info, dry_run).await?;\n\n    // Print results\n    let mut marked = 0;\n    let mut skipped = 0;\n    let mut has_mentions = 0;\n\n    for r in \u0026results {\n        match \u0026r.action {\n            tidy::TidyAction::Skipped =\u003e skipped += 1,\n            tidy::TidyAction::MarkedRead =\u003e {\n                marked += 1;\n                println!(\"Marked read: #{}\", r.channel_name);\n            }\n            tidy::TidyAction::HasMention(mention) =\u003e {\n                has_mentions += 1;\n                println!(\"Has mention: #{} - {}\", r.channel_name, mention);\n            }\n        }\n    }\n\n    println!(\"\\nSummary:\");\n    println!(\"  Marked as read: {}\", marked);\n    println!(\"  Has mentions:   {}\", has_mentions);\n    println!(\"  Already read:   {}\", skipped);\n\n    Ok(())\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":2}},{"line":329,"address":[],"length":0,"stats":{"Line":2}},{"line":330,"address":[],"length":0,"stats":{"Line":2}},{"line":332,"address":[],"length":0,"stats":{"Line":1}}],"covered":4,"coverable":192},{"path":["/","Users","chi","Projects","hu","src","slack","messages.rs"],"content":"//! Slack message operations\n//!\n//! Send messages and retrieve message history.\n\nuse anyhow::Result;\nuse serde::Deserialize;\n\nuse super::client::SlackClient;\nuse super::types::SlackMessage;\n\n/// Response from conversations.history API\n#[derive(Deserialize)]\nstruct HistoryResponse {\n    messages: Vec\u003cMessageResponse\u003e,\n}\n\n/// Response from chat.postMessage API\n#[derive(Deserialize)]\nstruct PostMessageResponse {\n    ts: String,\n    channel: String,\n}\n\n/// Raw message data from API\n#[derive(Deserialize)]\nstruct MessageResponse {\n    #[serde(rename = \"type\")]\n    msg_type: Option\u003cString\u003e,\n    user: Option\u003cString\u003e,\n    text: Option\u003cString\u003e,\n    ts: String,\n    thread_ts: Option\u003cString\u003e,\n    reply_count: Option\u003cu32\u003e,\n}\n\nimpl From\u003cMessageResponse\u003e for SlackMessage {\n    fn from(r: MessageResponse) -\u003e Self {\n        Self {\n            msg_type: r.msg_type.unwrap_or_else(|| \"message\".to_string()),\n            user: r.user,\n            text: r.text.unwrap_or_default(),\n            ts: r.ts,\n            thread_ts: r.thread_ts,\n            reply_count: r.reply_count,\n            username: None,\n        }\n    }\n}\n\n/// Get message history for a channel\npub async fn get_history(\n    client: \u0026SlackClient,\n    channel_id: \u0026str,\n    limit: usize,\n) -\u003e Result\u003cVec\u003cSlackMessage\u003e\u003e {\n    let limit_str = limit.to_string();\n    let response: HistoryResponse = client\n        .get_with_params(\n            \"conversations.history\",\n            \u0026[(\"channel\", channel_id), (\"limit\", \u0026limit_str)],\n        )\n        .await?;\n\n    let messages: Vec\u003cSlackMessage\u003e = response\n        .messages\n        .into_iter()\n        .map(SlackMessage::from)\n        .collect();\n\n    Ok(messages)\n}\n\n/// Send a message to a channel\npub async fn send_message(\n    client: \u0026SlackClient,\n    channel_id: \u0026str,\n    text: \u0026str,\n) -\u003e Result\u003c(String, String), anyhow::Error\u003e {\n    let body = serde_json::json!({\n        \"channel\": channel_id,\n        \"text\": text,\n    });\n\n    let response: PostMessageResponse = client.post(\"chat.postMessage\", \u0026body).await?;\n\n    Ok((response.channel, response.ts))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_message_response_to_slack_message_full() {\n        let response = MessageResponse {\n            msg_type: Some(\"message\".to_string()),\n            user: Some(\"U12345\".to_string()),\n            text: Some(\"Hello world\".to_string()),\n            ts: \"1704067200.123456\".to_string(),\n            thread_ts: Some(\"1704067100.000000\".to_string()),\n            reply_count: Some(5),\n        };\n\n        let message = SlackMessage::from(response);\n        assert_eq!(message.msg_type, \"message\");\n        assert_eq!(message.user, Some(\"U12345\".to_string()));\n        assert_eq!(message.text, \"Hello world\");\n        assert_eq!(message.ts, \"1704067200.123456\");\n        assert_eq!(message.thread_ts, Some(\"1704067100.000000\".to_string()));\n        assert_eq!(message.reply_count, Some(5));\n        assert!(message.username.is_none());\n    }\n\n    #[test]\n    fn test_message_response_to_slack_message_minimal() {\n        let response = MessageResponse {\n            msg_type: None,\n            user: None,\n            text: None,\n            ts: \"1704067200.123456\".to_string(),\n            thread_ts: None,\n            reply_count: None,\n        };\n\n        let message = SlackMessage::from(response);\n        assert_eq!(message.msg_type, \"message\"); // default value\n        assert!(message.user.is_none());\n        assert_eq!(message.text, \"\"); // default empty\n        assert_eq!(message.ts, \"1704067200.123456\");\n        assert!(message.thread_ts.is_none());\n        assert!(message.reply_count.is_none());\n    }\n\n    #[test]\n    fn test_history_response_deserialize() {\n        let json = r#\"{\n            \"messages\": [\n                {\"ts\": \"1704067200.123456\", \"text\": \"Hello\", \"user\": \"U12345\"},\n                {\"ts\": \"1704067100.123456\"}\n            ]\n        }\"#;\n\n        let response: HistoryResponse = serde_json::from_str(json).unwrap();\n        assert_eq!(response.messages.len(), 2);\n        assert_eq!(response.messages[0].ts, \"1704067200.123456\");\n        assert_eq!(response.messages[0].text, Some(\"Hello\".to_string()));\n    }\n\n    #[test]\n    fn test_post_message_response_deserialize() {\n        let json = r#\"{\"ts\": \"1704067200.123456\", \"channel\": \"C12345\"}\"#;\n        let response: PostMessageResponse = serde_json::from_str(json).unwrap();\n        assert_eq!(response.ts, \"1704067200.123456\");\n        assert_eq!(response.channel, \"C12345\");\n    }\n\n    #[test]\n    fn test_message_response_deserialize_with_type() {\n        let json = r#\"{\n            \"type\": \"message\",\n            \"user\": \"U12345\",\n            \"text\": \"Test message\",\n            \"ts\": \"1704067200.123456\",\n            \"thread_ts\": \"1704067100.000000\",\n            \"reply_count\": 10\n        }\"#;\n\n        let response: MessageResponse = serde_json::from_str(json).unwrap();\n        assert_eq!(response.msg_type, Some(\"message\".to_string()));\n        assert_eq!(response.user, Some(\"U12345\".to_string()));\n        assert_eq!(response.text, Some(\"Test message\".to_string()));\n        assert_eq!(response.ts, \"1704067200.123456\");\n        assert_eq!(response.thread_ts, Some(\"1704067100.000000\".to_string()));\n        assert_eq!(response.reply_count, Some(10));\n    }\n\n    #[test]\n    fn test_message_response_deserialize_empty_messages() {\n        let json = r#\"{\"messages\": []}\"#;\n        let response: HistoryResponse = serde_json::from_str(json).unwrap();\n        assert!(response.messages.is_empty());\n    }\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":2}},{"line":39,"address":[],"length":0,"stats":{"Line":6}},{"line":40,"address":[],"length":0,"stats":{"Line":2}},{"line":41,"address":[],"length":0,"stats":{"Line":4}},{"line":42,"address":[],"length":0,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}}],"covered":7,"coverable":22},{"path":["/","Users","chi","Projects","hu","src","slack","mod.rs"],"content":"//! Slack integration module\n//!\n//! Provides commands for interacting with Slack:\n//! - Authenticate via OAuth browser flow\n//! - List channels\n//! - Get channel info\n//! - Send messages\n//! - View message history\n//! - Search messages\n//! - List users\n//! - Show configuration status\n//!\n//! # CLI Usage\n//! Use [`run`] for CLI commands that format and print output.\n//!\n//! # Programmatic Usage (MCP/HTTP)\n//! Use the reusable functions that return typed data:\n//! - [`get_config`] - Get configuration status\n//! - [`list_channels`] - List all channels\n//! - [`get_channel_info`] - Get channel details\n//! - [`get_history`] - Get message history\n//! - [`send_message`] - Send a message\n//! - [`search_messages`] - Search messages\n//! - [`list_users`] - List workspace users\n\nmod auth;\nmod channels;\nmod client;\nmod config;\nmod display;\nmod handlers;\nmod messages;\nmod search;\nmod service;\nmod tidy;\nmod types;\n\nuse anyhow::Result;\nuse clap::Subcommand;\n\nuse client::SlackClient;\npub use config::SlackConfig;\npub use handlers::run;\npub use types::{SlackChannel, SlackMessage, SlackSearchResult, SlackUser};\n\n/// Slack subcommands\n#[derive(Subcommand, Debug)]\npub enum SlackCommands {\n    /// Authenticate with Slack (OAuth flow or direct token)\n    Auth {\n        /// Bot token to save directly (skips OAuth flow)\n        #[arg(short, long)]\n        token: Option\u003cString\u003e,\n        /// User token for search API (xoxp-...)\n        #[arg(short, long)]\n        user_token: Option\u003cString\u003e,\n        /// Local server port for OAuth callback\n        #[arg(short, long, default_value = \"9877\")]\n        port: u16,\n    },\n    /// List channels in the workspace\n    Channels {\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n    },\n    /// Show channel details\n    Info {\n        /// Channel name or ID (e.g., \"#general\" or \"C12345678\")\n        channel: String,\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n    },\n    /// Send a message to a channel\n    Send {\n        /// Channel name or ID\n        channel: String,\n        /// Message text\n        message: String,\n    },\n    /// Show message history for a channel\n    History {\n        /// Channel name or ID\n        channel: String,\n        /// Number of messages to show\n        #[arg(short, long, default_value = \"20\")]\n        limit: usize,\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n    },\n    /// Search messages\n    Search {\n        /// Search query\n        query: String,\n        /// Maximum results to return\n        #[arg(short = 'n', long, default_value = \"20\")]\n        count: usize,\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n    },\n    /// List users in the workspace\n    Users {\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n    },\n    /// Show Slack configuration status\n    Config,\n    /// Show current user info from token\n    Whoami,\n    /// Mark channels as read if no direct mentions\n    Tidy {\n        /// Dry run - show what would be marked without marking\n        #[arg(short, long)]\n        dry_run: bool,\n    },\n}\n\n// ============================================================================\n// Reusable functions for MCP/HTTP - return typed data, never print\n// ============================================================================\n\n/// Get Slack configuration status (for MCP/HTTP)\n#[allow(dead_code)]\npub fn get_config() -\u003e Result\u003cSlackConfig\u003e {\n    service::get_config()\n}\n\n/// List all channels (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn list_channels() -\u003e Result\u003cVec\u003cSlackChannel\u003e\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n    let client = SlackClient::new()?;\n    service::list_channels(\u0026client).await\n}\n\n/// Get channel info by name or ID (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn get_channel_info(channel: \u0026str) -\u003e Result\u003cSlackChannel\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n    let client = SlackClient::new()?;\n    service::get_channel_info(\u0026client, channel).await\n}\n\n/// Get message history for a channel (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn get_history(channel: \u0026str, limit: usize) -\u003e Result\u003cVec\u003cSlackMessage\u003e\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n    let client = SlackClient::new()?;\n    service::get_history(\u0026client, channel, limit).await\n}\n\n/// Send a message to a channel (for MCP/HTTP)\n/// Returns (channel_id, timestamp)\n#[allow(dead_code)]\npub async fn send_message(channel: \u0026str, text: \u0026str) -\u003e Result\u003c(String, String)\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n    let client = SlackClient::new()?;\n    service::send_message(\u0026client, channel, text).await\n}\n\n/// Search messages (for MCP/HTTP) - requires user token\n#[allow(dead_code)]\npub async fn search_messages(query: \u0026str, count: usize) -\u003e Result\u003cSlackSearchResult\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n    service::ensure_user_token(\u0026config)?;\n    let client = SlackClient::new()?;\n    service::search_messages(\u0026client, query, count).await\n}\n\n/// List users in the workspace (for MCP/HTTP)\n#[allow(dead_code)]\npub async fn list_users() -\u003e Result\u003cVec\u003cSlackUser\u003e\u003e {\n    let config = service::get_config()?;\n    service::ensure_configured(\u0026config)?;\n    let client = SlackClient::new()?;\n    service::list_users(\u0026client).await\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","slack","search.rs"],"content":"//! Slack message search\n//!\n//! Search messages across channels.\n\nuse anyhow::Result;\nuse serde::Deserialize;\n\nuse super::client::SlackClient;\nuse super::types::{SlackSearchChannel, SlackSearchMatch, SlackSearchResult};\n\n/// Response from search.messages API\n#[derive(Deserialize)]\nstruct SearchResponse {\n    messages: MessagesContainer,\n}\n\n/// Container for search matches\n#[derive(Deserialize)]\nstruct MessagesContainer {\n    total: u32,\n    matches: Vec\u003cMatchResponse\u003e,\n}\n\n/// Raw match data from API\n#[derive(Deserialize)]\nstruct MatchResponse {\n    channel: ChannelResponse,\n    user: Option\u003cString\u003e,\n    username: Option\u003cString\u003e,\n    text: String,\n    ts: String,\n    permalink: Option\u003cString\u003e,\n}\n\n/// Channel info in search response\n#[derive(Deserialize)]\nstruct ChannelResponse {\n    id: String,\n    name: String,\n}\n\nimpl From\u003cMatchResponse\u003e for SlackSearchMatch {\n    fn from(r: MatchResponse) -\u003e Self {\n        Self {\n            channel: SlackSearchChannel {\n                id: r.channel.id,\n                name: r.channel.name,\n            },\n            user: r.user,\n            username: r.username,\n            text: r.text,\n            ts: r.ts,\n            permalink: r.permalink,\n        }\n    }\n}\n\n/// Search messages across the workspace (requires user token)\npub async fn search_messages(\n    client: \u0026SlackClient,\n    query: \u0026str,\n    count: usize,\n) -\u003e Result\u003cSlackSearchResult\u003e {\n    let count_str = count.to_string();\n    let response: SearchResponse = client\n        .get_with_user_token(\n            \"search.messages\",\n            \u0026[\n                (\"query\", query),\n                (\"count\", \u0026count_str),\n                (\"sort\", \"timestamp\"),\n                (\"sort_dir\", \"desc\"),\n            ],\n        )\n        .await?;\n\n    Ok(SlackSearchResult {\n        total: response.messages.total,\n        matches: response\n            .messages\n            .matches\n            .into_iter()\n            .map(SlackSearchMatch::from)\n            .collect(),\n    })\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_response_to_slack_search_match_full() {\n        let response = MatchResponse {\n            channel: ChannelResponse {\n                id: \"C12345\".to_string(),\n                name: \"general\".to_string(),\n            },\n            user: Some(\"U12345\".to_string()),\n            username: Some(\"alice\".to_string()),\n            text: \"Hello world\".to_string(),\n            ts: \"1704067200.123456\".to_string(),\n            permalink: Some(\"https://slack.com/archives/C12345/p1704067200123456\".to_string()),\n        };\n\n        let match_result = SlackSearchMatch::from(response);\n        assert_eq!(match_result.channel.id, \"C12345\");\n        assert_eq!(match_result.channel.name, \"general\");\n        assert_eq!(match_result.user, Some(\"U12345\".to_string()));\n        assert_eq!(match_result.username, Some(\"alice\".to_string()));\n        assert_eq!(match_result.text, \"Hello world\");\n        assert_eq!(match_result.ts, \"1704067200.123456\");\n        assert!(match_result.permalink.is_some());\n    }\n\n    #[test]\n    fn test_match_response_to_slack_search_match_minimal() {\n        let response = MatchResponse {\n            channel: ChannelResponse {\n                id: \"C12345\".to_string(),\n                name: \"general\".to_string(),\n            },\n            user: None,\n            username: None,\n            text: \"Message\".to_string(),\n            ts: \"1704067200.123456\".to_string(),\n            permalink: None,\n        };\n\n        let match_result = SlackSearchMatch::from(response);\n        assert_eq!(match_result.channel.id, \"C12345\");\n        assert!(match_result.user.is_none());\n        assert!(match_result.username.is_none());\n        assert!(match_result.permalink.is_none());\n    }\n\n    #[test]\n    fn test_search_response_deserialize() {\n        let json = r#\"{\n            \"messages\": {\n                \"total\": 42,\n                \"matches\": [\n                    {\n                        \"channel\": {\"id\": \"C12345\", \"name\": \"general\"},\n                        \"user\": \"U12345\",\n                        \"username\": \"alice\",\n                        \"text\": \"Hello\",\n                        \"ts\": \"1704067200.123456\",\n                        \"permalink\": \"https://slack.com/...\"\n                    }\n                ]\n            }\n        }\"#;\n\n        let response: SearchResponse = serde_json::from_str(json).unwrap();\n        assert_eq!(response.messages.total, 42);\n        assert_eq!(response.messages.matches.len(), 1);\n        assert_eq!(response.messages.matches[0].text, \"Hello\");\n    }\n\n    #[test]\n    fn test_search_response_empty_matches() {\n        let json = r#\"{\n            \"messages\": {\n                \"total\": 0,\n                \"matches\": []\n            }\n        }\"#;\n\n        let response: SearchResponse = serde_json::from_str(json).unwrap();\n        assert_eq!(response.messages.total, 0);\n        assert!(response.messages.matches.is_empty());\n    }\n\n    #[test]\n    fn test_messages_container_deserialize() {\n        let json = r#\"{\"total\": 100, \"matches\": []}\"#;\n        let container: MessagesContainer = serde_json::from_str(json).unwrap();\n        assert_eq!(container.total, 100);\n        assert!(container.matches.is_empty());\n    }\n\n    #[test]\n    fn test_channel_response_deserialize() {\n        let json = r#\"{\"id\": \"C12345\", \"name\": \"test-channel\"}\"#;\n        let channel: ChannelResponse = serde_json::from_str(json).unwrap();\n        assert_eq!(channel.id, \"C12345\");\n        assert_eq!(channel.name, \"test-channel\");\n    }\n}\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":4}},{"line":49,"address":[],"length":0,"stats":{"Line":4}},{"line":50,"address":[],"length":0,"stats":{"Line":4}},{"line":51,"address":[],"length":0,"stats":{"Line":4}},{"line":52,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}}],"covered":7,"coverable":24},{"path":["/","Users","chi","Projects","hu","src","slack","tests.rs"],"content":"use super::*;\nuse config::{OAuthConfig, SlackConfig};\n\n#[test]\nfn test_ensure_configured_when_not_configured() {\n    let config = SlackConfig {\n        oauth: OAuthConfig::default(),\n        default_channel: String::new(),\n        is_configured: false,\n    };\n    let result = service::ensure_configured(\u0026config);\n    assert!(result.is_err());\n    assert!(result.unwrap_err().to_string().contains(\"not configured\"));\n}\n\n#[test]\nfn test_ensure_configured_when_configured() {\n    let config = SlackConfig {\n        oauth: OAuthConfig {\n            client_id: None,\n            client_secret: None,\n            bot_token: Some(\"xoxb-test\".to_string()),\n            user_token: None,\n            team_id: Some(\"T123\".to_string()),\n            team_name: Some(\"Test\".to_string()),\n        },\n        default_channel: String::new(),\n        is_configured: true,\n    };\n    let result = service::ensure_configured(\u0026config);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_slack_commands_debug() {\n    let cmd = SlackCommands::Channels { json: false };\n    let debug = format!(\"{:?}\", cmd);\n    assert!(debug.contains(\"Channels\"));\n}\n\n#[test]\nfn test_slack_commands_auth_debug() {\n    let cmd = SlackCommands::Auth {\n        token: Some(\"xoxb-test\".to_string()),\n        user_token: None,\n        port: 9877,\n    };\n    let debug = format!(\"{:?}\", cmd);\n    assert!(debug.contains(\"Auth\"));\n    assert!(debug.contains(\"9877\"));\n}\n\n#[test]\nfn test_slack_commands_info_debug() {\n    let cmd = SlackCommands::Info {\n        channel: \"#general\".to_string(),\n        json: true,\n    };\n    let debug = format!(\"{:?}\", cmd);\n    assert!(debug.contains(\"Info\"));\n    assert!(debug.contains(\"#general\"));\n}\n\n#[test]\nfn test_slack_commands_send_debug() {\n    let cmd = SlackCommands::Send {\n        channel: \"#test\".to_string(),\n        message: \"Hello\".to_string(),\n    };\n    let debug = format!(\"{:?}\", cmd);\n    assert!(debug.contains(\"Send\"));\n    assert!(debug.contains(\"Hello\"));\n}\n\n#[test]\nfn test_slack_commands_history_debug() {\n    let cmd = SlackCommands::History {\n        channel: \"#dev\".to_string(),\n        limit: 50,\n        json: false,\n    };\n    let debug = format!(\"{:?}\", cmd);\n    assert!(debug.contains(\"History\"));\n    assert!(debug.contains(\"50\"));\n}\n\n#[test]\nfn test_slack_commands_search_debug() {\n    let cmd = SlackCommands::Search {\n        query: \"deploy\".to_string(),\n        count: 20,\n        json: true,\n    };\n    let debug = format!(\"{:?}\", cmd);\n    assert!(debug.contains(\"Search\"));\n    assert!(debug.contains(\"deploy\"));\n}\n\n#[test]\nfn test_slack_commands_users_debug() {\n    let cmd = SlackCommands::Users { json: false };\n    let debug = format!(\"{:?}\", cmd);\n    assert!(debug.contains(\"Users\"));\n}\n\n#[test]\nfn test_slack_commands_config_debug() {\n    let cmd = SlackCommands::Config;\n    let debug = format!(\"{:?}\", cmd);\n    assert!(debug.contains(\"Config\"));\n}\n\n#[test]\nfn test_slack_commands_whoami_debug() {\n    let cmd = SlackCommands::Whoami;\n    let debug = format!(\"{:?}\", cmd);\n    assert!(debug.contains(\"Whoami\"));\n}\n\n#[test]\nfn test_slack_commands_tidy_debug() {\n    let cmd = SlackCommands::Tidy { dry_run: true };\n    let debug = format!(\"{:?}\", cmd);\n    assert!(debug.contains(\"Tidy\"));\n    assert!(debug.contains(\"true\"));\n}\n\n#[test]\nfn test_output_format_reexport() {\n    // Verify OutputFormat is accessible via types module\n    let format = types::OutputFormat::Table;\n    assert!(matches!(format, types::OutputFormat::Table));\n    let format = types::OutputFormat::Json;\n    assert!(matches!(format, types::OutputFormat::Json));\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":1}},{"line":8,"address":[],"length":0,"stats":{"Line":1}},{"line":16,"address":[],"length":0,"stats":{"Line":1}},{"line":19,"address":[],"length":0,"stats":{"Line":4}},{"line":20,"address":[],"length":0,"stats":{"Line":3}},{"line":23,"address":[],"length":0,"stats":{"Line":1}},{"line":25,"address":[],"length":0,"stats":{"Line":2}},{"line":33,"address":[],"length":0,"stats":{"Line":1}},{"line":36,"address":[],"length":0,"stats":{"Line":4}},{"line":37,"address":[],"length":0,"stats":{"Line":3}}],"covered":10,"coverable":10},{"path":["/","Users","chi","Projects","hu","src","slack","tidy","mod.rs"],"content":"//! Slack tidy operations\n//!\n//! Mark channels as read if no direct mentions in unread messages.\n\nuse anyhow::Result;\nuse serde::{Deserialize, Serialize};\nuse std::time::Duration;\nuse tokio::time::sleep;\n\nuse super::client::SlackClient;\n\n#[cfg(test)]\nmod tests;\n\n/// User info for mention detection\npub struct UserInfo {\n    pub user_id: String,\n    pub name: String,\n    pub full_name: String,\n}\n\n/// Channel with unread info\nstruct ChannelUnreadInfo {\n    last_read: String,\n    has_unreads: bool,\n}\n\n/// Response from conversations.list with membership info\n#[derive(Deserialize)]\nstruct ConversationsListResponse {\n    channels: Vec\u003cChannelListItem\u003e,\n    response_metadata: Option\u003cResponseMetadata\u003e,\n}\n\n#[derive(Deserialize)]\nstruct ChannelListItem {\n    id: String,\n    name: Option\u003cString\u003e,\n    user: Option\u003cString\u003e, // For DMs, contains the other user's ID\n    is_member: Option\u003cbool\u003e,\n    is_im: Option\u003cbool\u003e,\n}\n\n#[derive(Deserialize)]\nstruct ResponseMetadata {\n    next_cursor: Option\u003cString\u003e,\n}\n\n/// Response from conversations.info\n#[derive(Deserialize)]\nstruct ConversationsInfoResponse {\n    channel: ChannelInfoItem,\n}\n\n#[derive(Deserialize)]\nstruct ChannelInfoItem {\n    last_read: Option\u003cString\u003e,\n    latest: Option\u003cLatestMessage\u003e,\n}\n\n#[derive(Deserialize)]\nstruct LatestMessage {\n    ts: String,\n}\n\n/// Response from conversations.history\n#[derive(Deserialize)]\nstruct HistoryResponse {\n    messages: Vec\u003cHistoryMessage\u003e,\n}\n\n#[derive(Deserialize)]\nstruct HistoryMessage {\n    ts: String,\n    text: Option\u003cString\u003e,\n}\n\n/// Request body for conversations.mark\n#[derive(Serialize)]\nstruct MarkRequest {\n    channel: String,\n    ts: String,\n}\n\n/// Empty response from conversations.mark\n#[derive(Deserialize)]\nstruct MarkResponse {}\n\n/// Result of tidy operation for a single channel\n#[derive(Debug)]\npub struct TidyResult {\n    pub channel_name: String,\n    pub action: TidyAction,\n}\n\n#[derive(Debug)]\npub enum TidyAction {\n    Skipped,            // No unreads\n    MarkedRead,         // Marked as read (no mentions)\n    HasMention(String), // Has mention, not marked\n}\n\n/// Run tidy operation on all channels\npub async fn tidy_channels(\n    client: \u0026SlackClient,\n    user_info: \u0026UserInfo,\n    dry_run: bool,\n) -\u003e Result\u003cVec\u003cTidyResult\u003e\u003e {\n    let mut results = Vec::new();\n\n    // Get channels user is member of\n    let channels = list_member_channels(client).await?;\n    println!(\"Found {} channels you're a member of\", channels.len());\n\n    for channel in channels {\n        let display_name = get_display_name(\u0026channel);\n\n        // Rate limit\n        sleep(Duration::from_millis(500)).await;\n\n        // Get channel info with last_read\n        let info = get_channel_unread_info(client, \u0026channel.id).await?;\n\n        if !info.has_unreads {\n            results.push(TidyResult {\n                channel_name: display_name,\n                action: TidyAction::Skipped,\n            });\n            continue;\n        }\n\n        // Get unread messages\n        sleep(Duration::from_millis(500)).await;\n        let messages = get_messages_since(client, \u0026channel.id, \u0026info.last_read).await?;\n\n        // Check for mentions\n        if let Some(mention) = find_mention(\u0026messages, user_info) {\n            results.push(TidyResult {\n                channel_name: display_name,\n                action: TidyAction::HasMention(mention),\n            });\n            continue;\n        }\n\n        // No mentions - mark as read\n        if !dry_run {\n            if let Some(latest_ts) = messages.first().map(|m| m.ts.as_str()) {\n                sleep(Duration::from_millis(500)).await;\n                mark_channel_read(client, \u0026channel.id, latest_ts).await?;\n            }\n        }\n\n        results.push(TidyResult {\n            channel_name: display_name,\n            action: TidyAction::MarkedRead,\n        });\n    }\n\n    Ok(results)\n}\n\n/// Get display name for a channel/DM\nfn get_display_name(channel: \u0026ChannelListItem) -\u003e String {\n    if let Some(ref name) = channel.name {\n        name.clone()\n    } else if let Some(ref user_id) = channel.user {\n        // DM - show user ID (ideally we'd look up the name, but this works for now)\n        format!(\"DM:{}\", user_id)\n    } else {\n        channel.id.clone()\n    }\n}\n\n/// List channels where user is a member\nasync fn list_member_channels(client: \u0026SlackClient) -\u003e Result\u003cVec\u003cChannelListItem\u003e\u003e {\n    let mut all_channels = Vec::new();\n    let mut cursor: Option\u003cString\u003e = None;\n    let mut first = true;\n\n    loop {\n        if !first {\n            sleep(Duration::from_millis(500)).await;\n        }\n        first = false;\n\n        let mut params = vec![\n            (\"types\", \"public_channel,private_channel,mpim,im\"),\n            (\"exclude_archived\", \"true\"),\n            (\"limit\", \"200\"),\n        ];\n\n        let cursor_str;\n        if let Some(ref c) = cursor {\n            cursor_str = c.clone();\n            params.push((\"cursor\", \u0026cursor_str));\n        }\n\n        let response: ConversationsListResponse = client\n            .get_with_user_token(\"conversations.list\", \u0026params)\n            .await?;\n\n        for ch in response.channels {\n            // DMs (is_im) don't have is_member field - user is implicitly a member\n            let is_member = ch.is_im.unwrap_or(false) || ch.is_member.unwrap_or(false);\n            if is_member {\n                all_channels.push(ch);\n            }\n        }\n\n        match response.response_metadata.and_then(|m| m.next_cursor) {\n            Some(c) if !c.is_empty() =\u003e cursor = Some(c),\n            _ =\u003e break,\n        }\n    }\n\n    Ok(all_channels)\n}\n\n/// Get channel info to determine if there are unreads\nasync fn get_channel_unread_info(\n    client: \u0026SlackClient,\n    channel_id: \u0026str,\n) -\u003e Result\u003cChannelUnreadInfo\u003e {\n    let response: ConversationsInfoResponse = client\n        .get_with_user_token(\"conversations.info\", \u0026[(\"channel\", channel_id)])\n        .await?;\n\n    let last_read = response.channel.last_read.unwrap_or_default();\n    let latest_ts = response.channel.latest.map(|l| l.ts).unwrap_or_default();\n\n    // Has unreads if latest message ts \u003e last_read ts\n    let has_unreads = !last_read.is_empty() \u0026\u0026 !latest_ts.is_empty() \u0026\u0026 latest_ts \u003e last_read;\n\n    Ok(ChannelUnreadInfo {\n        last_read,\n        has_unreads,\n    })\n}\n\n/// Get messages since last_read timestamp\nasync fn get_messages_since(\n    client: \u0026SlackClient,\n    channel_id: \u0026str,\n    oldest: \u0026str,\n) -\u003e Result\u003cVec\u003cHistoryMessage\u003e\u003e {\n    let response: HistoryResponse = client\n        .get_with_user_token(\n            \"conversations.history\",\n            \u0026[\n                (\"channel\", channel_id),\n                (\"oldest\", oldest),\n                (\"limit\", \"100\"),\n            ],\n        )\n        .await?;\n\n    Ok(response.messages)\n}\n\n/// Check if any message contains a mention of the user\nfn find_mention(messages: \u0026[HistoryMessage], user_info: \u0026UserInfo) -\u003e Option\u003cString\u003e {\n    let user_mention = format!(\"\u003c@{}\u003e\", user_info.user_id);\n    let name_lower = user_info.name.to_lowercase();\n    let full_name_lower = user_info.full_name.to_lowercase();\n\n    for msg in messages {\n        if let Some(ref text) = msg.text {\n            // Check direct mention\n            if text.contains(\u0026user_mention) {\n                return Some(format!(\"@mention: {}\", truncate(text, 50)));\n            }\n\n            // Check name (case-insensitive)\n            let text_lower = text.to_lowercase();\n            if text_lower.contains(\u0026name_lower) {\n                return Some(format!(\"name '{}': {}\", user_info.name, truncate(text, 50)));\n            }\n\n            // Check full name (case-insensitive)\n            if text_lower.contains(\u0026full_name_lower) {\n                return Some(format!(\"full name: {}\", truncate(text, 50)));\n            }\n        }\n    }\n\n    None\n}\n\n/// Mark a channel as read at the given timestamp\nasync fn mark_channel_read(client: \u0026SlackClient, channel_id: \u0026str, ts: \u0026str) -\u003e Result\u003c()\u003e {\n    let body = MarkRequest {\n        channel: channel_id.to_string(),\n        ts: ts.to_string(),\n    };\n\n    let _: MarkResponse = client\n        .post_with_user_token(\"conversations.mark\", \u0026body)\n        .await?;\n    Ok(())\n}\n\nfn truncate(s: \u0026str, max: usize) -\u003e String {\n    if s.len() \u003c= max {\n        s.to_string()\n    } else {\n        format!(\"{}...\", \u0026s[..max.saturating_sub(3)])\n    }\n}\n","traces":[{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":3}},{"line":164,"address":[],"length":0,"stats":{"Line":4}},{"line":165,"address":[],"length":0,"stats":{"Line":2}},{"line":166,"address":[],"length":0,"stats":{"Line":3}},{"line":168,"address":[],"length":0,"stats":{"Line":2}},{"line":170,"address":[],"length":0,"stats":{"Line":2}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":7}},{"line":262,"address":[],"length":0,"stats":{"Line":21}},{"line":263,"address":[],"length":0,"stats":{"Line":14}},{"line":264,"address":[],"length":0,"stats":{"Line":14}},{"line":266,"address":[],"length":0,"stats":{"Line":15}},{"line":267,"address":[],"length":0,"stats":{"Line":11}},{"line":269,"address":[],"length":0,"stats":{"Line":10}},{"line":270,"address":[],"length":0,"stats":{"Line":3}},{"line":274,"address":[],"length":0,"stats":{"Line":8}},{"line":275,"address":[],"length":0,"stats":{"Line":8}},{"line":276,"address":[],"length":0,"stats":{"Line":6}},{"line":280,"address":[],"length":0,"stats":{"Line":4}},{"line":281,"address":[],"length":0,"stats":{"Line":3}},{"line":286,"address":[],"length":0,"stats":{"Line":3}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":8}},{"line":303,"address":[],"length":0,"stats":{"Line":16}},{"line":304,"address":[],"length":0,"stats":{"Line":12}},{"line":306,"address":[],"length":0,"stats":{"Line":8}}],"covered":24,"coverable":102},{"path":["/","Users","chi","Projects","hu","src","slack","tidy","tests.rs"],"content":"use super::*;\n\n#[test]\nfn test_user_info_creation() {\n    let info = UserInfo {\n        user_id: \"U12345\".to_string(),\n        name: \"Alice\".to_string(),\n        full_name: \"Alice Smith\".to_string(),\n    };\n    assert_eq!(info.user_id, \"U12345\");\n    assert_eq!(info.name, \"Alice\");\n    assert_eq!(info.full_name, \"Alice Smith\");\n}\n\n#[test]\nfn test_tidy_result_debug() {\n    let result = TidyResult {\n        channel_name: \"general\".to_string(),\n        action: TidyAction::MarkedRead,\n    };\n    let debug = format!(\"{:?}\", result);\n    assert!(debug.contains(\"general\"));\n    assert!(debug.contains(\"MarkedRead\"));\n}\n\n#[test]\nfn test_tidy_action_skipped_debug() {\n    let action = TidyAction::Skipped;\n    assert_eq!(format!(\"{:?}\", action), \"Skipped\");\n}\n\n#[test]\nfn test_tidy_action_marked_read_debug() {\n    let action = TidyAction::MarkedRead;\n    assert_eq!(format!(\"{:?}\", action), \"MarkedRead\");\n}\n\n#[test]\nfn test_tidy_action_has_mention_debug() {\n    let action = TidyAction::HasMention(\"@alice mentioned you\".to_string());\n    let debug = format!(\"{:?}\", action);\n    assert!(debug.contains(\"HasMention\"));\n    assert!(debug.contains(\"@alice mentioned you\"));\n}\n\n#[test]\nfn test_get_display_name_with_name() {\n    let channel = ChannelListItem {\n        id: \"C12345\".to_string(),\n        name: Some(\"general\".to_string()),\n        user: None,\n        is_member: Some(true),\n        is_im: None,\n    };\n    assert_eq!(get_display_name(\u0026channel), \"general\");\n}\n\n#[test]\nfn test_get_display_name_dm() {\n    let channel = ChannelListItem {\n        id: \"D12345\".to_string(),\n        name: None,\n        user: Some(\"U67890\".to_string()),\n        is_member: None,\n        is_im: Some(true),\n    };\n    assert_eq!(get_display_name(\u0026channel), \"DM:U67890\");\n}\n\n#[test]\nfn test_get_display_name_fallback_to_id() {\n    let channel = ChannelListItem {\n        id: \"G12345\".to_string(),\n        name: None,\n        user: None,\n        is_member: None,\n        is_im: None,\n    };\n    assert_eq!(get_display_name(\u0026channel), \"G12345\");\n}\n\n#[test]\nfn test_truncate_short_string() {\n    assert_eq!(truncate(\"hello\", 10), \"hello\");\n}\n\n#[test]\nfn test_truncate_exact_length() {\n    assert_eq!(truncate(\"hello\", 5), \"hello\");\n}\n\n#[test]\nfn test_truncate_long_string() {\n    assert_eq!(truncate(\"hello world\", 8), \"hello...\");\n}\n\n#[test]\nfn test_truncate_very_short_max() {\n    assert_eq!(truncate(\"hello\", 3), \"...\");\n}\n\n#[test]\nfn test_find_mention_direct_user_mention() {\n    let messages = vec![HistoryMessage {\n        ts: \"1704067200.123456\".to_string(),\n        text: Some(\"Hey \u003c@U12345\u003e check this out\".to_string()),\n    }];\n    let user_info = UserInfo {\n        user_id: \"U12345\".to_string(),\n        name: \"Alice\".to_string(),\n        full_name: \"Alice Smith\".to_string(),\n    };\n\n    let result = find_mention(\u0026messages, \u0026user_info);\n    assert!(result.is_some());\n    assert!(result.unwrap().contains(\"@mention\"));\n}\n\n#[test]\nfn test_find_mention_name_match() {\n    let messages = vec![HistoryMessage {\n        ts: \"1704067200.123456\".to_string(),\n        text: Some(\"Hey Alice, how are you?\".to_string()),\n    }];\n    let user_info = UserInfo {\n        user_id: \"U12345\".to_string(),\n        name: \"Alice\".to_string(),\n        full_name: \"Alice Smith\".to_string(),\n    };\n\n    let result = find_mention(\u0026messages, \u0026user_info);\n    assert!(result.is_some());\n    assert!(result.unwrap().contains(\"name 'Alice'\"));\n}\n\n#[test]\nfn test_find_mention_full_name_match() {\n    let messages = vec![HistoryMessage {\n        ts: \"1704067200.123456\".to_string(),\n        text: Some(\"I talked to Alice Smith yesterday\".to_string()),\n    }];\n    let user_info = UserInfo {\n        user_id: \"U12345\".to_string(),\n        name: \"Bob\".to_string(),\n        full_name: \"Alice Smith\".to_string(),\n    };\n\n    let result = find_mention(\u0026messages, \u0026user_info);\n    assert!(result.is_some());\n    assert!(result.unwrap().contains(\"full name\"));\n}\n\n#[test]\nfn test_find_mention_case_insensitive() {\n    let messages = vec![HistoryMessage {\n        ts: \"1704067200.123456\".to_string(),\n        text: Some(\"ALICE is here\".to_string()),\n    }];\n    let user_info = UserInfo {\n        user_id: \"U12345\".to_string(),\n        name: \"alice\".to_string(),\n        full_name: \"Alice Smith\".to_string(),\n    };\n\n    let result = find_mention(\u0026messages, \u0026user_info);\n    assert!(result.is_some());\n}\n\n#[test]\nfn test_find_mention_no_match() {\n    let messages = vec![HistoryMessage {\n        ts: \"1704067200.123456\".to_string(),\n        text: Some(\"Just a regular message\".to_string()),\n    }];\n    let user_info = UserInfo {\n        user_id: \"U12345\".to_string(),\n        name: \"Alice\".to_string(),\n        full_name: \"Alice Smith\".to_string(),\n    };\n\n    let result = find_mention(\u0026messages, \u0026user_info);\n    assert!(result.is_none());\n}\n\n#[test]\nfn test_find_mention_empty_messages() {\n    let messages: Vec\u003cHistoryMessage\u003e = vec![];\n    let user_info = UserInfo {\n        user_id: \"U12345\".to_string(),\n        name: \"Alice\".to_string(),\n        full_name: \"Alice Smith\".to_string(),\n    };\n\n    let result = find_mention(\u0026messages, \u0026user_info);\n    assert!(result.is_none());\n}\n\n#[test]\nfn test_find_mention_message_without_text() {\n    let messages = vec![HistoryMessage {\n        ts: \"1704067200.123456\".to_string(),\n        text: None,\n    }];\n    let user_info = UserInfo {\n        user_id: \"U12345\".to_string(),\n        name: \"Alice\".to_string(),\n        full_name: \"Alice Smith\".to_string(),\n    };\n\n    let result = find_mention(\u0026messages, \u0026user_info);\n    assert!(result.is_none());\n}\n\n#[test]\nfn test_conversations_list_response_deserialize() {\n    let json = r#\"{\n            \"channels\": [\n                {\"id\": \"C12345\", \"name\": \"general\", \"is_member\": true},\n                {\"id\": \"D67890\", \"user\": \"U99999\", \"is_im\": true}\n            ],\n            \"response_metadata\": {\"next_cursor\": \"abc123\"}\n        }\"#;\n\n    let response: ConversationsListResponse = serde_json::from_str(json).unwrap();\n    assert_eq!(response.channels.len(), 2);\n    assert_eq!(response.channels[0].id, \"C12345\");\n    assert_eq!(response.channels[1].user, Some(\"U99999\".to_string()));\n}\n\n#[test]\nfn test_channel_list_item_deserialize() {\n    let json = r#\"{\"id\": \"C12345\", \"name\": \"test\", \"is_member\": true, \"is_im\": false}\"#;\n    let item: ChannelListItem = serde_json::from_str(json).unwrap();\n    assert_eq!(item.id, \"C12345\");\n    assert_eq!(item.name, Some(\"test\".to_string()));\n    assert_eq!(item.is_member, Some(true));\n    assert_eq!(item.is_im, Some(false));\n}\n\n#[test]\nfn test_conversations_info_response_deserialize() {\n    let json = r#\"{\n            \"channel\": {\n                \"last_read\": \"1704067200.000000\",\n                \"latest\": {\"ts\": \"1704067300.000000\"}\n            }\n        }\"#;\n\n    let response: ConversationsInfoResponse = serde_json::from_str(json).unwrap();\n    assert_eq!(\n        response.channel.last_read,\n        Some(\"1704067200.000000\".to_string())\n    );\n    assert_eq!(response.channel.latest.unwrap().ts, \"1704067300.000000\");\n}\n\n#[test]\nfn test_history_response_deserialize() {\n    let json = r#\"{\n            \"messages\": [\n                {\"ts\": \"1704067200.123456\", \"text\": \"Hello\"},\n                {\"ts\": \"1704067100.123456\"}\n            ]\n        }\"#;\n\n    let response: HistoryResponse = serde_json::from_str(json).unwrap();\n    assert_eq!(response.messages.len(), 2);\n    assert_eq!(response.messages[0].ts, \"1704067200.123456\");\n    assert_eq!(response.messages[0].text, Some(\"Hello\".to_string()));\n}\n\n#[test]\nfn test_mark_request_serialize() {\n    let request = MarkRequest {\n        channel: \"C12345\".to_string(),\n        ts: \"1704067200.123456\".to_string(),\n    };\n\n    let json = serde_json::to_string(\u0026request).unwrap();\n    assert!(json.contains(\"C12345\"));\n    assert!(json.contains(\"1704067200.123456\"));\n}\n\n#[test]\nfn test_mark_response_deserialize() {\n    let json = r#\"{}\"#;\n    let response: MarkResponse = serde_json::from_str(json).unwrap();\n    // Just verify it deserializes without error\n    let _ = response;\n}\n\n#[test]\nfn test_response_metadata_deserialize() {\n    let json = r#\"{\"next_cursor\": \"cursor123\"}\"#;\n    let meta: ResponseMetadata = serde_json::from_str(json).unwrap();\n    assert_eq!(meta.next_cursor, Some(\"cursor123\".to_string()));\n}\n\n#[test]\nfn test_channel_info_item_deserialize() {\n    let json = r#\"{\"last_read\": \"1704067200.000000\"}\"#;\n    let item: ChannelInfoItem = serde_json::from_str(json).unwrap();\n    assert_eq!(item.last_read, Some(\"1704067200.000000\".to_string()));\n    assert!(item.latest.is_none());\n}\n\n#[test]\nfn test_latest_message_deserialize() {\n    let json = r#\"{\"ts\": \"1704067200.123456\"}\"#;\n    let latest: LatestMessage = serde_json::from_str(json).unwrap();\n    assert_eq!(latest.ts, \"1704067200.123456\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","slack","types.rs"],"content":"//! Slack data types and structures\n\nuse serde::{Deserialize, Serialize};\n\n/// Slack channel information\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SlackChannel {\n    /// Channel ID (e.g., \"C12345678\")\n    pub id: String,\n    /// Channel name (without #)\n    pub name: String,\n    /// Whether this is a private channel\n    pub is_private: bool,\n    /// Whether the bot is a member of this channel\n    pub is_member: bool,\n    /// Channel topic\n    pub topic: Option\u003cString\u003e,\n    /// Channel purpose\n    pub purpose: Option\u003cString\u003e,\n    /// Number of members\n    pub num_members: Option\u003cu32\u003e,\n    /// Creation timestamp\n    pub created: i64,\n}\n\n/// Slack message\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SlackMessage {\n    /// Message type (usually \"message\")\n    #[serde(rename = \"type\")]\n    pub msg_type: String,\n    /// User ID who sent the message\n    pub user: Option\u003cString\u003e,\n    /// Message text\n    pub text: String,\n    /// Timestamp (unique ID for the message)\n    pub ts: String,\n    /// Thread timestamp (if this is a reply)\n    pub thread_ts: Option\u003cString\u003e,\n    /// Number of replies in thread\n    pub reply_count: Option\u003cu32\u003e,\n    /// User display name (enriched after fetch)\n    #[serde(skip_deserializing)]\n    pub username: Option\u003cString\u003e,\n}\n\n/// Slack user information\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SlackUser {\n    /// User ID\n    pub id: String,\n    /// Team ID\n    pub team_id: Option\u003cString\u003e,\n    /// Username (handle without @)\n    pub name: String,\n    /// Display name\n    pub real_name: Option\u003cString\u003e,\n    /// Whether this is a bot\n    pub is_bot: bool,\n    /// Whether this user is deleted\n    pub deleted: bool,\n    /// User's timezone\n    pub tz: Option\u003cString\u003e,\n}\n\n/// Search result match\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SlackSearchMatch {\n    /// Channel where the message was posted\n    pub channel: SlackSearchChannel,\n    /// User ID who posted\n    pub user: Option\u003cString\u003e,\n    /// Username who posted\n    pub username: Option\u003cString\u003e,\n    /// Message text\n    pub text: String,\n    /// Timestamp\n    pub ts: String,\n    /// Permalink to the message\n    pub permalink: Option\u003cString\u003e,\n}\n\n/// Channel info in search results\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SlackSearchChannel {\n    /// Channel ID\n    pub id: String,\n    /// Channel name\n    pub name: String,\n}\n\n/// Search results container\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SlackSearchResult {\n    /// Total matches found\n    pub total: u32,\n    /// Matches returned\n    pub matches: Vec\u003cSlackSearchMatch\u003e,\n}\n\n/// Output format for Slack commands\n#[derive(Debug, Clone, Copy, Default)]\npub enum OutputFormat {\n    /// Human-readable table format\n    #[default]\n    Table,\n    /// JSON format for scripting\n    Json,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_output_format_default() {\n        let format = OutputFormat::default();\n        assert!(matches!(format, OutputFormat::Table));\n    }\n\n    #[test]\n    fn test_output_format_clone() {\n        let format = OutputFormat::Json;\n        let cloned = format.clone();\n        assert!(matches!(cloned, OutputFormat::Json));\n    }\n\n    #[test]\n    fn test_output_format_debug() {\n        let format = OutputFormat::Table;\n        let debug = format!(\"{:?}\", format);\n        assert_eq!(debug, \"Table\");\n    }\n\n    #[test]\n    fn test_slack_channel_debug() {\n        let channel = SlackChannel {\n            id: \"C12345\".to_string(),\n            name: \"general\".to_string(),\n            is_private: false,\n            is_member: true,\n            topic: Some(\"Test topic\".to_string()),\n            purpose: None,\n            num_members: Some(100),\n            created: 1704067200,\n        };\n        let debug = format!(\"{:?}\", channel);\n        assert!(debug.contains(\"SlackChannel\"));\n        assert!(debug.contains(\"general\"));\n    }\n\n    #[test]\n    fn test_slack_channel_clone() {\n        let channel = SlackChannel {\n            id: \"C12345\".to_string(),\n            name: \"general\".to_string(),\n            is_private: false,\n            is_member: true,\n            topic: None,\n            purpose: None,\n            num_members: None,\n            created: 1704067200,\n        };\n        let cloned = channel.clone();\n        assert_eq!(cloned.id, channel.id);\n        assert_eq!(cloned.name, channel.name);\n    }\n\n    #[test]\n    fn test_slack_message_debug() {\n        let msg = SlackMessage {\n            msg_type: \"message\".to_string(),\n            user: Some(\"U12345\".to_string()),\n            text: \"Hello world\".to_string(),\n            ts: \"1704067200.123456\".to_string(),\n            thread_ts: None,\n            reply_count: Some(5),\n            username: None,\n        };\n        let debug = format!(\"{:?}\", msg);\n        assert!(debug.contains(\"SlackMessage\"));\n    }\n\n    #[test]\n    fn test_slack_user_debug() {\n        let user = SlackUser {\n            id: \"U12345\".to_string(),\n            team_id: Some(\"T12345\".to_string()),\n            name: \"alice\".to_string(),\n            real_name: Some(\"Alice Smith\".to_string()),\n            is_bot: false,\n            deleted: false,\n            tz: Some(\"America/New_York\".to_string()),\n        };\n        let debug = format!(\"{:?}\", user);\n        assert!(debug.contains(\"SlackUser\"));\n    }\n\n    #[test]\n    fn test_slack_search_result_debug() {\n        let result = SlackSearchResult {\n            total: 42,\n            matches: vec![],\n        };\n        let debug = format!(\"{:?}\", result);\n        assert!(debug.contains(\"SlackSearchResult\"));\n        assert!(debug.contains(\"42\"));\n    }\n\n    #[test]\n    fn test_slack_search_match_debug() {\n        let m = SlackSearchMatch {\n            channel: SlackSearchChannel {\n                id: \"C12345\".to_string(),\n                name: \"general\".to_string(),\n            },\n            user: Some(\"U12345\".to_string()),\n            username: Some(\"alice\".to_string()),\n            text: \"Hello\".to_string(),\n            ts: \"1704067200.123456\".to_string(),\n            permalink: Some(\"https://slack.com/...\".to_string()),\n        };\n        let debug = format!(\"{:?}\", m);\n        assert!(debug.contains(\"SlackSearchMatch\"));\n    }\n\n    #[test]\n    fn test_slack_search_channel_clone() {\n        let channel = SlackSearchChannel {\n            id: \"C12345\".to_string(),\n            name: \"general\".to_string(),\n        };\n        let cloned = channel.clone();\n        assert_eq!(cloned.id, channel.id);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","util","config","mod.rs"],"content":"use anyhow::{Context, Result};\nuse serde::{Deserialize, Serialize};\nuse std::fs;\nuse std::path::PathBuf;\n\n#[cfg(test)]\nmod tests;\n\n#[derive(Debug, Serialize, Deserialize, Default)]\npub struct Credentials {\n    #[serde(default)]\n    pub github: Option\u003cGithubCredentials\u003e,\n    #[serde(default)]\n    pub jira: Option\u003cJiraCredentials\u003e,\n    #[serde(default)]\n    pub brave: Option\u003cBraveCredentials\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct BraveCredentials {\n    pub api_key: String,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct GithubCredentials {\n    pub token: String,\n    pub username: String,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone, Default)]\npub struct JiraCredentials {\n    pub access_token: String,\n    pub refresh_token: String,\n    pub expires_at: i64, // Unix timestamp\n    pub cloud_id: String,\n    pub site_url: String,\n}\n\n/// Returns the config directory path\npub fn config_dir() -\u003e Result\u003cPathBuf\u003e {\n    let proj_dirs = directories::ProjectDirs::from(\"\", \"\", \"hu\")\n        .context(\"Could not determine config directory\")?;\n    Ok(proj_dirs.config_dir().to_path_buf())\n}\n\n/// Returns the path to credentials.toml\nfn credentials_path() -\u003e Result\u003cPathBuf\u003e {\n    Ok(config_dir()?.join(\"credentials.toml\"))\n}\n\n/// Load credentials from config dir\npub fn load_credentials() -\u003e Result\u003cCredentials\u003e {\n    let path = credentials_path()?;\n    load_credentials_from(\u0026path)\n}\n\n/// Load credentials from a specific path (testable)\npub fn load_credentials_from(path: \u0026PathBuf) -\u003e Result\u003cCredentials\u003e {\n    if !path.exists() {\n        return Ok(Credentials::default());\n    }\n\n    let contents =\n        fs::read_to_string(path).with_context(|| format!(\"Failed to read {}\", path.display()))?;\n\n    toml::from_str(\u0026contents).with_context(|| format!(\"Failed to parse {}\", path.display()))\n}\n\n/// Save credentials to config dir\npub fn save_credentials(creds: \u0026Credentials) -\u003e Result\u003c()\u003e {\n    let path = credentials_path()?;\n    save_credentials_to(creds, \u0026path)\n}\n\n/// Save credentials to a specific path (testable)\npub fn save_credentials_to(creds: \u0026Credentials, path: \u0026PathBuf) -\u003e Result\u003c()\u003e {\n    if let Some(dir) = path.parent() {\n        fs::create_dir_all(dir)\n            .with_context(|| format!(\"Failed to create directory {}\", dir.display()))?;\n    }\n\n    let contents = toml::to_string_pretty(creds).context(\"Failed to serialize credentials\")?;\n\n    fs::write(path, contents).with_context(|| format!(\"Failed to write {}\", path.display()))?;\n\n    Ok(())\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":17}},{"line":41,"address":[],"length":0,"stats":{"Line":85}},{"line":43,"address":[],"length":0,"stats":{"Line":17}},{"line":47,"address":[],"length":0,"stats":{"Line":15}},{"line":48,"address":[],"length":0,"stats":{"Line":30}},{"line":52,"address":[],"length":0,"stats":{"Line":11}},{"line":53,"address":[],"length":0,"stats":{"Line":22}},{"line":54,"address":[],"length":0,"stats":{"Line":22}},{"line":58,"address":[],"length":0,"stats":{"Line":25}},{"line":59,"address":[],"length":0,"stats":{"Line":25}},{"line":60,"address":[],"length":0,"stats":{"Line":4}},{"line":63,"address":[],"length":0,"stats":{"Line":21}},{"line":64,"address":[],"length":0,"stats":{"Line":63}},{"line":66,"address":[],"length":0,"stats":{"Line":63}},{"line":70,"address":[],"length":0,"stats":{"Line":2}},{"line":71,"address":[],"length":0,"stats":{"Line":4}},{"line":72,"address":[],"length":0,"stats":{"Line":6}},{"line":76,"address":[],"length":0,"stats":{"Line":11}},{"line":77,"address":[],"length":0,"stats":{"Line":22}},{"line":78,"address":[],"length":0,"stats":{"Line":22}},{"line":79,"address":[],"length":0,"stats":{"Line":11}},{"line":82,"address":[],"length":0,"stats":{"Line":44}},{"line":84,"address":[],"length":0,"stats":{"Line":44}},{"line":86,"address":[],"length":0,"stats":{"Line":11}}],"covered":24,"coverable":24},{"path":["/","Users","chi","Projects","hu","src","util","config","tests.rs"],"content":"use super::*;\n\n#[test]\nfn config_dir_returns_path() {\n    let dir = config_dir().unwrap();\n    assert!(dir.to_string_lossy().contains(\"hu\"));\n}\n\n#[test]\nfn credentials_path_is_in_config_dir() {\n    let path = credentials_path().unwrap();\n    assert!(path.to_string_lossy().contains(\"hu\"));\n    assert!(path.to_string_lossy().ends_with(\"credentials.toml\"));\n}\n\n#[test]\nfn credentials_serialize_deserialize() {\n    let creds = Credentials {\n        github: Some(GithubCredentials {\n            token: \"test_token\".to_string(),\n            username: \"testuser\".to_string(),\n        }),\n        jira: None,\n        brave: None,\n    };\n\n    let toml_str = toml::to_string(\u0026creds).unwrap();\n    let parsed: Credentials = toml::from_str(\u0026toml_str).unwrap();\n\n    assert!(parsed.github.is_some());\n    let gh = parsed.github.unwrap();\n    assert_eq!(gh.token, \"test_token\");\n    assert_eq!(gh.username, \"testuser\");\n}\n\n#[test]\nfn empty_credentials_default() {\n    let creds = Credentials::default();\n    assert!(creds.github.is_none());\n    assert!(creds.jira.is_none());\n}\n\n#[test]\nfn credentials_without_github_parses() {\n    let toml_str = \"\";\n    let creds: Credentials = toml::from_str(toml_str).unwrap();\n    assert!(creds.github.is_none());\n    assert!(creds.jira.is_none());\n}\n\n#[test]\nfn credentials_toml_format() {\n    let creds = Credentials {\n        github: Some(GithubCredentials {\n            token: \"ghp_abc123\".to_string(),\n            username: \"octocat\".to_string(),\n        }),\n        jira: None,\n        brave: None,\n    };\n\n    let toml_str = toml::to_string_pretty(\u0026creds).unwrap();\n    assert!(toml_str.contains(\"[github]\"));\n    assert!(toml_str.contains(\"token = \\\"ghp_abc123\\\"\"));\n    assert!(toml_str.contains(\"username = \\\"octocat\\\"\"));\n}\n\n#[test]\nfn github_credentials_clone() {\n    let creds = GithubCredentials {\n        token: \"token\".to_string(),\n        username: \"user\".to_string(),\n    };\n    let cloned = creds.clone();\n    assert_eq!(cloned.token, creds.token);\n    assert_eq!(cloned.username, creds.username);\n}\n\n#[test]\nfn credentials_debug_format() {\n    let creds = Credentials::default();\n    let debug_str = format!(\"{:?}\", creds);\n    assert!(debug_str.contains(\"Credentials\"));\n}\n\n#[test]\nfn github_credentials_debug_format() {\n    let creds = GithubCredentials {\n        token: \"token\".to_string(),\n        username: \"user\".to_string(),\n    };\n    let debug_str = format!(\"{:?}\", creds);\n    assert!(debug_str.contains(\"GithubCredentials\"));\n}\n\n#[test]\nfn load_credentials_handles_missing_file() {\n    // load_credentials returns Ok with default if file doesn't exist\n    // This tests the path exists check\n    let result = load_credentials();\n    // Either returns existing creds or default\n    assert!(result.is_ok());\n}\n\n#[test]\nfn credentials_path_parent_exists() {\n    let path = credentials_path().unwrap();\n    let parent = path.parent();\n    assert!(parent.is_some());\n}\n\n#[test]\nfn config_dir_is_absolute() {\n    let dir = config_dir().unwrap();\n    assert!(dir.is_absolute());\n}\n\n// File I/O tests with temp files\n#[test]\nfn save_and_load_credentials_roundtrip() {\n    let temp_dir = std::env::temp_dir().join(\"hu_test_config\");\n    let _ = std::fs::remove_dir_all(\u0026temp_dir); // Clean up from previous runs\n    let path = temp_dir.join(\"credentials.toml\");\n\n    let creds = Credentials {\n        github: Some(GithubCredentials {\n            token: \"test_token_123\".to_string(),\n            username: \"testuser\".to_string(),\n        }),\n        jira: None,\n        brave: None,\n    };\n\n    // Save\n    save_credentials_to(\u0026creds, \u0026path).unwrap();\n    assert!(path.exists());\n\n    // Load\n    let loaded = load_credentials_from(\u0026path).unwrap();\n    assert!(loaded.github.is_some());\n    let gh = loaded.github.unwrap();\n    assert_eq!(gh.token, \"test_token_123\");\n    assert_eq!(gh.username, \"testuser\");\n\n    // Cleanup\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n}\n\n#[test]\nfn load_credentials_from_missing_file() {\n    let path = PathBuf::from(\"/nonexistent/path/credentials.toml\");\n    let creds = load_credentials_from(\u0026path).unwrap();\n    assert!(creds.github.is_none());\n}\n\n#[test]\nfn load_credentials_from_empty_file() {\n    let temp_dir = std::env::temp_dir().join(\"hu_test_empty\");\n    let _ = std::fs::create_dir_all(\u0026temp_dir);\n    let path = temp_dir.join(\"credentials.toml\");\n\n    std::fs::write(\u0026path, \"\").unwrap();\n    let creds = load_credentials_from(\u0026path).unwrap();\n    assert!(creds.github.is_none());\n\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n}\n\n#[test]\nfn load_credentials_from_partial_file() {\n    let temp_dir = std::env::temp_dir().join(\"hu_test_partial\");\n    let _ = std::fs::create_dir_all(\u0026temp_dir);\n    let path = temp_dir.join(\"credentials.toml\");\n\n    std::fs::write(\u0026path, \"[github]\\ntoken = \\\"abc\\\"\\nusername = \\\"user\\\"\").unwrap();\n    let creds = load_credentials_from(\u0026path).unwrap();\n    assert!(creds.github.is_some());\n    assert_eq!(creds.github.unwrap().token, \"abc\");\n\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n}\n\n#[test]\nfn save_credentials_creates_parent_dirs() {\n    let temp_dir = std::env::temp_dir().join(\"hu_test_nested/a/b/c\");\n    let _ = std::fs::remove_dir_all(std::env::temp_dir().join(\"hu_test_nested\"));\n    let path = temp_dir.join(\"credentials.toml\");\n\n    let creds = Credentials::default();\n    save_credentials_to(\u0026creds, \u0026path).unwrap();\n    assert!(path.exists());\n\n    let _ = std::fs::remove_dir_all(std::env::temp_dir().join(\"hu_test_nested\"));\n}\n\n#[test]\nfn save_credentials_overwrites_existing() {\n    let temp_dir = std::env::temp_dir().join(\"hu_test_overwrite\");\n    let _ = std::fs::create_dir_all(\u0026temp_dir);\n    let path = temp_dir.join(\"credentials.toml\");\n\n    // Save first version\n    let creds1 = Credentials {\n        github: Some(GithubCredentials {\n            token: \"old\".to_string(),\n            username: \"old\".to_string(),\n        }),\n        jira: None,\n        brave: None,\n    };\n    save_credentials_to(\u0026creds1, \u0026path).unwrap();\n\n    // Save second version\n    let creds2 = Credentials {\n        github: Some(GithubCredentials {\n            token: \"new\".to_string(),\n            username: \"new\".to_string(),\n        }),\n        jira: None,\n        brave: None,\n    };\n    save_credentials_to(\u0026creds2, \u0026path).unwrap();\n\n    // Load and verify\n    let loaded = load_credentials_from(\u0026path).unwrap();\n    assert_eq!(loaded.github.unwrap().token, \"new\");\n\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n}\n\n// JiraCredentials tests\n#[test]\nfn jira_credentials_default() {\n    let creds = JiraCredentials::default();\n    assert_eq!(creds.access_token, \"\");\n    assert_eq!(creds.refresh_token, \"\");\n    assert_eq!(creds.expires_at, 0);\n    assert_eq!(creds.cloud_id, \"\");\n    assert_eq!(creds.site_url, \"\");\n}\n\n#[test]\nfn jira_credentials_clone() {\n    let creds = JiraCredentials {\n        access_token: \"access\".to_string(),\n        refresh_token: \"refresh\".to_string(),\n        expires_at: 1234567890,\n        cloud_id: \"cloud123\".to_string(),\n        site_url: \"https://example.atlassian.net\".to_string(),\n    };\n    let cloned = creds.clone();\n    assert_eq!(cloned.access_token, creds.access_token);\n    assert_eq!(cloned.refresh_token, creds.refresh_token);\n    assert_eq!(cloned.expires_at, creds.expires_at);\n    assert_eq!(cloned.cloud_id, creds.cloud_id);\n    assert_eq!(cloned.site_url, creds.site_url);\n}\n\n#[test]\nfn jira_credentials_debug_format() {\n    let creds = JiraCredentials::default();\n    let debug_str = format!(\"{:?}\", creds);\n    assert!(debug_str.contains(\"JiraCredentials\"));\n}\n\n#[test]\nfn jira_credentials_serialize_deserialize() {\n    let creds = Credentials {\n        github: None,\n        jira: Some(JiraCredentials {\n            access_token: \"access_token\".to_string(),\n            refresh_token: \"refresh_token\".to_string(),\n            expires_at: 1234567890,\n            cloud_id: \"cloud123\".to_string(),\n            site_url: \"https://example.atlassian.net\".to_string(),\n        }),\n        brave: None,\n    };\n\n    let toml_str = toml::to_string(\u0026creds).unwrap();\n    let parsed: Credentials = toml::from_str(\u0026toml_str).unwrap();\n\n    assert!(parsed.jira.is_some());\n    let jira = parsed.jira.unwrap();\n    assert_eq!(jira.access_token, \"access_token\");\n    assert_eq!(jira.refresh_token, \"refresh_token\");\n    assert_eq!(jira.expires_at, 1234567890);\n    assert_eq!(jira.cloud_id, \"cloud123\");\n    assert_eq!(jira.site_url, \"https://example.atlassian.net\");\n}\n\n#[test]\nfn jira_credentials_toml_format() {\n    let creds = Credentials {\n        github: None,\n        jira: Some(JiraCredentials {\n            access_token: \"test_access\".to_string(),\n            refresh_token: \"test_refresh\".to_string(),\n            expires_at: 9876543210,\n            cloud_id: \"test_cloud\".to_string(),\n            site_url: \"https://test.atlassian.net\".to_string(),\n        }),\n        brave: None,\n    };\n\n    let toml_str = toml::to_string_pretty(\u0026creds).unwrap();\n    assert!(toml_str.contains(\"[jira]\"));\n    assert!(toml_str.contains(\"access_token = \\\"test_access\\\"\"));\n    assert!(toml_str.contains(\"refresh_token = \\\"test_refresh\\\"\"));\n    assert!(toml_str.contains(\"expires_at = 9876543210\"));\n    assert!(toml_str.contains(\"cloud_id = \\\"test_cloud\\\"\"));\n    assert!(toml_str.contains(\"site_url = \\\"https://test.atlassian.net\\\"\"));\n}\n\n#[test]\nfn save_and_load_jira_credentials_roundtrip() {\n    let temp_dir = std::env::temp_dir().join(\"hu_test_jira_config\");\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n    let path = temp_dir.join(\"credentials.toml\");\n\n    let creds = Credentials {\n        github: None,\n        jira: Some(JiraCredentials {\n            access_token: \"jira_access\".to_string(),\n            refresh_token: \"jira_refresh\".to_string(),\n            expires_at: 1111111111,\n            cloud_id: \"jira_cloud\".to_string(),\n            site_url: \"https://jira.atlassian.net\".to_string(),\n        }),\n        brave: None,\n    };\n\n    save_credentials_to(\u0026creds, \u0026path).unwrap();\n    assert!(path.exists());\n\n    let loaded = load_credentials_from(\u0026path).unwrap();\n    assert!(loaded.jira.is_some());\n    let jira = loaded.jira.unwrap();\n    assert_eq!(jira.access_token, \"jira_access\");\n    assert_eq!(jira.refresh_token, \"jira_refresh\");\n    assert_eq!(jira.expires_at, 1111111111);\n    assert_eq!(jira.cloud_id, \"jira_cloud\");\n    assert_eq!(jira.site_url, \"https://jira.atlassian.net\");\n\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n}\n\n#[test]\nfn credentials_with_both_github_and_jira() {\n    let creds = Credentials {\n        github: Some(GithubCredentials {\n            token: \"gh_token\".to_string(),\n            username: \"ghuser\".to_string(),\n        }),\n        jira: Some(JiraCredentials {\n            access_token: \"jira_access\".to_string(),\n            refresh_token: \"jira_refresh\".to_string(),\n            expires_at: 2222222222,\n            cloud_id: \"both_cloud\".to_string(),\n            site_url: \"https://both.atlassian.net\".to_string(),\n        }),\n        brave: None,\n    };\n\n    let toml_str = toml::to_string(\u0026creds).unwrap();\n    let parsed: Credentials = toml::from_str(\u0026toml_str).unwrap();\n\n    assert!(parsed.github.is_some());\n    assert!(parsed.jira.is_some());\n    assert_eq!(parsed.github.unwrap().token, \"gh_token\");\n    assert_eq!(parsed.jira.unwrap().access_token, \"jira_access\");\n}\n\n// BraveCredentials tests\n#[test]\nfn brave_credentials_clone() {\n    let creds = BraveCredentials {\n        api_key: \"brave_key\".to_string(),\n    };\n    let cloned = creds.clone();\n    assert_eq!(cloned.api_key, creds.api_key);\n}\n\n#[test]\nfn brave_credentials_debug_format() {\n    let creds = BraveCredentials {\n        api_key: \"key\".to_string(),\n    };\n    let debug_str = format!(\"{:?}\", creds);\n    assert!(debug_str.contains(\"BraveCredentials\"));\n}\n\n#[test]\nfn brave_credentials_serialize_deserialize() {\n    let creds = Credentials {\n        github: None,\n        jira: None,\n        brave: Some(BraveCredentials {\n            api_key: \"test_api_key\".to_string(),\n        }),\n    };\n\n    let toml_str = toml::to_string(\u0026creds).unwrap();\n    let parsed: Credentials = toml::from_str(\u0026toml_str).unwrap();\n\n    assert!(parsed.brave.is_some());\n    let brave = parsed.brave.unwrap();\n    assert_eq!(brave.api_key, \"test_api_key\");\n}\n\n#[test]\nfn brave_credentials_toml_format() {\n    let creds = Credentials {\n        github: None,\n        jira: None,\n        brave: Some(BraveCredentials {\n            api_key: \"brave_api_key_123\".to_string(),\n        }),\n    };\n\n    let toml_str = toml::to_string_pretty(\u0026creds).unwrap();\n    assert!(toml_str.contains(\"[brave]\"));\n    assert!(toml_str.contains(\"api_key = \\\"brave_api_key_123\\\"\"));\n}\n\n#[test]\nfn save_and_load_brave_credentials_roundtrip() {\n    let temp_dir = std::env::temp_dir().join(\"hu_test_brave_config\");\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n    let path = temp_dir.join(\"credentials.toml\");\n\n    let creds = Credentials {\n        github: None,\n        jira: None,\n        brave: Some(BraveCredentials {\n            api_key: \"brave_roundtrip_key\".to_string(),\n        }),\n    };\n\n    save_credentials_to(\u0026creds, \u0026path).unwrap();\n    assert!(path.exists());\n\n    let loaded = load_credentials_from(\u0026path).unwrap();\n    assert!(loaded.brave.is_some());\n    let brave = loaded.brave.unwrap();\n    assert_eq!(brave.api_key, \"brave_roundtrip_key\");\n\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n}\n\n#[test]\nfn credentials_with_all_three() {\n    let creds = Credentials {\n        github: Some(GithubCredentials {\n            token: \"gh\".to_string(),\n            username: \"user\".to_string(),\n        }),\n        jira: Some(JiraCredentials {\n            access_token: \"jira\".to_string(),\n            refresh_token: \"refresh\".to_string(),\n            expires_at: 123,\n            cloud_id: \"cloud\".to_string(),\n            site_url: \"https://x.atlassian.net\".to_string(),\n        }),\n        brave: Some(BraveCredentials {\n            api_key: \"brave\".to_string(),\n        }),\n    };\n\n    let toml_str = toml::to_string(\u0026creds).unwrap();\n    let parsed: Credentials = toml::from_str(\u0026toml_str).unwrap();\n\n    assert!(parsed.github.is_some());\n    assert!(parsed.jira.is_some());\n    assert!(parsed.brave.is_some());\n    assert_eq!(parsed.brave.unwrap().api_key, \"brave\");\n}\n\n#[test]\nfn save_credentials_and_load_integration() {\n    // Integration test: save and load using actual config path\n    // First load existing to preserve it\n    let original = load_credentials().ok();\n\n    // Save test credentials\n    let test_creds = Credentials {\n        github: Some(GithubCredentials {\n            token: \"integration_test_token\".to_string(),\n            username: \"integration_test_user\".to_string(),\n        }),\n        jira: None,\n        brave: None,\n    };\n    save_credentials(\u0026test_creds).unwrap();\n\n    // Load and verify\n    let loaded = load_credentials().unwrap();\n    assert!(loaded.github.is_some());\n    assert_eq!(\n        loaded.github.as_ref().unwrap().token,\n        \"integration_test_token\"\n    );\n\n    // Restore original if it existed, or save empty\n    if let Some(orig) = original {\n        save_credentials(\u0026orig).unwrap();\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","util","mod.rs"],"content":"mod config;\n\npub use config::{\n    load_credentials, save_credentials, BraveCredentials, GithubCredentials, JiraCredentials,\n};\n\n#[allow(unused_imports)]\npub use config::{config_dir, Credentials};\n\n// These are used in tests\n#[allow(unused_imports)]\npub use config::{load_credentials_from, save_credentials_to};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","utils","cli.rs"],"content":"use clap::{Args, Subcommand};\n\n#[derive(Debug, Subcommand)]\npub enum UtilsCommand {\n    /// Fetch URL and convert to markdown\n    FetchHtml(FetchHtmlArgs),\n    /// Smart grep with token-saving options\n    Grep(GrepArgs),\n    /// Web search using Brave Search API\n    WebSearch(WebSearchArgs),\n    /// Build heading index for markdown files\n    DocsIndex(DocsIndexArgs),\n    /// Search docs index for matching sections\n    DocsSearch(DocsSearchArgs),\n    /// Extract a section from a markdown file\n    DocsSection(DocsSectionArgs),\n}\n\n#[derive(Debug, Args)]\npub struct FetchHtmlArgs {\n    /// URL to fetch\n    pub url: String,\n\n    /// Extract main content only (strip nav, footer, scripts, ads)\n    #[arg(long, short = 'c')]\n    pub content: bool,\n\n    /// Return summary (first N paragraphs + headings)\n    #[arg(long, short = 's')]\n    pub summary: bool,\n\n    /// Extract links only [text](url)\n    #[arg(long, short = 'l')]\n    pub links: bool,\n\n    /// Extract headings only (document outline)\n    #[arg(long, short = 'H')]\n    pub headings: bool,\n\n    /// CSS selector to target (e.g., \"article\", \"main\", \".content\")\n    #[arg(long)]\n    pub selector: Option\u003cString\u003e,\n\n    /// Output to file instead of stdout\n    #[arg(long, short = 'o')]\n    pub output: Option\u003cString\u003e,\n\n    /// Raw output (no filtering)\n    #[arg(long, short = 'r')]\n    pub raw: bool,\n}\n\n#[derive(Debug, Args)]\npub struct GrepArgs {\n    /// Pattern to search for (regex)\n    pub pattern: String,\n\n    /// Path to search (default: current directory)\n    #[arg(default_value = \".\")]\n    pub path: String,\n\n    /// Return file:line references only (no content)\n    #[arg(long)]\n    pub refs: bool,\n\n    /// Deduplicate similar matches\n    #[arg(long)]\n    pub unique: bool,\n\n    /// Sort by relevance (match density)\n    #[arg(long)]\n    pub ranked: bool,\n\n    /// Limit number of results\n    #[arg(long, short = 'n')]\n    pub limit: Option\u003cusize\u003e,\n\n    /// Show function/class signature only (not body)\n    #[arg(long)]\n    pub signature: bool,\n\n    /// File glob pattern (e.g., \"*.rs\", \"*.py\")\n    #[arg(long, short = 'g')]\n    pub glob: Option\u003cString\u003e,\n\n    /// Case insensitive search\n    #[arg(long, short = 'i')]\n    pub ignore_case: bool,\n\n    /// Include hidden files\n    #[arg(long)]\n    pub hidden: bool,\n}\n\n#[derive(Debug, Args)]\npub struct WebSearchArgs {\n    /// Search query\n    pub query: String,\n\n    /// Number of results to fetch content from (default: 3)\n    #[arg(long, short = 'n', default_value = \"3\")]\n    pub results: usize,\n\n    /// Only show search results (don't fetch content)\n    #[arg(long, short = 'l')]\n    pub list: bool,\n\n    /// Output to file instead of stdout\n    #[arg(long, short = 'o')]\n    pub output: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Args)]\npub struct DocsIndexArgs {\n    /// Directory to index\n    #[arg(default_value = \".\")]\n    pub path: String,\n\n    /// Output index to file (JSON)\n    #[arg(long, short = 'o')]\n    pub output: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Args)]\npub struct DocsSearchArgs {\n    /// Path to index file (JSON)\n    pub index: String,\n\n    /// Search query\n    pub query: String,\n\n    /// Limit number of results\n    #[arg(long, short = 'n')]\n    pub limit: Option\u003cusize\u003e,\n}\n\n#[derive(Debug, Args)]\npub struct DocsSectionArgs {\n    /// Markdown file path\n    pub file: String,\n\n    /// Section heading to extract\n    pub heading: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","utils","docs_index","mod.rs"],"content":"use anyhow::{Context, Result};\nuse regex::Regex;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::Path;\n\n#[cfg(test)]\nmod tests;\n\n/// Section in a markdown file\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct Section {\n    /// Heading text (without # prefix)\n    pub heading: String,\n    /// Heading level (1-6)\n    pub level: u8,\n    /// Start line (1-indexed)\n    pub start_line: usize,\n    /// End line (exclusive, 0 means end of file)\n    pub end_line: usize,\n}\n\nimpl Section {\n    pub fn new(heading: String, level: u8, start_line: usize) -\u003e Self {\n        Self {\n            heading,\n            level,\n            start_line,\n            end_line: 0,\n        }\n    }\n}\n\n/// Index of a single markdown file\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct FileIndex {\n    /// File path (relative to index root)\n    pub path: String,\n    /// Total line count\n    pub line_count: usize,\n    /// Sections in the file\n    pub sections: Vec\u003cSection\u003e,\n}\n\nimpl FileIndex {\n    pub fn new(path: String, line_count: usize) -\u003e Self {\n        Self {\n            path,\n            line_count,\n            sections: Vec::new(),\n        }\n    }\n}\n\n/// Index of all markdown files in a directory\n#[derive(Debug, Clone, Serialize, Deserialize, Default, PartialEq)]\npub struct DocsIndex {\n    /// Root directory path\n    pub root: String,\n    /// Map of relative path to file index\n    pub files: HashMap\u003cString, FileIndex\u003e,\n}\n\nimpl DocsIndex {\n    pub fn new(root: String) -\u003e Self {\n        Self {\n            root,\n            files: HashMap::new(),\n        }\n    }\n\n    /// Add a file index\n    pub fn add_file(\u0026mut self, index: FileIndex) {\n        self.files.insert(index.path.clone(), index);\n    }\n\n    /// Get file count\n    pub fn file_count(\u0026self) -\u003e usize {\n        self.files.len()\n    }\n\n    /// Get total section count\n    pub fn section_count(\u0026self) -\u003e usize {\n        self.files.values().map(|f| f.sections.len()).sum()\n    }\n}\n\n/// Build an index for markdown files in a directory\npub fn build_index(dir: \u0026str) -\u003e Result\u003cDocsIndex\u003e {\n    let root = Path::new(dir);\n    if !root.is_dir() {\n        anyhow::bail!(\"Not a directory: {}\", dir);\n    }\n\n    let mut index = DocsIndex::new(dir.to_string());\n    index_directory(root, root, \u0026mut index)?;\n\n    Ok(index)\n}\n\n/// Recursively index a directory\nfn index_directory(root: \u0026Path, dir: \u0026Path, index: \u0026mut DocsIndex) -\u003e Result\u003c()\u003e {\n    let entries = fs::read_dir(dir)\n        .with_context(|| format!(\"Failed to read directory: {}\", dir.display()))?;\n\n    for entry in entries.flatten() {\n        let path = entry.path();\n        let name = path.file_name().and_then(|n| n.to_str()).unwrap_or(\"\");\n\n        // Skip hidden directories\n        if name.starts_with('.') {\n            continue;\n        }\n\n        if path.is_dir() {\n            index_directory(root, \u0026path, index)?;\n        } else if let Some(ext) = path.extension().and_then(|e| e.to_str()) {\n            if ext == \"md\" || ext == \"markdown\" {\n                let file_index = index_file(root, \u0026path)?;\n                index.add_file(file_index);\n            }\n        }\n    }\n\n    Ok(())\n}\n\n/// Index a single markdown file\nfn index_file(root: \u0026Path, path: \u0026Path) -\u003e Result\u003cFileIndex\u003e {\n    let content = fs::read_to_string(path)\n        .with_context(|| format!(\"Failed to read file: {}\", path.display()))?;\n\n    let relative_path = path\n        .strip_prefix(root)\n        .map(|p| p.to_string_lossy().to_string())\n        .unwrap_or_else(|_| path.to_string_lossy().to_string());\n\n    let line_count = content.lines().count();\n    let mut file_index = FileIndex::new(relative_path, line_count);\n\n    // Parse headings\n    let heading_re = Regex::new(r\"^(#{1,6})\\s+(.+)$\").unwrap();\n    let mut sections: Vec\u003cSection\u003e = Vec::new();\n\n    for (line_num, line) in content.lines().enumerate() {\n        let line_num = line_num + 1;\n\n        if let Some(caps) = heading_re.captures(line) {\n            let level = caps.get(1).unwrap().as_str().len() as u8;\n            let heading = caps.get(2).unwrap().as_str().to_string();\n\n            // Close the most recent unclosed section\n            // Each section ends when the next heading starts, regardless of level\n            // This gives simple non-overlapping ranges for extraction\n            if let Some(last) = sections.iter_mut().rev().find(|s| s.end_line == 0) {\n                last.end_line = line_num;\n            }\n\n            sections.push(Section::new(heading, level, line_num));\n        }\n    }\n\n    // Close remaining open sections at end of file\n    for section in \u0026mut sections {\n        if section.end_line == 0 {\n            section.end_line = line_count + 1;\n        }\n    }\n\n    file_index.sections = sections;\n    Ok(file_index)\n}\n\n/// Save index to JSON file\npub fn save_index(index: \u0026DocsIndex, path: \u0026str) -\u003e Result\u003c()\u003e {\n    let json = serde_json::to_string_pretty(index).context(\"Failed to serialize index\")?;\n    fs::write(path, json).with_context(|| format!(\"Failed to write index to {}\", path))?;\n    Ok(())\n}\n\n/// Load index from JSON file\npub fn load_index(path: \u0026str) -\u003e Result\u003cDocsIndex\u003e {\n    let content =\n        fs::read_to_string(path).with_context(|| format!(\"Failed to read index from {}\", path))?;\n    serde_json::from_str(\u0026content).with_context(|| format!(\"Failed to parse index from {}\", path))\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":33}},{"line":47,"address":[],"length":0,"stats":{"Line":30}},{"line":51,"address":[],"length":0,"stats":{"Line":30}},{"line":66,"address":[],"length":0,"stats":{"Line":17}},{"line":69,"address":[],"length":0,"stats":{"Line":17}},{"line":74,"address":[],"length":0,"stats":{"Line":26}},{"line":75,"address":[],"length":0,"stats":{"Line":130}},{"line":79,"address":[],"length":0,"stats":{"Line":4}},{"line":80,"address":[],"length":0,"stats":{"Line":8}},{"line":84,"address":[],"length":0,"stats":{"Line":1}},{"line":85,"address":[],"length":0,"stats":{"Line":8}},{"line":90,"address":[],"length":0,"stats":{"Line":6}},{"line":91,"address":[],"length":0,"stats":{"Line":18}},{"line":92,"address":[],"length":0,"stats":{"Line":6}},{"line":93,"address":[],"length":0,"stats":{"Line":2}},{"line":96,"address":[],"length":0,"stats":{"Line":20}},{"line":97,"address":[],"length":0,"stats":{"Line":20}},{"line":99,"address":[],"length":0,"stats":{"Line":5}},{"line":103,"address":[],"length":0,"stats":{"Line":10}},{"line":104,"address":[],"length":0,"stats":{"Line":30}},{"line":105,"address":[],"length":0,"stats":{"Line":10}},{"line":107,"address":[],"length":0,"stats":{"Line":36}},{"line":108,"address":[],"length":0,"stats":{"Line":48}},{"line":109,"address":[],"length":0,"stats":{"Line":112}},{"line":112,"address":[],"length":0,"stats":{"Line":32}},{"line":113,"address":[],"length":0,"stats":{"Line":1}},{"line":116,"address":[],"length":0,"stats":{"Line":15}},{"line":117,"address":[],"length":0,"stats":{"Line":20}},{"line":118,"address":[],"length":0,"stats":{"Line":50}},{"line":119,"address":[],"length":0,"stats":{"Line":10}},{"line":120,"address":[],"length":0,"stats":{"Line":40}},{"line":121,"address":[],"length":0,"stats":{"Line":30}},{"line":126,"address":[],"length":0,"stats":{"Line":10}},{"line":130,"address":[],"length":0,"stats":{"Line":10}},{"line":131,"address":[],"length":0,"stats":{"Line":30}},{"line":132,"address":[],"length":0,"stats":{"Line":10}},{"line":134,"address":[],"length":0,"stats":{"Line":20}},{"line":135,"address":[],"length":0,"stats":{"Line":20}},{"line":136,"address":[],"length":0,"stats":{"Line":30}},{"line":137,"address":[],"length":0,"stats":{"Line":10}},{"line":139,"address":[],"length":0,"stats":{"Line":30}},{"line":140,"address":[],"length":0,"stats":{"Line":40}},{"line":143,"address":[],"length":0,"stats":{"Line":40}},{"line":144,"address":[],"length":0,"stats":{"Line":30}},{"line":146,"address":[],"length":0,"stats":{"Line":180}},{"line":147,"address":[],"length":0,"stats":{"Line":160}},{"line":149,"address":[],"length":0,"stats":{"Line":185}},{"line":150,"address":[],"length":0,"stats":{"Line":75}},{"line":151,"address":[],"length":0,"stats":{"Line":100}},{"line":156,"address":[],"length":0,"stats":{"Line":95}},{"line":157,"address":[],"length":0,"stats":{"Line":15}},{"line":160,"address":[],"length":0,"stats":{"Line":150}},{"line":165,"address":[],"length":0,"stats":{"Line":60}},{"line":166,"address":[],"length":0,"stats":{"Line":35}},{"line":167,"address":[],"length":0,"stats":{"Line":10}},{"line":171,"address":[],"length":0,"stats":{"Line":20}},{"line":172,"address":[],"length":0,"stats":{"Line":10}},{"line":176,"address":[],"length":0,"stats":{"Line":1}},{"line":177,"address":[],"length":0,"stats":{"Line":4}},{"line":178,"address":[],"length":0,"stats":{"Line":4}},{"line":179,"address":[],"length":0,"stats":{"Line":1}},{"line":183,"address":[],"length":0,"stats":{"Line":2}},{"line":184,"address":[],"length":0,"stats":{"Line":1}},{"line":185,"address":[],"length":0,"stats":{"Line":9}},{"line":186,"address":[],"length":0,"stats":{"Line":3}}],"covered":65,"coverable":65},{"path":["/","Users","chi","Projects","hu","src","utils","docs_index","tests.rs"],"content":"use super::*;\n\n#[test]\nfn section_new() {\n    let section = Section::new(\"Test\".to_string(), 2, 5);\n    assert_eq!(section.heading, \"Test\");\n    assert_eq!(section.level, 2);\n    assert_eq!(section.start_line, 5);\n    assert_eq!(section.end_line, 0);\n}\n\n#[test]\nfn section_clone() {\n    let section = Section::new(\"Test\".to_string(), 1, 1);\n    let cloned = section.clone();\n    assert_eq!(section, cloned);\n}\n\n#[test]\nfn section_debug() {\n    let section = Section::new(\"Test\".to_string(), 1, 1);\n    let debug = format!(\"{:?}\", section);\n    assert!(debug.contains(\"Section\"));\n}\n\n#[test]\nfn section_serialize() {\n    let section = Section::new(\"Test\".to_string(), 1, 1);\n    let json = serde_json::to_string(\u0026section).unwrap();\n    let parsed: Section = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(section, parsed);\n}\n\n#[test]\nfn file_index_new() {\n    let index = FileIndex::new(\"test.md\".to_string(), 100);\n    assert_eq!(index.path, \"test.md\");\n    assert_eq!(index.line_count, 100);\n    assert!(index.sections.is_empty());\n}\n\n#[test]\nfn file_index_clone() {\n    let index = FileIndex::new(\"test.md\".to_string(), 50);\n    let cloned = index.clone();\n    assert_eq!(index, cloned);\n}\n\n#[test]\nfn file_index_debug() {\n    let index = FileIndex::new(\"test.md\".to_string(), 50);\n    let debug = format!(\"{:?}\", index);\n    assert!(debug.contains(\"FileIndex\"));\n}\n\n#[test]\nfn file_index_serialize() {\n    let mut index = FileIndex::new(\"test.md\".to_string(), 50);\n    index\n        .sections\n        .push(Section::new(\"Heading\".to_string(), 1, 1));\n    let json = serde_json::to_string(\u0026index).unwrap();\n    let parsed: FileIndex = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(index, parsed);\n}\n\n#[test]\nfn docs_index_new() {\n    let index = DocsIndex::new(\"./docs\".to_string());\n    assert_eq!(index.root, \"./docs\");\n    assert!(index.files.is_empty());\n}\n\n#[test]\nfn docs_index_default() {\n    let index = DocsIndex::default();\n    assert_eq!(index.root, \"\");\n    assert!(index.files.is_empty());\n}\n\n#[test]\nfn docs_index_add_file() {\n    let mut index = DocsIndex::new(\"./\".to_string());\n    index.add_file(FileIndex::new(\"test.md\".to_string(), 50));\n    assert_eq!(index.file_count(), 1);\n}\n\n#[test]\nfn docs_index_counts() {\n    let mut index = DocsIndex::new(\"./\".to_string());\n    let mut file1 = FileIndex::new(\"a.md\".to_string(), 50);\n    file1.sections.push(Section::new(\"H1\".to_string(), 1, 1));\n    file1.sections.push(Section::new(\"H2\".to_string(), 2, 10));\n    let mut file2 = FileIndex::new(\"b.md\".to_string(), 30);\n    file2.sections.push(Section::new(\"Intro\".to_string(), 1, 1));\n\n    index.add_file(file1);\n    index.add_file(file2);\n\n    assert_eq!(index.file_count(), 2);\n    assert_eq!(index.section_count(), 3);\n}\n\n#[test]\nfn docs_index_clone() {\n    let index = DocsIndex::new(\"./\".to_string());\n    let cloned = index.clone();\n    assert_eq!(index, cloned);\n}\n\n#[test]\nfn docs_index_debug() {\n    let index = DocsIndex::new(\"./\".to_string());\n    let debug = format!(\"{:?}\", index);\n    assert!(debug.contains(\"DocsIndex\"));\n}\n\n#[test]\nfn docs_index_serialize() {\n    let mut index = DocsIndex::new(\"./docs\".to_string());\n    index.add_file(FileIndex::new(\"test.md\".to_string(), 50));\n    let json = serde_json::to_string(\u0026index).unwrap();\n    let parsed: DocsIndex = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(index, parsed);\n}\n\n// Test indexing with temp directory\nfn create_test_docs(suffix: \u0026str) -\u003e std::path::PathBuf {\n    use std::sync::atomic::{AtomicU64, Ordering};\n    static COUNTER: AtomicU64 = AtomicU64::new(0);\n    let id = COUNTER.fetch_add(1, Ordering::SeqCst);\n\n    let tmp_dir = std::env::temp_dir().join(format!(\n        \"hu_docs_test_{}_{}_{suffix}\",\n        std::process::id(),\n        id\n    ));\n    let _ = std::fs::remove_dir_all(\u0026tmp_dir);\n    std::fs::create_dir_all(\u0026tmp_dir).unwrap();\n\n    // Create test markdown files\n    std::fs::write(\n        tmp_dir.join(\"README.md\"),\n        \"# Project\\n\\nIntroduction.\\n\\n## Setup\\n\\nSetup steps.\\n\\n## Usage\\n\\nUsage info.\\n\",\n    )\n    .unwrap();\n\n    std::fs::create_dir_all(tmp_dir.join(\"docs\")).unwrap();\n    std::fs::write(\n        tmp_dir.join(\"docs/api.md\"),\n        \"# API Reference\\n\\n## Endpoints\\n\\nList of endpoints.\\n\",\n    )\n    .unwrap();\n\n    tmp_dir\n}\n\nfn cleanup_test_docs(path: \u0026std::path::Path) {\n    let _ = std::fs::remove_dir_all(path);\n}\n\n#[test]\nfn build_index_basic() {\n    let tmp_dir = create_test_docs(\"test\");\n    let index = build_index(tmp_dir.to_str().unwrap()).unwrap();\n\n    assert_eq!(index.file_count(), 2);\n    assert!(index.files.contains_key(\"README.md\"));\n    assert!(index.files.contains_key(\"docs/api.md\"));\n\n    cleanup_test_docs(\u0026tmp_dir);\n}\n\n#[test]\nfn build_index_sections() {\n    let tmp_dir = create_test_docs(\"test\");\n    let index = build_index(tmp_dir.to_str().unwrap()).unwrap();\n\n    let readme = index.files.get(\"README.md\").unwrap();\n    assert_eq!(readme.sections.len(), 3);\n    assert_eq!(readme.sections[0].heading, \"Project\");\n    assert_eq!(readme.sections[0].level, 1);\n    assert_eq!(readme.sections[1].heading, \"Setup\");\n    assert_eq!(readme.sections[1].level, 2);\n\n    cleanup_test_docs(\u0026tmp_dir);\n}\n\n#[test]\nfn build_index_section_ranges() {\n    let tmp_dir = create_test_docs(\"test\");\n    let index = build_index(tmp_dir.to_str().unwrap()).unwrap();\n\n    let readme = index.files.get(\"README.md\").unwrap();\n    // \"# Project\" starts at line 1, ends when \"## Setup\" starts at line 5\n    assert_eq!(readme.sections[0].start_line, 1);\n    assert_eq!(readme.sections[0].end_line, 5);\n    // \"## Setup\" ends when \"## Usage\" starts\n    assert_eq!(readme.sections[1].start_line, 5);\n    assert_eq!(readme.sections[1].end_line, 9);\n\n    cleanup_test_docs(\u0026tmp_dir);\n}\n\n#[test]\nfn build_index_not_directory() {\n    let result = build_index(\"/nonexistent/path\");\n    assert!(result.is_err());\n}\n\n#[test]\nfn save_and_load_index() {\n    let tmp_dir = create_test_docs(\"test\");\n    let index = build_index(tmp_dir.to_str().unwrap()).unwrap();\n\n    let index_path = tmp_dir.join(\"index.json\");\n    save_index(\u0026index, index_path.to_str().unwrap()).unwrap();\n    assert!(index_path.exists());\n\n    let loaded = load_index(index_path.to_str().unwrap()).unwrap();\n    assert_eq!(index, loaded);\n\n    cleanup_test_docs(\u0026tmp_dir);\n}\n\n#[test]\nfn load_index_not_found() {\n    let result = load_index(\"/nonexistent/index.json\");\n    assert!(result.is_err());\n}\n\n#[test]\nfn build_index_skips_hidden_dirs() {\n    let tmp_dir = create_test_docs(\"hidden\");\n\n    // Create a hidden directory with a markdown file\n    let hidden_dir = tmp_dir.join(\".hidden\");\n    std::fs::create_dir_all(\u0026hidden_dir).unwrap();\n    std::fs::write(\n        hidden_dir.join(\"secret.md\"),\n        \"# Secret\\n\\nHidden content.\\n\",\n    )\n    .unwrap();\n\n    let index = build_index(tmp_dir.to_str().unwrap()).unwrap();\n\n    // Should have 2 files (README.md and docs/api.md) but not .hidden/secret.md\n    assert_eq!(index.file_count(), 2);\n    assert!(!index.files.contains_key(\".hidden/secret.md\"));\n\n    cleanup_test_docs(\u0026tmp_dir);\n}\n","traces":[{"line":128,"address":[],"length":0,"stats":{"Line":5}},{"line":131,"address":[],"length":0,"stats":{"Line":20}},{"line":133,"address":[],"length":0,"stats":{"Line":25}},{"line":134,"address":[],"length":0,"stats":{"Line":5}},{"line":135,"address":[],"length":0,"stats":{"Line":5}},{"line":136,"address":[],"length":0,"stats":{"Line":5}},{"line":138,"address":[],"length":0,"stats":{"Line":5}},{"line":139,"address":[],"length":0,"stats":{"Line":15}},{"line":143,"address":[],"length":0,"stats":{"Line":5}},{"line":148,"address":[],"length":0,"stats":{"Line":15}},{"line":150,"address":[],"length":0,"stats":{"Line":5}},{"line":155,"address":[],"length":0,"stats":{"Line":5}},{"line":158,"address":[],"length":0,"stats":{"Line":5}},{"line":159,"address":[],"length":0,"stats":{"Line":5}}],"covered":14,"coverable":14},{"path":["/","Users","chi","Projects","hu","src","utils","docs_search.rs"],"content":"use super::docs_index::DocsIndex;\n\n/// Search result\n#[derive(Debug, Clone, PartialEq)]\npub struct SearchResult {\n    /// File path (relative)\n    pub file: String,\n    /// Section heading\n    pub heading: String,\n    /// Section level\n    pub level: u8,\n    /// Start line in file\n    pub start_line: usize,\n    /// End line in file\n    pub end_line: usize,\n    /// Match score (higher is better)\n    pub score: u32,\n}\n\n/// Search the index for matching sections\npub fn search_index(index: \u0026DocsIndex, query: \u0026str) -\u003e Vec\u003cSearchResult\u003e {\n    let query_lower = query.to_lowercase();\n    let query_words: Vec\u003c\u0026str\u003e = query_lower.split_whitespace().collect();\n    let mut results = Vec::new();\n\n    for (path, file_index) in \u0026index.files {\n        for section in \u0026file_index.sections {\n            if let Some(score) = match_score(\u0026section.heading, \u0026query_lower, \u0026query_words) {\n                results.push(SearchResult {\n                    file: path.clone(),\n                    heading: section.heading.clone(),\n                    level: section.level,\n                    start_line: section.start_line,\n                    end_line: section.end_line,\n                    score,\n                });\n            }\n        }\n    }\n\n    // Sort by score (descending)\n    results.sort_by(|a, b| b.score.cmp(\u0026a.score));\n\n    results\n}\n\n/// Calculate match score for a heading against a query\nfn match_score(heading: \u0026str, query_lower: \u0026str, query_words: \u0026[\u0026str]) -\u003e Option\u003cu32\u003e {\n    let heading_lower = heading.to_lowercase();\n\n    // Exact match (highest priority)\n    if heading_lower == query_lower {\n        return Some(1000);\n    }\n\n    // Contains full query\n    if heading_lower.contains(query_lower) {\n        return Some(500);\n    }\n\n    // Word matching\n    let heading_words: Vec\u003c\u0026str\u003e = heading_lower.split_whitespace().collect();\n    let mut matched_words = 0;\n\n    for qw in query_words {\n        for hw in \u0026heading_words {\n            if hw.contains(qw) || qw.contains(hw) {\n                matched_words += 1;\n                break;\n            }\n        }\n    }\n\n    if matched_words \u003e 0 {\n        // Score based on percentage of query words matched\n        let score = (matched_words * 100) / query_words.len().max(1);\n        return Some(score as u32);\n    }\n\n    None\n}\n\n/// Format search results for display\npub fn format_results(results: \u0026[SearchResult], limit: Option\u003cusize\u003e) -\u003e String {\n    if results.is_empty() {\n        return \"No matching sections found\".to_string();\n    }\n\n    let results = if let Some(n) = limit {\n        \u0026results[..n.min(results.len())]\n    } else {\n        results\n    };\n\n    let mut output = Vec::new();\n\n    for result in results {\n        let level_marker = \"#\".repeat(result.level as usize);\n        output.push(format!(\n            \"{} {} ({}:L{}-{})\",\n            level_marker, result.heading, result.file, result.start_line, result.end_line\n        ));\n    }\n\n    output.join(\"\\n\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::utils::docs_index::{FileIndex, Section};\n\n    fn test_index() -\u003e DocsIndex {\n        let mut index = DocsIndex::new(\"./\".to_string());\n\n        let mut readme = FileIndex::new(\"README.md\".to_string(), 50);\n        readme.sections.push(Section {\n            heading: \"Getting Started\".to_string(),\n            level: 1,\n            start_line: 1,\n            end_line: 20,\n        });\n        readme.sections.push(Section {\n            heading: \"Installation\".to_string(),\n            level: 2,\n            start_line: 5,\n            end_line: 15,\n        });\n        readme.sections.push(Section {\n            heading: \"Configuration\".to_string(),\n            level: 2,\n            start_line: 15,\n            end_line: 20,\n        });\n\n        let mut api = FileIndex::new(\"api.md\".to_string(), 100);\n        api.sections.push(Section {\n            heading: \"API Reference\".to_string(),\n            level: 1,\n            start_line: 1,\n            end_line: 100,\n        });\n        api.sections.push(Section {\n            heading: \"Getting Started with API\".to_string(),\n            level: 2,\n            start_line: 10,\n            end_line: 50,\n        });\n\n        index.add_file(readme);\n        index.add_file(api);\n\n        index\n    }\n\n    #[test]\n    fn search_exact_match() {\n        let index = test_index();\n        let results = search_index(\u0026index, \"Installation\");\n        assert!(!results.is_empty());\n        assert_eq!(results[0].heading, \"Installation\");\n        assert_eq!(results[0].score, 1000);\n    }\n\n    #[test]\n    fn search_case_insensitive() {\n        let index = test_index();\n        let results = search_index(\u0026index, \"installation\");\n        assert!(!results.is_empty());\n        assert_eq!(results[0].heading, \"Installation\");\n    }\n\n    #[test]\n    fn search_contains() {\n        let index = test_index();\n        let results = search_index(\u0026index, \"Config\");\n        assert!(!results.is_empty());\n        assert!(results.iter().any(|r| r.heading == \"Configuration\"));\n    }\n\n    #[test]\n    fn search_word_match() {\n        let index = test_index();\n        let results = search_index(\u0026index, \"Getting\");\n        assert_eq!(results.len(), 2); // \"Getting Started\" and \"Getting Started with API\"\n    }\n\n    #[test]\n    fn search_no_match() {\n        let index = test_index();\n        let results = search_index(\u0026index, \"nonexistent\");\n        assert!(results.is_empty());\n    }\n\n    #[test]\n    fn search_sorted_by_score() {\n        let index = test_index();\n        let results = search_index(\u0026index, \"Installation\");\n        // Exact match should be first\n        assert!(results[0].score \u003e= results.last().map(|r| r.score).unwrap_or(0));\n    }\n\n    #[test]\n    fn search_result_clone() {\n        let result = SearchResult {\n            file: \"test.md\".to_string(),\n            heading: \"Test\".to_string(),\n            level: 1,\n            start_line: 1,\n            end_line: 10,\n            score: 100,\n        };\n        let cloned = result.clone();\n        assert_eq!(result, cloned);\n    }\n\n    #[test]\n    fn search_result_debug() {\n        let result = SearchResult {\n            file: \"test.md\".to_string(),\n            heading: \"Test\".to_string(),\n            level: 1,\n            start_line: 1,\n            end_line: 10,\n            score: 100,\n        };\n        let debug = format!(\"{:?}\", result);\n        assert!(debug.contains(\"SearchResult\"));\n    }\n\n    #[test]\n    fn match_score_exact() {\n        let score = match_score(\"Installation\", \"installation\", \u0026[\"installation\"]);\n        assert_eq!(score, Some(1000));\n    }\n\n    #[test]\n    fn match_score_contains() {\n        let score = match_score(\"Configuration Options\", \"config\", \u0026[\"config\"]);\n        assert_eq!(score, Some(500));\n    }\n\n    #[test]\n    fn match_score_word_partial() {\n        // Test that partial word matches work when heading word contains query word\n        // or query word contains heading word\n        // \"started\" contains \"start\" - heading word contains query word\n        let score = match_score(\"Started Guide\", \"start\", \u0026[\"start\"]);\n        // But \"started guide\" also contains \"start\" as substring, so it gets 500\n        assert_eq!(score, Some(500));\n\n        // Test case where query word contains heading word (qw.contains(hw))\n        // \"testing\" contains \"test\"\n        let score2 = match_score(\"Test Results\", \"testing\", \u0026[\"testing\"]);\n        // \"test results\" does NOT contain \"testing\", so it falls through to word matching\n        // Word matching: \"testing\".contains(\"test\")? Yes\n        assert!(score2.is_some());\n        assert!(score2.unwrap() \u003c 500);\n\n        // Another case: heading contains partial word but not as substring\n        let score3 = match_score(\"API Docs\", \"apis\", \u0026[\"apis\"]);\n        // \"api docs\" does NOT contain \"apis\", but \"apis\".contains(\"api\")? Yes\n        assert!(score3.is_some());\n        assert!(score3.unwrap() \u003c 500);\n    }\n\n    #[test]\n    fn match_score_no_match() {\n        let score = match_score(\"Installation\", \"api\", \u0026[\"api\"]);\n        assert!(score.is_none());\n    }\n\n    #[test]\n    fn format_results_empty() {\n        let results: Vec\u003cSearchResult\u003e = vec![];\n        let output = format_results(\u0026results, None);\n        assert_eq!(output, \"No matching sections found\");\n    }\n\n    #[test]\n    fn format_results_single() {\n        let results = vec![SearchResult {\n            file: \"test.md\".to_string(),\n            heading: \"Test Section\".to_string(),\n            level: 2,\n            start_line: 5,\n            end_line: 15,\n            score: 100,\n        }];\n        let output = format_results(\u0026results, None);\n        assert!(output.contains(\"## Test Section\"));\n        assert!(output.contains(\"test.md:L5-15\"));\n    }\n\n    #[test]\n    fn format_results_multiple() {\n        let results = vec![\n            SearchResult {\n                file: \"a.md\".to_string(),\n                heading: \"First\".to_string(),\n                level: 1,\n                start_line: 1,\n                end_line: 10,\n                score: 100,\n            },\n            SearchResult {\n                file: \"b.md\".to_string(),\n                heading: \"Second\".to_string(),\n                level: 2,\n                start_line: 5,\n                end_line: 20,\n                score: 50,\n            },\n        ];\n        let output = format_results(\u0026results, None);\n        let lines: Vec\u003c\u0026str\u003e = output.lines().collect();\n        assert_eq!(lines.len(), 2);\n    }\n\n    #[test]\n    fn format_results_with_limit() {\n        let results = vec![\n            SearchResult {\n                file: \"a.md\".to_string(),\n                heading: \"First\".to_string(),\n                level: 1,\n                start_line: 1,\n                end_line: 10,\n                score: 100,\n            },\n            SearchResult {\n                file: \"b.md\".to_string(),\n                heading: \"Second\".to_string(),\n                level: 2,\n                start_line: 5,\n                end_line: 20,\n                score: 50,\n            },\n        ];\n        let output = format_results(\u0026results, Some(1));\n        let lines: Vec\u003c\u0026str\u003e = output.lines().collect();\n        assert_eq!(lines.len(), 1);\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":6}},{"line":22,"address":[],"length":0,"stats":{"Line":18}},{"line":23,"address":[],"length":0,"stats":{"Line":24}},{"line":24,"address":[],"length":0,"stats":{"Line":12}},{"line":26,"address":[],"length":0,"stats":{"Line":42}},{"line":27,"address":[],"length":0,"stats":{"Line":72}},{"line":28,"address":[],"length":0,"stats":{"Line":102}},{"line":29,"address":[],"length":0,"stats":{"Line":18}},{"line":30,"address":[],"length":0,"stats":{"Line":18}},{"line":31,"address":[],"length":0,"stats":{"Line":18}},{"line":32,"address":[],"length":0,"stats":{"Line":12}},{"line":33,"address":[],"length":0,"stats":{"Line":12}},{"line":34,"address":[],"length":0,"stats":{"Line":6}},{"line":35,"address":[],"length":0,"stats":{"Line":6}},{"line":42,"address":[],"length":0,"stats":{"Line":15}},{"line":44,"address":[],"length":0,"stats":{"Line":6}},{"line":48,"address":[],"length":0,"stats":{"Line":36}},{"line":49,"address":[],"length":0,"stats":{"Line":108}},{"line":52,"address":[],"length":0,"stats":{"Line":36}},{"line":53,"address":[],"length":0,"stats":{"Line":4}},{"line":57,"address":[],"length":0,"stats":{"Line":64}},{"line":58,"address":[],"length":0,"stats":{"Line":5}},{"line":62,"address":[],"length":0,"stats":{"Line":108}},{"line":63,"address":[],"length":0,"stats":{"Line":54}},{"line":65,"address":[],"length":0,"stats":{"Line":81}},{"line":66,"address":[],"length":0,"stats":{"Line":131}},{"line":67,"address":[],"length":0,"stats":{"Line":318}},{"line":68,"address":[],"length":0,"stats":{"Line":2}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":74,"address":[],"length":0,"stats":{"Line":27}},{"line":76,"address":[],"length":0,"stats":{"Line":8}},{"line":77,"address":[],"length":0,"stats":{"Line":2}},{"line":80,"address":[],"length":0,"stats":{"Line":25}},{"line":84,"address":[],"length":0,"stats":{"Line":4}},{"line":85,"address":[],"length":0,"stats":{"Line":8}},{"line":86,"address":[],"length":0,"stats":{"Line":2}},{"line":89,"address":[],"length":0,"stats":{"Line":7}},{"line":90,"address":[],"length":0,"stats":{"Line":4}},{"line":92,"address":[],"length":0,"stats":{"Line":2}},{"line":95,"address":[],"length":0,"stats":{"Line":6}},{"line":97,"address":[],"length":0,"stats":{"Line":15}},{"line":98,"address":[],"length":0,"stats":{"Line":20}},{"line":99,"address":[],"length":0,"stats":{"Line":12}},{"line":100,"address":[],"length":0,"stats":{"Line":4}},{"line":101,"address":[],"length":0,"stats":{"Line":4}},{"line":105,"address":[],"length":0,"stats":{"Line":6}}],"covered":46,"coverable":46},{"path":["/","Users","chi","Projects","hu","src","utils","docs_section.rs"],"content":"use anyhow::{Context, Result};\nuse regex::Regex;\nuse std::fs;\n\n/// Extract a section from markdown content by heading\npub fn extract_section(content: \u0026str, heading: \u0026str) -\u003e Option\u003cString\u003e {\n    let heading_lower = heading.to_lowercase();\n    let heading_re = Regex::new(r\"^(#{1,6})\\s+(.+)$\").unwrap();\n\n    let lines: Vec\u003c\u0026str\u003e = content.lines().collect();\n    let mut section_start: Option\u003c(usize, u8)\u003e = None;\n    let mut section_end: Option\u003cusize\u003e = None;\n\n    for (i, line) in lines.iter().enumerate() {\n        if let Some(caps) = heading_re.captures(line) {\n            let level = caps.get(1).unwrap().as_str().len() as u8;\n            let text = caps.get(2).unwrap().as_str();\n\n            if let Some((_, start_level)) = section_start {\n                // We're in a section - check if this heading ends it\n                if level \u003c= start_level {\n                    section_end = Some(i);\n                    break;\n                }\n            } else if text.to_lowercase() == heading_lower\n                || text.to_lowercase().contains(\u0026heading_lower)\n            {\n                // Found the section\n                section_start = Some((i, level));\n            }\n        }\n    }\n\n    // If we found the start but not the end, section goes to end of file\n    if let Some((start, _)) = section_start {\n        let end = section_end.unwrap_or(lines.len());\n        let section_lines: Vec\u003c\u0026str\u003e = lines[start..end].to_vec();\n        return Some(section_lines.join(\"\\n\"));\n    }\n\n    None\n}\n\n/// Extract a section from a file by heading\npub fn extract_section_from_file(path: \u0026str, heading: \u0026str) -\u003e Result\u003cString\u003e {\n    let content =\n        fs::read_to_string(path).with_context(|| format!(\"Failed to read file: {}\", path))?;\n\n    extract_section(\u0026content, heading)\n        .ok_or_else(|| anyhow::anyhow!(\"Section not found: {}\", heading))\n}\n\n/// Extract a section by line range\n#[cfg(test)]\npub fn extract_lines(content: \u0026str, start: usize, end: usize) -\u003e String {\n    let lines: Vec\u003c\u0026str\u003e = content.lines().collect();\n    // Convert 1-indexed line numbers to 0-indexed array indices\n    // start is inclusive, end is exclusive\n    let start_idx = start.saturating_sub(1).min(lines.len());\n    let end_idx = end.saturating_sub(1).min(lines.len());\n\n    if start_idx \u003e= end_idx {\n        return String::new();\n    }\n\n    lines[start_idx..end_idx].join(\"\\n\")\n}\n\n/// Extract a section from a file by line range\n#[cfg(test)]\npub fn extract_lines_from_file(path: \u0026str, start: usize, end: usize) -\u003e Result\u003cString\u003e {\n    let content =\n        fs::read_to_string(path).with_context(|| format!(\"Failed to read file: {}\", path))?;\n    Ok(extract_lines(\u0026content, start, end))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    const TEST_CONTENT: \u0026str = r#\"# Main Title\n\nIntroduction paragraph.\n\n## First Section\n\nFirst section content.\nMore content here.\n\n### Nested Section\n\nNested content.\n\n## Second Section\n\nSecond section content.\n\n### Another Nested\n\nMore nested.\n\n## Third Section\n\nFinal content.\n\"#;\n\n    #[test]\n    fn extract_section_h1() {\n        let section = extract_section(TEST_CONTENT, \"Main Title\").unwrap();\n        assert!(section.starts_with(\"# Main Title\"));\n        // H1 section should include everything until another H1 (none here)\n        // or end of file\n    }\n\n    #[test]\n    fn extract_section_h2() {\n        let section = extract_section(TEST_CONTENT, \"First Section\").unwrap();\n        assert!(section.starts_with(\"## First Section\"));\n        assert!(section.contains(\"First section content\"));\n        assert!(section.contains(\"### Nested Section\"));\n        // Should NOT include \"## Second Section\"\n        assert!(!section.contains(\"## Second Section\"));\n    }\n\n    #[test]\n    fn extract_section_h3() {\n        let section = extract_section(TEST_CONTENT, \"Nested Section\").unwrap();\n        assert!(section.starts_with(\"### Nested Section\"));\n        assert!(section.contains(\"Nested content\"));\n        // Should end at \"## Second Section\"\n        assert!(!section.contains(\"## Second Section\"));\n    }\n\n    #[test]\n    fn extract_section_last() {\n        let section = extract_section(TEST_CONTENT, \"Third Section\").unwrap();\n        assert!(section.starts_with(\"## Third Section\"));\n        assert!(section.contains(\"Final content\"));\n    }\n\n    #[test]\n    fn extract_section_case_insensitive() {\n        let section = extract_section(TEST_CONTENT, \"first section\").unwrap();\n        assert!(section.starts_with(\"## First Section\"));\n    }\n\n    #[test]\n    fn extract_section_partial_match() {\n        let section = extract_section(TEST_CONTENT, \"Nested\").unwrap();\n        // Should match first \"Nested Section\"\n        assert!(section.starts_with(\"### Nested Section\"));\n    }\n\n    #[test]\n    fn extract_section_not_found() {\n        let section = extract_section(TEST_CONTENT, \"Nonexistent\");\n        assert!(section.is_none());\n    }\n\n    #[test]\n    fn extract_section_empty_content() {\n        let section = extract_section(\"\", \"Any\");\n        assert!(section.is_none());\n    }\n\n    #[test]\n    fn extract_section_no_headings() {\n        let content = \"Just some text\\nNo headings here\\n\";\n        let section = extract_section(content, \"Test\");\n        assert!(section.is_none());\n    }\n\n    #[test]\n    fn extract_lines_basic() {\n        let content = \"line1\\nline2\\nline3\\nline4\\nline5\";\n        let section = extract_lines(content, 2, 4);\n        assert_eq!(section, \"line2\\nline3\");\n    }\n\n    #[test]\n    fn extract_lines_from_start() {\n        let content = \"line1\\nline2\\nline3\";\n        let section = extract_lines(content, 1, 2);\n        assert_eq!(section, \"line1\");\n    }\n\n    #[test]\n    fn extract_lines_to_end() {\n        let content = \"line1\\nline2\\nline3\";\n        let section = extract_lines(content, 2, 100);\n        assert_eq!(section, \"line2\\nline3\");\n    }\n\n    #[test]\n    fn extract_lines_out_of_bounds() {\n        let content = \"line1\\nline2\";\n        let section = extract_lines(content, 10, 20);\n        assert_eq!(section, \"\");\n    }\n\n    #[test]\n    fn extract_lines_invalid_range() {\n        let content = \"line1\\nline2\\nline3\";\n        let section = extract_lines(content, 5, 2);\n        assert_eq!(section, \"\");\n    }\n\n    #[test]\n    fn extract_lines_empty_content() {\n        let section = extract_lines(\"\", 1, 10);\n        assert_eq!(section, \"\");\n    }\n\n    // File-based tests\n    #[test]\n    fn extract_section_from_file_cargo_toml() {\n        // Cargo.toml doesn't have markdown headings, so this should fail\n        let result = extract_section_from_file(\n            concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/Cargo.toml\"),\n            \"dependencies\",\n        );\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn extract_section_from_file_not_found() {\n        let result = extract_section_from_file(\"/nonexistent/file.md\", \"Test\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn extract_lines_from_file_cargo_toml() {\n        let result =\n            extract_lines_from_file(concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/Cargo.toml\"), 1, 5);\n        assert!(result.is_ok());\n        let content = result.unwrap();\n        assert!(!content.is_empty());\n    }\n\n    #[test]\n    fn extract_lines_from_file_not_found() {\n        let result = extract_lines_from_file(\"/nonexistent/file.md\", 1, 10);\n        assert!(result.is_err());\n    }\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":10}},{"line":7,"address":[],"length":0,"stats":{"Line":30}},{"line":8,"address":[],"length":0,"stats":{"Line":40}},{"line":10,"address":[],"length":0,"stats":{"Line":50}},{"line":11,"address":[],"length":0,"stats":{"Line":30}},{"line":12,"address":[],"length":0,"stats":{"Line":30}},{"line":14,"address":[],"length":0,"stats":{"Line":384}},{"line":15,"address":[],"length":0,"stats":{"Line":398}},{"line":16,"address":[],"length":0,"stats":{"Line":102}},{"line":17,"address":[],"length":0,"stats":{"Line":136}},{"line":19,"address":[],"length":0,"stats":{"Line":45}},{"line":21,"address":[],"length":0,"stats":{"Line":11}},{"line":22,"address":[],"length":0,"stats":{"Line":4}},{"line":23,"address":[],"length":0,"stats":{"Line":4}},{"line":25,"address":[],"length":0,"stats":{"Line":23}},{"line":26,"address":[],"length":0,"stats":{"Line":36}},{"line":29,"address":[],"length":0,"stats":{"Line":6}},{"line":35,"address":[],"length":0,"stats":{"Line":16}},{"line":36,"address":[],"length":0,"stats":{"Line":30}},{"line":37,"address":[],"length":0,"stats":{"Line":30}},{"line":38,"address":[],"length":0,"stats":{"Line":12}},{"line":41,"address":[],"length":0,"stats":{"Line":4}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":1}},{"line":47,"address":[],"length":0,"stats":{"Line":9}},{"line":49,"address":[],"length":0,"stats":{"Line":3}},{"line":50,"address":[],"length":0,"stats":{"Line":3}},{"line":55,"address":[],"length":0,"stats":{"Line":7}},{"line":56,"address":[],"length":0,"stats":{"Line":35}},{"line":59,"address":[],"length":0,"stats":{"Line":42}},{"line":60,"address":[],"length":0,"stats":{"Line":42}},{"line":62,"address":[],"length":0,"stats":{"Line":7}},{"line":63,"address":[],"length":0,"stats":{"Line":3}},{"line":66,"address":[],"length":0,"stats":{"Line":16}},{"line":71,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":9}},{"line":74,"address":[],"length":0,"stats":{"Line":3}}],"covered":38,"coverable":38},{"path":["/","Users","chi","Projects","hu","src","utils","fetch_html","mod.rs"],"content":"use anyhow::{Context, Result};\nuse regex::Regex;\nuse std::fs;\n\nuse super::cli::FetchHtmlArgs;\n\n#[cfg(test)]\nmod tests;\n\n/// Handle the `hu utils fetch-html` command\npub async fn run(args: FetchHtmlArgs) -\u003e Result\u003c()\u003e {\n    let html = fetch_url(\u0026args.url).await?;\n\n    let output = if args.raw {\n        html_to_markdown(\u0026html)\n    } else if args.links {\n        extract_links(\u0026html)\n    } else if args.headings {\n        extract_headings(\u0026html)\n    } else if args.summary {\n        extract_summary(\u0026html)\n    } else if args.content || args.selector.is_some() {\n        let selector = args.selector.as_deref();\n        extract_content(\u0026html, selector)\n    } else {\n        // Default: content extraction\n        extract_content(\u0026html, None)\n    };\n\n    if let Some(path) = args.output {\n        fs::write(\u0026path, \u0026output).with_context(|| format!(\"Failed to write to {}\", path))?;\n        eprintln!(\"Written to {}\", path);\n    } else {\n        println!(\"{}\", output);\n    }\n\n    Ok(())\n}\n\n/// Fetch URL content\nasync fn fetch_url(url: \u0026str) -\u003e Result\u003cString\u003e {\n    let client = reqwest::Client::builder()\n        .user_agent(\"hu-cli/0.1\")\n        .build()?;\n\n    let response = client\n        .get(url)\n        .send()\n        .await\n        .with_context(|| format!(\"Failed to fetch {}\", url))?;\n\n    response\n        .text()\n        .await\n        .with_context(|| format!(\"Failed to read response from {}\", url))\n}\n\n/// Convert HTML to markdown (basic conversion)\npub fn html_to_markdown(html: \u0026str) -\u003e String {\n    let mut result = html.to_string();\n\n    // Remove script and style tags with content\n    result = remove_tag_with_content(\u0026result, \"script\");\n    result = remove_tag_with_content(\u0026result, \"style\");\n    result = remove_tag_with_content(\u0026result, \"noscript\");\n\n    // Convert headings\n    for level in 1..=6 {\n        let prefix = \"#\".repeat(level);\n        let open_re = Regex::new(\u0026format!(r\"(?i)\u003ch{}\\b[^\u003e]*\u003e\", level)).unwrap();\n        let close_re = Regex::new(\u0026format!(r\"(?i)\u003c/h{}\u003e\", level)).unwrap();\n        result = open_re\n            .replace_all(\u0026result, format!(\"\\n{} \", prefix))\n            .to_string();\n        result = close_re.replace_all(\u0026result, \"\\n\").to_string();\n    }\n\n    // Convert links\n    let link_re = Regex::new(r#\"(?i)\u003ca\\s+[^\u003e]*href=[\"']([^\"']+)[\"'][^\u003e]*\u003e([^\u003c]*)\u003c/a\u003e\"#).unwrap();\n    result = link_re.replace_all(\u0026result, \"[$2]($1)\").to_string();\n\n    // Convert emphasis (strong/b -\u003e **, em/i -\u003e *)\n    for tag in [\"strong\", \"b\"] {\n        let re = Regex::new(\u0026format!(r\"(?i)\u003c{}\\b[^\u003e]*\u003e([^\u003c]*)\u003c/{}\u003e\", tag, tag)).unwrap();\n        result = re.replace_all(\u0026result, \"**$1**\").to_string();\n    }\n    for tag in [\"em\", \"i\"] {\n        let re = Regex::new(\u0026format!(r\"(?i)\u003c{}\\b[^\u003e]*\u003e([^\u003c]*)\u003c/{}\u003e\", tag, tag)).unwrap();\n        result = re.replace_all(\u0026result, \"*$1*\").to_string();\n    }\n\n    // Convert code\n    result = Regex::new(r\"(?i)\u003ccode\\b[^\u003e]*\u003e([^\u003c]*)\u003c/code\u003e\")\n        .unwrap()\n        .replace_all(\u0026result, \"`$1`\")\n        .to_string();\n\n    // Convert pre/code blocks\n    let pre_re = Regex::new(r\"(?is)\u003cpre\\b[^\u003e]*\u003e\u003ccode\\b[^\u003e]*\u003e(.+?)\u003c/code\u003e\u003c/pre\u003e\").unwrap();\n    result = pre_re.replace_all(\u0026result, \"\\n```\\n$1\\n```\\n\").to_string();\n\n    // Convert lists\n    result = Regex::new(r\"(?i)\u003cli\\b[^\u003e]*\u003e\")\n        .unwrap()\n        .replace_all(\u0026result, \"\\n- \")\n        .to_string();\n    result = Regex::new(r\"(?i)\u003c/li\u003e\")\n        .unwrap()\n        .replace_all(\u0026result, \"\")\n        .to_string();\n\n    // Convert paragraphs and line breaks\n    result = Regex::new(r\"(?i)\u003cp\\b[^\u003e]*\u003e\")\n        .unwrap()\n        .replace_all(\u0026result, \"\\n\\n\")\n        .to_string();\n    result = Regex::new(r\"(?i)\u003c/p\u003e\")\n        .unwrap()\n        .replace_all(\u0026result, \"\\n\")\n        .to_string();\n    result = Regex::new(r\"(?i)\u003cbr\\s*/?\u003e\")\n        .unwrap()\n        .replace_all(\u0026result, \"\\n\")\n        .to_string();\n\n    // Remove remaining HTML tags\n    result = Regex::new(r\"\u003c[^\u003e]+\u003e\")\n        .unwrap()\n        .replace_all(\u0026result, \"\")\n        .to_string();\n\n    // Decode common HTML entities\n    result = result\n        .replace(\"\u0026amp;\", \"\u0026\")\n        .replace(\"\u0026lt;\", \"\u003c\")\n        .replace(\"\u0026gt;\", \"\u003e\")\n        .replace(\"\u0026quot;\", \"\\\"\")\n        .replace(\"\u0026#39;\", \"'\")\n        .replace(\"\u0026nbsp;\", \" \");\n\n    // Clean up whitespace\n    result = Regex::new(r\"\\n{3,}\")\n        .unwrap()\n        .replace_all(\u0026result, \"\\n\\n\")\n        .to_string();\n    result = Regex::new(r\"[ \\t]+\")\n        .unwrap()\n        .replace_all(\u0026result, \" \")\n        .to_string();\n\n    result.trim().to_string()\n}\n\n/// Remove HTML tag and its content\nfn remove_tag_with_content(html: \u0026str, tag: \u0026str) -\u003e String {\n    let re = Regex::new(\u0026format!(r\"(?is)\u003c{}\\b[^\u003e]*\u003e.*?\u003c/{}\u003e\", tag, tag)).unwrap();\n    re.replace_all(html, \"\").to_string()\n}\n\n/// Extract main content only (strip nav, footer, scripts, ads)\npub fn extract_content(html: \u0026str, selector: Option\u003c\u0026str\u003e) -\u003e String {\n    let mut result = html.to_string();\n\n    // If selector provided, try to extract just that\n    if let Some(sel) = selector {\n        if let Some(content) = extract_by_selector(\u0026result, sel) {\n            return html_to_markdown(\u0026content);\n        }\n    }\n\n    // Remove noise elements\n    for tag in \u0026[\n        \"script\", \"style\", \"noscript\", \"nav\", \"footer\", \"header\", \"aside\", \"iframe\", \"svg\",\n    ] {\n        result = remove_tag_with_content(\u0026result, tag);\n    }\n\n    // Remove common ad/noise classes\n    let noise_patterns = [\n        r#\"\u003c[^\u003e]+class=\"[^\"]*(?:ad|advertisement|sidebar|menu|nav|footer|header|cookie|popup|modal|banner)[^\"]*\"[^\u003e]*\u003e.*?\u003c/[^\u003e]+\u003e\"#,\n        r#\"\u003c[^\u003e]+id=\"[^\"]*(?:ad|advertisement|sidebar|menu|nav|footer|header|cookie|popup|modal|banner)[^\"]*\"[^\u003e]*\u003e.*?\u003c/[^\u003e]+\u003e\"#,\n    ];\n\n    for pattern in \u0026noise_patterns {\n        if let Ok(re) = Regex::new(\u0026format!(\"(?is){}\", pattern)) {\n            result = re.replace_all(\u0026result, \"\").to_string();\n        }\n    }\n\n    // Try to find main content area\n    if let Some(main) = extract_by_selector(\u0026result, \"main\") {\n        return html_to_markdown(\u0026main);\n    }\n    if let Some(article) = extract_by_selector(\u0026result, \"article\") {\n        return html_to_markdown(\u0026article);\n    }\n    if let Some(content) = extract_by_selector(\u0026result, \".content\") {\n        return html_to_markdown(\u0026content);\n    }\n\n    html_to_markdown(\u0026result)\n}\n\n/// Try to extract content by CSS-like selector (simplified)\nfn extract_by_selector(html: \u0026str, selector: \u0026str) -\u003e Option\u003cString\u003e {\n    let pattern = if let Some(class) = selector.strip_prefix('.') {\n        // Class selector\n        format!(\n            r#\"(?is)\u003c[^\u003e]+class=\"[^\"]*\\b{}\\b[^\"]*\"[^\u003e]*\u003e(.*?)\u003c/[^\u003e]+\u003e\"#,\n            regex::escape(class)\n        )\n    } else if let Some(id) = selector.strip_prefix('#') {\n        // ID selector\n        format!(\n            r#\"(?is)\u003c[^\u003e]+id=\"{}\"[^\u003e]*\u003e(.*?)\u003c/[^\u003e]+\u003e\"#,\n            regex::escape(id)\n        )\n    } else {\n        // Tag selector\n        format!(\n            r\"(?is)\u003c{}\\b[^\u003e]*\u003e(.*?)\u003c/{}\u003e\",\n            regex::escape(selector),\n            regex::escape(selector)\n        )\n    };\n\n    Regex::new(\u0026pattern)\n        .ok()\n        .and_then(|re| re.captures(html))\n        .map(|caps| caps.get(1).map_or(\"\", |m| m.as_str()).to_string())\n}\n\n/// Extract links only\npub fn extract_links(html: \u0026str) -\u003e String {\n    let link_re = Regex::new(r#\"(?i)\u003ca\\s+[^\u003e]*href=[\"']([^\"']+)[\"'][^\u003e]*\u003e([^\u003c]*)\u003c/a\u003e\"#).unwrap();\n\n    let mut links = Vec::new();\n    for cap in link_re.captures_iter(html) {\n        let url = cap.get(1).map_or(\"\", |m| m.as_str());\n        let text = cap.get(2).map_or(\"\", |m| m.as_str()).trim();\n\n        // Skip empty links, anchors, javascript\n        if url.is_empty()\n            || url.starts_with('#')\n            || url.starts_with(\"javascript:\")\n            || text.is_empty()\n        {\n            continue;\n        }\n\n        links.push(format!(\"- [{}]({})\", text, url));\n    }\n\n    links.join(\"\\n\")\n}\n\n/// Extract headings only (document outline)\npub fn extract_headings(html: \u0026str) -\u003e String {\n    let mut headings = Vec::new();\n    let strip_tags_re = Regex::new(r\"\u003c[^\u003e]+\u003e\").unwrap();\n\n    for level in 1..=6 {\n        let re = Regex::new(\u0026format!(r\"(?is)\u003ch{}\\b[^\u003e]*\u003e(.*?)\u003c/h{}\u003e\", level, level)).unwrap();\n\n        for cap in re.captures_iter(html) {\n            let text = cap.get(1).map_or(\"\", |m| m.as_str());\n            // Strip any nested tags\n            let clean = strip_tags_re.replace_all(text, \"\").trim().to_string();\n\n            if !clean.is_empty() {\n                let indent = \"  \".repeat(level - 1);\n                headings.push(format!(\"{}{} {}\", indent, \"#\".repeat(level), clean));\n            }\n        }\n    }\n\n    headings.join(\"\\n\")\n}\n\n/// Extract summary (first N paragraphs + all headings)\npub fn extract_summary(html: \u0026str) -\u003e String {\n    let content = extract_content(html, None);\n    let lines: Vec\u003c\u0026str\u003e = content.lines().collect();\n\n    let mut result = Vec::new();\n    let mut para_count = 0;\n    let max_paras = 3;\n\n    for line in lines {\n        let trimmed = line.trim();\n        if trimmed.is_empty() {\n            continue;\n        }\n\n        // Always include headings\n        if trimmed.starts_with('#') {\n            result.push(line.to_string());\n            continue;\n        }\n\n        // Include first N paragraphs\n        if para_count \u003c max_paras {\n            result.push(line.to_string());\n            if !trimmed.starts_with('-') \u0026\u0026 !trimmed.starts_with('*') {\n                para_count += 1;\n            }\n        }\n    }\n\n    result.join(\"\\n\\n\")\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":27}},{"line":60,"address":[],"length":0,"stats":{"Line":81}},{"line":63,"address":[],"length":0,"stats":{"Line":108}},{"line":64,"address":[],"length":0,"stats":{"Line":108}},{"line":65,"address":[],"length":0,"stats":{"Line":108}},{"line":68,"address":[],"length":0,"stats":{"Line":513}},{"line":69,"address":[],"length":0,"stats":{"Line":810}},{"line":70,"address":[],"length":0,"stats":{"Line":810}},{"line":71,"address":[],"length":0,"stats":{"Line":810}},{"line":72,"address":[],"length":0,"stats":{"Line":648}},{"line":73,"address":[],"length":0,"stats":{"Line":648}},{"line":74,"address":[],"length":0,"stats":{"Line":324}},{"line":75,"address":[],"length":0,"stats":{"Line":486}},{"line":79,"address":[],"length":0,"stats":{"Line":108}},{"line":80,"address":[],"length":0,"stats":{"Line":108}},{"line":83,"address":[],"length":0,"stats":{"Line":135}},{"line":84,"address":[],"length":0,"stats":{"Line":270}},{"line":85,"address":[],"length":0,"stats":{"Line":162}},{"line":87,"address":[],"length":0,"stats":{"Line":135}},{"line":88,"address":[],"length":0,"stats":{"Line":270}},{"line":89,"address":[],"length":0,"stats":{"Line":162}},{"line":93,"address":[],"length":0,"stats":{"Line":108}},{"line":94,"address":[],"length":0,"stats":{"Line":54}},{"line":95,"address":[],"length":0,"stats":{"Line":27}},{"line":96,"address":[],"length":0,"stats":{"Line":27}},{"line":99,"address":[],"length":0,"stats":{"Line":108}},{"line":100,"address":[],"length":0,"stats":{"Line":108}},{"line":103,"address":[],"length":0,"stats":{"Line":108}},{"line":104,"address":[],"length":0,"stats":{"Line":54}},{"line":105,"address":[],"length":0,"stats":{"Line":27}},{"line":106,"address":[],"length":0,"stats":{"Line":27}},{"line":107,"address":[],"length":0,"stats":{"Line":108}},{"line":108,"address":[],"length":0,"stats":{"Line":54}},{"line":109,"address":[],"length":0,"stats":{"Line":27}},{"line":110,"address":[],"length":0,"stats":{"Line":27}},{"line":113,"address":[],"length":0,"stats":{"Line":108}},{"line":114,"address":[],"length":0,"stats":{"Line":54}},{"line":115,"address":[],"length":0,"stats":{"Line":27}},{"line":116,"address":[],"length":0,"stats":{"Line":27}},{"line":117,"address":[],"length":0,"stats":{"Line":108}},{"line":118,"address":[],"length":0,"stats":{"Line":54}},{"line":119,"address":[],"length":0,"stats":{"Line":27}},{"line":120,"address":[],"length":0,"stats":{"Line":27}},{"line":121,"address":[],"length":0,"stats":{"Line":108}},{"line":122,"address":[],"length":0,"stats":{"Line":54}},{"line":123,"address":[],"length":0,"stats":{"Line":27}},{"line":124,"address":[],"length":0,"stats":{"Line":27}},{"line":127,"address":[],"length":0,"stats":{"Line":108}},{"line":128,"address":[],"length":0,"stats":{"Line":54}},{"line":129,"address":[],"length":0,"stats":{"Line":27}},{"line":130,"address":[],"length":0,"stats":{"Line":27}},{"line":133,"address":[],"length":0,"stats":{"Line":216}},{"line":134,"address":[],"length":0,"stats":{"Line":162}},{"line":135,"address":[],"length":0,"stats":{"Line":135}},{"line":136,"address":[],"length":0,"stats":{"Line":108}},{"line":137,"address":[],"length":0,"stats":{"Line":81}},{"line":138,"address":[],"length":0,"stats":{"Line":54}},{"line":139,"address":[],"length":0,"stats":{"Line":27}},{"line":142,"address":[],"length":0,"stats":{"Line":108}},{"line":143,"address":[],"length":0,"stats":{"Line":54}},{"line":144,"address":[],"length":0,"stats":{"Line":27}},{"line":145,"address":[],"length":0,"stats":{"Line":27}},{"line":146,"address":[],"length":0,"stats":{"Line":108}},{"line":147,"address":[],"length":0,"stats":{"Line":54}},{"line":148,"address":[],"length":0,"stats":{"Line":27}},{"line":149,"address":[],"length":0,"stats":{"Line":27}},{"line":151,"address":[],"length":0,"stats":{"Line":54}},{"line":155,"address":[],"length":0,"stats":{"Line":163}},{"line":156,"address":[],"length":0,"stats":{"Line":652}},{"line":157,"address":[],"length":0,"stats":{"Line":489}},{"line":161,"address":[],"length":0,"stats":{"Line":10}},{"line":162,"address":[],"length":0,"stats":{"Line":30}},{"line":165,"address":[],"length":0,"stats":{"Line":11}},{"line":166,"address":[],"length":0,"stats":{"Line":3}},{"line":167,"address":[],"length":0,"stats":{"Line":2}},{"line":172,"address":[],"length":0,"stats":{"Line":171}},{"line":173,"address":[],"length":0,"stats":{"Line":90}},{"line":175,"address":[],"length":0,"stats":{"Line":243}},{"line":179,"address":[],"length":0,"stats":{"Line":18}},{"line":180,"address":[],"length":0,"stats":{"Line":9}},{"line":181,"address":[],"length":0,"stats":{"Line":9}},{"line":184,"address":[],"length":0,"stats":{"Line":45}},{"line":185,"address":[],"length":0,"stats":{"Line":72}},{"line":186,"address":[],"length":0,"stats":{"Line":54}},{"line":191,"address":[],"length":0,"stats":{"Line":19}},{"line":192,"address":[],"length":0,"stats":{"Line":2}},{"line":194,"address":[],"length":0,"stats":{"Line":17}},{"line":195,"address":[],"length":0,"stats":{"Line":2}},{"line":197,"address":[],"length":0,"stats":{"Line":15}},{"line":198,"address":[],"length":0,"stats":{"Line":2}},{"line":201,"address":[],"length":0,"stats":{"Line":12}},{"line":205,"address":[],"length":0,"stats":{"Line":29}},{"line":206,"address":[],"length":0,"stats":{"Line":67}},{"line":208,"address":[],"length":0,"stats":{"Line":9}},{"line":210,"address":[],"length":0,"stats":{"Line":18}},{"line":212,"address":[],"length":0,"stats":{"Line":22}},{"line":214,"address":[],"length":0,"stats":{"Line":2}},{"line":216,"address":[],"length":0,"stats":{"Line":4}},{"line":220,"address":[],"length":0,"stats":{"Line":18}},{"line":222,"address":[],"length":0,"stats":{"Line":36}},{"line":223,"address":[],"length":0,"stats":{"Line":36}},{"line":227,"address":[],"length":0,"stats":{"Line":58}},{"line":229,"address":[],"length":0,"stats":{"Line":116}},{"line":230,"address":[],"length":0,"stats":{"Line":71}},{"line":234,"address":[],"length":0,"stats":{"Line":3}},{"line":235,"address":[],"length":0,"stats":{"Line":12}},{"line":237,"address":[],"length":0,"stats":{"Line":6}},{"line":238,"address":[],"length":0,"stats":{"Line":16}},{"line":239,"address":[],"length":0,"stats":{"Line":42}},{"line":240,"address":[],"length":0,"stats":{"Line":49}},{"line":243,"address":[],"length":0,"stats":{"Line":14}},{"line":244,"address":[],"length":0,"stats":{"Line":14}},{"line":245,"address":[],"length":0,"stats":{"Line":12}},{"line":246,"address":[],"length":0,"stats":{"Line":10}},{"line":248,"address":[],"length":0,"stats":{"Line":3}},{"line":251,"address":[],"length":0,"stats":{"Line":16}},{"line":254,"address":[],"length":0,"stats":{"Line":6}},{"line":258,"address":[],"length":0,"stats":{"Line":3}},{"line":259,"address":[],"length":0,"stats":{"Line":6}},{"line":260,"address":[],"length":0,"stats":{"Line":12}},{"line":262,"address":[],"length":0,"stats":{"Line":39}},{"line":263,"address":[],"length":0,"stats":{"Line":72}},{"line":265,"address":[],"length":0,"stats":{"Line":58}},{"line":266,"address":[],"length":0,"stats":{"Line":24}},{"line":268,"address":[],"length":0,"stats":{"Line":16}},{"line":270,"address":[],"length":0,"stats":{"Line":8}},{"line":271,"address":[],"length":0,"stats":{"Line":20}},{"line":272,"address":[],"length":0,"stats":{"Line":24}},{"line":277,"address":[],"length":0,"stats":{"Line":6}},{"line":281,"address":[],"length":0,"stats":{"Line":6}},{"line":282,"address":[],"length":0,"stats":{"Line":24}},{"line":283,"address":[],"length":0,"stats":{"Line":24}},{"line":285,"address":[],"length":0,"stats":{"Line":12}},{"line":286,"address":[],"length":0,"stats":{"Line":12}},{"line":287,"address":[],"length":0,"stats":{"Line":12}},{"line":289,"address":[],"length":0,"stats":{"Line":60}},{"line":290,"address":[],"length":0,"stats":{"Line":81}},{"line":291,"address":[],"length":0,"stats":{"Line":54}},{"line":292,"address":[],"length":0,"stats":{"Line":10}},{"line":296,"address":[],"length":0,"stats":{"Line":34}},{"line":297,"address":[],"length":0,"stats":{"Line":8}},{"line":298,"address":[],"length":0,"stats":{"Line":2}},{"line":302,"address":[],"length":0,"stats":{"Line":15}},{"line":303,"address":[],"length":0,"stats":{"Line":52}},{"line":304,"address":[],"length":0,"stats":{"Line":35}},{"line":305,"address":[],"length":0,"stats":{"Line":11}},{"line":310,"address":[],"length":0,"stats":{"Line":12}}],"covered":147,"coverable":175},{"path":["/","Users","chi","Projects","hu","src","utils","fetch_html","tests.rs"],"content":"use super::*;\n\n#[test]\nfn html_to_markdown_headings() {\n    let html = \"\u003ch1\u003eTitle\u003c/h1\u003e\u003ch2\u003eSubtitle\u003c/h2\u003e\";\n    let md = html_to_markdown(html);\n    assert!(md.contains(\"# Title\"));\n    assert!(md.contains(\"## Subtitle\"));\n}\n\n#[test]\nfn html_to_markdown_links() {\n    let html = r#\"\u003ca href=\"https://example.com\"\u003eClick here\u003c/a\u003e\"#;\n    let md = html_to_markdown(html);\n    assert!(md.contains(\"[Click here](https://example.com)\"));\n}\n\n#[test]\nfn html_to_markdown_emphasis() {\n    let html = \"\u003cstrong\u003ebold\u003c/strong\u003e and \u003cem\u003eitalic\u003c/em\u003e\";\n    let md = html_to_markdown(html);\n    assert!(md.contains(\"**bold**\"));\n    assert!(md.contains(\"*italic*\"));\n}\n\n#[test]\nfn html_to_markdown_strips_scripts() {\n    let html = \"\u003cp\u003eText\u003c/p\u003e\u003cscript\u003ealert('x')\u003c/script\u003e\u003cp\u003eMore\u003c/p\u003e\";\n    let md = html_to_markdown(html);\n    assert!(!md.contains(\"alert\"));\n    assert!(md.contains(\"Text\"));\n    assert!(md.contains(\"More\"));\n}\n\n#[test]\nfn extract_links_basic() {\n    let html = r##\"\n            \u003ca href=\"https://a.com\"\u003eLink A\u003c/a\u003e\n            \u003ca href=\"https://b.com\"\u003eLink B\u003c/a\u003e\n            \u003ca href=\"#\"\u003eSkip\u003c/a\u003e\n        \"##;\n    let links = extract_links(html);\n    assert!(links.contains(\"[Link A](https://a.com)\"));\n    assert!(links.contains(\"[Link B](https://b.com)\"));\n    assert!(!links.contains(\"Skip\"));\n}\n\n#[test]\nfn extract_headings_basic() {\n    let html = \"\u003ch1\u003eMain\u003c/h1\u003e\u003ch2\u003eSub\u003c/h2\u003e\u003ch3\u003eDeep\u003c/h3\u003e\";\n    let headings = extract_headings(html);\n    assert!(headings.contains(\"# Main\"));\n    assert!(headings.contains(\"## Sub\"));\n    assert!(headings.contains(\"### Deep\"));\n}\n\n#[test]\nfn extract_by_selector_tag() {\n    let html = \"\u003cmain\u003e\u003cp\u003eContent\u003c/p\u003e\u003c/main\u003e\";\n    let content = extract_by_selector(html, \"main\");\n    assert!(content.is_some());\n    assert!(content.unwrap().contains(\"Content\"));\n}\n\n#[test]\nfn extract_by_selector_class() {\n    let html = r#\"\u003cdiv class=\"content\"\u003e\u003cp\u003eInner\u003c/p\u003e\u003c/div\u003e\"#;\n    let content = extract_by_selector(html, \".content\");\n    assert!(content.is_some());\n    assert!(content.unwrap().contains(\"Inner\"));\n}\n\n#[test]\nfn remove_tag_with_content_basic() {\n    let html = \"\u003cp\u003eKeep\u003c/p\u003e\u003cnav\u003eRemove\u003c/nav\u003e\u003cp\u003eAlso keep\u003c/p\u003e\";\n    let result = remove_tag_with_content(html, \"nav\");\n    assert!(result.contains(\"Keep\"));\n    assert!(result.contains(\"Also keep\"));\n    assert!(!result.contains(\"Remove\"));\n}\n\n#[test]\nfn extract_summary_limits_paragraphs() {\n    let html = \"\u003cp\u003ePara 1\u003c/p\u003e\u003cp\u003ePara 2\u003c/p\u003e\u003cp\u003ePara 3\u003c/p\u003e\u003cp\u003ePara 4\u003c/p\u003e\u003cp\u003ePara 5\u003c/p\u003e\";\n    let summary = extract_summary(html);\n    assert!(summary.contains(\"Para 1\"));\n    assert!(summary.contains(\"Para 2\"));\n    assert!(summary.contains(\"Para 3\"));\n    // Should be limited\n}\n\n#[test]\nfn html_to_markdown_inline_code() {\n    let html = \"\u003cp\u003eUse \u003ccode\u003efoo()\u003c/code\u003e method\u003c/p\u003e\";\n    let md = html_to_markdown(html);\n    assert!(md.contains(\"`foo()`\"));\n}\n\n#[test]\nfn html_to_markdown_lists() {\n    let html = \"\u003cul\u003e\u003cli\u003eItem 1\u003c/li\u003e\u003cli\u003eItem 2\u003c/li\u003e\u003c/ul\u003e\";\n    let md = html_to_markdown(html);\n    assert!(md.contains(\"- Item 1\"));\n    assert!(md.contains(\"- Item 2\"));\n}\n\n#[test]\nfn html_to_markdown_paragraphs() {\n    let html = \"\u003cp\u003eFirst paragraph\u003c/p\u003e\u003cp\u003eSecond paragraph\u003c/p\u003e\";\n    let md = html_to_markdown(html);\n    assert!(md.contains(\"First paragraph\"));\n    assert!(md.contains(\"Second paragraph\"));\n}\n\n#[test]\nfn html_to_markdown_br_tags() {\n    let html = \"Line 1\u003cbr/\u003eLine 2\u003cbr\u003eLine 3\";\n    let md = html_to_markdown(html);\n    assert!(md.contains(\"Line 1\"));\n    assert!(md.contains(\"Line 2\"));\n    assert!(md.contains(\"Line 3\"));\n}\n\n#[test]\nfn html_to_markdown_entities() {\n    let html = \"5 \u0026lt; 10 \u0026amp; 10 \u0026gt; 5\";\n    let md = html_to_markdown(html);\n    assert!(md.contains(\"5 \u003c 10 \u0026 10 \u003e 5\"));\n}\n\n#[test]\nfn html_to_markdown_b_and_i_tags() {\n    let html = \"\u003cb\u003ebold\u003c/b\u003e and \u003ci\u003eitalic\u003c/i\u003e\";\n    let md = html_to_markdown(html);\n    assert!(md.contains(\"**bold**\"));\n    assert!(md.contains(\"*italic*\"));\n}\n\n#[test]\nfn html_to_markdown_noscript() {\n    let html = \"\u003cp\u003eContent\u003c/p\u003e\u003cnoscript\u003eEnable JS\u003c/noscript\u003e\";\n    let md = html_to_markdown(html);\n    assert!(md.contains(\"Content\"));\n    assert!(!md.contains(\"Enable JS\"));\n}\n\n#[test]\nfn html_to_markdown_style() {\n    let html = \"\u003cstyle\u003ebody { color: red; }\u003c/style\u003e\u003cp\u003eText\u003c/p\u003e\";\n    let md = html_to_markdown(html);\n    assert!(!md.contains(\"color\"));\n    assert!(md.contains(\"Text\"));\n}\n\n#[test]\nfn extract_links_skips_javascript() {\n    let html = r#\"\u003ca href=\"javascript:void(0)\"\u003eJS Link\u003c/a\u003e\u003ca href=\"https://x.com\"\u003eReal\u003c/a\u003e\"#;\n    let links = extract_links(html);\n    assert!(!links.contains(\"JS Link\"));\n    assert!(links.contains(\"Real\"));\n}\n\n#[test]\nfn extract_links_skips_empty_text() {\n    let html = r#\"\u003ca href=\"https://x.com\"\u003e\u003c/a\u003e\u003ca href=\"https://y.com\"\u003eValid\u003c/a\u003e\"#;\n    let links = extract_links(html);\n    assert!(!links.contains(\"https://x.com\")); // skipped - empty text\n    assert!(links.contains(\"Valid\"));\n}\n\n#[test]\nfn extract_by_selector_id() {\n    let html = r#\"\u003cdiv id=\"main\"\u003e\u003cp\u003eMain content\u003c/p\u003e\u003c/div\u003e\"#;\n    let content = extract_by_selector(html, \"#main\");\n    assert!(content.is_some());\n    assert!(content.unwrap().contains(\"Main content\"));\n}\n\n#[test]\nfn extract_by_selector_not_found() {\n    let html = \"\u003cp\u003eJust text\u003c/p\u003e\";\n    let content = extract_by_selector(html, \"#nonexistent\");\n    assert!(content.is_none());\n}\n\n#[test]\nfn extract_content_with_selector() {\n    let html = r#\"\u003cnav\u003eSkip\u003c/nav\u003e\u003cdiv class=\"content\"\u003e\u003cp\u003eKeep\u003c/p\u003e\u003c/div\u003e\"#;\n    let content = extract_content(html, Some(\".content\"));\n    assert!(content.contains(\"Keep\"));\n    assert!(!content.contains(\"Skip\"));\n}\n\n#[test]\nfn extract_content_strips_noise_elements() {\n    let html = \"\u003cnav\u003eNav\u003c/nav\u003e\u003cscript\u003ealert()\u003c/script\u003e\u003cmain\u003e\u003cp\u003eMain\u003c/p\u003e\u003c/main\u003e\";\n    let content = extract_content(html, None);\n    assert!(content.contains(\"Main\"));\n    assert!(!content.contains(\"Nav\"));\n    assert!(!content.contains(\"alert\"));\n}\n\n#[test]\nfn extract_content_finds_article() {\n    let html = \"\u003cheader\u003eHeader\u003c/header\u003e\u003carticle\u003e\u003cp\u003eArticle\u003c/p\u003e\u003c/article\u003e\";\n    let content = extract_content(html, None);\n    assert!(content.contains(\"Article\"));\n}\n\n#[test]\nfn extract_content_finds_content_class() {\n    let html = r#\"\u003caside\u003eSide\u003c/aside\u003e\u003cdiv class=\"content\"\u003e\u003cp\u003eMain\u003c/p\u003e\u003c/div\u003e\"#;\n    let content = extract_content(html, None);\n    assert!(content.contains(\"Main\"));\n}\n\n#[test]\nfn extract_headings_strips_nested_tags() {\n    let html = \"\u003ch1\u003e\u003cspan class='icon'\u003e*\u003c/span\u003e Title\u003c/h1\u003e\";\n    let headings = extract_headings(html);\n    assert!(headings.contains(\"# * Title\") || headings.contains(\"# Title\"));\n}\n\n#[test]\nfn extract_headings_empty() {\n    let html = \"\u003cp\u003eNo headings\u003c/p\u003e\";\n    let headings = extract_headings(html);\n    assert!(headings.is_empty());\n}\n\n#[test]\nfn extract_summary_includes_headings() {\n    let html = \"\u003ch1\u003eTitle\u003c/h1\u003e\u003cp\u003ePara 1\u003c/p\u003e\u003ch2\u003eSection\u003c/h2\u003e\u003cp\u003ePara 2\u003c/p\u003e\";\n    let summary = extract_summary(html);\n    assert!(summary.contains(\"Title\"));\n    assert!(summary.contains(\"Section\"));\n}\n\n#[test]\nfn extract_summary_skips_empty_lines() {\n    let html = \"\u003cp\u003ePara 1\u003c/p\u003e\u003cp\u003e\u003c/p\u003e\u003cp\u003ePara 2\u003c/p\u003e\";\n    let summary = extract_summary(html);\n    assert!(summary.contains(\"Para 1\"));\n    assert!(summary.contains(\"Para 2\"));\n}\n\n#[test]\nfn extract_summary_handles_lists() {\n    let html = \"\u003cp\u003eIntro\u003c/p\u003e\u003cul\u003e\u003cli\u003eItem 1\u003c/li\u003e\u003cli\u003eItem 2\u003c/li\u003e\u003c/ul\u003e\u003cp\u003ePara 2\u003c/p\u003e\";\n    let summary = extract_summary(html);\n    // List items shouldn't count toward para limit\n    assert!(summary.contains(\"Intro\"));\n    assert!(summary.contains(\"Item 1\"));\n}\n\n#[test]\nfn html_to_markdown_h1_to_h6() {\n    let html = \"\u003ch1\u003eH1\u003c/h1\u003e\u003ch2\u003eH2\u003c/h2\u003e\u003ch3\u003eH3\u003c/h3\u003e\u003ch4\u003eH4\u003c/h4\u003e\u003ch5\u003eH5\u003c/h5\u003e\u003ch6\u003eH6\u003c/h6\u003e\";\n    let md = html_to_markdown(html);\n    assert!(md.contains(\"# H1\"));\n    assert!(md.contains(\"## H2\"));\n    assert!(md.contains(\"### H3\"));\n    assert!(md.contains(\"#### H4\"));\n    assert!(md.contains(\"##### H5\"));\n    assert!(md.contains(\"###### H6\"));\n}\n\n#[test]\nfn html_to_markdown_cleans_whitespace() {\n    let html = \"\u003cp\u003eText\u003c/p\u003e\\n\\n\\n\\n\u003cp\u003eMore\u003c/p\u003e\";\n    let md = html_to_markdown(html);\n    // Should not have excessive newlines\n    assert!(!md.contains(\"\\n\\n\\n\"));\n}\n\n#[test]\nfn html_to_markdown_nbsp_entity() {\n    let html = \"word\u0026nbsp;word\";\n    let md = html_to_markdown(html);\n    assert!(md.contains(\"word word\"));\n}\n\n#[test]\nfn html_to_markdown_quot_entity() {\n    let html = \"\u0026quot;quoted\u0026quot;\";\n    let md = html_to_markdown(html);\n    assert!(md.contains(\"\\\"quoted\\\"\"));\n}\n\n#[test]\nfn html_to_markdown_apos_entity() {\n    let html = \"it\u0026#39;s\";\n    let md = html_to_markdown(html);\n    assert!(md.contains(\"it's\"));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","utils","grep","mod.rs"],"content":"use anyhow::{Context, Result};\nuse regex::Regex;\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::Path;\n\nuse super::cli::GrepArgs;\nuse super::signature::extract_signature;\n\n#[cfg(test)]\nmod tests;\n\n/// A single grep match\n#[derive(Debug, Clone)]\npub struct GrepMatch {\n    pub file: String,\n    pub line_num: usize,\n    pub content: String,\n    pub match_count: usize,\n}\n\n/// Handle the `hu utils grep` command\npub fn run(args: GrepArgs) -\u003e Result\u003c()\u003e {\n    let matches = search_files(\u0026args)?;\n\n    if matches.is_empty() {\n        eprintln!(\"No matches found.\");\n        return Ok(());\n    }\n\n    let output = format_matches(\u0026matches, \u0026args);\n    println!(\"{}\", output);\n\n    Ok(())\n}\n\n/// Search files for pattern\npub fn search_files(args: \u0026GrepArgs) -\u003e Result\u003cVec\u003cGrepMatch\u003e\u003e {\n    let re = if args.ignore_case {\n        Regex::new(\u0026format!(\"(?i){}\", \u0026args.pattern))\n    } else {\n        Regex::new(\u0026args.pattern)\n    }\n    .with_context(|| format!(\"Invalid regex pattern: {}\", args.pattern))?;\n\n    let glob_pattern = args.glob.as_deref();\n    let mut matches = Vec::new();\n\n    collect_matches(\u0026args.path, \u0026re, glob_pattern, args.hidden, \u0026mut matches)?;\n\n    // Apply post-processing\n    let mut matches = if args.unique {\n        dedupe_matches(matches)\n    } else {\n        matches\n    };\n\n    if args.ranked {\n        rank_matches(\u0026mut matches);\n    }\n\n    if let Some(limit) = args.limit {\n        matches.truncate(limit);\n    }\n\n    Ok(matches)\n}\n\n/// Recursively collect matches from files\nfn collect_matches(\n    path: \u0026str,\n    re: \u0026Regex,\n    glob_pattern: Option\u003c\u0026str\u003e,\n    include_hidden: bool,\n    matches: \u0026mut Vec\u003cGrepMatch\u003e,\n) -\u003e Result\u003c()\u003e {\n    let path = Path::new(path);\n\n    if path.is_file() {\n        if should_search_file(path, glob_pattern) {\n            search_file(path, re, matches)?;\n        }\n        return Ok(());\n    }\n\n    if !path.is_dir() {\n        return Ok(());\n    }\n\n    let entries =\n        fs::read_dir(path).with_context(|| format!(\"Failed to read directory: {:?}\", path))?;\n\n    for entry in entries.flatten() {\n        let entry_path = entry.path();\n        let file_name = entry_path\n            .file_name()\n            .and_then(|n| n.to_str())\n            .unwrap_or(\"\");\n\n        // Skip hidden files unless requested\n        if !include_hidden \u0026\u0026 file_name.starts_with('.') {\n            continue;\n        }\n\n        // Skip common non-code directories\n        if entry_path.is_dir() \u0026\u0026 is_ignored_dir(file_name) {\n            continue;\n        }\n\n        if entry_path.is_dir() {\n            collect_matches(\n                entry_path.to_str().unwrap_or(\"\"),\n                re,\n                glob_pattern,\n                include_hidden,\n                matches,\n            )?;\n        } else if should_search_file(\u0026entry_path, glob_pattern) {\n            search_file(\u0026entry_path, re, matches)?;\n        }\n    }\n\n    Ok(())\n}\n\n/// Check if a directory should be ignored\nfn is_ignored_dir(name: \u0026str) -\u003e bool {\n    matches!(\n        name,\n        \"node_modules\"\n            | \"target\"\n            | \".git\"\n            | \".svn\"\n            | \".hg\"\n            | \"__pycache__\"\n            | \".mypy_cache\"\n            | \".pytest_cache\"\n            | \"venv\"\n            | \".venv\"\n            | \"dist\"\n            | \"build\"\n            | \".next\"\n            | \".nuxt\"\n    )\n}\n\n/// Check if a file matches the glob pattern\nfn should_search_file(path: \u0026Path, glob_pattern: Option\u003c\u0026str\u003e) -\u003e bool {\n    // Skip binary files\n    let ext = path.extension().and_then(|e| e.to_str()).unwrap_or(\"\");\n    if is_binary_extension(ext) {\n        return false;\n    }\n\n    // If no glob, search all text files\n    let Some(pattern) = glob_pattern else {\n        return true;\n    };\n\n    // Simple glob matching\n    let file_name = path.file_name().and_then(|n| n.to_str()).unwrap_or(\"\");\n    glob_matches(file_name, pattern)\n}\n\n/// Check if extension indicates binary file\nfn is_binary_extension(ext: \u0026str) -\u003e bool {\n    matches!(\n        ext.to_lowercase().as_str(),\n        \"png\"\n            | \"jpg\"\n            | \"jpeg\"\n            | \"gif\"\n            | \"ico\"\n            | \"webp\"\n            | \"bmp\"\n            | \"svg\"\n            | \"pdf\"\n            | \"zip\"\n            | \"tar\"\n            | \"gz\"\n            | \"bz2\"\n            | \"xz\"\n            | \"7z\"\n            | \"rar\"\n            | \"exe\"\n            | \"dll\"\n            | \"so\"\n            | \"dylib\"\n            | \"a\"\n            | \"o\"\n            | \"obj\"\n            | \"wasm\"\n            | \"class\"\n            | \"jar\"\n            | \"pyc\"\n            | \"pyo\"\n            | \"mp3\"\n            | \"mp4\"\n            | \"avi\"\n            | \"mkv\"\n            | \"mov\"\n            | \"wav\"\n            | \"flac\"\n            | \"ttf\"\n            | \"otf\"\n            | \"woff\"\n            | \"woff2\"\n            | \"eot\"\n            | \"sqlite\"\n            | \"db\"\n    )\n}\n\n/// Simple glob matching (supports * and ?)\npub fn glob_matches(name: \u0026str, pattern: \u0026str) -\u003e bool {\n    let pattern = pattern.trim_start_matches(\"**/\");\n\n    if let Some(ext) = pattern.strip_prefix(\"*.\") {\n        // Extension match: *.rs\n        name.ends_with(\u0026format!(\".{}\", ext))\n    } else if pattern.contains('*') {\n        // Convert glob to regex\n        let regex_pattern = pattern\n            .replace('.', \"\\\\.\")\n            .replace('*', \".*\")\n            .replace('?', \".\");\n        Regex::new(\u0026format!(\"^{}$\", regex_pattern))\n            .map(|re| re.is_match(name))\n            .unwrap_or(false)\n    } else {\n        // Exact match\n        name == pattern\n    }\n}\n\n/// Search a single file for matches\nfn search_file(path: \u0026Path, re: \u0026Regex, matches: \u0026mut Vec\u003cGrepMatch\u003e) -\u003e Result\u003c()\u003e {\n    let content = match fs::read_to_string(path) {\n        Ok(c) =\u003e c,\n        Err(_) =\u003e return Ok(()), // Skip unreadable files\n    };\n\n    let file_str = path.to_str().unwrap_or(\"\");\n\n    for (line_num, line) in content.lines().enumerate() {\n        let match_count = re.find_iter(line).count();\n        if match_count \u003e 0 {\n            matches.push(GrepMatch {\n                file: file_str.to_string(),\n                line_num: line_num + 1,\n                content: line.to_string(),\n                match_count,\n            });\n        }\n    }\n\n    Ok(())\n}\n\n/// Deduplicate similar matches\nfn dedupe_matches(matches: Vec\u003cGrepMatch\u003e) -\u003e Vec\u003cGrepMatch\u003e {\n    let mut seen: HashMap\u003cString, GrepMatch\u003e = HashMap::new();\n\n    for m in matches {\n        // Normalize content for comparison (trim, collapse whitespace)\n        let normalized = m.content.split_whitespace().collect::\u003cVec\u003c_\u003e\u003e().join(\" \");\n\n        seen.entry(normalized)\n            .and_modify(|existing| existing.match_count += m.match_count)\n            .or_insert(m);\n    }\n\n    seen.into_values().collect()\n}\n\n/// Rank matches by relevance (match density)\nfn rank_matches(matches: \u0026mut [GrepMatch]) {\n    matches.sort_by(|a, b| {\n        // Higher match count first\n        b.match_count\n            .cmp(\u0026a.match_count)\n            // Then shorter content (more focused)\n            .then_with(|| a.content.len().cmp(\u0026b.content.len()))\n    });\n}\n\n/// Format matches for output\npub fn format_matches(matches: \u0026[GrepMatch], args: \u0026GrepArgs) -\u003e String {\n    let mut output = Vec::new();\n\n    for m in matches {\n        if args.refs {\n            // Just file:line reference\n            output.push(format!(\"{}:{}\", m.file, m.line_num));\n        } else if args.signature {\n            // Try to extract function signature\n            if let Some(sig) = extract_signature(\u0026m.content, \u0026m.file) {\n                output.push(format!(\"{}:{}: {}\", m.file, m.line_num, sig));\n            } else {\n                output.push(format!(\"{}:{}: {}\", m.file, m.line_num, m.content.trim()));\n            }\n        } else {\n            // Full match with content\n            output.push(format!(\"{}:{}: {}\", m.file, m.line_num, m.content.trim()));\n        }\n    }\n\n    output.join(\"\\n\")\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":2}},{"line":24,"address":[],"length":0,"stats":{"Line":6}},{"line":26,"address":[],"length":0,"stats":{"Line":4}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":8}},{"line":32,"address":[],"length":0,"stats":{"Line":4}},{"line":34,"address":[],"length":0,"stats":{"Line":2}},{"line":38,"address":[],"length":0,"stats":{"Line":14}},{"line":39,"address":[],"length":0,"stats":{"Line":27}},{"line":40,"address":[],"length":0,"stats":{"Line":3}},{"line":42,"address":[],"length":0,"stats":{"Line":26}},{"line":44,"address":[],"length":0,"stats":{"Line":17}},{"line":46,"address":[],"length":0,"stats":{"Line":39}},{"line":47,"address":[],"length":0,"stats":{"Line":26}},{"line":49,"address":[],"length":0,"stats":{"Line":78}},{"line":52,"address":[],"length":0,"stats":{"Line":26}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[],"length":0,"stats":{"Line":12}},{"line":58,"address":[],"length":0,"stats":{"Line":14}},{"line":59,"address":[],"length":0,"stats":{"Line":1}},{"line":62,"address":[],"length":0,"stats":{"Line":15}},{"line":63,"address":[],"length":0,"stats":{"Line":2}},{"line":66,"address":[],"length":0,"stats":{"Line":13}},{"line":70,"address":[],"length":0,"stats":{"Line":13}},{"line":77,"address":[],"length":0,"stats":{"Line":39}},{"line":79,"address":[],"length":0,"stats":{"Line":26}},{"line":80,"address":[],"length":0,"stats":{"Line":9}},{"line":81,"address":[],"length":0,"stats":{"Line":12}},{"line":83,"address":[],"length":0,"stats":{"Line":3}},{"line":86,"address":[],"length":0,"stats":{"Line":10}},{"line":87,"address":[],"length":0,"stats":{"Line":1}},{"line":90,"address":[],"length":0,"stats":{"Line":9}},{"line":91,"address":[],"length":0,"stats":{"Line":27}},{"line":93,"address":[],"length":0,"stats":{"Line":34}},{"line":94,"address":[],"length":0,"stats":{"Line":48}},{"line":95,"address":[],"length":0,"stats":{"Line":32}},{"line":97,"address":[],"length":0,"stats":{"Line":48}},{"line":101,"address":[],"length":0,"stats":{"Line":44}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":106,"address":[],"length":0,"stats":{"Line":17}},{"line":107,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":14}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":42}},{"line":119,"address":[],"length":0,"stats":{"Line":52}},{"line":123,"address":[],"length":0,"stats":{"Line":9}},{"line":127,"address":[],"length":0,"stats":{"Line":6}},{"line":128,"address":[],"length":0,"stats":{"Line":4}},{"line":129,"address":[],"length":0,"stats":{"Line":6}},{"line":148,"address":[],"length":0,"stats":{"Line":19}},{"line":150,"address":[],"length":0,"stats":{"Line":152}},{"line":151,"address":[],"length":0,"stats":{"Line":38}},{"line":152,"address":[],"length":0,"stats":{"Line":1}},{"line":156,"address":[],"length":0,"stats":{"Line":20}},{"line":157,"address":[],"length":0,"stats":{"Line":16}},{"line":161,"address":[],"length":0,"stats":{"Line":16}},{"line":162,"address":[],"length":0,"stats":{"Line":6}},{"line":166,"address":[],"length":0,"stats":{"Line":28}},{"line":167,"address":[],"length":0,"stats":{"Line":7}},{"line":168,"address":[],"length":0,"stats":{"Line":28}},{"line":215,"address":[],"length":0,"stats":{"Line":10}},{"line":216,"address":[],"length":0,"stats":{"Line":30}},{"line":218,"address":[],"length":0,"stats":{"Line":16}},{"line":220,"address":[],"length":0,"stats":{"Line":18}},{"line":221,"address":[],"length":0,"stats":{"Line":8}},{"line":223,"address":[],"length":0,"stats":{"Line":10}},{"line":227,"address":[],"length":0,"stats":{"Line":4}},{"line":228,"address":[],"length":0,"stats":{"Line":8}},{"line":232,"address":[],"length":0,"stats":{"Line":2}},{"line":237,"address":[],"length":0,"stats":{"Line":16}},{"line":238,"address":[],"length":0,"stats":{"Line":32}},{"line":239,"address":[],"length":0,"stats":{"Line":32}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":80}},{"line":245,"address":[],"length":0,"stats":{"Line":710}},{"line":246,"address":[],"length":0,"stats":{"Line":1695}},{"line":247,"address":[],"length":0,"stats":{"Line":361}},{"line":248,"address":[],"length":0,"stats":{"Line":66}},{"line":249,"address":[],"length":0,"stats":{"Line":66}},{"line":250,"address":[],"length":0,"stats":{"Line":44}},{"line":251,"address":[],"length":0,"stats":{"Line":44}},{"line":252,"address":[],"length":0,"stats":{"Line":22}},{"line":257,"address":[],"length":0,"stats":{"Line":16}},{"line":261,"address":[],"length":0,"stats":{"Line":2}},{"line":262,"address":[],"length":0,"stats":{"Line":6}},{"line":264,"address":[],"length":0,"stats":{"Line":10}},{"line":266,"address":[],"length":0,"stats":{"Line":12}},{"line":268,"address":[],"length":0,"stats":{"Line":12}},{"line":269,"address":[],"length":0,"stats":{"Line":6}},{"line":270,"address":[],"length":0,"stats":{"Line":8}},{"line":273,"address":[],"length":0,"stats":{"Line":6}},{"line":277,"address":[],"length":0,"stats":{"Line":2}},{"line":278,"address":[],"length":0,"stats":{"Line":6}},{"line":280,"address":[],"length":0,"stats":{"Line":2}},{"line":281,"address":[],"length":0,"stats":{"Line":4}},{"line":283,"address":[],"length":0,"stats":{"Line":2}},{"line":288,"address":[],"length":0,"stats":{"Line":6}},{"line":289,"address":[],"length":0,"stats":{"Line":12}},{"line":291,"address":[],"length":0,"stats":{"Line":28}},{"line":292,"address":[],"length":0,"stats":{"Line":18}},{"line":294,"address":[],"length":0,"stats":{"Line":21}},{"line":295,"address":[],"length":0,"stats":{"Line":11}},{"line":297,"address":[],"length":0,"stats":{"Line":6}},{"line":298,"address":[],"length":0,"stats":{"Line":3}},{"line":300,"address":[],"length":0,"stats":{"Line":5}},{"line":304,"address":[],"length":0,"stats":{"Line":10}},{"line":308,"address":[],"length":0,"stats":{"Line":12}}],"covered":104,"coverable":112},{"path":["/","Users","chi","Projects","hu","src","utils","grep","tests.rs"],"content":"use super::*;\n\n#[test]\nfn glob_matches_extension() {\n    assert!(glob_matches(\"foo.rs\", \"*.rs\"));\n    assert!(glob_matches(\"bar.rs\", \"*.rs\"));\n    assert!(!glob_matches(\"foo.py\", \"*.rs\"));\n}\n\n#[test]\nfn glob_matches_recursive() {\n    assert!(glob_matches(\"foo.rs\", \"**/*.rs\"));\n}\n\n#[test]\nfn glob_matches_exact() {\n    assert!(glob_matches(\"Cargo.toml\", \"Cargo.toml\"));\n    assert!(!glob_matches(\"cargo.toml\", \"Cargo.toml\"));\n}\n\n#[test]\nfn glob_matches_wildcard() {\n    assert!(glob_matches(\"test_foo.rs\", \"test_*.rs\"));\n    assert!(!glob_matches(\"foo_test.rs\", \"test_*.rs\"));\n}\n\n#[test]\nfn is_ignored_dir_common() {\n    assert!(is_ignored_dir(\"node_modules\"));\n    assert!(is_ignored_dir(\"target\"));\n    assert!(is_ignored_dir(\".git\"));\n    assert!(!is_ignored_dir(\"src\"));\n    assert!(!is_ignored_dir(\"lib\"));\n}\n\n#[test]\nfn is_binary_extension_images() {\n    assert!(is_binary_extension(\"png\"));\n    assert!(is_binary_extension(\"jpg\"));\n    assert!(is_binary_extension(\"gif\"));\n}\n\n#[test]\nfn is_binary_extension_archives() {\n    assert!(is_binary_extension(\"zip\"));\n    assert!(is_binary_extension(\"tar\"));\n    assert!(is_binary_extension(\"gz\"));\n}\n\n#[test]\nfn is_binary_extension_code() {\n    assert!(!is_binary_extension(\"rs\"));\n    assert!(!is_binary_extension(\"py\"));\n    assert!(!is_binary_extension(\"js\"));\n}\n\n#[test]\nfn format_matches_refs_mode() {\n    let matches = vec![GrepMatch {\n        file: \"src/main.rs\".to_string(),\n        line_num: 42,\n        content: \"    let x = 1;\".to_string(),\n        match_count: 1,\n    }];\n    let args = GrepArgs {\n        pattern: \"x\".to_string(),\n        path: \".\".to_string(),\n        refs: true,\n        unique: false,\n        ranked: false,\n        limit: None,\n        signature: false,\n        glob: None,\n        ignore_case: false,\n        hidden: false,\n    };\n    let output = format_matches(\u0026matches, \u0026args);\n    assert_eq!(output, \"src/main.rs:42\");\n}\n\n#[test]\nfn format_matches_full_mode() {\n    let matches = vec![GrepMatch {\n        file: \"src/main.rs\".to_string(),\n        line_num: 42,\n        content: \"    let x = 1;\".to_string(),\n        match_count: 1,\n    }];\n    let args = GrepArgs {\n        pattern: \"x\".to_string(),\n        path: \".\".to_string(),\n        refs: false,\n        unique: false,\n        ranked: false,\n        limit: None,\n        signature: false,\n        glob: None,\n        ignore_case: false,\n        hidden: false,\n    };\n    let output = format_matches(\u0026matches, \u0026args);\n    assert_eq!(output, \"src/main.rs:42: let x = 1;\");\n}\n\n#[test]\nfn dedupe_matches_combines_counts() {\n    let matches = vec![\n        GrepMatch {\n            file: \"a.rs\".to_string(),\n            line_num: 1,\n            content: \"let x = 1;\".to_string(),\n            match_count: 1,\n        },\n        GrepMatch {\n            file: \"b.rs\".to_string(),\n            line_num: 5,\n            content: \"let x = 1;\".to_string(),\n            match_count: 2,\n        },\n    ];\n    let deduped = dedupe_matches(matches);\n    assert_eq!(deduped.len(), 1);\n    assert_eq!(deduped[0].match_count, 3); // 1 + 2\n}\n\n#[test]\nfn rank_matches_by_count() {\n    let mut matches = vec![\n        GrepMatch {\n            file: \"a.rs\".to_string(),\n            line_num: 1,\n            content: \"one match\".to_string(),\n            match_count: 1,\n        },\n        GrepMatch {\n            file: \"b.rs\".to_string(),\n            line_num: 2,\n            content: \"three matches\".to_string(),\n            match_count: 3,\n        },\n    ];\n    rank_matches(\u0026mut matches);\n    assert_eq!(matches[0].match_count, 3); // Higher count first\n}\n\n#[test]\nfn search_files_respects_limit() {\n    let temp_dir = std::env::temp_dir().join(\"hu_grep_test\");\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n    std::fs::create_dir_all(\u0026temp_dir).unwrap();\n\n    std::fs::write(temp_dir.join(\"a.txt\"), \"test line 1\\ntest line 2\\n\").unwrap();\n    std::fs::write(temp_dir.join(\"b.txt\"), \"test line 3\\n\").unwrap();\n\n    let args = GrepArgs {\n        pattern: \"test\".to_string(),\n        path: temp_dir.to_str().unwrap().to_string(),\n        refs: false,\n        unique: false,\n        ranked: false,\n        limit: Some(2),\n        signature: false,\n        glob: None,\n        ignore_case: false,\n        hidden: false,\n    };\n\n    let matches = search_files(\u0026args).unwrap();\n    assert_eq!(matches.len(), 2);\n\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n}\n\n#[test]\nfn search_files_respects_glob() {\n    let temp_dir = std::env::temp_dir().join(\"hu_grep_glob_test\");\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n    std::fs::create_dir_all(\u0026temp_dir).unwrap();\n\n    std::fs::write(temp_dir.join(\"foo.rs\"), \"test\\n\").unwrap();\n    std::fs::write(temp_dir.join(\"bar.py\"), \"test\\n\").unwrap();\n\n    let args = GrepArgs {\n        pattern: \"test\".to_string(),\n        path: temp_dir.to_str().unwrap().to_string(),\n        refs: false,\n        unique: false,\n        ranked: false,\n        limit: None,\n        signature: false,\n        glob: Some(\"*.rs\".to_string()),\n        ignore_case: false,\n        hidden: false,\n    };\n\n    let matches = search_files(\u0026args).unwrap();\n    assert_eq!(matches.len(), 1);\n    assert!(matches[0].file.ends_with(\"foo.rs\"));\n\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n}\n\n#[test]\nfn format_matches_signature_mode() {\n    let matches = vec![GrepMatch {\n        file: \"src/main.rs\".to_string(),\n        line_num: 42,\n        content: \"pub fn process() {\".to_string(),\n        match_count: 1,\n    }];\n    let args = GrepArgs {\n        pattern: \"process\".to_string(),\n        path: \".\".to_string(),\n        refs: false,\n        unique: false,\n        ranked: false,\n        limit: None,\n        signature: true,\n        glob: None,\n        ignore_case: false,\n        hidden: false,\n    };\n    let output = format_matches(\u0026matches, \u0026args);\n    assert!(output.contains(\"pub fn process()\"));\n    assert!(!output.contains(\"{\")); // signature strips the brace\n}\n\n#[test]\nfn format_matches_signature_no_match() {\n    // When line doesn't match signature pattern, falls back to trimmed content\n    let matches = vec![GrepMatch {\n        file: \"src/main.rs\".to_string(),\n        line_num: 42,\n        content: \"    let x = 1;\".to_string(),\n        match_count: 1,\n    }];\n    let args = GrepArgs {\n        pattern: \"x\".to_string(),\n        path: \".\".to_string(),\n        refs: false,\n        unique: false,\n        ranked: false,\n        limit: None,\n        signature: true,\n        glob: None,\n        ignore_case: false,\n        hidden: false,\n    };\n    let output = format_matches(\u0026matches, \u0026args);\n    assert!(output.contains(\"let x = 1;\"));\n}\n\n#[test]\nfn grep_match_debug() {\n    let m = GrepMatch {\n        file: \"test.rs\".to_string(),\n        line_num: 1,\n        content: \"test\".to_string(),\n        match_count: 1,\n    };\n    let debug = format!(\"{:?}\", m);\n    assert!(debug.contains(\"GrepMatch\"));\n}\n\n#[test]\nfn grep_match_clone() {\n    let m = GrepMatch {\n        file: \"test.rs\".to_string(),\n        line_num: 1,\n        content: \"test\".to_string(),\n        match_count: 1,\n    };\n    let cloned = m.clone();\n    assert_eq!(cloned.file, m.file);\n    assert_eq!(cloned.line_num, m.line_num);\n}\n\n#[test]\nfn search_files_with_unique() {\n    let temp_dir = std::env::temp_dir().join(\"hu_grep_unique_test\");\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n    std::fs::create_dir_all(\u0026temp_dir).unwrap();\n\n    std::fs::write(temp_dir.join(\"a.txt\"), \"let x = 1;\\n\").unwrap();\n    std::fs::write(temp_dir.join(\"b.txt\"), \"let x = 1;\\n\").unwrap();\n\n    let args = GrepArgs {\n        pattern: \"let\".to_string(),\n        path: temp_dir.to_str().unwrap().to_string(),\n        refs: false,\n        unique: true,\n        ranked: false,\n        limit: None,\n        signature: false,\n        glob: None,\n        ignore_case: false,\n        hidden: false,\n    };\n\n    let matches = search_files(\u0026args).unwrap();\n    assert_eq!(matches.len(), 1);\n    assert_eq!(matches[0].match_count, 2);\n\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n}\n\n#[test]\nfn search_files_with_ranked() {\n    let temp_dir = std::env::temp_dir().join(\"hu_grep_ranked_test\");\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n    std::fs::create_dir_all(\u0026temp_dir).unwrap();\n\n    std::fs::write(temp_dir.join(\"a.txt\"), \"test\\n\").unwrap();\n    std::fs::write(temp_dir.join(\"b.txt\"), \"test test test\\n\").unwrap();\n\n    let args = GrepArgs {\n        pattern: \"test\".to_string(),\n        path: temp_dir.to_str().unwrap().to_string(),\n        refs: false,\n        unique: false,\n        ranked: true,\n        limit: None,\n        signature: false,\n        glob: None,\n        ignore_case: false,\n        hidden: false,\n    };\n\n    let matches = search_files(\u0026args).unwrap();\n    assert!(matches[0].match_count \u003e= matches[1].match_count);\n\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n}\n\n#[test]\nfn collect_matches_skips_hidden() {\n    let temp_dir = std::env::temp_dir().join(\"hu_grep_hidden_test\");\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n    std::fs::create_dir_all(\u0026temp_dir).unwrap();\n    std::fs::create_dir_all(temp_dir.join(\".hidden\")).unwrap();\n\n    std::fs::write(temp_dir.join(\"visible.txt\"), \"test\\n\").unwrap();\n    std::fs::write(temp_dir.join(\".hidden\").join(\"secret.txt\"), \"test\\n\").unwrap();\n\n    let args = GrepArgs {\n        pattern: \"test\".to_string(),\n        path: temp_dir.to_str().unwrap().to_string(),\n        refs: false,\n        unique: false,\n        ranked: false,\n        limit: None,\n        signature: false,\n        glob: None,\n        ignore_case: false,\n        hidden: false,\n    };\n\n    let matches = search_files(\u0026args).unwrap();\n    assert_eq!(matches.len(), 1);\n    assert!(matches[0].file.contains(\"visible\"));\n\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n}\n\n#[test]\nfn collect_matches_includes_hidden_when_requested() {\n    let temp_dir = std::env::temp_dir().join(\"hu_grep_hidden_incl_test\");\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n    std::fs::create_dir_all(\u0026temp_dir).unwrap();\n\n    std::fs::write(temp_dir.join(\".hidden_file.txt\"), \"test\\n\").unwrap();\n    std::fs::write(temp_dir.join(\"visible.txt\"), \"test\\n\").unwrap();\n\n    let args = GrepArgs {\n        pattern: \"test\".to_string(),\n        path: temp_dir.to_str().unwrap().to_string(),\n        refs: false,\n        unique: false,\n        ranked: false,\n        limit: None,\n        signature: false,\n        glob: None,\n        ignore_case: false,\n        hidden: true,\n    };\n\n    let matches = search_files(\u0026args).unwrap();\n    assert_eq!(matches.len(), 2);\n\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n}\n\n#[test]\nfn search_files_skips_ignored_dirs() {\n    let temp_dir = std::env::temp_dir().join(\"hu_grep_ignored_test\");\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n    std::fs::create_dir_all(\u0026temp_dir).unwrap();\n    std::fs::create_dir_all(temp_dir.join(\"node_modules\")).unwrap();\n\n    std::fs::write(temp_dir.join(\"app.js\"), \"test\\n\").unwrap();\n    std::fs::write(temp_dir.join(\"node_modules\").join(\"dep.js\"), \"test\\n\").unwrap();\n\n    let args = GrepArgs {\n        pattern: \"test\".to_string(),\n        path: temp_dir.to_str().unwrap().to_string(),\n        refs: false,\n        unique: false,\n        ranked: false,\n        limit: None,\n        signature: false,\n        glob: None,\n        ignore_case: false,\n        hidden: false,\n    };\n\n    let matches = search_files(\u0026args).unwrap();\n    assert_eq!(matches.len(), 1);\n    assert!(matches[0].file.contains(\"app.js\"));\n\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n}\n\n#[test]\nfn search_files_single_file_path() {\n    let temp_dir = std::env::temp_dir().join(\"hu_grep_single_file_test\");\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n    std::fs::create_dir_all(\u0026temp_dir).unwrap();\n\n    let file_path = temp_dir.join(\"single.txt\");\n    std::fs::write(\u0026file_path, \"test line\\n\").unwrap();\n\n    let args = GrepArgs {\n        pattern: \"test\".to_string(),\n        path: file_path.to_str().unwrap().to_string(),\n        refs: false,\n        unique: false,\n        ranked: false,\n        limit: None,\n        signature: false,\n        glob: None,\n        ignore_case: false,\n        hidden: false,\n    };\n\n    let matches = search_files(\u0026args).unwrap();\n    assert_eq!(matches.len(), 1);\n\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n}\n\n#[test]\nfn search_files_nonexistent_path() {\n    let args = GrepArgs {\n        pattern: \"test\".to_string(),\n        path: \"/nonexistent/path/12345\".to_string(),\n        refs: false,\n        unique: false,\n        ranked: false,\n        limit: None,\n        signature: false,\n        glob: None,\n        ignore_case: false,\n        hidden: false,\n    };\n\n    let matches = search_files(\u0026args).unwrap();\n    assert!(matches.is_empty());\n}\n\n#[test]\nfn search_files_invalid_regex() {\n    let args = GrepArgs {\n        pattern: \"[invalid\".to_string(),\n        path: \".\".to_string(),\n        refs: false,\n        unique: false,\n        ranked: false,\n        limit: None,\n        signature: false,\n        glob: None,\n        ignore_case: false,\n        hidden: false,\n    };\n\n    let result = search_files(\u0026args);\n    assert!(result.is_err());\n}\n\n#[test]\nfn search_files_case_insensitive() {\n    let temp_dir = std::env::temp_dir().join(\"hu_grep_case_test\");\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n    std::fs::create_dir_all(\u0026temp_dir).unwrap();\n\n    std::fs::write(temp_dir.join(\"test.txt\"), \"Hello HELLO hello\\n\").unwrap();\n\n    let args_sensitive = GrepArgs {\n        pattern: \"Hello\".to_string(),\n        path: temp_dir.to_str().unwrap().to_string(),\n        refs: false,\n        unique: false,\n        ranked: false,\n        limit: None,\n        signature: false,\n        glob: None,\n        ignore_case: false,\n        hidden: false,\n    };\n\n    let matches_sensitive = search_files(\u0026args_sensitive).unwrap();\n    assert_eq!(matches_sensitive[0].match_count, 1);\n\n    let args_insensitive = GrepArgs {\n        pattern: \"Hello\".to_string(),\n        path: temp_dir.to_str().unwrap().to_string(),\n        refs: false,\n        unique: false,\n        ranked: false,\n        limit: None,\n        signature: false,\n        glob: None,\n        ignore_case: true,\n        hidden: false,\n    };\n\n    let matches_insensitive = search_files(\u0026args_insensitive).unwrap();\n    assert_eq!(matches_insensitive[0].match_count, 3);\n\n    let _ = std::fs::remove_dir_all(\u0026temp_dir);\n}\n\n#[test]\nfn should_search_file_binary_extension() {\n    let path = std::path::Path::new(\"image.png\");\n    assert!(!should_search_file(path, None));\n}\n\n#[test]\nfn should_search_file_text_no_glob() {\n    let path = std::path::Path::new(\"file.txt\");\n    assert!(should_search_file(path, None));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","chi","Projects","hu","src","utils","mod.rs"],"content":"mod cli;\nmod docs_index;\nmod docs_search;\nmod docs_section;\nmod fetch_html;\nmod grep;\nmod signature;\nmod web_search;\n\npub use cli::UtilsCommand;\n\nuse anyhow::Result;\n\n/// Run a utils subcommand\npub async fn run_command(cmd: UtilsCommand) -\u003e Result\u003c()\u003e {\n    match cmd {\n        UtilsCommand::FetchHtml(args) =\u003e fetch_html::run(args).await,\n        UtilsCommand::Grep(args) =\u003e grep::run(args),\n        UtilsCommand::WebSearch(args) =\u003e web_search::run(args).await,\n        UtilsCommand::DocsIndex(args) =\u003e run_docs_index(args),\n        UtilsCommand::DocsSearch(args) =\u003e run_docs_search(args),\n        UtilsCommand::DocsSection(args) =\u003e run_docs_section(args),\n    }\n}\n\nuse cli::{DocsIndexArgs, DocsSearchArgs, DocsSectionArgs};\n\nfn run_docs_index(args: DocsIndexArgs) -\u003e Result\u003c()\u003e {\n    let index = docs_index::build_index(\u0026args.path)?;\n\n    if let Some(output) = args.output {\n        docs_index::save_index(\u0026index, \u0026output)?;\n        println!(\"Index saved to {}\", output);\n    } else {\n        println!(\n            \"Indexed {} files, {} sections\",\n            index.file_count(),\n            index.section_count()\n        );\n        for (path, file) in \u0026index.files {\n            println!(\"\\n{}:\", path);\n            for section in \u0026file.sections {\n                let indent = \"  \".repeat((section.level - 1) as usize);\n                println!(\n                    \"  {}{} (L{}-{})\",\n                    indent, section.heading, section.start_line, section.end_line\n                );\n            }\n        }\n    }\n\n    Ok(())\n}\n\nfn run_docs_search(args: DocsSearchArgs) -\u003e Result\u003c()\u003e {\n    let index = docs_index::load_index(\u0026args.index)?;\n    let results = docs_search::search_index(\u0026index, \u0026args.query);\n    let output = docs_search::format_results(\u0026results, args.limit);\n    println!(\"{}\", output);\n    Ok(())\n}\n\nfn run_docs_section(args: DocsSectionArgs) -\u003e Result\u003c()\u003e {\n    let content = docs_section::extract_section_from_file(\u0026args.file, \u0026args.heading)?;\n    println!(\"{}\", content);\n    Ok(())\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":4}},{"line":16,"address":[],"length":0,"stats":{"Line":2}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":6}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}}],"covered":3,"coverable":35},{"path":["/","Users","chi","Projects","hu","src","utils","signature.rs"],"content":"//! Language-specific signature extraction for code search results.\n//!\n//! Extracts function/class/struct signatures from source code lines\n//! to provide cleaner search output.\n\nuse regex::Regex;\nuse std::path::Path;\n\n/// Try to extract function/method signature from a line based on file extension.\npub fn extract_signature(line: \u0026str, file: \u0026str) -\u003e Option\u003cString\u003e {\n    let trimmed = line.trim();\n    let ext = Path::new(file)\n        .extension()\n        .and_then(|e| e.to_str())\n        .unwrap_or(\"\");\n\n    match ext {\n        \"rs\" =\u003e extract_rust_signature(trimmed),\n        \"py\" =\u003e extract_python_signature(trimmed),\n        \"js\" | \"ts\" | \"jsx\" | \"tsx\" =\u003e extract_js_signature(trimmed),\n        \"rb\" =\u003e extract_ruby_signature(trimmed),\n        \"go\" =\u003e extract_go_signature(trimmed),\n        _ =\u003e None,\n    }\n}\n\n/// Extract Rust function/struct signature\nfn extract_rust_signature(line: \u0026str) -\u003e Option\u003cString\u003e {\n    // fn name(...) -\u003e Type\n    if let Some(caps) =\n        Regex::new(r\"^(pub\\s+)?(async\\s+)?fn\\s+(\\w+)\\s*(\u003c[^\u003e]+\u003e)?\\s*\\([^)]*\\)(\\s*-\u003e\\s*[^{]+)?\")\n            .ok()?\n            .captures(line)\n    {\n        return Some(\n            caps.get(0)?\n                .as_str()\n                .trim_end_matches('{')\n                .trim()\n                .to_string(),\n        );\n    }\n\n    // struct/enum/impl\n    if let Some(caps) = Regex::new(r\"^(pub\\s+)?(struct|enum|impl|trait)\\s+(\\w+)(\u003c[^\u003e]+\u003e)?\")\n        .ok()?\n        .captures(line)\n    {\n        return Some(caps.get(0)?.as_str().to_string());\n    }\n\n    None\n}\n\n/// Extract Python function/class signature\nfn extract_python_signature(line: \u0026str) -\u003e Option\u003cString\u003e {\n    // def name(...):\n    if let Some(caps) = Regex::new(r\"^(async\\s+)?def\\s+(\\w+)\\s*\\([^)]*\\)(\\s*-\u003e\\s*[^:]+)?:\")\n        .ok()?\n        .captures(line)\n    {\n        return Some(caps.get(0)?.as_str().trim_end_matches(':').to_string());\n    }\n\n    // class Name:\n    if let Some(caps) = Regex::new(r\"^class\\s+(\\w+)(\\([^)]*\\))?:\")\n        .ok()?\n        .captures(line)\n    {\n        return Some(caps.get(0)?.as_str().trim_end_matches(':').to_string());\n    }\n\n    None\n}\n\n/// Extract JavaScript/TypeScript function signature\nfn extract_js_signature(line: \u0026str) -\u003e Option\u003cString\u003e {\n    // function name(...)\n    if let Some(caps) =\n        Regex::new(r\"^(export\\s+)?(async\\s+)?function\\s+(\\w+)\\s*(\u003c[^\u003e]+\u003e)?\\s*\\([^)]*\\)\")\n            .ok()?\n            .captures(line)\n    {\n        return Some(caps.get(0)?.as_str().to_string());\n    }\n\n    // const name = (...) =\u003e\n    if let Some(caps) =\n        Regex::new(r\"^(export\\s+)?(const|let|var)\\s+(\\w+)\\s*=\\s*(async\\s+)?\\([^)]*\\)\\s*=\u003e\")\n            .ok()?\n            .captures(line)\n    {\n        return Some(\n            caps.get(0)?\n                .as_str()\n                .trim_end_matches(\"=\u003e\")\n                .trim()\n                .to_string(),\n        );\n    }\n\n    // class Name\n    if let Some(caps) = Regex::new(r\"^(export\\s+)?class\\s+(\\w+)(\\s+extends\\s+\\w+)?\")\n        .ok()?\n        .captures(line)\n    {\n        return Some(caps.get(0)?.as_str().to_string());\n    }\n\n    None\n}\n\n/// Extract Ruby method/class signature\nfn extract_ruby_signature(line: \u0026str) -\u003e Option\u003cString\u003e {\n    // def name(...)\n    if let Some(caps) = Regex::new(r\"^def\\s+(\\w+[?!=]?)(\\([^)]*\\))?\")\n        .ok()?\n        .captures(line)\n    {\n        return Some(caps.get(0)?.as_str().to_string());\n    }\n\n    // class Name\n    if let Some(caps) = Regex::new(r\"^class\\s+(\\w+)(\\s*\u003c\\s*\\w+)?\")\n        .ok()?\n        .captures(line)\n    {\n        return Some(caps.get(0)?.as_str().to_string());\n    }\n\n    None\n}\n\n/// Extract Go function signature\nfn extract_go_signature(line: \u0026str) -\u003e Option\u003cString\u003e {\n    // func name(...)\n    if let Some(caps) =\n        Regex::new(r\"^func\\s+(\\([^)]+\\)\\s+)?(\\w+)\\s*\\([^)]*\\)(\\s*\\([^)]*\\)|\\s*\\w+)?\")\n            .ok()?\n            .captures(line)\n    {\n        return Some(caps.get(0)?.as_str().to_string());\n    }\n\n    // type Name struct/interface\n    if let Some(caps) = Regex::new(r\"^type\\s+(\\w+)\\s+(struct|interface)\")\n        .ok()?\n        .captures(line)\n    {\n        return Some(caps.get(0)?.as_str().to_string());\n    }\n\n    None\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn extract_rust_fn_signature() {\n        let sig = extract_rust_signature(\"pub fn foo(x: i32) -\u003e String {\").unwrap();\n        assert_eq!(sig, \"pub fn foo(x: i32) -\u003e String\");\n    }\n\n    #[test]\n    fn extract_rust_async_fn_signature() {\n        let sig = extract_rust_signature(\"pub async fn fetch() -\u003e Result\u003c()\u003e {\").unwrap();\n        assert_eq!(sig, \"pub async fn fetch() -\u003e Result\u003c()\u003e\");\n    }\n\n    #[test]\n    fn extract_rust_struct_signature() {\n        let sig = extract_rust_signature(\"pub struct Config\u003cT\u003e {\").unwrap();\n        assert_eq!(sig, \"pub struct Config\u003cT\u003e\");\n    }\n\n    #[test]\n    fn extract_python_def_signature() {\n        let sig = extract_python_signature(\"def process(data: list) -\u003e dict:\").unwrap();\n        assert_eq!(sig, \"def process(data: list) -\u003e dict\");\n    }\n\n    #[test]\n    fn extract_python_class_signature() {\n        let sig = extract_python_signature(\"class Handler(BaseHandler):\").unwrap();\n        assert_eq!(sig, \"class Handler(BaseHandler)\");\n    }\n\n    #[test]\n    fn extract_python_async_def() {\n        let sig = extract_python_signature(\"async def fetch_data(url: str) -\u003e dict:\").unwrap();\n        assert!(sig.contains(\"async def fetch_data\"));\n    }\n\n    #[test]\n    fn extract_python_signature_no_match() {\n        let result = extract_python_signature(\"just some regular text\");\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn extract_js_function_signature() {\n        let sig = extract_js_signature(\"export async function fetchData(url) {\").unwrap();\n        assert_eq!(sig, \"export async function fetchData(url)\");\n    }\n\n    #[test]\n    fn extract_js_arrow_signature() {\n        let sig = extract_js_signature(\"const handler = async (req, res) =\u003e\").unwrap();\n        assert_eq!(sig, \"const handler = async (req, res)\");\n    }\n\n    #[test]\n    fn extract_js_class_signature() {\n        let sig = extract_js_signature(\"export class UserService extends BaseService {\").unwrap();\n        assert!(sig.contains(\"class UserService\"));\n        assert!(sig.contains(\"extends BaseService\"));\n    }\n\n    #[test]\n    fn extract_js_signature_no_match() {\n        let result = extract_js_signature(\"console.log('hello')\");\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn extract_ruby_def_signature() {\n        let sig = extract_ruby_signature(\"def process(data)\").unwrap();\n        assert_eq!(sig, \"def process(data)\");\n    }\n\n    #[test]\n    fn extract_ruby_predicate_signature() {\n        let sig = extract_ruby_signature(\"def valid?\").unwrap();\n        assert_eq!(sig, \"def valid?\");\n    }\n\n    #[test]\n    fn extract_ruby_class_with_inheritance() {\n        let sig = extract_ruby_signature(\"class User \u003c ActiveRecord::Base\").unwrap();\n        assert!(sig.contains(\"class User\"));\n    }\n\n    #[test]\n    fn extract_ruby_signature_no_match() {\n        let result = extract_ruby_signature(\"puts 'hello world'\");\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn extract_go_func_signature() {\n        let sig =\n            extract_go_signature(\"func (s *Server) Handle(w http.ResponseWriter, r *http.Request)\")\n                .unwrap();\n        assert!(sig.contains(\"func\"));\n        assert!(sig.contains(\"Handle\"));\n    }\n\n    #[test]\n    fn extract_go_type_interface() {\n        let sig = extract_go_signature(\"type Handler interface {\").unwrap();\n        assert_eq!(sig, \"type Handler interface\");\n    }\n\n    #[test]\n    fn extract_go_signature_no_match() {\n        let result = extract_go_signature(\"fmt.Println(\\\"hello\\\")\");\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn extract_signature_by_extension() {\n        let sig = extract_signature(\"pub fn test() {\", \"foo.rs\").unwrap();\n        assert!(sig.contains(\"fn test\"));\n\n        let sig = extract_signature(\"def test():\", \"foo.py\").unwrap();\n        assert!(sig.contains(\"def test\"));\n    }\n\n    #[test]\n    fn extract_signature_unknown_extension() {\n        let result = extract_signature(\"some random line\", \"file.xyz\");\n        assert!(result.is_none());\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":5}},{"line":11,"address":[],"length":0,"stats":{"Line":15}},{"line":12,"address":[],"length":0,"stats":{"Line":10}},{"line":14,"address":[],"length":0,"stats":{"Line":15}},{"line":17,"address":[],"length":0,"stats":{"Line":5}},{"line":18,"address":[],"length":0,"stats":{"Line":11}},{"line":19,"address":[],"length":0,"stats":{"Line":4}},{"line":20,"address":[],"length":0,"stats":{"Line":4}},{"line":21,"address":[],"length":0,"stats":{"Line":1}},{"line":22,"address":[],"length":0,"stats":{"Line":1}},{"line":23,"address":[],"length":0,"stats":{"Line":1}},{"line":28,"address":[],"length":0,"stats":{"Line":6}},{"line":30,"address":[],"length":0,"stats":{"Line":4}},{"line":31,"address":[],"length":0,"stats":{"Line":12}},{"line":33,"address":[],"length":0,"stats":{"Line":12}},{"line":36,"address":[],"length":0,"stats":{"Line":8}},{"line":37,"address":[],"length":0,"stats":{"Line":4}},{"line":38,"address":[],"length":0,"stats":{"Line":4}},{"line":39,"address":[],"length":0,"stats":{"Line":4}},{"line":40,"address":[],"length":0,"stats":{"Line":4}},{"line":45,"address":[],"length":0,"stats":{"Line":5}},{"line":47,"address":[],"length":0,"stats":{"Line":4}},{"line":49,"address":[],"length":0,"stats":{"Line":4}},{"line":52,"address":[],"length":0,"stats":{"Line":1}},{"line":56,"address":[],"length":0,"stats":{"Line":5}},{"line":58,"address":[],"length":0,"stats":{"Line":13}},{"line":60,"address":[],"length":0,"stats":{"Line":10}},{"line":62,"address":[],"length":0,"stats":{"Line":15}},{"line":66,"address":[],"length":0,"stats":{"Line":5}},{"line":68,"address":[],"length":0,"stats":{"Line":4}},{"line":70,"address":[],"length":0,"stats":{"Line":5}},{"line":73,"address":[],"length":0,"stats":{"Line":1}},{"line":77,"address":[],"length":0,"stats":{"Line":4}},{"line":79,"address":[],"length":0,"stats":{"Line":1}},{"line":80,"address":[],"length":0,"stats":{"Line":8}},{"line":82,"address":[],"length":0,"stats":{"Line":8}},{"line":84,"address":[],"length":0,"stats":{"Line":4}},{"line":88,"address":[],"length":0,"stats":{"Line":1}},{"line":89,"address":[],"length":0,"stats":{"Line":6}},{"line":91,"address":[],"length":0,"stats":{"Line":6}},{"line":94,"address":[],"length":0,"stats":{"Line":2}},{"line":95,"address":[],"length":0,"stats":{"Line":1}},{"line":96,"address":[],"length":0,"stats":{"Line":1}},{"line":97,"address":[],"length":0,"stats":{"Line":1}},{"line":98,"address":[],"length":0,"stats":{"Line":1}},{"line":103,"address":[],"length":0,"stats":{"Line":5}},{"line":105,"address":[],"length":0,"stats":{"Line":4}},{"line":107,"address":[],"length":0,"stats":{"Line":4}},{"line":110,"address":[],"length":0,"stats":{"Line":1}},{"line":114,"address":[],"length":0,"stats":{"Line":4}},{"line":116,"address":[],"length":0,"stats":{"Line":10}},{"line":118,"address":[],"length":0,"stats":{"Line":8}},{"line":120,"address":[],"length":0,"stats":{"Line":8}},{"line":124,"address":[],"length":0,"stats":{"Line":5}},{"line":126,"address":[],"length":0,"stats":{"Line":4}},{"line":128,"address":[],"length":0,"stats":{"Line":4}},{"line":131,"address":[],"length":0,"stats":{"Line":1}},{"line":135,"address":[],"length":0,"stats":{"Line":3}},{"line":137,"address":[],"length":0,"stats":{"Line":1}},{"line":138,"address":[],"length":0,"stats":{"Line":6}},{"line":140,"address":[],"length":0,"stats":{"Line":6}},{"line":142,"address":[],"length":0,"stats":{"Line":4}},{"line":146,"address":[],"length":0,"stats":{"Line":5}},{"line":148,"address":[],"length":0,"stats":{"Line":4}},{"line":150,"address":[],"length":0,"stats":{"Line":4}},{"line":153,"address":[],"length":0,"stats":{"Line":1}}],"covered":66,"coverable":66},{"path":["/","Users","chi","Projects","hu","src","utils","web_search","mod.rs"],"content":"use anyhow::{bail, Context, Result};\nuse serde::Deserialize;\nuse std::fs;\n\nuse super::cli::WebSearchArgs;\nuse super::fetch_html::extract_summary;\nuse crate::util::{load_credentials, BraveCredentials};\n\n#[cfg(test)]\nmod tests;\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/// A single search result from Brave API\n#[derive(Debug, Clone, Deserialize)]\npub struct SearchResult {\n    pub title: String,\n    pub url: String,\n    #[serde(default)]\n    pub description: String,\n}\n\n/// Web results container from Brave API\n#[derive(Debug, Deserialize)]\npub struct WebResults {\n    #[serde(default)]\n    pub results: Vec\u003cSearchResult\u003e,\n}\n\n/// Top-level Brave API response\n#[derive(Debug, Deserialize)]\npub struct BraveSearchResponse {\n    #[serde(default)]\n    pub web: Option\u003cWebResults\u003e,\n}\n\n/// Fetched content for a search result\n#[derive(Debug)]\npub struct FetchedResult {\n    pub title: String,\n    pub url: String,\n    pub description: String,\n    pub content: Option\u003cString\u003e,\n}\n\n// ============================================================================\n// Client trait\n// ============================================================================\n\n/// Trait for Brave Search API operations\n#[async_trait::async_trait]\npub trait BraveSearchApi {\n    async fn search(\u0026self, query: \u0026str, count: usize) -\u003e Result\u003cVec\u003cSearchResult\u003e\u003e;\n}\n\n/// Production client for Brave Search\npub struct BraveSearchClient {\n    api_key: String,\n    http: reqwest::Client,\n}\n\nimpl BraveSearchClient {\n    pub fn new(api_key: String) -\u003e Self {\n        let http = reqwest::Client::builder()\n            .user_agent(\"hu-cli/0.1\")\n            .build()\n            .expect(\"Failed to build HTTP client\");\n        Self { api_key, http }\n    }\n\n    pub fn from_credentials(creds: \u0026BraveCredentials) -\u003e Self {\n        Self::new(creds.api_key.clone())\n    }\n}\n\n#[async_trait::async_trait]\nimpl BraveSearchApi for BraveSearchClient {\n    async fn search(\u0026self, query: \u0026str, count: usize) -\u003e Result\u003cVec\u003cSearchResult\u003e\u003e {\n        let url = format!(\n            \"https://api.search.brave.com/res/v1/web/search?q={}\u0026count={}\",\n            urlencoding::encode(query),\n            count\n        );\n\n        let response = self\n            .http\n            .get(\u0026url)\n            .header(\"Accept\", \"application/json\")\n            .header(\"X-Subscription-Token\", \u0026self.api_key)\n            .send()\n            .await\n            .context(\"Failed to call Brave Search API\")?;\n\n        if !response.status().is_success() {\n            let status = response.status();\n            let body = response.text().await.unwrap_or_default();\n            bail!(\"Brave API error {}: {}\", status, body);\n        }\n\n        let data: BraveSearchResponse = response\n            .json()\n            .await\n            .context(\"Failed to parse Brave API response\")?;\n\n        Ok(data.web.map(|w| w.results).unwrap_or_default())\n    }\n}\n\n// ============================================================================\n// HTTP fetcher trait\n// ============================================================================\n\n/// Trait for fetching URL content\n#[async_trait::async_trait]\npub trait HttpFetcher {\n    async fn fetch(\u0026self, url: \u0026str) -\u003e Result\u003cString\u003e;\n}\n\n/// Production HTTP fetcher\npub struct DefaultHttpFetcher {\n    http: reqwest::Client,\n}\n\nimpl Default for DefaultHttpFetcher {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl DefaultHttpFetcher {\n    pub fn new() -\u003e Self {\n        let http = reqwest::Client::builder()\n            .user_agent(\"hu-cli/0.1\")\n            .timeout(std::time::Duration::from_secs(10))\n            .build()\n            .expect(\"Failed to build HTTP client\");\n        Self { http }\n    }\n}\n\n#[async_trait::async_trait]\nimpl HttpFetcher for DefaultHttpFetcher {\n    async fn fetch(\u0026self, url: \u0026str) -\u003e Result\u003cString\u003e {\n        let response = self\n            .http\n            .get(url)\n            .send()\n            .await\n            .with_context(|| format!(\"Failed to fetch {}\", url))?;\n\n        response\n            .text()\n            .await\n            .with_context(|| format!(\"Failed to read response from {}\", url))\n    }\n}\n\n// ============================================================================\n// Service\n// ============================================================================\n\n/// Search and optionally fetch content from results\npub async fn search_and_fetch(\n    api: \u0026impl BraveSearchApi,\n    fetcher: \u0026impl HttpFetcher,\n    query: \u0026str,\n    count: usize,\n    fetch_content: bool,\n) -\u003e Result\u003cVec\u003cFetchedResult\u003e\u003e {\n    let results = api.search(query, count).await?;\n\n    let mut fetched = Vec::new();\n    for result in results.into_iter().take(count) {\n        let content = if fetch_content {\n            match fetcher.fetch(\u0026result.url).await {\n                Ok(html) =\u003e Some(extract_summary(\u0026html)),\n                Err(_) =\u003e None,\n            }\n        } else {\n            None\n        };\n\n        fetched.push(FetchedResult {\n            title: result.title,\n            url: result.url,\n            description: result.description,\n            content,\n        });\n    }\n\n    Ok(fetched)\n}\n\n/// Format results as markdown\npub fn format_results(results: \u0026[FetchedResult], include_content: bool) -\u003e String {\n    let mut output = String::new();\n\n    for (i, result) in results.iter().enumerate() {\n        output.push_str(\u0026format!(\"## {}. {}\\n\", i + 1, result.title));\n        output.push_str(\u0026format!(\"**URL:** {}\\n\\n\", result.url));\n\n        if !result.description.is_empty() {\n            output.push_str(\u0026format!(\"\u003e {}\\n\\n\", result.description));\n        }\n\n        if include_content {\n            if let Some(content) = \u0026result.content {\n                output.push_str(\"### Content\\n\\n\");\n                output.push_str(content);\n                output.push_str(\"\\n\\n\");\n            } else {\n                output.push_str(\"*Content unavailable*\\n\\n\");\n            }\n        }\n\n        output.push_str(\"---\\n\\n\");\n    }\n\n    output.trim_end().to_string()\n}\n\n// ============================================================================\n// Handler\n// ============================================================================\n\n/// Handle the `hu utils web-search` command\npub async fn run(args: WebSearchArgs) -\u003e Result\u003c()\u003e {\n    let creds = load_credentials()?;\n    let brave = creds\n        .brave\n        .context(\"Brave API key not configured. Add [brave] section to credentials.toml\")?;\n\n    let client = BraveSearchClient::from_credentials(\u0026brave);\n    let fetcher = DefaultHttpFetcher::new();\n\n    let fetch_content = !args.list;\n    let results =\n        search_and_fetch(\u0026client, \u0026fetcher, \u0026args.query, args.results, fetch_content).await?;\n\n    let output = format_results(\u0026results, fetch_content);\n\n    if let Some(path) = args.output {\n        fs::write(\u0026path, \u0026output).with_context(|| format!(\"Failed to write to {}\", path))?;\n        eprintln!(\"Written to {}\", path);\n    } else {\n        println!(\"{}\", output);\n    }\n\n    Ok(())\n}\n\n// ============================================================================\n// Tests\n// ============================================================================\n","traces":[{"line":65,"address":[],"length":0,"stats":{"Line":2}},{"line":66,"address":[],"length":0,"stats":{"Line":4}},{"line":73,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":3}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":1}},{"line":128,"address":[],"length":0,"stats":{"Line":1}},{"line":133,"address":[],"length":0,"stats":{"Line":2}},{"line":134,"address":[],"length":0,"stats":{"Line":4}},{"line":136,"address":[],"length":0,"stats":{"Line":4}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":4}},{"line":172,"address":[],"length":0,"stats":{"Line":20}},{"line":174,"address":[],"length":0,"stats":{"Line":8}},{"line":175,"address":[],"length":0,"stats":{"Line":23}},{"line":176,"address":[],"length":0,"stats":{"Line":14}},{"line":177,"address":[],"length":0,"stats":{"Line":16}},{"line":178,"address":[],"length":0,"stats":{"Line":4}},{"line":179,"address":[],"length":0,"stats":{"Line":2}},{"line":182,"address":[],"length":0,"stats":{"Line":3}},{"line":185,"address":[],"length":0,"stats":{"Line":21}},{"line":186,"address":[],"length":0,"stats":{"Line":14}},{"line":187,"address":[],"length":0,"stats":{"Line":14}},{"line":188,"address":[],"length":0,"stats":{"Line":7}},{"line":189,"address":[],"length":0,"stats":{"Line":7}},{"line":193,"address":[],"length":0,"stats":{"Line":4}},{"line":197,"address":[],"length":0,"stats":{"Line":4}},{"line":198,"address":[],"length":0,"stats":{"Line":8}},{"line":200,"address":[],"length":0,"stats":{"Line":20}},{"line":201,"address":[],"length":0,"stats":{"Line":16}},{"line":202,"address":[],"length":0,"stats":{"Line":12}},{"line":204,"address":[],"length":0,"stats":{"Line":7}},{"line":205,"address":[],"length":0,"stats":{"Line":9}},{"line":208,"address":[],"length":0,"stats":{"Line":4}},{"line":209,"address":[],"length":0,"stats":{"Line":4}},{"line":210,"address":[],"length":0,"stats":{"Line":4}},{"line":211,"address":[],"length":0,"stats":{"Line":4}},{"line":212,"address":[],"length":0,"stats":{"Line":2}},{"line":214,"address":[],"length":0,"stats":{"Line":2}},{"line":218,"address":[],"length":0,"stats":{"Line":12}},{"line":221,"address":[],"length":0,"stats":{"Line":8}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}}],"covered":39,"coverable":58},{"path":["/","Users","chi","Projects","hu","src","utils","web_search","tests.rs"],"content":"use super::*;\n\n// Mock implementations for testing\nstruct MockBraveApi {\n    results: Vec\u003cSearchResult\u003e,\n}\n\n#[async_trait::async_trait]\nimpl BraveSearchApi for MockBraveApi {\n    async fn search(\u0026self, _query: \u0026str, count: usize) -\u003e Result\u003cVec\u003cSearchResult\u003e\u003e {\n        Ok(self.results.iter().take(count).cloned().collect())\n    }\n}\n\nstruct MockFetcher {\n    content: String,\n}\n\n#[async_trait::async_trait]\nimpl HttpFetcher for MockFetcher {\n    async fn fetch(\u0026self, _url: \u0026str) -\u003e Result\u003cString\u003e {\n        Ok(self.content.clone())\n    }\n}\n\nstruct FailingFetcher;\n\n#[async_trait::async_trait]\nimpl HttpFetcher for FailingFetcher {\n    async fn fetch(\u0026self, url: \u0026str) -\u003e Result\u003cString\u003e {\n        bail!(\"Failed to fetch {}\", url)\n    }\n}\n\nfn sample_results() -\u003e Vec\u003cSearchResult\u003e {\n    vec![\n        SearchResult {\n            title: \"Result One\".to_string(),\n            url: \"https://example.com/one\".to_string(),\n            description: \"First result description\".to_string(),\n        },\n        SearchResult {\n            title: \"Result Two\".to_string(),\n            url: \"https://example.com/two\".to_string(),\n            description: \"Second result description\".to_string(),\n        },\n        SearchResult {\n            title: \"Result Three\".to_string(),\n            url: \"https://example.com/three\".to_string(),\n            description: \"\".to_string(),\n        },\n    ]\n}\n\n#[test]\nfn search_result_debug() {\n    let result = SearchResult {\n        title: \"Test\".to_string(),\n        url: \"https://test.com\".to_string(),\n        description: \"Desc\".to_string(),\n    };\n    let debug = format!(\"{:?}\", result);\n    assert!(debug.contains(\"SearchResult\"));\n    assert!(debug.contains(\"Test\"));\n}\n\n#[test]\nfn search_result_clone() {\n    let result = SearchResult {\n        title: \"Test\".to_string(),\n        url: \"https://test.com\".to_string(),\n        description: \"Desc\".to_string(),\n    };\n    let cloned = result.clone();\n    assert_eq!(cloned.title, result.title);\n    assert_eq!(cloned.url, result.url);\n}\n\n#[test]\nfn web_results_debug() {\n    let results = WebResults { results: vec![] };\n    let debug = format!(\"{:?}\", results);\n    assert!(debug.contains(\"WebResults\"));\n}\n\n#[test]\nfn brave_search_response_debug() {\n    let response = BraveSearchResponse { web: None };\n    let debug = format!(\"{:?}\", response);\n    assert!(debug.contains(\"BraveSearchResponse\"));\n}\n\n#[test]\nfn fetched_result_debug() {\n    let result = FetchedResult {\n        title: \"Test\".to_string(),\n        url: \"https://test.com\".to_string(),\n        description: \"Desc\".to_string(),\n        content: Some(\"Content\".to_string()),\n    };\n    let debug = format!(\"{:?}\", result);\n    assert!(debug.contains(\"FetchedResult\"));\n}\n\n#[test]\nfn brave_client_new() {\n    let client = BraveSearchClient::new(\"test_key\".to_string());\n    assert_eq!(client.api_key, \"test_key\");\n}\n\n#[test]\nfn brave_client_from_credentials() {\n    let creds = BraveCredentials {\n        api_key: \"creds_key\".to_string(),\n    };\n    let client = BraveSearchClient::from_credentials(\u0026creds);\n    assert_eq!(client.api_key, \"creds_key\");\n}\n\n#[test]\nfn default_http_fetcher_new() {\n    let fetcher = DefaultHttpFetcher::new();\n    let _ = format!(\"{:?}\", fetcher.http);\n}\n\n#[test]\nfn default_http_fetcher_default() {\n    let fetcher = DefaultHttpFetcher::default();\n    let _ = format!(\"{:?}\", fetcher.http);\n}\n\n#[tokio::test]\nasync fn search_and_fetch_without_content() {\n    let api = MockBraveApi {\n        results: sample_results(),\n    };\n    let fetcher = MockFetcher {\n        content: \"\u003cp\u003eTest\u003c/p\u003e\".to_string(),\n    };\n\n    let results = search_and_fetch(\u0026api, \u0026fetcher, \"test\", 2, false)\n        .await\n        .unwrap();\n\n    assert_eq!(results.len(), 2);\n    assert_eq!(results[0].title, \"Result One\");\n    assert!(results[0].content.is_none());\n}\n\n#[tokio::test]\nasync fn search_and_fetch_with_content() {\n    let api = MockBraveApi {\n        results: sample_results(),\n    };\n    let fetcher = MockFetcher {\n        content: \"\u003cp\u003eFetched content here\u003c/p\u003e\".to_string(),\n    };\n\n    let results = search_and_fetch(\u0026api, \u0026fetcher, \"test\", 2, true)\n        .await\n        .unwrap();\n\n    assert_eq!(results.len(), 2);\n    assert!(results[0].content.is_some());\n    assert!(results[0].content.as_ref().unwrap().contains(\"Fetched\"));\n}\n\n#[tokio::test]\nasync fn search_and_fetch_handles_fetch_failure() {\n    let api = MockBraveApi {\n        results: sample_results(),\n    };\n    let fetcher = FailingFetcher;\n\n    let results = search_and_fetch(\u0026api, \u0026fetcher, \"test\", 2, true)\n        .await\n        .unwrap();\n\n    assert_eq!(results.len(), 2);\n    assert!(results[0].content.is_none());\n}\n\n#[tokio::test]\nasync fn search_and_fetch_limits_results() {\n    let api = MockBraveApi {\n        results: sample_results(),\n    };\n    let fetcher = MockFetcher {\n        content: \"\u003cp\u003eTest\u003c/p\u003e\".to_string(),\n    };\n\n    let results = search_and_fetch(\u0026api, \u0026fetcher, \"test\", 1, false)\n        .await\n        .unwrap();\n\n    assert_eq!(results.len(), 1);\n}\n\n#[test]\nfn format_results_list_mode() {\n    let results = vec![\n        FetchedResult {\n            title: \"Title One\".to_string(),\n            url: \"https://one.com\".to_string(),\n            description: \"Description one\".to_string(),\n            content: None,\n        },\n        FetchedResult {\n            title: \"Title Two\".to_string(),\n            url: \"https://two.com\".to_string(),\n            description: \"\".to_string(),\n            content: None,\n        },\n    ];\n\n    let output = format_results(\u0026results, false);\n    assert!(output.contains(\"## 1. Title One\"));\n    assert!(output.contains(\"**URL:** https://one.com\"));\n    assert!(output.contains(\"\u003e Description one\"));\n    assert!(output.contains(\"## 2. Title Two\"));\n    assert!(!output.contains(\"### Content\"));\n}\n\n#[test]\nfn format_results_with_content() {\n    let results = vec![FetchedResult {\n        title: \"Title\".to_string(),\n        url: \"https://test.com\".to_string(),\n        description: \"Desc\".to_string(),\n        content: Some(\"The actual content\".to_string()),\n    }];\n\n    let output = format_results(\u0026results, true);\n    assert!(output.contains(\"### Content\"));\n    assert!(output.contains(\"The actual content\"));\n}\n\n#[test]\nfn format_results_content_unavailable() {\n    let results = vec![FetchedResult {\n        title: \"Title\".to_string(),\n        url: \"https://test.com\".to_string(),\n        description: \"Desc\".to_string(),\n        content: None,\n    }];\n\n    let output = format_results(\u0026results, true);\n    assert!(output.contains(\"*Content unavailable*\"));\n}\n\n#[test]\nfn format_results_empty() {\n    let results: Vec\u003cFetchedResult\u003e = vec![];\n    let output = format_results(\u0026results, false);\n    assert!(output.is_empty());\n}\n\n#[test]\nfn brave_search_response_deserialize() {\n    let json =\n        r#\"{\"web\": {\"results\": [{\"title\": \"Test\", \"url\": \"https://t.com\", \"description\": \"D\"}]}}\"#;\n    let response: BraveSearchResponse = serde_json::from_str(json).unwrap();\n    assert!(response.web.is_some());\n    let web = response.web.unwrap();\n    assert_eq!(web.results.len(), 1);\n    assert_eq!(web.results[0].title, \"Test\");\n}\n\n#[test]\nfn brave_search_response_deserialize_empty() {\n    let json = r#\"{}\"#;\n    let response: BraveSearchResponse = serde_json::from_str(json).unwrap();\n    assert!(response.web.is_none());\n}\n\n#[test]\nfn brave_search_response_deserialize_empty_web() {\n    let json = r#\"{\"web\": {\"results\": []}}\"#;\n    let response: BraveSearchResponse = serde_json::from_str(json).unwrap();\n    assert!(response.web.is_some());\n    assert!(response.web.unwrap().results.is_empty());\n}\n\n#[test]\nfn search_result_deserialize_missing_description() {\n    let json = r#\"{\"title\": \"Test\", \"url\": \"https://t.com\"}\"#;\n    let result: SearchResult = serde_json::from_str(json).unwrap();\n    assert_eq!(result.title, \"Test\");\n    assert_eq!(result.description, \"\");\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":4}},{"line":21,"address":[],"length":0,"stats":{"Line":2}},{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":35,"address":[],"length":0,"stats":{"Line":4}},{"line":36,"address":[],"length":0,"stats":{"Line":4}},{"line":37,"address":[],"length":0,"stats":{"Line":4}},{"line":38,"address":[],"length":0,"stats":{"Line":12}},{"line":39,"address":[],"length":0,"stats":{"Line":12}},{"line":40,"address":[],"length":0,"stats":{"Line":4}},{"line":42,"address":[],"length":0,"stats":{"Line":4}},{"line":43,"address":[],"length":0,"stats":{"Line":12}},{"line":44,"address":[],"length":0,"stats":{"Line":12}},{"line":45,"address":[],"length":0,"stats":{"Line":4}},{"line":47,"address":[],"length":0,"stats":{"Line":4}},{"line":48,"address":[],"length":0,"stats":{"Line":12}},{"line":49,"address":[],"length":0,"stats":{"Line":12}},{"line":50,"address":[],"length":0,"stats":{"Line":4}}],"covered":17,"coverable":17}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      },
    };
  });

  return [...folders, ...files.filter(file => file.path.length === 1)];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener('hashchange', () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.slice(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(
      ({current}) => {
        return {current: [...current, file.path[0]]};
      },
      () => this.updateHash(),
    );
  }

  back(file) {
    this.setState(
      ({current}) => {
        return {current: current.slice(0, current.length - 1)};
      },
      () => this.updateHash(),
    );
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e(
    'div',
    {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e(
      'table',
      {className: 'files-list'},
      e('thead', {className: 'files-list__head'}, e('tr', null, e('th', null, 'Path'), e('th', null, 'Coverage'))),
      e(
        'tbody',
        {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile})),
      ),
    ),
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? (file.covered / file.coverable) * 100 : -1;
  const coverageDelta =
    file.prevRun && (file.covered / file.coverable) * 100 - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'tr',
    {
      className:
        'files-list__file' +
        (coverage >= 0 && coverage < 50 ? ' files-list__file_low' : '') +
        (coverage >= 50 && coverage < 80 ? ' files-list__file_medium' : '') +
        (coverage >= 80 ? ' files-list__file_high' : '') +
        (file.is_folder ? ' files-list__file_folder' : ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e(
      'td',
      null,
      file.covered + ' / ' + file.coverable + (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
    ),
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'}, e(FileHeader, {file, onBack}), e(FileContent, {file}));
}

function FileHeader({file, onBack}) {
  const coverage = (file.covered / file.coverable) * 100;
  const coverageDelta = file.prevRun && coverage - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'div',
    {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e(
      'div',
      {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable + (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
      e('input', {id: 'theme-toggle', type: 'checkbox', hidden: true}),
      e('label', {for: 'theme-toggle', id: 'theme-toggle-label'}, ''),
    ),
  );
}

function FileContent({file}) {
  return e(
    'pre',
    {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      const nbHit = covered? trace.stats.Line: 0;
      return e(
        'div',
        { className: 'code-text-container' },
        e(
          'code',
          {
            className: 'code-line' + (covered ? ' code-line_covered' : '') + (uncovered ? ' code-line_uncovered' : ''),
          },
          line
        ),
        e(
          'div',
          { className: 'cover-indicator' + (covered? ' check-cover': '') + (uncovered? ' no-cover': '')},
          e(
            'div',
            { className: (covered? 'stat-line-hit': '')},
            covered? nbHit: ""
          )
        )
      );
    }),
  );
}

(function () {
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData &&
    previousData.files.forEach(file => {
      const path = file.path.slice(commonPath.length).join('/');
      prevFilesMap.set(path, file);
    });

  const files = data.files.map(file => {
    const path = file.path.slice(commonPath.length);
    const {covered = 0, coverable = 0} = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: {covered, coverable},
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    },
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));

  const toggle = document.getElementById('theme-toggle');
  const label = document.getElementById('theme-toggle-label');
  label.textContent = '';

  toggle.addEventListener('change', () => {
    if (toggle.checked) {
      document.documentElement.setAttribute('data-theme', 'dark');
      label.textContent = '';
    } else {
      document.documentElement.removeAttribute('data-theme');
      label.textContent = '';
    }
  });
})();
</script>
</body>
</html>